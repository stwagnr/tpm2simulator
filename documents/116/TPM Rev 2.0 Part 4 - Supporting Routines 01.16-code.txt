     Trusted Platform Module Library

     Part 4: Supporting Routines

     Family "2.0"

     Level 00 Revision 01.16

     October 30, 2014

     Published

     Contact: admin@trustedcomputinggroup.org

     TCG Published

     Copyright © TCG 2006-2014

TCG
Trusted Platform Module Library                                                    Part 4: Supporting Routines

Licenses and Notices

1.  Copyright Licenses:

         Trusted Computing Group (TCG) grants to the user of the source code in this specification (the

         "Source Code") a worldwide, irrevocable, nonexclusive, royalty free, copyright license to

         reproduce, create derivative works, distribute, display and perform the Source Code and

         derivative works thereof, and to grant others the rights granted herein.

         The TCG grants to the user of the other parts of the specification (other than the Source Code)

         the rights to reproduce, distribute, display, and perform the specification solely for the purpose

         of developing products based on such documents.

2.  Source Code Distribution Conditions:

         Redistributions of Source Code must retain the above copyright licenses, this list of conditions

         and the following disclaimers.

         Redistributions in binary form must reproduce the above copyright licenses, this list of

         conditions and the following disclaimers in the documentation and/or other materials provided

         with the distribution.

3.  Disclaimers:

         THE COPYRIGHT LICENSES SET FORTH ABOVE DO NOT REPRESENT ANY FORM OF LICENSE OR

         WAIVER, EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, WITH RESPECT TO PATENT RIGHTS

         HELD BY TCG MEMBERS (OR OTHER THIRD PARTIES) THAT MAY BE NECESSARY TO IMPLEMENT

         THIS SPECIFICATION OR OTHERWISE. Contact TCG Administration

         (admin@trustedcomputinggroup.org) for information on specification licensing rights available

         through TCG membership agreements.

         THIS SPECIFICATION IS PROVIDED "AS IS" WITH NO EXPRESS OR IMPLIED WARRANTIES

         WHATSOEVER, INCLUDING ANY WARRANTY OF MERCHANTABILITY OR FITNESS FOR A

         PARTICULAR PURPOSE, ACCURACY, COMPLETENESS, OR NONINFRINGEMENT OF INTELLECTUAL

         PROPERTY RIGHTS, OR ANY WARRANTY OTHERWISE ARISING OUT OF ANY PROPOSAL,

         SPECIFICATION OR SAMPLE.

         Without limitation, TCG and its members and licensors disclaim all liability, including liability for

         infringement of any proprietary rights, relating to use of information in this specification and to

         the implementation of this specification, and TCG disclaims all liability for cost of procurement

         of substitute goods or services, lost profits, loss of use, loss of data or any incidental,

         consequential, direct, indirect, or special damages, whether under contract, tort, warranty or

         otherwise, arising in any way out of use or reliance upon this specification or any information

         herein.

Any marks and brands contained herein are the property of their respective owner.

Page ii                                   TCG Published                                               Family "2.0"

October 30, 2014                         Copyright © TCG 2006-2014                 Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

                             CONTENTS

1  Scope ...................................................................................................................................1

2  Terms and definitions ...........................................................................................................1

3  Symbols and abbreviated terms ............................................................................................1

4  Automation ...........................................................................................................................1

   4.1  Configuration Parser ...................................................................................................1

   4.2  Structure Parser ..........................................................................................................2

   4.2.1         Introduction ..........................................................................................................2

   4.2.2         Unmarshaling Code Prototype ..............................................................................2

        4.2.2.1  Simple Types and Structures ..........................................................................2

        4.2.2.2  Union Types ...................................................................................................3

        4.2.2.3  Null Types ......................................................................................................3

        4.2.2.4  Arrays.............................................................................................................3

   4.2.3         Marshaling Code Function Prototypes ..................................................................4

        4.2.3.1  Simple Types and Structures ..........................................................................4

        4.2.3.2  Union Types ...................................................................................................4

        4.2.3.3  Arrays.............................................................................................................4

   4.3  Command Parser ........................................................................................................5

   4.4  Portability .................................................................................................................... 5

5  Header Files .........................................................................................................................6

   5.1  Introduction .................................................................................................................6

   5.2  BaseTypes.h ...............................................................................................................6

   5.3  bits.h ...........................................................................................................................7

   5.4  bool.h ..........................................................................................................................8

   5.5  Capabilities.h ..............................................................................................................8

   5.6  TPMB.h .......................................................................................................................8

   5.7  TpmError.h ..................................................................................................................9

   5.8  Global.h ......................................................................................................................9

   5.8.1         Description ...........................................................................................................9

   5.8.2         Includes ...............................................................................................................9

   5.8.3         Defines and Types ............................................................................................. 10

        5.8.3.1  Unreferenced Parameter ..............................................................................10

        5.8.3.2  Crypto Self-Test Values ................................................................................ 10

        5.8.3.3  Hash and HMAC State Structures .................................................................10

        5.8.3.4  Other Types.................................................................................................. 11

   5.8.4         Loaded Object Structures ...................................................................................11

        5.8.4.1  Description ...................................................................................................11

        5.8.4.2  OBJECT_ATTRIBUTES ................................................................................11

        5.8.4.3  OBJECT Structure ........................................................................................12

        5.8.4.4  HASH_OBJECT Structure.............................................................................12

        5.8.4.5  ANY_OBJECT ..............................................................................................13

   5.8.5         AUTH_DUP Types .............................................................................................. 13

   5.8.6         Active Session Context.......................................................................................13

        5.8.6.1  Description ...................................................................................................13

        5.8.6.2  SESSION_ATTRIBUTES ..............................................................................13

        5.8.6.3  SESSION Structure ......................................................................................14

   5.8.7         PCR ...................................................................................................................15

        5.8.7.1  PCR_SAVE Structure ...................................................................................15

Family "2.0"                 TCG Published              Page iii

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

         5.8.7.2    PCR_POLICY ...............................................................................................16

         5.8.7.3    PCR_AUTHVALUE .......................................................................................16

   5.8.8          Startup ...............................................................................................................16

         5.8.8.1    SHUTDOWN_NONE .....................................................................................16

         5.8.8.2    STARTUP_TYPE ..........................................................................................16

   5.8.9          NV ...................................................................................................................... 16

         5.8.9.1    NV_RESERVE .............................................................................................. 16

         5.8.9.2    NV_INDEX.................................................................................................... 18

   5.8.10         COMMIT_INDEX_MASK .....................................................................................18

   5.8.11         RAM Global Values ............................................................................................18

         5.8.11.1   Description ...................................................................................................18

         5.8.11.2   g_rcIndex .....................................................................................................18

         5.8.11.3   g_exclusiveAuditSession ..............................................................................18

         5.8.11.4   g_time ..........................................................................................................18

         5.8.11.5   g_phEnable ..................................................................................................18

         5.8.11.6   g_pceReConfig .............................................................................................19

         5.8.11.7   g_DRTMHandle ............................................................................................19

         5.8.11.8   g_DrtmPreStartup ......................................................................................... 19

         5.8.11.9   g_StartupLocality3 ........................................................................................ 19

         5.8.11.10  g_updateNV .................................................................................................19

         5.8.11.11  g_clearOrderly .............................................................................................. 19

         5.8.11.12  g_prevOrderlyState ...................................................................................... 20

         5.8.11.13  g_nvOk .........................................................................................................20

         5.8.11.14  g_platformUnique .........................................................................................20

   5.8.12         Persistent Global Values ....................................................................................20

         5.8.12.1   Description ...................................................................................................20

         5.8.12.2   PERSISTENT_DATA ....................................................................................20

         5.8.12.3   ORDERLY_DATA .........................................................................................22

         5.8.12.4   STATE_CLEAR_DATA .................................................................................23

         5.8.12.5   State Reset Data ..........................................................................................24

   5.8.13         Global Macro Definitions ....................................................................................25

   5.8.14         Private data........................................................................................................25

   5.9   Tpm.h........................................................................................................................ 29

   5.10  swap.h ......................................................................................................................30

   5.11  InternalRoutines.h .....................................................................................................31

   5.12  TpmBuildSwitches.h ..................................................................................................32

   5.13  VendorString.h ..........................................................................................................33

6  Main ...................................................................................................................................35

   6.1   CommandDispatcher() ............................................................................................... 35

   6.2   ExecCommand.c .......................................................................................................35

   6.2.1          Introduction ........................................................................................................35

   6.2.2          Includes .............................................................................................................35

   6.2.3          ExecuteCommand() ............................................................................................35

   6.3   ParseHandleBuffer() .................................................................................................. 41

   6.4   SessionProcess.c ......................................................................................................42

   6.4.1          Introduction ........................................................................................................42

   6.4.2          Includes and Data Definitions .............................................................................42

   6.4.3          Authorization Support Functions .........................................................................42

         6.4.3.1    IsDAExempted() ...........................................................................................42

         6.4.3.2    IncrementLockout() ....................................................................................... 43

Page iv                          TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

        6.4.3.3   IsSessionBindEntity() ................................................................................... 44

        6.4.3.4   IsPolicySessionRequired() ............................................................................ 45

        6.4.3.5   IsAuthValueAvailable() .................................................................................46

        6.4.3.6   IsAuthPolicyAvailable() ................................................................................. 48

   6.4.4         Session Parsing Functions .................................................................................49

        6.4.4.1   ComputeCpHash() ........................................................................................49

        6.4.4.2   CheckPWAuthSession()................................................................................ 50

        6.4.4.3   ComputeCommandHMAC() ........................................................................... 51

        6.4.4.4   CheckSessionHMAC() ..................................................................................53

        6.4.4.5   CheckPolicyAuthSession() ............................................................................ 53

        6.4.4.6   RetrieveSessionData() .................................................................................. 56

        6.4.4.7   CheckLockedOut() ........................................................................................59

        6.4.4.8   CheckAuthSession() .....................................................................................60

        6.4.4.9   CheckCommandAudit() .................................................................................62

        6.4.4.10  ParseSessionBuffer() .................................................................................... 63

        6.4.4.11  CheckAuthNoSession() .................................................................................65

   6.4.5         Response Session Processing ...........................................................................66

        6.4.5.1   Introduction ..................................................................................................66

        6.4.5.2   ComputeRpHash() ........................................................................................66

        6.4.5.3   InitAuditSession() .........................................................................................67

        6.4.5.4   Audit() ..........................................................................................................67

        6.4.5.5   CommandAudit() ........................................................................................... 68

        6.4.5.6   UpdateAuditSessionStatus() .........................................................................69

        6.4.5.7   ComputeResponseHMAC() ...........................................................................70

        6.4.5.8   BuildSingleResponseAuth() ..........................................................................71

        6.4.5.9   UpdateTPMNonce() ......................................................................................72

        6.4.5.10  UpdateInternalSession() ...............................................................................72

        6.4.5.11  BuildResponseSession() ............................................................................... 73

7  Command Support Functions..............................................................................................76

   7.1  Introduction ...............................................................................................................76

   7.2  Attestation Command Support (Attest_spt.c) .............................................................76

   7.2.1         Includes .............................................................................................................76

   7.2.2         Functions ...........................................................................................................76

        7.2.2.1   FillInAttestInfo() ............................................................................................76

        7.2.2.2   SignAttestInfo() ............................................................................................77

   7.3  Context Management Command Support (Context_spt.c) ..........................................79

   7.3.1         Includes .............................................................................................................79

   7.3.2         Functions ...........................................................................................................79

        7.3.2.1   ComputeContextProtectionKey() ................................................................... 79

        7.3.2.2   ComputeContextIntegrity() ............................................................................80

        7.3.2.3   SequenceDataImportExport() ........................................................................ 81

   7.4  Policy Command Support (Policy_spt.c) .................................................................... 81

   7.4.1         PolicyParameterChecks() ................................................................................... 81

   7.4.2         PolicyContextUpdate()........................................................................................ 82

   7.5  NV Command Support (NV_spt.c) .............................................................................83

   7.5.1         Includes .............................................................................................................83

   7.5.2         Fuctions .............................................................................................................83

        7.5.2.1   NvReadAccessChecks() ...............................................................................83

        7.5.2.2   NvWriteAccessChecks() ............................................................................... 84

   7.6  Object Command Support (Object_spt.c) ...................................................................85

Family "2.0"                 TCG Published              Page v

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

   7.6.1          Includes .............................................................................................................85

   7.6.2          Local Functions ..................................................................................................86

         7.6.2.1   EqualCryptSet() ............................................................................................ 86

         7.6.2.2   GetIV2BSize() ..............................................................................................86

         7.6.2.3   ComputeProtectionKeyParms() ..................................................................... 87

         7.6.2.4   ComputeOuterIntegrity() ............................................................................... 88

         7.6.2.5   ComputeInnerIntegrity() ................................................................................ 89

         7.6.2.6   ProduceInnerIntegrity() ................................................................................. 89

         7.6.2.7   CheckInnerIntegrity() .................................................................................... 90

   7.6.3          Public Functions .................................................................................................90

         7.6.3.1   AreAttributesForParent() ............................................................................... 90

         7.6.3.2   SchemeChecks() ..........................................................................................91

         7.6.3.3   PublicAttributesValidation() ........................................................................... 94

         7.6.3.4   FillInCreationData() ......................................................................................95

         7.6.3.5   GetSeedForKDF() ......................................................................................... 97

         7.6.3.6   ProduceOuterW rap() ..................................................................................... 97

         7.6.3.7   UnwrapOuter() ..............................................................................................99

         7.6.3.8   SensitiveToPrivate() ................................................................................... 100

         7.6.3.9   PrivateToSensitive() ................................................................................... 101

         7.6.3.10  SensitiveToDuplicate()................................................................................ 103

         7.6.3.11  DuplicateToSensitive()................................................................................ 105

         7.6.3.12  SecretToCredential() .................................................................................. 107

         7.6.3.13  CredentialToSecret() .................................................................................. 108

8  Subsystem........................................................................................................................ 109

   8.1   CommandAudit.c ..................................................................................................... 109

   8.1.1          Introduction ...................................................................................................... 109

   8.1.2          Includes ........................................................................................................... 109

   8.1.3          Functions ......................................................................................................... 109

         8.1.3.1   CommandAuditPreInstall_Init() ................................................................... 109

         8.1.3.2   CommandAuditStartup() ............................................................................. 109

         8.1.3.3   CommandAuditSet() ................................................................................... 110

         8.1.3.4   CommandAuditClear() ................................................................................ 110

         8.1.3.5   CommandAuditIsRequired() ........................................................................ 111

         8.1.3.6   CommandAuditCapGetCCList() .................................................................. 111

         8.1.3.7   CommandAuditGetDigest............................................................................ 112

   8.2   DA.c ........................................................................................................................ 113

   8.2.1          Introduction ...................................................................................................... 113

   8.2.2          Includes and Data Definitions ........................................................................... 113

   8.2.3          Functions ......................................................................................................... 113

         8.2.3.1   DAPreInstall_Init() ...................................................................................... 113

         8.2.3.2   DAStartup() ................................................................................................ 114

         8.2.3.3   DARegisterFailure() .................................................................................... 114

         8.2.3.4   DASelfHeal() .............................................................................................. 115

   8.3   Hierarchy.c.............................................................................................................. 116

   8.3.1          Introduction ...................................................................................................... 116

   8.3.2          Includes ........................................................................................................... 116

   8.3.3          Functions ......................................................................................................... 116

         8.3.3.1   HierarchyPreInstall() ................................................................................... 116

         8.3.3.2   HierarchyStartup() ...................................................................................... 117

         8.3.3.3   HierarchyGetProof() ................................................................................... 118

         8.3.3.4   HierarchyGetPrimarySeed() ........................................................................ 118

         8.3.3.5   HierarchyIsEnabled() .................................................................................. 119

Page vi                          TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

8.4  NV.c ........................................................................................................................ 119

8.4.1         Introduction ...................................................................................................... 119

8.4.2         Includes, Defines and Data Definitions ............................................................. 119

8.4.3         NV Utility Functions .......................................................................................... 120

     8.4.3.1   NvCheckState() .......................................................................................... 120

     8.4.3.2   NvIsAvailable() ........................................................................................... 120

     8.4.3.3   NvCommit................................................................................................... 120

     8.4.3.4   NvReadMaxCount() .................................................................................... 121

     8.4.3.5   NvWriteMaxCount() .................................................................................... 121

8.4.4         NV Index and Persistent Object Access Functions ............................................ 121

     8.4.4.1   Introduction ................................................................................................ 121

     8.4.4.2   NvNext() ..................................................................................................... 121

     8.4.4.3   NvGetEnd() ................................................................................................ 122

     8.4.4.4   NvGetFreeByte ........................................................................................... 122

     8.4.4.5   NvGetEvictObjectSize................................................................................. 123

     8.4.4.6   NvGetCounterSize ...................................................................................... 123

     8.4.4.7   NvTestSpace()............................................................................................ 123

     8.4.4.8   NvAdd() ...................................................................................................... 124

     8.4.4.9   NvDelete() .................................................................................................. 124

8.4.5         RAM-based NV Index Data Access Functions................................................... 125

     8.4.5.1   Introduction ................................................................................................ 125

     8.4.5.2   NvTestRAMSpace() .................................................................................... 125

     8.4.5.3   NvGetRamIndexOffset ................................................................................ 126

     8.4.5.4   NvAddRAM() .............................................................................................. 126

     8.4.5.5   NvDeleteRAM() .......................................................................................... 127

8.4.6         Utility Functions................................................................................................ 128

     8.4.6.1   NvInitStatic() .............................................................................................. 128

     8.4.6.2   NvInit() ....................................................................................................... 129

     8.4.6.3   NvReadReserved() ..................................................................................... 129

     8.4.6.4   NvWriteReserved() ..................................................................................... 130

     8.4.6.5   NvReadPersistent() .................................................................................... 130

     8.4.6.6   NvIsPlatformPersistentHandle() .................................................................. 131

     8.4.6.7   NvIsOwnerPersistentHandle() ..................................................................... 131

     8.4.6.8   NvNextIndex() ............................................................................................ 131

     8.4.6.9   NvNextEvict() ............................................................................................. 132

     8.4.6.10  NvFindHandle() .......................................................................................... 132

     8.4.6.11  NvPowerOn() .............................................................................................. 133

     8.4.6.12  NvStateSave() ............................................................................................ 133

     8.4.6.13  NvEntityStartup() ........................................................................................ 134

8.4.7         NV Access Functions ....................................................................................... 135

     8.4.7.1   Introduction ................................................................................................ 135

     8.4.7.2   NvIsUndefinedIndex() ................................................................................. 135

     8.4.7.3   NvIndexIsAccessible() ................................................................................ 136

     8.4.7.4   NvIsUndefinedEvictHandle() ....................................................................... 137

     8.4.7.5   NvGetEvictObject() ..................................................................................... 138

     8.4.7.6   NvGetIndexInfo() ........................................................................................ 138

     8.4.7.7   NvInitialCounter() ....................................................................................... 139

     8.4.7.8   NvGetIndexData() ....................................................................................... 139

     8.4.7.9   NvGetIntIndexData() ................................................................................... 140

     8.4.7.10  NvWriteIndexInfo()...................................................................................... 141

     8.4.7.11  NvWriteIndexData() .................................................................................... 142

     8.4.7.12  NvGetName() ............................................................................................. 143

     8.4.7.13  NvDefineIndex().......................................................................................... 143

Family "2.0"                 TCG Published              Page vii

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

           8.4.7.14  NvAddEvictObject() .................................................................................... 144

           8.4.7.15  NvDeleteEntity() ......................................................................................... 145

           8.4.7.16  NvFlushHierarchy() ..................................................................................... 146

           8.4.7.17  NvSetGlobalLock()...................................................................................... 147

           8.4.7.18  InsertSort() ................................................................................................. 148

           8.4.7.19  NvCapGetPersistent()................................................................................. 149

           8.4.7.20  NvCapGetIndex() ........................................................................................ 150

           8.4.7.21  NvCapGetIndexNumber()............................................................................ 151

           8.4.7.22  NvCapGetPersistentNumber() .................................................................... 151

           8.4.7.23  NvCapGetPersistentAvail() ......................................................................... 151

           8.4.7.24  NvCapGetCounterNumber() ........................................................................ 151

           8.4.7.25  NvCapGetCounterAvail() ............................................................................ 152

8.5        Object.c................................................................................................................... 153

8.5.1               Introduction ...................................................................................................... 153

8.5.2               Includes and Data Definitions ........................................................................... 153

8.5.3               Functions ......................................................................................................... 153

           8.5.3.1   ObjectStartup() ........................................................................................... 153

           8.5.3.2   ObjectCleanupEvict() .................................................................................. 153

           8.5.3.3   ObjectIsPresent() ....................................................................................... 154

           8.5.3.4   ObjectIsSequence() .................................................................................... 154

           8.5.3.5   ObjectGet()................................................................................................. 155

           8.5.3.6   ObjectGetName()........................................................................................ 155

           8.5.3.7   ObjectGetNameAlg()................................................................................... 155

           8.5.3.8   ObjectGetQualifiedName().......................................................................... 156

           8.5.3.9   ObjectDataGetHierarchy() .......................................................................... 156

           8.5.3.10  ObjectGetHierarchy() .................................................................................. 156

           8.5.3.11  ObjectAllocateSlot() .................................................................................... 157

           8.5.3.12  ObjectLoad()............................................................................................... 157

           8.5.3.13  AllocateSequenceSlot() .............................................................................. 160

           8.5.3.14  ObjectCreateHMACSequence() .................................................................. 160

           8.5.3.15  ObjectCreateHashSequence() .................................................................... 161

           8.5.3.16  ObjectCreateEventSequence() ................................................................... 161

           8.5.3.17  ObjectTerminateEvent() .............................................................................. 162

           8.5.3.18  ObjectContextLoad()................................................................................... 163

           8.5.3.19  ObjectFlush().............................................................................................. 163

           8.5.3.20  ObjectFlushHierarchy() ............................................................................... 163

           8.5.3.21  ObjectLoadEvict() ....................................................................................... 164

           8.5.3.22  ObjectComputeName() ............................................................................... 165

           8.5.3.23  ObjectComputeQualifiedName() ................................................................. 166

           8.5.3.24  ObjectDataIsStorage() ................................................................................ 166

           8.5.3.25  ObjectIsStorage() ....................................................................................... 167

           8.5.3.26  ObjectCapGetLoaded() ............................................................................... 167

           8.5.3.27  ObjectCapGetTransientAvail() .................................................................... 168

8.6        PCR.c ..................................................................................................................... 168

8.6.1               Introduction ...................................................................................................... 168

8.6.2               Includes, Defines, and Data Definitions ............................................................ 168

8.6.3               Functions ......................................................................................................... 169

           8.6.3.1   PCRBelongsAuthGroup() ............................................................................ 169

           8.6.3.2   PCRBelongsPolicyGroup() .......................................................................... 169

           8.6.3.3   PCRBelongsTCBGroup() ............................................................................ 170

           8.6.3.4   PCRPolicyIsAvailable() ............................................................................... 170

           8.6.3.5   PCRGetAuthValue().................................................................................... 171

           8.6.3.6   PCRGetAuthPolicy() ................................................................................... 171

           8.6.3.7   PCRSimStart() ............................................................................................ 172

           8.6.3.8   GetSavedPcrPointer()................................................................................. 172

Page viii                        TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

     8.6.3.9   PcrIsAllocated() .......................................................................................... 173

     8.6.3.10  GetPcrPointer() .......................................................................................... 174

     8.6.3.11  IsPcrSelected() ........................................................................................... 175

     8.6.3.12  FilterPcr() ................................................................................................... 175

     8.6.3.13  PcrDrtm().................................................................................................... 176

     8.6.3.14  PCRStartup() .............................................................................................. 176

     8.6.3.15  PCRStateSave() ......................................................................................... 177

     8.6.3.16  PCRIsStateSaved() .................................................................................... 178

     8.6.3.17  PCRIsResetAllowed() ................................................................................. 179

     8.6.3.18  PCRChanged() ........................................................................................... 179

     8.6.3.19  PCRIsExtendAllowed() ............................................................................... 179

     8.6.3.20  PCRExtend() .............................................................................................. 180

     8.6.3.21  PCRComputeCurrentDigest() ...................................................................... 181

     8.6.3.22  PCRRead() ................................................................................................. 181

     8.6.3.23  PcrWrite() ................................................................................................... 183

     8.6.3.24  PCRAllocate()............................................................................................. 183

     8.6.3.25  PCRSetValue() ........................................................................................... 185

     8.6.3.26  PCRResetDynamics ................................................................................... 185

     8.6.3.27  PCRCapGetAllocation() .............................................................................. 186

     8.6.3.28  PCRSetSelectBit() ...................................................................................... 186

     8.6.3.29  PCRGetProperty() ...................................................................................... 187

     8.6.3.30  PCRCapGetProperties() ............................................................................. 188

     8.6.3.31  PCRCapGetHandles()................................................................................. 189

8.7  PP.c ........................................................................................................................ 190

8.7.1         Introduction ...................................................................................................... 190

8.7.2         Includes ........................................................................................................... 190

8.7.3         Functions ......................................................................................................... 190

     8.7.3.1   PhysicalPresencePreInstall_Init() ............................................................... 190

     8.7.3.2   PhysicalPresenceCommandSet() ................................................................ 191

     8.7.3.3   PhysicalPresenceCommandClear() ............................................................. 191

     8.7.3.4   PhysicalPresenceIsRequired() .................................................................... 192

     8.7.3.5   PhysicalPresenceCapGetCCList() .............................................................. 192

8.8  Session.c ................................................................................................................ 193

8.8.1         Introduction ...................................................................................................... 193

8.8.2         Includes, Defines, and Local Variables ............................................................. 194

8.8.3         File Scope Function -- ContextIdSetOldest()..................................................... 194

8.8.4         Startup Function -- SessionStartup() ................................................................ 195

8.8.5         Access Functions ............................................................................................. 196

     8.8.5.1   SessionIsLoaded()...................................................................................... 196

     8.8.5.2   SessionIsSaved() ....................................................................................... 196

     8.8.5.3   SessionPCRValueIsCurrent()...................................................................... 197

     8.8.5.4   SessionGet() .............................................................................................. 197

8.8.6         Utility Functions................................................................................................ 198

     8.8.6.1   ContextIdSessionCreate()........................................................................... 198

     8.8.6.2   SessionCreate().......................................................................................... 199

     8.8.6.3   SessionContextSave() ................................................................................ 201

     8.8.6.4   SessionContextLoad() ................................................................................ 202

     8.8.6.5   SessionFlush() ........................................................................................... 204

     8.8.6.6   SessionComputeBoundEntity() ................................................................... 204

     8.8.6.7   SessionInitPolicyData()............................................................................... 205

     8.8.6.8   SessionResetPolicyData() .......................................................................... 206

     8.8.6.9   SessionCapGetLoaded()............................................................................. 206

     8.8.6.10  SessionCapGetSaved() .............................................................................. 207

     8.8.6.11  SessionCapGetLoadedNumber() ................................................................ 208

Family "2.0"                 TCG Published              Page ix

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

        8.8.6.12  SessionCapGetLoadedAvail() ..................................................................... 208

        8.8.6.13  SessionCapGetActiveNumber() .................................................................. 209

        8.8.6.14  SessionCapGetActiveAvail() ....................................................................... 209

   8.9  Time.c ..................................................................................................................... 209

        8.9.1    Introduction ...................................................................................................... 209

        8.9.2    Includes ........................................................................................................... 209

        8.9.3    Functions ......................................................................................................... 210

        8.9.3.1   TimePowerOn() .......................................................................................... 210

        8.9.3.2   TimeStartup() ............................................................................................. 210

        8.9.3.3   TimeUpdateToCurrent() .............................................................................. 211

        8.9.3.4   TimeSetAdjustRate() .................................................................................. 212

        8.9.3.5   TimeGetRange() ......................................................................................... 212

        8.9.3.6   TimeFillInfo ................................................................................................ 213

9  Support ............................................................................................................................ 214

   9.1  AlgorithmCap.c........................................................................................................ 214

        9.1.1    Description ....................................................................................................... 214

        9.1.2    Includes and Defines ........................................................................................ 214

        9.1.3    AlgorithmCapGetImplemented()........................................................................ 215

   9.2  Bits.c....................................................................................................................... 217

        9.2.1    Introduction ...................................................................................................... 217

        9.2.2    Includes ........................................................................................................... 217

        9.2.3    Functions ......................................................................................................... 217

        9.2.3.1   BitIsSet() .................................................................................................... 217

        9.2.3.2   BitSet() ....................................................................................................... 217

        9.2.3.3   BitClear() .................................................................................................... 218

   9.3  CommandAttributeData.c ........................................................................................ 218

   9.4  CommandCodeAttributes.c ...................................................................................... 224

        9.4.1    Introduction ...................................................................................................... 224

        9.4.2    Includes and Defines ........................................................................................ 224

        9.4.3    Command Attribute Functions .......................................................................... 224

        9.4.3.1   CommandAuthRole() .................................................................................. 224

        9.4.3.2   CommandIsImplemented() .......................................................................... 224

        9.4.3.3   CommandGetAttribute() .............................................................................. 225

        9.4.3.4   EncryptSize() .............................................................................................. 225

        9.4.3.5   DecryptSize().............................................................................................. 226

        9.4.3.6   IsSessionAllowed() ..................................................................................... 226

        9.4.3.7   IsHandleInResponse() ................................................................................ 226

        9.4.3.8   IsWriteOperation() ...................................................................................... 227

        9.4.3.9   IsReadOperation() ...................................................................................... 227

        9.4.3.10  CommandCapGetCCList() .......................................................................... 227

   9.5  DRTM.c................................................................................................................... 228

        9.5.1    Description ....................................................................................................... 228

        9.5.2    Includes ........................................................................................................... 228

        9.5.3    Functions ......................................................................................................... 229

        9.5.3.1   Signal_Hash_Start() ................................................................................... 229

        9.5.3.2   Signal_Hash_Data() ................................................................................... 229

        9.5.3.3   Signal_Hash_End()..................................................................................... 229

   9.6  Entity.c .................................................................................................................... 229

        9.6.1    Description ....................................................................................................... 229

        9.6.2    Includes ........................................................................................................... 229

Page x                           TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part  4: Supporting Routines                             Trusted Platform Module Library

      9.6.3         Functions ......................................................................................................... 230

           9.6.3.1   EntityGetLoadStatus() ................................................................................ 230

           9.6.3.2   EntityGetAuthValue() .................................................................................. 232

           9.6.3.3   EntityGetAuthPolicy() ................................................................................. 233

           9.6.3.4   EntityGetName() ......................................................................................... 234

           9.6.3.5   EntityGetHierarchy() ................................................................................... 235

      9.7   Global.c................................................................................................................... 236

      9.7.1         Description ....................................................................................................... 236

      9.7.2         Includes and Defines ........................................................................................ 236

      9.7.3         Global Data Values .......................................................................................... 236

      9.7.4         Private Values .................................................................................................. 237

           9.7.4.1   SessionProcess.c ....................................................................................... 237

           9.7.4.2   DA.c ........................................................................................................... 237

           9.7.4.3   NV.c ........................................................................................................... 237

           9.7.4.4   Object.c ...................................................................................................... 238

           9.7.4.5   PCR.c......................................................................................................... 238

           9.7.4.6   Session.c.................................................................................................... 238

           9.7.4.7   Manufacture.c............................................................................................. 238

           9.7.4.8   Power.c ...................................................................................................... 238

           9.7.4.9   MemoryLib.c ............................................................................................... 238

           9.7.4.10  SelfTest.c ................................................................................................... 238

           9.7.4.11  TpmFail.c ................................................................................................... 238

      9.8   Handle.c.................................................................................................................. 239

      9.8.1         Description ....................................................................................................... 239

      9.8.2         Includes ........................................................................................................... 239

      9.8.3         Functions ......................................................................................................... 239

           9.8.3.1   HandleGetType() ........................................................................................ 239

           9.8.3.2   NextPermanentHandle() ............................................................................. 239

           9.8.3.3   PermanentCapGetHandles() ....................................................................... 240

      9.9   Locality.c................................................................................................................. 241

      9.9.1         Includes ........................................................................................................... 241

      9.9.2         LocalityGetAttributes() ...................................................................................... 241

      9.10  Manufacture.c ......................................................................................................... 241

      9.10.1        Description ....................................................................................................... 241

      9.10.2        Includes and Data Definitions ........................................................................... 241

      9.10.3        Functions ......................................................................................................... 242

           9.10.3.1  TPM_Manufacture() .................................................................................... 242

           9.10.3.2  TPM_TearDown() ....................................................................................... 243

      9.11  Marshal.c ................................................................................................................ 244

      9.11.1        Introduction ...................................................................................................... 244

      9.11.2        Unmarshal and Marshal a Value ....................................................................... 244

      9.11.3        Unmarshal and Marshal a Union ....................................................................... 245

      9.11.4        Unmarshal and Marshal a Structure.................................................................. 247

      9.11.5        Unmarshal and Marshal an Array ..................................................................... 249

      9.11.6        TPM2B Handling .............................................................................................. 251

      9.12  MemoryLib.c............................................................................................................ 252

      9.12.1        Description ....................................................................................................... 252

      9.12.2        Includes and Data Definitions ........................................................................... 252

      9.12.3        Functions on BYTE Arrays................................................................................ 252

Family "2.0"                  TCG Published              Page xi

Level 00 Revision 01.16       Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

          9.12.3.1   MemoryMove()............................................................................................ 252

          9.12.3.2   MemoryCopy() ............................................................................................ 253

          9.12.3.3   MemoryEqual() ........................................................................................... 253

          9.12.3.4   MemoryCopy2B() ........................................................................................ 253

          9.12.3.5   MemoryConcat2B() ..................................................................................... 254

          9.12.3.6   Memory2BEqual() ....................................................................................... 254

          9.12.3.7   MemorySet()............................................................................................... 255

          9.12.3.8   MemoryGetActionInputBuffer().................................................................... 255

          9.12.3.9   MemoryGetActionOutputBuffer() ................................................................. 255

          9.12.3.10  MemoryGetResponseBuffer()...................................................................... 256

          9.12.3.11  MemoryRemoveTrailingZeros() ................................................................... 256

    9.13  Power.c ................................................................................................................... 256

    9.13.1  Description ....................................................................................................... 256

    9.13.2  Includes and Data Definitions ........................................................................... 256

    9.13.3  Functions ......................................................................................................... 257

          9.13.3.1   TPMInit() .................................................................................................... 257

          9.13.3.2   TPMRegisterStartup() ................................................................................. 257

          9.13.3.3   TPMIsStarted() ........................................................................................... 257

    9.14  PropertyCap.c ......................................................................................................... 257

    9.14.1  Description ....................................................................................................... 257

    9.14.2  Includes ........................................................................................................... 258

    9.14.3  Functions ......................................................................................................... 258

          9.14.3.1   PCRGetProperty() ...................................................................................... 258

          9.14.3.2   TPMCapGetProperties() ............................................................................. 264

    9.15  TpmFail.c ................................................................................................................ 265

    9.15.1  Includes, Defines, and Types ........................................................................... 265

    9.15.2  Typedefs .......................................................................................................... 265

    9.15.3  Local Functions ................................................................................................ 266

          9.15.3.1   MarshalUint16() .......................................................................................... 266

          9.15.3.2   MarshalUint32() .......................................................................................... 266

          9.15.3.3   UnmarshalHeader() .................................................................................... 267

    9.15.4  Public Functions ............................................................................................... 267

          9.15.4.1   SetForceFailureMode() ............................................................................... 267

          9.15.4.2   TpmFail() .................................................................................................... 267

    9.15.5  TpmFailureMode .............................................................................................. 268

10  Cryptographic Functions ................................................................................................... 272

    10.1  Introduction ............................................................................................................. 272

    10.2  CryptUtil.c ............................................................................................................... 272

    10.2.1  Includes ........................................................................................................... 272

    10.2.2  TranslateCryptErrors() ...................................................................................... 272

    10.2.3  Random Number Generation Functions ............................................................ 273

          10.2.3.1   CryptDrbgGetPutState().............................................................................. 273

          10.2.3.2   CryptStirRandom() ...................................................................................... 273

          10.2.3.3   CryptGenerateRandom()............................................................................. 273

    10.2.4  Hash/HMAC Functions ..................................................................................... 274

          10.2.4.1   CryptGetContextAlg() ................................................................................. 274

          10.2.4.2   CryptStartHash()......................................................................................... 274

          10.2.4.3   CryptStartHashSequence() ......................................................................... 275

          10.2.4.4   CryptStartHMAC()....................................................................................... 275

Page xii                         TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

10.2.4.5      CryptStartHMACSequence() ....................................................................... 276

10.2.4.6      CryptStartHMAC2B() .................................................................................. 276

10.2.4.7      CryptStartHMACSequence2B() ................................................................... 277

10.2.4.8      CryptUpdateDigest() ................................................................................... 277

10.2.4.9      CryptUpdateDigest2B() ............................................................................... 278

10.2.4.10     CryptUpdateDigestInt() ............................................................................... 278

10.2.4.11     CryptCompleteHash() ................................................................................. 279

10.2.4.12     CryptCompleteHash2B() ............................................................................. 279

10.2.4.13     CryptHashBlock() ....................................................................................... 280

10.2.4.14     CryptCompleteHMAC() ............................................................................... 280

10.2.4.15     CryptCompleteHMAC2B() ........................................................................... 281

10.2.4.16     CryptHashStateImportExport() .................................................................... 281

10.2.4.17     CryptGetHashDigestSize() .......................................................................... 281

10.2.4.18     CryptGetHashBlockSize() ........................................................................... 282

10.2.4.19     CryptGetHashAlgByIndex() ......................................................................... 282

10.2.4.20     CryptSignHMAC() ....................................................................................... 282

10.2.4.21     CryptHMACVerifySignature() ...................................................................... 283

10.2.4.22     CryptGenerateKeyedHash() ........................................................................ 283

10.2.4.23     CryptKDFa() ............................................................................................... 285

10.2.4.24     CryptKDFaOnce() ....................................................................................... 285

10.2.4.25     KDFa() ....................................................................................................... 285

10.2.4.26     CryptKDFe() ............................................................................................... 286

10.2.5        RSA Functions ................................................................................................. 286

10.2.5.1      BuildRSA() ................................................................................................. 286

10.2.5.2      CryptTestKeyRSA() .................................................................................... 286

10.2.5.3      CryptGenerateKeyRSA()............................................................................. 287

10.2.5.4      CryptLoadPrivateRSA() .............................................................................. 288

10.2.5.5      CryptSelectRSAScheme() ........................................................................... 288

10.2.5.6      CryptDecryptRSA() ..................................................................................... 289

10.2.5.7      CryptEncryptRSA() ..................................................................................... 291

10.2.5.8      CryptSignRSA() .......................................................................................... 292

10.2.5.9      CryptRSAVerifySignature() ......................................................................... 293

10.2.6        ECC Functions ................................................................................................. 294

10.2.6.1      CryptEccGetCurveDataPointer() ................................................................. 294

10.2.6.2      CryptEccGetKeySizeInBits() ....................................................................... 294

10.2.6.3      CryptEccGetKeySizeBytes() ....................................................................... 294

10.2.6.4      CryptEccGetParameter()............................................................................. 294

10.2.6.5      CryptGetCurveSignScheme() ...................................................................... 295

10.2.6.6      CryptEccIsPointOnCurve() .......................................................................... 295

10.2.6.7      CryptNewEccKey() ..................................................................................... 296

10.2.6.8      CryptEccPointMultiply() .............................................................................. 296

10.2.6.9      CryptGenerateKeyECC() ............................................................................ 297

10.2.6.10     CryptSignECC() .......................................................................................... 297

10.2.6.11     CryptECCVerifySignature() ......................................................................... 298

10.2.6.12     CryptGenerateR() ....................................................................................... 299

10.2.6.13     CryptCommit() ............................................................................................ 301

10.2.6.14     CryptEndCommit() ...................................................................................... 301

10.2.6.15     CryptCommitCompute() .............................................................................. 301

10.2.6.16     CryptEccGetParameters() ........................................................................... 302

10.2.6.17     CryptIsSchemeAnonymous()....................................................................... 303

10.2.7        Symmetric Functions ........................................................................................ 303

10.2.7.1      ParmDecryptSym() ..................................................................................... 303

10.2.7.2      ParmEncryptSym() ..................................................................................... 304

10.2.7.3      CryptGenerateNewSymmetric() .................................................................. 305

10.2.7.4      CryptGenerateKeySymmetric() ................................................................... 306

Family "2.0"                 TCG Published              Page xiii

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

          10.2.7.5   CryptXORObfuscation() .............................................................................. 307

10.2.8    Initialization and shut down .............................................................................. 307

          10.2.8.1   CryptInitUnits() ........................................................................................... 307

          10.2.8.2   CryptStopUnits() ......................................................................................... 308

          10.2.8.3   CryptUtilStartup()........................................................................................ 308

10.2.9    Algorithm-Independent Functions ..................................................................... 309

          10.2.9.1   Introduction ................................................................................................ 309

          10.2.9.2   CryptIsAsymAlgorithm() .............................................................................. 309

          10.2.9.3   CryptGetSymmetricBlockSize() ................................................................... 309

          10.2.9.4   CryptSymmetricEncrypt() ............................................................................ 310

          10.2.9.5   CryptSymmetricDecrypt() ............................................................................ 311

          10.2.9.6   CryptSecretEncrypt() .................................................................................. 313

          10.2.9.7   CryptSecretDecrypt() .................................................................................. 315

          10.2.9.8   CryptParameterEncryption() ....................................................................... 318

          10.2.9.9   CryptParameterDecryption() ....................................................................... 319

          10.2.9.10  CryptComputeSymmetricUnique() ............................................................... 320

          10.2.9.11  CryptComputeSymValue() .......................................................................... 321

          10.2.9.12  CryptCreateObject() ................................................................................... 321

          10.2.9.13  CryptObjectIsPublicConsistent() ................................................................. 324

          10.2.9.14  CryptObjectPublicPrivateMatch() ................................................................ 325

          10.2.9.15  CryptGetSignHashAlg() .............................................................................. 326

          10.2.9.16  CryptIsSplitSign() ....................................................................................... 327

          10.2.9.17  CryptIsSignScheme() .................................................................................. 327

          10.2.9.18  CryptIsDecryptScheme() ............................................................................. 328

          10.2.9.19  CryptSelectSignScheme() ........................................................................... 328

          10.2.9.20  CryptSign() ................................................................................................. 330

          10.2.9.21  CryptVerifySignature() ................................................................................ 331

10.2.10 Math functions .................................................................................................. 332

          10.2.10.1  CryptDivide() .............................................................................................. 332

          10.2.10.2  CryptCompare() .......................................................................................... 333

          10.2.10.3  CryptCompareSigned() ............................................................................... 333

          10.2.10.4  CryptGetTestResult .................................................................................... 333

10.2.11 Capability Support ............................................................................................ 334

          10.2.11.1  CryptCapGetECCCurve() ............................................................................ 334

          10.2.11.2  CryptCapGetEccCurveNumber() ................................................................. 335

          10.2.11.3  CryptAreKeySizesConsistent() .................................................................... 335

          10.2.11.4  CryptAlgSetImplemented() .......................................................................... 336

10.3      Ticket.c ................................................................................................................... 336

10.3.1    Introduction ...................................................................................................... 336

10.3.2    Includes ........................................................................................................... 336

10.3.3    Functions ......................................................................................................... 336

          10.3.3.1   TicketIsSafe() ............................................................................................. 336

          10.3.3.2   TicketComputeVerified() ............................................................................. 337

          10.3.3.3   TicketComputeAuth() .................................................................................. 337

          10.3.3.4   TicketComputeHashCheck() ....................................................................... 338

          10.3.3.5   TicketComputeCreation() ............................................................................ 339

10.4      CryptSelfTest.c ....................................................................................................... 339

10.4.1    Introduction ...................................................................................................... 339

10.4.2    Functions ......................................................................................................... 340

          10.4.2.1   RunSelfTest() ............................................................................................. 340

          10.4.2.2   CryptSelfTest() ........................................................................................... 340

Page xiv                         TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

     10.4.2.3   CryptIncrementalSelfTest() ......................................................................... 341

     10.4.2.4   CryptInitializeToTest() ................................................................................ 342

     10.4.2.5   CryptTestAlgorithm() .................................................................................. 342

Annex A (informative)    Implementation Dependent .................................................................. 344

A.1  Introduction ............................................................................................................. 344

A.2  Implementation.h..................................................................................................... 344

Annex B (informative)    Cryptographic Library Interface ............................................................ 359

B.1  Introduction ............................................................................................................. 359

B.2  Integer Format ........................................................................................................ 359

B.3  CryptoEngine.h ....................................................................................................... 359

B.3.1.        Introduction ...................................................................................................... 359

B.3.2.        General Purpose Macros .................................................................................. 360

B.3.3.        Self-test ........................................................................................................... 360

B.3.4.        Hash-related Structures.................................................................................... 360

B.3.5.        Asymmetric Structures and Values ................................................................... 362

     B.3.5.1.   ECC-related Structures............................................................................... 362

     B.3.5.2.   RSA-related Structures ............................................................................... 362

B.3.6.        Miscelaneous ................................................................................................... 362

B.4  OsslCryptoEngine.h ................................................................................................ 364

B.4.1.        Introduction ...................................................................................................... 364

B.4.2.        Defines............................................................................................................. 364

B.5  MathFunctions.c ...................................................................................................... 365

B.5.1.        Introduction ...................................................................................................... 365

B.5.2.        Externally Accessible Functions ....................................................................... 365

     B.5.2.1.   _math__Normalize2B() ............................................................................... 365

     B.5.2.2.   _math__Denormalize2B() ........................................................................... 366

     B.5.2.3.   _math__sub() ............................................................................................. 366

     B.5.2.4.   _math__Inc() .............................................................................................. 367

     B.5.2.5.   _math__Dec() ............................................................................................. 368

     B.5.2.6.   _math__Mul() ............................................................................................. 368

     B.5.2.7.   _math__Div() .............................................................................................. 369

     B.5.2.8.   _math__uComp() ........................................................................................ 370

     B.5.2.9.   _math__Comp() .......................................................................................... 371

     B.5.2.10.  _math__ModExp......................................................................................... 372

     B.5.2.11.  _math__IsPrime() ....................................................................................... 373

B.6  CpriCryptPri.c.......................................................................................................... 375

B.6.1.        Introduction ...................................................................................................... 375

B.6.2.        Includes and Locals.......................................................................................... 375

B.6.3.        Functions ......................................................................................................... 375

     B.6.3.1.   TpmFail() .................................................................................................... 375

     B.6.3.2.   FAILURE_TRAP() ....................................................................................... 375

     B.6.3.3.   _cpri__InitCryptoUnits() .............................................................................. 375

     B.6.3.4.   _cpri__StopCryptoUnits()............................................................................ 376

     B.6.3.5.   _cpri__Startup().......................................................................................... 376

B.7  CpriRNG.c............................................................................................................... 377

B.7.1.        Introduction ...................................................................................................... 377

B.7.2.        Includes ........................................................................................................... 377

B.7.3.        Functions ......................................................................................................... 377

     B.7.3.1.   _cpri__RngStartup() ................................................................................... 377

Family "2.0"                 TCG Published              Page xv

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

          B.7.3.2.   _cpri__DrbgGetPutState() .......................................................................... 377

          B.7.3.3.   _cpri__StirRandom()................................................................................... 378

          B.7.3.4.   _cpri__GenerateRandom().......................................................................... 378

          B.7.3.4.1. _cpri__GenerateSeededRandom() .............................................................. 379

B.8       CpriHash.c .............................................................................................................. 380

B.8.1.    Description ....................................................................................................... 380

B.8.2.    Includes, Defines, and Types ........................................................................... 380

B.8.3.    Static Functions................................................................................................ 380

          B.8.3.1.   GetHashServer() ........................................................................................ 380

          B.8.3.2.   MarshalHashState() .................................................................................... 381

          B.8.3.3.   GetHashState()........................................................................................... 381

          B.8.3.4.   GetHashInfoPointer() .................................................................................. 382

B.8.4.    Hash Functions ................................................................................................ 382

          B.8.4.1.   _cpri__HashStartup().................................................................................. 382

          B.8.4.2.   _cpri__GetHashAlgByIndex() ...................................................................... 382

          B.8.4.3.   _cpri__GetHashBlockSize() ........................................................................ 383

          B.8.4.4.   _cpri__GetHashDER .................................................................................. 383

          B.8.4.5.   _cpri__GetDigestSize()............................................................................... 383

          B.8.4.6.   _cpri__GetContextAlg() .............................................................................. 384

          B.8.4.7.   _cpri__CopyHashState ............................................................................... 384

          B.8.4.8.   _cpri__StartHash() ..................................................................................... 384

          B.8.4.9.   _cpri__UpdateHash() .................................................................................. 385

          B.8.4.10.  _cpri__CompleteHash() .............................................................................. 386

          B.8.4.11.  _cpri__ImportExportHashState() ................................................................. 387

          B.8.4.12.  _cpri__HashBlock() .................................................................................... 388

B.8.5.    HMAC Functions .............................................................................................. 389

          B.8.5.1.   _cpri__StartHMAC ...................................................................................... 389

          B.8.5.2.   _cpri_CompleteHMAC() .............................................................................. 390

B.8.6.    Mask and Key Generation Functions ................................................................ 390

          B.8.6.1.   _crypi_MGF1()............................................................................................ 390

          B.8.6.2.   _cpri_KDFa() .............................................................................................. 392

          B.8.6.3.   _cpri__KDFe() ............................................................................................ 394

B.9       CpriHashData.c ....................................................................................................... 396

B.10      CpriMisc.c ............................................................................................................... 397

B.10.1.   Includes ........................................................................................................... 397

B.10.2.   Functions ......................................................................................................... 397

          B.10.2.1.  BnTo2B() .................................................................................................... 397

          B.10.2.2.  Copy2B() .................................................................................................... 397

          B.10.2.3.  BnFrom2B() ................................................................................................ 398

B.11      CpriSym.c ............................................................................................................... 399

B.11.1.   Introduction ...................................................................................................... 399

B.11.2.   Includes, Defines, and Typedefs....................................................................... 399

B.11.3.   Utility Functions................................................................................................ 399

          B.11.3.1.  _cpri_SymStartup() ..................................................................................... 399

          B.11.3.2.  _cpri__GetSymmetricBlockSize() ................................................................ 399

B.11.4.   AES        Encryption ................................................................................................ 400

          B.11.4.1.  _cpri__AESEncryptCBC() ........................................................................... 400

          B.11.4.2.  _cpri__AESDecryptCBC() ........................................................................... 401

          B.11.4.3.  _cpri__AESEncryptCFB() ........................................................................... 402

Page xvi                         TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                               Trusted Platform Module Library

B.11.4.4.     _cpri__AESDecryptCFB() ........................................................................... 403

B.11.4.5.     _cpri__AESEncryptCTR() ........................................................................... 404

B.11.4.6.     _cpri__AESDecryptCTR() ........................................................................... 405

B.11.4.7.     _cpri__AESEncryptECB() ........................................................................... 405

B.11.4.8.     _cpri__AESDecryptECB() ........................................................................... 406

B.11.4.9.     _cpri__AESEncryptOFB() ........................................................................... 406

B.11.4.10. _cpri__AESDecryptOFB() ........................................................................... 407

B.11.5.       SM4  Encryption ................................................................................................ 408

B.11.5.1.     _cpri__SM4EncryptCBC() ........................................................................... 408

B.11.5.2.     _cpri__SM4DecryptCBC() ........................................................................... 409

B.11.5.3.     _cpri__SM4EncryptCFB() ........................................................................... 410

B.11.5.4.     _cpri__SM4DecryptCFB() ........................................................................... 410

B.11.5.5.     _cpri__SM4EncryptCTR() ........................................................................... 411

B.11.5.6.     _cpri__SM4DecryptCTR() ........................................................................... 412

B.11.5.7.     _cpri__SM4EncryptECB() ........................................................................... 413

B.11.5.8.     _cpri__SM4DecryptECB() ........................................................................... 413

B.11.5.9.     _cpri__SM4EncryptOFB() ........................................................................... 414

B.11.5.10. _cpri__SM4DecryptOFB() ........................................................................... 415

B.12  RSA Files ................................................................................................................ 416

B.12.1.       CpriRSA.c ........................................................................................................ 416

B.12.1.1.     Introduction ................................................................................................ 416

B.12.1.2.     Includes...................................................................................................... 416

B.12.1.3.     Local Functions .......................................................................................... 416

B.12.1.3.1.        RsaPrivateExponent() ............................................................................ 416

B.12.1.3.2.        _cpri__TestKeyRSA() ............................................................................. 418

B.12.1.3.3.        RSAEP() ................................................................................................ 420

B.12.1.3.4.        RSADP() ................................................................................................ 420

B.12.1.3.5.        OaepEncode() ........................................................................................ 421

B.12.1.3.6.        OaepDecode() ........................................................................................ 423

B.12.1.3.7.        PKSC1v1_5Encode().............................................................................. 425

B.12.1.3.8.        RSAES_Decode()................................................................................... 425

B.12.1.3.9.        PssEncode()........................................................................................... 426

B.12.1.3.10.       PssDecode() ........................................................................................ 427

B.12.1.3.11.       PKSC1v1_5SignEncode() ..................................................................... 429

B.12.1.3.12.       RSASSA_Decode()............................................................................... 430

B.12.1.4.     Externally Accessible Functions.................................................................. 431

B.12.1.4.1.        _cpri__RsaStartup() ............................................................................... 431

B.12.1.4.2.        _cpri__EncryptRSA() .............................................................................. 431

B.12.1.4.3.        _cpri__DecryptRSA().............................................................................. 433

B.12.1.4.4.        _cpri__SignRSA()................................................................................... 434

B.12.1.4.5.        _cpri__ValidateSignatureRSA() .............................................................. 435

B.12.1.4.6.        _cpri__GenerateKeyRSA() ..................................................................... 435

B.12.2.       Alternative RSA  Key Generation ....................................................................... 440

B.12.2.1.     Introduction ................................................................................................ 440

B.12.2.2.     RSAKeySieve.h .......................................................................................... 440

B.12.2.3.     RSAKeySieve.c .......................................................................................... 443

B.12.2.3.1.        Includes and defines .............................................................................. 443

B.12.2.3.2.        Bit Manipulation Functions ..................................................................... 443

B.12.2.3.3.        Miscellaneous Functions ........................................................................ 445

B.12.2.3.4.        Public Function ...................................................................................... 455

B.12.2.4.     RSAData.c.................................................................................................. 459

B.13  Elliptic Curve Files .................................................................................................. 471

Family "2.0"                   TCG Published              Page xvii

Level 00 Revision 01.16        Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

B.13.1.     CpriDataEcc.h .................................................................................................. 471

B.13.2.     CpriDataEcc.c .................................................................................................. 472

B.13.3.     CpriECC.c ........................................................................................................ 479

     B.13.3.1.    Includes and Defines .................................................................................. 479

     B.13.3.2.    Functions.................................................................................................... 479

     B.13.3.2.1.       _cpri__EccStartup()................................................................................ 479

     B.13.3.2.2.       _cpri__GetCurveIdByIndex() .................................................................. 479

     B.13.3.2.3.       _cpri__EccGetParametersByCurveId() ................................................... 479

     B.13.3.2.4.       Point2B() ................................................................................................ 480

     B.13.3.2.5.       EccCurveInit() ........................................................................................ 481

     B.13.3.2.6.       PointFrom2B() ........................................................................................ 482

     B.13.3.2.7.       EccInitPoint2B() ..................................................................................... 482

     B.13.3.2.8.       PointMul() .............................................................................................. 483

     B.13.3.2.9.       GetRandomPrivate()............................................................................... 483

     B.13.3.2.10.      Mod2B() ............................................................................................... 484

     B.13.3.2.11.      _cpri__EccPointMultiply ....................................................................... 484

     B.13.3.2.12.      ClearPoint2B()...................................................................................... 486

     B.13.3.2.13.      _cpri__EccCommitCompute() ............................................................... 486

     B.13.3.2.14.      _cpri__EccIsPointOnCurve() ................................................................ 489

     B.13.3.2.15.      _cpri__GenerateKeyEcc()..................................................................... 490

     B.13.3.2.16.      _cpri__GetEphemeralEcc()................................................................... 492

     B.13.3.2.17.      SignEcdsa().......................................................................................... 492

     B.13.3.2.18.      EcDaa() ................................................................................................ 495

     B.13.3.2.19.      SchnorrEcc() ........................................................................................ 496

     B.13.3.2.20.      SignSM2() ............................................................................................ 499

     B.13.3.2.21.      _cpri__SignEcc() .................................................................................. 502

     B.13.3.2.22.      ValidateSignatureEcdsa() ..................................................................... 502

     B.13.3.2.23.      ValidateSignatureEcSchnorr() .............................................................. 505

     B.13.3.2.24.      ValidateSignatueSM2Dsa()................................................................... 506

     B.13.3.2.25.      _cpri__ValidateSignatureEcc() ............................................................. 508

     B.13.3.2.26.      avf1() ................................................................................................... 509

     B.13.3.2.27.      C_2_2_MQV() ...................................................................................... 509

     B.13.3.2.28.      avfSm2() .............................................................................................. 512

     B.13.3.2.29.      C_2_2_ECDH() .................................................................................... 514

     B.13.3.2.30.      _cpri__C_2_2_KeyExchange() ............................................................. 515

Annex C (informative)  Simulation Environment ....................................................................... 517

C.1         Introduction ............................................................................................................. 517

C.2         Cancel.c .................................................................................................................. 517

C.2.1.      Introduction ...................................................................................................... 517

C.2.2.      Includes, Typedefs, Structures, and Defines ..................................................... 517

C.2.3.      Functions ......................................................................................................... 517

     C.2.3.1.     _plat__IsCanceled() ................................................................................... 517

     C.2.3.2.     _plat__SetCancel() ..................................................................................... 517

     C.2.3.3.     _plat__ClearCancel() .................................................................................. 518

C.3         Clock.c .................................................................................................................... 519

C.3.1.      Introduction ...................................................................................................... 519

C.3.2.      Includes and Data Definitions ........................................................................... 519

C.3.3.      Functions ......................................................................................................... 519

     C.3.3.1.     _plat__ClockReset() ................................................................................... 519

     C.3.3.2.     _plat__ClockTimeFromStart() ..................................................................... 519

     C.3.3.3.     _plat__ClockTimeElapsed() ........................................................................ 519

     C.3.3.4.     _plat__ClockAdjustRate() ........................................................................... 520

C.4         Entropy.c................................................................................................................. 521

Page xviii                       TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part 4: Supporting Routines                             Trusted Platform Module Library

C.4.1.        Includes ........................................................................................................... 521

C.4.2.        Local values ..................................................................................................... 521

C.4.3.        _plat__GetEntropy() ......................................................................................... 521

C.5  LocalityPlat.c........................................................................................................... 523

C.5.1.        Includes ........................................................................................................... 523

C.5.2.        Functions ......................................................................................................... 523

     C.5.2.1.   _plat__LocalityGet() ................................................................................... 523

     C.5.2.2.   _plat__LocalitySet() .................................................................................... 523

     C.5.2.3.   _plat__IsRsaKeyCacheEnabled() ............................................................... 523

C.6  NVMem.c ................................................................................................................ 524

C.6.1.        Introduction ...................................................................................................... 524

C.6.2.        Includes ........................................................................................................... 524

C.6.3.        Functions ......................................................................................................... 524

     C.6.3.1.   _plat__NvErrors() ....................................................................................... 524

     C.6.3.2.   _plat__NVEnable() ..................................................................................... 524

     C.6.3.3.   _plat__NVDisable() .................................................................................... 525

     C.6.3.4.   _plat__IsNvAvailable() ................................................................................ 526

     C.6.3.5.   _plat__NvMemoryRead() ............................................................................ 526

     C.6.3.6.   _plat__NvIsDifferent()................................................................................. 526

     C.6.3.7.   _plat__NvMemoryWrite() ............................................................................ 527

     C.6.3.8.   _plat__NvMemoryMove() ............................................................................ 527

     C.6.3.9.   _plat__NvCommit() ..................................................................................... 527

     C.6.3.10.  _plat__SetNvAvail() .................................................................................... 528

     C.6.3.11.  _plat__ClearNvAvail() ................................................................................. 528

C.7  PowerPlat.c ............................................................................................................. 529

C.7.1.        Includes and Function Prototypes ..................................................................... 529

C.7.2.        Functions ......................................................................................................... 529

     C.7.2.1.   _plat__Signal_PowerOn() ........................................................................... 529

     C.7.2.2.   _plat__WasPowerLost() .............................................................................. 529

     C.7.2.3.   _plat_Signal_Reset() .................................................................................. 529

     C.7.2.4.   _plat__Signal_PowerOff() ........................................................................... 530

C.8  Platform.h ............................................................................................................... 531

C.8.1.        Includes and Defines ........................................................................................ 531

C.8.2.        Power Functions............................................................................................... 531

     C.8.2.1.   _plat__Signal_PowerOn ............................................................................. 531

     C.8.2.2.   _plat__Signal_Reset................................................................................... 531

     C.8.2.3.   _plat__WasPowerLost() .............................................................................. 531

     C.8.2.4.   _plat__Signal_PowerOff() ........................................................................... 531

C.8.3.        Physical Presence Functions ............................................................................ 531

     C.8.3.1.   _plat__PhysicalPresenceAsserted() ............................................................ 531

     C.8.3.2.   _plat__Signal_PhysicalPresenceOn............................................................ 532

     C.8.3.3.   _plat__Signal_PhysicalPresenceOff() ......................................................... 532

C.8.4.        Command Canceling Functions ........................................................................ 532

     C.8.4.1.   _plat__IsCanceled() ................................................................................... 532

     C.8.4.2.   _plat__SetCancel() ..................................................................................... 532

     C.8.4.3.   _plat__ClearCancel() .................................................................................. 532

C.8.5.        NV memory functions ....................................................................................... 533

     C.8.5.1.   _plat__NvErrors() ....................................................................................... 533

     C.8.5.2.   _plat__NVEnable() ..................................................................................... 533

Family "2.0"                 TCG Published              Page xix

Level 00 Revision 01.16      Copyright © TCG 2006-2014  October 30, 2014
Trusted Platform Module Library                             Part 4: Supporting Routines

         C.8.5.3.   _plat__NVDisable() .................................................................................... 533

         C.8.5.4.   _plat__IsNvAvailable() ................................................................................ 533

         C.8.5.5.   _plat__NvCommit() ..................................................................................... 533

         C.8.5.6.   _plat__NvMemoryRead() ............................................................................ 534

         C.8.5.7.   _plat__NvIsDifferent()................................................................................. 534

         C.8.5.8.   _plat__NvMemoryWrite() ............................................................................ 534

         C.8.5.9.   _plat__NvMemoryMove() ............................................................................ 534

         C.8.5.10.  _plat__SetNvAvail() .................................................................................... 535

         C.8.5.11.  _plat__ClearNvAvail() ................................................................................. 535

C.8.6.   Locality Functions ............................................................................................ 535

         C.8.6.1.   _plat__LocalityGet() ................................................................................... 535

         C.8.6.2.   _plat__LocalitySet() .................................................................................... 535

         C.8.6.3.   _plat__IsRsaKeyCacheEnabled() ............................................................... 535

C.8.7.   Clock Constants and Functions ........................................................................ 535

         C.8.7.1.   _plat__ClockReset() ................................................................................... 536

         C.8.7.2.   _plat__ClockTimeFromStart() ..................................................................... 536

         C.8.7.3.   _plat__ClockTimeElapsed() ........................................................................ 536

         C.8.7.4.   _plat__ClockAdjustRate() ........................................................................... 536

C.8.8.   Single Function Files ........................................................................................ 537

         C.8.8.1.   _plat__GetEntropy() ................................................................................... 537

C.9      PlatformData.h ........................................................................................................ 538

C.10     PlatformData.c ........................................................................................................ 539

C.10.1.  Description ....................................................................................................... 539

C.10.2.  Includes ........................................................................................................... 539

C.11     PPPlat.c .................................................................................................................. 540

C.11.1.  Description ....................................................................................................... 540

C.11.2.  Includes ........................................................................................................... 540

C.11.3.  Functions ......................................................................................................... 540

         C.11.3.1.  _plat__PhysicalPresenceAsserted() ............................................................ 540

         C.11.3.2.  _plat__Signal_PhysicalPresenceOn() ......................................................... 540

         C.11.3.3.  _plat__Signal_PhysicalPresenceOff() ......................................................... 540

C.12     Unique.c.................................................................................................................. 541

C.12.1.  Introduction ...................................................................................................... 541

C.12.2.  Includes ........................................................................................................... 541

C.12.3.  _plat__GetUnique() .......................................................................................... 541

Annex D (informative)  Remote Procedure Interface ................................................................ 542

D.1      Introduction ............................................................................................................. 542

D.2      TpmTcpProtocol.h ................................................................................................... 543

D.2.1.   Introduction ...................................................................................................... 543

D.2.2.   Typedefs and Defines ....................................................................................... 543

D.3      TcpServer.c............................................................................................................. 545

D.3.1.   Description ....................................................................................................... 545

D.3.2.   Includes, Locals, Defines and Function Prototypes ........................................... 545

D.3.3.   Functions ......................................................................................................... 545

         D.3.3.1.   CreateSocket() ........................................................................................... 545

         D.3.3.2.   PlatformServer() ......................................................................................... 546

         D.3.3.3.   PlatformSvcRoutine().................................................................................. 547

         D.3.3.4.   PlatformSignalService() .............................................................................. 548

         D.3.3.5.   RegularCommandService() ......................................................................... 549

Page xx                          TCG Published              Family "2.0"

October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
Part  4: Supporting Routines                             Trusted Platform Module Library

           D.3.3.6.   StartTcpServer() ......................................................................................... 549

           D.3.3.7.   ReadBytes() ............................................................................................... 550

           D.3.3.8.   WriteBytes() ............................................................................................... 550

           D.3.3.9.   WriteUINT32() ............................................................................................ 551

           D.3.3.10.  ReadVarBytes() .......................................................................................... 551

           D.3.3.11.  WriteVarBytes() .......................................................................................... 552

           D.3.3.12.  TpmServer() ............................................................................................... 552

      D.4  TPMCmdp.c ............................................................................................................ 555

      D.4.1.  Description ....................................................................................................... 555

      D.4.2.  Includes and Data Definitions ........................................................................... 555

      D.4.3.  Functions ......................................................................................................... 555

           D.4.3.1.   Signal_PowerOn() ...................................................................................... 555

           D.4.3.2.   Signal_PowerOff() ...................................................................................... 556

           D.4.3.3.   _rpc__ForceFailureMode().......................................................................... 556

           D.4.3.4.   _rpc__Signal_PhysicalPresenceOn() .......................................................... 556

           D.4.3.5.   _rpc__Signal_PhysicalPresenceOff() .......................................................... 556

           D.4.3.6.   _rpc__Signal_Hash_Start() ......................................................................... 557

           D.4.3.7.   _rpc__Signal_Hash_Data() ......................................................................... 557

           D.4.3.8.   _rpc__Signal_HashEnd() ............................................................................ 557

           D.4.3.9.   _rpc__Signal_CancelOn() ........................................................................... 558

           D.4.3.10.  _rpc__Signal_CancelOff()........................................................................... 558

           D.4.3.11.  _rpc__Signal_NvOn() ................................................................................. 559

           D.4.3.12.  _rpc__Signal_NvOff() ................................................................................. 559

           D.4.3.13.  _rpc__Shutdown() ...................................................................................... 559

      D.5  TPMCmds.c............................................................................................................. 560

      D.5.1.  Description ....................................................................................................... 560

      D.5.2.  Includes, Defines, Data Definitions, and Function Prototypes ........................... 560

      D.5.3.  Functions ......................................................................................................... 560

           D.5.3.1.   Usage() ...................................................................................................... 560

           D.5.3.2.   main() ......................................................................................................... 560

Family "2.0"                  TCG Published              Page xxi

Level 00 Revision 01.16       Copyright © TCG 2006-2014  October 30, 2014
Part 4: Supporting Routines                                                                Trusted Platform Module Library

                                    Trusted Platform Module Library

                                        Part 4: Supporting Routines

1    Scope

This part contains C code that describes the algorithms and methods used by the command code in TPM

2.0 Part 3. The code in this document augments TPM 2.0 Part 2 and TPM 2.0 Part 3 to provide a

complete   description    of  a  TPM,   including     the  supporting   framework   for        the  code  that   performs  the

command actions.

Any TPM 2.0 Part 4 code may be replaced by code that provides similar results when interfacing to the

action code in TPM 2.0 Part 3. The behavior of code in this document that is not included in an annex is

normative, as observed at the interfaces with TPM 2.0 Part 3 code. Code in an annex is provided for

completeness, that is, to allow a full implementation of the specification from the provided code.

The code in parts 3 and 4 is written to define the behavior of a compliant TPM. In some cases (e.g.,

firmware   update),   it  is  not   possible  to      provide   a  compliant  implementation.       In    those  cases,    any

implementation provided by the vendor that meets the general description of the function provided in TPM

2.0 Part 3 would be compliant.

The  code  in  parts  3   and    4  is  not  written  to  meet     any  particular  level  of  conformance      nor  does  this

specification require that a TPM meet any particular level of conformance.

2    Terms and definitions

For the purposes of this document, the terms and definitions given in TPM 2.0 Part 1 apply.

3    Symbols and abbreviated terms

For the purposes of this document, the symbols and abbreviated terms given in TPM 2.0 Part 1 apply.

4    Automation

TPM 2.0 Part 2 and 3 are constructed so that they can be processed by an automated parser.                                 For

example, TPM 2.0 Part 2 can be processed to generate header file contents such as structures, typedefs,

and enums.     TPM 2.0 Part 3 can be processed to generate command and response marshaling and

unmarshaling code.

The automated processor is not provided to the TCG.                It was used to generate the Microsoft Visual Studio

TPM simulator files.      These files are not specification reference code, but rather design examples.

4.1  Configuration Parser

The tables in the TPM 2.0 Part 2 Annexes are constructed so that they can be processed by a program.

The program that processes these tables in the TPM 2.0 Part 2 Annexes is called "The TPM 2.0 Part 2

Configuration Parser."

The tables in the TPM 2.0 Part 2 Annexes determine the configuration of a TPM implementation. These

tables may be modified by an implementer to describe the algorithms and commands to be executed in

by a specific implementation as well as to set implementation limits such as the number of PCR, sizes of

buffers, etc.

The TPM 2.0 Part 2 Configuration Parser produces a set of structures and definitions that are used by the

TPM 2.0 Part 2 Structure Parser.

Family "2.0"                                          TCG Published                                                  Page 1

Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                    October 30, 2014
Trusted Platform Module Library                                                                    Part 4: Supporting Routines

4.2      Structure Parser

4.2.1      Introduction

The program that processes the tables in TPM 2.0 Part 2 (other than the table in the annexes) is called

"The TPM 2.0 Part 2 Structure Parser."

NOTE               A Perl script was used to parse the tables in TPM 2.0 Part 2 to produce the header files and unmarshaling code

                   in for the reference implementation.

The    TPM    2.0  Part  2  Structure  Parser  takes            as  input  the   files  produced   by   the  TPM        2.0  Part  2

Configuration Parser and the same TPM 2.0 Part 2 specification that was used as input to the TPM 2.0

Part 2 Configuration Parser. The TPM 2.0 Part 2 Structure Parser will generate all of the C structure

constant    definitions  that  are  required   by        the    TPM  interface.  Additionally,     the  parser   will   generate

unmarshaling code for all structures passed to the TPM, and marshaling code for structures passed from

the TPM.

The unmarshaling code produced by the parser uses the prototypes defined below. The unmarshaling

code will perform validations of the data to ensure that it is compliant with the limitations on the data

imposed by the structure definition and use the response code provided in the table if not.

EXAMPLE:           The definition for a TPMI_RH_PROVISION indicates that the primitive data type is a TPM_HANDLE and the

                   only allowed values are TPM_RH_OWNER and TPM_RH_PLATFORM. The definition also indicates that the

                   TPM shall indicate TPM_RC_HANDLE if the input value is not none of these values. The unmarshaling code

                   will validate that the input value has one of those allowed values and return TPM_RC_HANDLE if not.

The sections below describe the function prototypes for the marshaling and unmarshaling code that is

automatically generated by the TPM 2.0 Part 2 Structure Parser. These prototypes are described here as

the unmarshaling and marshaling of various types occurs in places other than when the command is

being parsed or the response is being built. The prototypes and the description of the interface are

intended to aid in the comprehension of the code that uses these auto-generated routines.

4.2.2      Unmarshaling Code Prototype

4.2.2.1       Simple Types and Structures

The general form for the unmarshaling code for a simple type or a structure is:

               TPM_RC    TYPE_Unmarshal(TYPE             *target,          BYTE  **buffer,      INT32   *size);

Where:

     TYPE                           name of the data type or structure

     *target                        location in the TPM memory into which the data from **buffer is placed

     **buffer                       location in          input  buffer  containing      the  most  significant  octet   (MSO)      of

                                    *target

     *size                          number of octets remaining in **buffer

When     the  data  is   successfully  unmarshaled,             the  called      routine  will  return  TPM_RC_SUCCESS.

Otherwise, it will return a Format-One response code (see TPM 2.0 Part 2).

If the data is successfully unmarshaled, *buffer is advanced point to the first octet of the next parameter

in the input buffer and size is reduced by the number of octets removed from the buffer.

When the data type is a simple type, the parser will generate code that will unmarshal the underlying type

and then perform checks on the type as indicated by the type definition.

Page 2                                                   TCG Published                                           Family "2.0"

October 30, 2014                        Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
Part 4: Supporting Routines                                                       Trusted Platform Module Library

When the data type is a structure, the parser will generate code that unmarshals each of the structure

elements in turn and performs any additional parameter checks as indicated by the data type.

4.2.2.2    Union Types

When a union is defined, an extra parameter is defined for the unmarshaling code. This parameter is the

selector for the type. The unmarshaling code for the union will unmarshal the type indicated by the

selector.

The function prototype for a union has the form:

TPM_RC     TYPE_Unmarshal(TYPE          *target,   BYTE    **buffer,   INT32      *size,  UINT32      selector);

where:

TYPE                              name of the union type or structure

*target                           location in the TPM memory into which the data from **buffer is placed

**buffer                          location in   input  buffer  containing    the  most   significant  octet  (MSO)   of

                                  *target

*size                             number of octets remaining in **buffer

selector                          union selector that determines what will be unmarshaled into *target

4.2.2.3    Null Types

In some cases, the structure definition allows an optional "null" value. The "null" value allows the use of

the same C type for the entity even though it does not always have the same members.

For example, the TPMI_ALG_HASH data type is used in many places. In some cases, TPM_ALG_NULL

is permitted and in some cases it is not. If two different data types had to be defined, the interfaces and

code would become more complex because of the number of cast operations that would be necessary.

Rather than encumber the code, the "null" value is defined and the unmarshaling code is given a flag to

indicate if this instance of the type accepts the "null" parameter or not. When the data type has a "null"

value, the function prototype is

         TPM_RC  TYPE_Unmarshal(TYPE    *target,       BYTE    **buffer,     INT32   *size,   bool    flag);

The parser detects when      the  type  allows  a  "null"  value  and  will  always  include  flag    in  any  call  to

unmarshal that type.

4.2.2.4    Arrays

Any data type may be included in an array. The function prototype use to unmarshal an array for a TYPE is

TPM_RC     TYPE_Array_Unmarshal(TYPE           *target,    BYTE   **buffer,       INT32  *size,INT32      count);

The generated code for an array uses a count-limited loop within which it calls the unmarshaling code for

TYPE.

Family "2.0"                                    TCG Published                                                  Page 3

Level 00 Revision 01.16                 Copyright © TCG 2006-2014                             October 30, 2014
Trusted Platform Module Library                                                        Part 4: Supporting Routines

4.2.3    Marshaling Code Function Prototypes

4.2.3.1  Simple Types and Structures

The general form for the unmarshaling code for a simple type or a structure is:

                   UINT16  TYPE_Marshal(TYPE      *source,    BYTE  **buffer,     INT32   *size);

Where:

TYPE                             name of the data type or structure

*source                          location in the TPM memory containing the value that is to be marshaled

                                 in to the designated buffer

**buffer                         location in the output buffer where the first octet of the TYPE is to be

                                 placed

*size                            number of octets remaining in **buffer. If size is a NULL pointer, then

                                 no  data  is  marshaled      and  the  routine  will  compute  the  size  of  the

                                 memory required to marshal the indicated type

When the data is successfully marshaled, the called routine will return the number of octets marshaled

into **buffer.

If the data is successfully marshaled, *buffer is advanced point to the first octet of the next location in

the output buffer and *size is reduced by the number of octets placed in the buffer.

When the data type is a simple type, the parser will generate code that will marshal the underlying type.

The presumption is that the TPM internal structures are consistent and correct so the marshaling code

does not validate that the data placed in the buffer has a permissible value.

When the data type is a structure, the parser will generate code that marshals each of the structure

elements in turn.

4.2.3.2  Union Types

An extra parameter is defined for the marshaling function of a union. This parameter is the selector for the

type. The marshaling code for the union will marshal the type indicated by the selector.

The function prototype for a union has the form:

UINT16   TYPE_Marshal(TYPE           *target,     BYTE  **buffer,   INT32      *size,  UINT32   selector);

The parameters have a similar meaning as those in 5.2.2.2 but the data movement is from source to

buffer.

4.2.3.3  Arrays

Any type may be included in an array. The function prototype use to unmarshal an array is:

UINT16   TYPE_Array_Marshal(TYPE           *source,     BYTE  **buffer,    INT32  *size,    INT32    count);

The generated code for an array uses a count-limited loop within which it calls the marshaling code            for

TYPE.

Page 4                                         TCG Published                                         Family "2.0"

October 30, 2014                     Copyright © TCG 2006-2014                         Level 00 Revision 01.16
Part 4: Supporting Routines                                                 Trusted Platform Module Library

4.3  Command Parser

The program that processes the tables in TPM 2.0 Part 3 is called "The TPM 2.0 Part 3 Command

Parser."

The TPM 2.0 Part 3 Command Parser takes as input a TPM 2.0 Part 3 of the TPM specification and some

configuration files produced by the TPM 2.0 Part 2 Configuration Parser. This parser uses the contents of

the command and response tables in TPM 2.0 Part 3 to produce unmarshaling code for the command

and the marshaling code for the response. Additionally, this parser produces support routines that are

used to check that the proper number of authorization values of the proper type have been provided.

These support routines are called by the functions in this TPM 2.0 Part 4.

4.4  Portability

Where reasonable, the code is written to be portable. There are a few known cases where the code is not

portable. Specifically, the handling of bit fields will not always be portable. The bit fields are marshaled

and unmarshaled as a simple element of the underlying type. For example, a TPMA_SESSION is defined

as a bit field in an octet (BYTE). When sent on the interface a TPMA_SESSION will occupy one octet.

When unmarshaled, it is unmarshaled as a UINT8. The ramifications of this are that a TPMA_SESSION

will occupy the 0th octet of the structure in which it is placed regardless of the size of the structure.

Many compilers will pad a bit field to some "natural" size for the processor, often 4 octets, meaning that

sizeof(TPMA_SESSION) would return 4 rather than 1 (the canonical size of a TPMA_SESSION).

For a little endian machine, padding of bit fields should have little consequence since the 0th octet always

contains the 0th bit of the structure no matter how large the structure. However, for a big endian machine,

the 0th bit will be in the highest numbered octet. When unmarshaling a TPMA_SESSION, the current

unmarshaling code will place the input octet at the 0th octet of the TPMA_SESSION. Since the 0th octet is

most significant octet, this has the effect of shifting all the session attribute bits left by 24 places.

As a consequence, someone implementing on a big endian machine should do one of two things:

a)   allocate all structures as packed to a byte boundary (this may not be possible if the processor does

     not handle unaligned accesses); or

b)   modify the code that manipulates bit fields that are not defined as being the alignment size of the

     system.

For many RISC processors, option #2 would be the only choice. This is may not be a terribly daunting

task since only two attribute structures are not 32-bits (TPMA_SESSION and TPMA_LOCALITY).

Family "2.0"                             TCG Published                                                     Page 5

Level 00 Revision 01.16      Copyright © TCG 2006-2014                      October 30, 2014
    Trusted Platform Module Library                                                       Part 4: Supporting Routines

    5    Header Files

    5.1     Introduction

    The files in this section are used to define   values  that  are  used  in  multiple  parts of the specification and

    are not confined to a single module.

    5.2     BaseTypes.h

1   #ifndef    _BASETYPES_H

2   #define    _BASETYPES_H

3   #include   "stdint.h"

    NULL definition

4   #ifndef               NULL

5   #define               NULL            (0)

6   #endif

7   typedef    uint8_t                    UINT8;

8   typedef    uint8_t                    BYTE;

9   typedef    int8_t                     INT8;

10  typedef    int                        BOOL;

11  typedef    uint16_t                   UINT16;

12  typedef    int16_t                    INT16;

13  typedef    uint32_t                   UINT32;

14  typedef    int32_t                    INT32;

15  typedef    uint64_t                   UINT64;

16  typedef    int64_t                    INT64;

17  typedef    struct  {

18       UINT16           size;

19       BYTE             buffer[1];

20  }  TPM2B;

21  #endif

    Page 6                                         TCG Published                          Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                       Level 00 Revision 01.16
   Part 4: Supporting Routines                                      Trusted Platform Module Library

   5.3     bits.h

1  #ifndef         _BITS_H

2  #define         _BITS_H

3  #define  CLEAR_BIT(bit,      vector)  BitClear((bit),  (BYTE  *)&(vector),  sizeof(vector))

4  #define  SET_BIT(bit,    vector)      BitSet((bit),  (BYTE  *)&(vector),  sizeof(vector))

5  #define  TEST_BIT(bit,       vector)  BitIsSet((bit),  (BYTE  *)&(vector),  sizeof(vector))

6  #endif

   Family "2.0"                          TCG Published                                        Page 7

   Level 00 Revision 01.16               Copyright © TCG 2006-2014             October 30, 2014
    Trusted Platform Module Library                                                           Part 4: Supporting Routines

    5.4       bool.h

1   #ifndef           _BOOL_H

2   #define           _BOOL_H

3   #if    defined(TRUE)

4   #undef    TRUE

5   #endif

6   #if    defined    FALSE

7   #undef    FALSE

8   #endif

9   typedef   int     BOOL;

10  #define   FALSE         ((BOOL)0)

11  #define   TRUE          ((BOOL)1)

12  #endif

    5.5       Capabilities.h

    This file contains defines for the number of capability values that will fit into the largest data buffer.

    These defines are used in various function in the "support" and the "subsystem" code groups. A module

    that supports a type that is returned by a capability will have a function that returns the capabilities of the

    type.

    EXAMPLE           PCR.c contains PCRCapGetHandles() and PCRCapGetProperties().

1   #ifndef           _CAPABILITIES_H

2   #define           _CAPABILITIES_H

3   #define         MAX_CAP_DATA                  (MAX_CAP_BUFFER-sizeof(TPM_CAP)-sizeof(UINT32))

4   #define         MAX_CAP_ALGS                  (ALG_LAST_VALUE     -  ALG_FIRST_VALUE          +  1)

5   #define         MAX_CAP_HANDLES               (MAX_CAP_DATA/sizeof(TPM_HANDLE))

6   #define         MAX_CAP_CC                    ((TPM_CC_LAST    -  TPM_CC_FIRST)      +    1)

7   #define         MAX_TPM_PROPERTIES            (MAX_CAP_DATA/sizeof(TPMS_TAGGED_PROPERTY))

8   #define         MAX_PCR_PROPERTIES            (MAX_CAP_DATA/sizeof(TPMS_TAGGED_PCR_SELECT))

9   #define         MAX_ECC_CURVES                (MAX_CAP_DATA/sizeof(TPM_ECC_CURVE))

10  #endif

    5.6       TPMB.h

    This file contains extra TPM2B structures

1   #ifndef   _TPMB_H

2   #define   _TPMB_H

    This macro helps avoid having to type in the     structure in  order  to  create  a  new  TPM2B      type  that  is  used  in

    a function.

3   #define   TPM2B_TYPE(name,            bytes)     \

4          typedef    union     {                    \

5             struct        {                        \

6                     UINT16       size;             \

7                     BYTE         buffer[(bytes)];  \

8             }  t;                                  \

9             TPM2B         b;                       \

10         }  TPM2B_##name

    Macro to instance and initialize a TPM2B value

11  #define   TPM2B_INIT(TYPE,            name)   \

12         TPM2B_##TYPE            name   =  {sizeof(name.t.buffer),      {0}}

13  #define   TPM2B_BYTE_VALUE(bytes)             TPM2B_TYPE(bytes##_BYTE_VALUE,            bytes)

14  #endif

    Page 8                                           TCG Published                                             Family "2.0"

    October 30, 2014                             Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                              Trusted Platform Module Library

    5.7     TpmError.h

1   #ifndef      _TPM_ERROR_H

2   #define      _TPM_ERROR_H

3   #include      "TpmBuildSwitches.h"

4   #define            FATAL_ERROR_ALLOCATION                               (1)

5   #define            FATAL_ERROR_DIVIDE_ZERO                              (2)

6   #define            FATAL_ERROR_INTERNAL                                 (3)

7   #define            FATAL_ERROR_PARAMETER                                (4)

8   #define            FATAL_ERROR_ENTROPY                                  (5)

9   #define            FATAL_ERROR_SELF_TEST                                (6)

10  #define            FATAL_ERROR_CRYPTO                                   (7)

11  #define            FATAL_ERROR_NV_UNRECOVERABLE                         (8)

12  #define            FATAL_ERROR_REMANUFACTURED                           (9)   //   indicates      that     the     TPM  has

13                                                                                //   been  re-manufactured           after       an

14                                                                                //   unrecoverable           NV  error

15  #define            FATAL_ERROR_DRBG                                     (10)

16  #define            FATAL_ERROR_FORCED                                   (666)

    These are the crypto assertion routines. When a function returns an unexpected                             and     unrecoverable

    result, the assertion fails and the TpmFail() is called

17  void

18  TpmFail(const      char   *function,          int   line,     int  code);

19  typedef      void       (*FAIL_FUNCTION)(const            char     *,  int,   int);

20  #define      FAIL(a)    (TpmFail(__FUNCTION__,            __LINE__,     a))

21  #if   defined(EMPTY_ASSERT)

22  #     define  pAssert(a)          ((void)0)

23  #else

24  #     define  pAssert(a)     (!!(a)        ?  1  :  (FAIL(FATAL_ERROR_PARAMETER),                 0))

25  #endif

26  #endif   //   _TPM_ERROR_H

    5.8     Global.h

    5.8.1        Description

    This   file   contains  internal  global      type  definitions    and       data  declarations      that  are     need  between

    subsystems.   The       instantiation  of  global   data  is  in   Global.c.  The    initialization  of    global  data  is in the

    subsystem that is the primary owner of the data.

    The first part of this file has the typedefs for structures and other defines used in many portions of the

    code. After the typedef section, is a section that defines global values that are only present in RAM. The

    next   three  sections  define    the  structures   for   the  NV      data  areas:  persistent,     orderly,   and     state  save.

    Additional sections define the data that is used in specific modules. That data is private to the module but

    is collected here to simplify the management of the instance data. All the data is instanced in Global.c.

    5.8.2        Includes

1   #ifndef                 GLOBAL_H

2   #define                 GLOBAL_H

3   //#define     SELF_TEST

4   #include                "TpmBuildSwitches.h"

5   #include                "Tpm.h"

6   #include                "TPMB.h"

7   #include                "CryptoEngine.h"

8   #include                <setjmp.h>

    Family "2.0"                                        TCG Published                                                        Page 9

    Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                        October 30, 2014
    Trusted Platform Module Library                                                       Part 4: Supporting Routines

    5.8.3     Defines and Types

    5.8.3.1     Unreferenced Parameter

    This define is used to eliminate the compiler     warning about an unreferenced       parameter.    Basically,  it  tells

    the compiler that it is not an accident that the  parameter is unreferenced.

9   #ifndef   UNREFERENCED_PARAMETER

10  #  define         UNREFERENCED_PARAMETER(a)       (a)

11  #endif

12  #include          "bits.h"

    5.8.3.2     Crypto Self-Test Values

    Define these values here if the AlgorithmTests() project is not used

13  #ifndef   SELF_TEST

14  extern   ALGORITHM_VECTOR             g_implementedAlgorithms;

15  extern   ALGORITHM_VECTOR             g_toTest;

16  #else

17  LIB_IMPORT        extern   ALGORITHM_VECTOR       g_implementedAlgorithms;

18  LIB_IMPORT        extern   ALGORITHM_VECTOR       g_toTest;

19  #endif

    These macros are used in CryptUtil() to invoke the incremental self test.

20  #define           TEST(alg)  if(TEST_BIT(alg,     g_toTest))     CryptTestAlgorithm(alg,            NULL)

    Use of TPM_ALG_NULL is reserved for RSAEP/RSADP testing. If someone is wanting to                   test a hash     with

    that value, don't do it.

21  #define           TEST_HASH(alg)                                                                           \

22                    if(       TEST_BIT(alg,    g_toTest)                                                     \

23                         &&   (alg  !=  ALG_NULL_VALUE))                                                     \

24                         CryptTestAlgorithm(alg,    NULL)

    5.8.3.3     Hash and HMAC State Structures

    These definitions are for the types that can be in a hash state           structure.  These  types  are  used   in  the

    crypto utilities

25  typedef   BYTE         HASH_STATE_TYPE;

26  #define   HASH_STATE_EMPTY                ((HASH_STATE_TYPE)      0)

27  #define   HASH_STATE_HASH                 ((HASH_STATE_TYPE)      1)

28  #define   HASH_STATE_HMAC                 ((HASH_STATE_TYPE)      2)

    A HASH_STATE structure contains an opaque hash stack state. A caller would use this structure when

    performing incremental hash operations. The state is updated on each call. If type is an HMAC_STATE,

    or HMAC_STATE_SEQUENCE then state is followed by the HMAC key in oPad format.

29  typedef   struct

30  {

31     CPRI_HASH_STATE                state;                //  hash      state

32     HASH_STATE_TYPE                type;                 //  type      of  the  context

33  }  HASH_STATE;

    Page 10                                           TCG Published                                     Family "2.0"

    October 30, 2014                          Copyright © TCG 2006-2014                   Level 00 Revision 01.16
    Part 4: Supporting Routines                                                               Trusted Platform Module Library

    An HMAC_STATE structure contains an opaque HMAC stack state. A caller would use this structure

    when performing incremental HMAC operations. This structure contains a hash state and an HMAC key

    and allows slightly better stack optimization than adding an HMAC key to each hash state.

34  typedef      struct

35  {

36       HASH_STATE                 hashState;                 //    the     hash     state

37       TPM2B_HASH_BLOCK           hmacKey;                   //    the     HMAC     key

38  }  HMAC_STATE;

    5.8.3.4      Other Types

    An AUTH_VALUE is a BYTE array containing a digest (TPMU_HA)

39  typedef      BYTE       AUTH_VALUE[sizeof(TPMU_HA)];

    A TIME_INFO is a BYTE array that can contain a TPMS_TIME_INFO

40  typedef      BYTE       TIME_INFO[sizeof(TPMS_TIME_INFO)];

    A NAME is a BYTE array that can contain a TPMU_NAME

41  typedef      BYTE       NAME[sizeof(TPMU_NAME)];

    5.8.4        Loaded Object Structures

    5.8.4.1      Description

    The structures in this section define the object layout as it exists in TPM memory.

    Two types of objects are defined: an ordinary object such as a key, and a sequence object that may be a

    hash, HMAC, or event.

    5.8.4.2      OBJECT_ATTRIBUTES

    An OBJECT_ATTRIBUTES structure contains the variable attributes of an object. These properties                                  are

    not    part  of    the  public  properties  but  are       used  by   the     TPM         in   managing          the  object.   An

    OBJECT_ATTRIBUTES is used in the definition of the OBJECT data type.

42  typedef      struct

43  {

44       unsigned                   publicOnly          :  1;  //0)      SET   if     only     the   public       portion      of

45                                                             //        an   object       is     loaded

46       unsigned                   epsHierarchy        :  1;  //1)      SET   if     the     object     belongs     to    EPS

47                                                             //        Hierarchy

48       unsigned                   ppsHierarchy        :  1;  //2)      SET   if     the     object     belongs     to    PPS

49                                                             //        Hierarchy

50       unsigned                   spsHierarchy        :  1;  //3)      SET   f   the     object       belongs      to   SPS

51                                                             //        Hierarchy

52       unsigned                   evict               :  1;  //4)      SET   if     the     object     is   a   platform      or

53                                                             //        owner     evict       object.        Platform-

54                                                             //        evict     object         belongs     to     PPS

55                                                             //        hierarchy,           owner-evict         object

56                                                             //        belongs       to     SPS   or   EPS     hierarchy.

57                                                             //        This     bit     is   also     used     to  mark  a

58                                                             //        completed         sequence       object     so    it

59                                                             //        will     be   flush       when   the

60                                                             //        SequenceComplete               command      succeeds.

61       unsigned                   primary          :     1;  //5)      SET   for     a   primary       object

    Family "2.0"                                     TCG Published                                                         Page 11

    Level 00 Revision 01.16                Copyright © TCG 2006-2014                                             October 30, 2014
     Trusted Platform  Module   Library                                                              Part 4: Supporting Routines

62       unsigned                     temporary        :  1;      //6)    SET   for     a   temporary         object

63       unsigned                     stClear          :  1;      //7)    SET   for     an     stClear       object

64       unsigned                     hmacSeq          :  1;      //8)    SET   for     an     HMAC   sequence       object

65       unsigned                     hashSeq          :  1;      //9)    SET   for     a   hash     sequence       object

66       unsigned                     eventSeq         :  1;      //10)    SET     for     an   event     sequence       object

67       unsigned                     ticketSafe       :  1;      //11)    SET     if   a   ticket       is   safe   to     create

68                                                                //       for     hash     sequence         object

69       unsigned                     firstBlock       :  1;      //12)    SET     if   the     first     block     of   hash

70                                                                //       data     has     been     received.          It

71                                                                //       works       with     ticketSafe         bit

72       unsigned                     isParent         :  1;      //13)    SET     if   the     key   has     the   proper

73                                                                //       attributes           to   be   a   parent     key

74       unsigned                     privateExp       :  1;      //14)    SET     when     the     private       exponent

75                                                                //       of   an     RSA     key   has     been   validated.

76       unsigned              reserved         :  1;         //15)   reserved      bits.       unused.

77   }  OBJECT_ATTRIBUTES;

     5.8.4.3       OBJECT Structure

     An  OBJECT     structure  holds  the  object  public,    sensitive,  and   meta-data        associated.       This     structure  is

     implementation dependent. For this implementation, the structure is not optimized for space but rather for

     clarity of the reference implementation. Other implementations may choose to overlap portions of the

     structure that are not used simultaneously. These changes would necessitate changes to the source code

     but those changes would be compatible with the reference implementation.

78   typedef  struct

79   {

80       //   The   attributes      field  is  required       to  be  first    followed         by   the     publicArea.

81       //   This  allows     the  overlay    of  the    object      structure     and     a   sequence       structure

82       OBJECT_ATTRIBUTES            attributes;                 //  object       attributes

83       TPMT_PUBLIC                  publicArea;                 //  public       area     of   an   object

84       TPMT_SENSITIVE               sensitive;                  //  sensitive         area     of   an     object

85

86   #ifdef   TPM_ALG_RSA

87       TPM2B_PUBLIC_KEY_RSA         privateExponent;            //  Additional           field     for     the   private

88                                                                //  exponent         of   an   RSA     key.

89   #endif

90       TPM2B_NAME                   qualifiedName;              //  object       qualified         name

91       TPMI_DH_OBJECT               evictHandle;                //  if   the     object       is   an   evict     object,

92                                                                //  the    original          handle     is   kept     here.

93                                                                //  The    'working'          handle       will   be   the

94                                                                //  handle       of   an     object     slot.

95

96       TPM2B_NAME                   name;                       //  Name     of   the     object       name.     Kept     here

97                                                                //  to   avoid       repeatedly         computing         it.

98   }  OBJECT;

     5.8.4.4       HASH_OBJECT Structure

     This structure holds a hash sequence object or an event sequence object.

     The first four components of this structure are manually set to be the same as the first four components of

     the object structure. This prevents the object from being inadvertently misused as sequence objects

     occupy the same memory as a regular object. A debug check is present to make sure that the offsets are

     what they are supposed to be.

99   typedef  struct

100  {

101      OBJECT_ATTRIBUTES            attributes;                 //  The    attributes          of   the     HASH   object

102      TPMI_ALG_PUBLIC              type;                       //  algorithm

103      TPMI_ALG_HASH                nameAlg;                    //  name     algorithm

104      TPMA_OBJECT                  objectAttributes;           //  object       attributes

     Page 12                                           TCG Published                                                     Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part 4: Supporting Routines                                                       Trusted Platform Module Library

105

106     //    The  data    below  is  unique    to    a   sequence  object

107     TPM2B_AUTH                    auth;                     //  auth    for   use  of  sequence

108     union

109     {

110              HASH_STATE           hashState[HASH_COUNT];

111              HMAC_STATE           hmacState;

112     }                             state;

113  }  HASH_OBJECT;

     5.8.4.5       ANY_OBJECT

     This is the union for holding either a sequence object or a regular object.

114  typedef     union

115  {

116     OBJECT                        entity;

117     HASH_OBJECT                   hash;

118  }  ANY_OBJECT;

     5.8.5       AUTH_DUP Types

     These values are used in the authorization processing.

119  typedef     UINT32               AUTH_ROLE;

120  #define     AUTH_NONE            ((AUTH_ROLE)(0))

121  #define     AUTH_USER            ((AUTH_ROLE)(1))

122  #define     AUTH_ADMIN           ((AUTH_ROLE)(2))

123  #define     AUTH_DUP             ((AUTH_ROLE)(3))

     5.8.6       Active Session Context

     5.8.6.1       Description

     The structures in this section define the internal structure of a session context.

     5.8.6.2       SESSION_ATTRIBUTES

     The attributes in the SESSION_ATTRIBUTES structure track the various properties of the session. It

     maintains most of the tracking state information for the policy session. It is used within the SESSION

     structure.

124  typedef     struct

125  {

126     unsigned                      isPolicy     :  1;        //1)  SET   if    the  session    may     only

127                                                             //    be    used  for    policy

128     unsigned                      isAudit   :     1;        //2)  SET   if    the  session    is   used

129                                                             //    for   audit

130     unsigned                      isBound   :     1;        //3)  SET   if    the  session    is   bound     to

131                                                             //    with  an    entity.

132                                                             //    This  attribute       will  be      CLEAR     if

133                                                             //    either      isPolicy  or    isAudit       is   SET.

134     unsigned                      iscpHashDefined     :  1;//4)   SET   if    the  cpHash    has   been     defined

135                                                             //    This  attribute       is   not   SET   unless

136                                                             //    'isPolicy'       is  SET.

137     unsigned                      isAuthValueNeeded      :  1;

138                                                             //5)  SET   if    the  authValue      is  required

139                                                             //    for   computing      the   session     HMAC.

140                                                             //    This  attribute       is   not   SET   unless

     Family "2.0"                                         TCG Published                                              Page 13

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                     Part 4: Supporting Routines

141                                                                   //      isPolicy       is     SET.

142     unsigned             isPasswordNeeded                     :   1;

143                                                                   //6)    SET   if   a   password         authValue           is

144                                                                   //      required       for     authorization

145                                                                   //      This   attribute           is   not     SET     unless

146                                                                   //      isPolicy       is     SET.

147     unsigned             isPPRequired   :           1;            //7)    SET   if   physical           presence       is

148                                                                   //      required       to     be   asserted         when     the

149                                                                   //      authorization             is   checked.

150                                                                   //      This   attribute           is   not     SET     unless

151                                                                   //      isPolicy       is     SET.

152     unsigned             isTrialPolicy      :              1;     //8)    SET   if   the     policy       session         is

153                                                                   //      created       for     trial     of     the   policy's

154                                                                   //      policyHash         generation.

155                                                                   //      This   attribute           is   not     SET     unless

156                                                                   //      isPolicy       is     SET.

157     unsigned             isDaBound   :  1;                        //9)    SET   if   the     bind       entity     had     noDA

158                                                                   //      CLEAR.     If     this     is   SET,     then       an

159                                                                   //      auth   failure         using       this     session

160                                                                   //      will   count       against         lockout       even

161                                                                   //      if   the   object         being     authorized          is

162                                                                   //      exempt     from       DA.

163     unsigned             isLockoutBound             :         1;  //10)SET      if   the     session         is   bound       to

164                                                                   //      lockoutAuth.

165     unsigned             requestWasBound                   :     1;//11)   SET   if     the     session       is   being       used

166                                                                   //       with     the     bind     entity.       If     SET

167                                                                   //       the   authValue           will     not     be   use

168                                                                   //       in   the     response         HMAC     computation.

169     unsigned             checkNvWritten             :         1;  //12)    SET   if     the     TPMA_NV_WRITTEN

170                                                                   //       attribute         needs       to   be   checked

171                                                                   //       when     the     policy       is   used     for

172                                                                   //       authorization             for     NV   access.

173                                                                   //       If   this     is     SET     for   any     other

174                                                                   //       type,     the     policy       will     fail.

175     unsigned             nvWrittenState             :         1;  //13)    SET   if     TPMA_NV_WRITTEN               is

176                                                                   //       required         to   be     SET.

177  }  SESSION_ATTRIBUTES;

     5.8.6.3    SESSION Structure

     The SESSION structure contains all the context of            a session except for the associated contextID.

     NOTE:        The contextID of a session is only relevant     when the session context is stored off the TPM.

178  typedef  struct

179  {

180     TPM_ALG_ID           authHashAlg;                             //  session       hash     algorithm

181     TPM2B_NONCE          nonceTPM;                                //  last     TPM-generated             nonce     for

182                                                                   //  this     session

183

184     TPMT_SYM_DEF         symmetric;                               //  session       symmetric           algorithm         (if     any)

185     TPM2B_AUTH           sessionKey;                              //  session       secret       value       used     for

186                                                                   //  generating         HMAC       and   encryption           keys

187

188     SESSION_ATTRIBUTES   attributes;                              //  session       attributes

189     TPM_CC               commandCode;                             //  command       code     (policy         session)

190     TPMA_LOCALITY        commandLocality;                         //  command       locality         (policy       session)

191     UINT32               pcrCounter;                              //  PCR     counter       value       when     PCR   is

192                                                                   //  included       (policy         session)

193                                                                   //  If   no   PCR     is   included,           this

194                                                                   //  value     is   0.

195

196     UINT64               startTime;                               //  value     of   TPMS_CLOCK_INFO.clock                     when

197                                                                   //  the     session       was     started       (policy

     Page 14                                TCG Published                                                                      Family "2.0"

     October 30, 2014                 Copyright © TCG 2006-2014                                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

198                                                          //   session)

199

200     UINT64                       timeOut;                //   timeout       relative   to

201                                                          //   TPMS_CLOCK_INFO.clock

202                                                          //   There     is   no  timeout      if  this     value

203                                                          //   is   0.

204     union

205     {

206             TPM2B_NAME           boundEntity;            //      value  used     to    track     the  entity    to

207                                                          //      which  the      session     is   bound

208

209             TPM2B_DIGEST         cpHash;                 //      the   required      cpHash      value   for    the

210                                                          //      command     being     authorized

211

212     }       u1;                                          //      'boundEntity'         and   'cpHash'      may

213                                                          //      share  the      same  space      to  save    memory

214

215     union

216     {

217             TPM2B_DIGEST         auditDigest;            //   audit     session      digest

218             TPM2B_DIGEST         policyDigest;               //   policyHash

219

220     }       u2;                                          //   audit     log  and     policyHash       may

221                                                          //   share     space    to    save   memory

222  }  SESSION;

     5.8.7      PCR

     5.8.7.1         PCR_SAVE Structure

     The PCR_SAVE structure type contains the PCR data that are saved across power cycles. Only the static

     PCR are required to be saved across power cycles. The DRTM and resettable PCR are not saved. The

     number of static and resettable PCR is determined by the platform-specific specification to which the TPM

     is built.

223  typedef    struct

224  {

225  #ifdef     TPM_ALG_SHA1

226     BYTE                         sha1[NUM_STATIC_PCR][SHA1_DIGEST_SIZE];

227  #endif

228  #ifdef     TPM_ALG_SHA256

229     BYTE                         sha256[NUM_STATIC_PCR][SHA256_DIGEST_SIZE];

230  #endif

231  #ifdef     TPM_ALG_SHA384

232     BYTE                         sha384[NUM_STATIC_PCR][SHA384_DIGEST_SIZE];

233  #endif

234  #ifdef     TPM_ALG_SHA512

235     BYTE                         sha512[NUM_STATIC_PCR][SHA512_DIGEST_SIZE];

236  #endif

237  #ifdef     TPM_ALG_SM3_256

238     BYTE                         sm3_256[NUM_STATIC_PCR][SM3_256_DIGEST_SIZE];

239  #endif

240

241     //      This   counter  increments    whenever  the  PCR     are   updated.

242     //      NOTE:  A   platform-specific   specification      may     designate

243     //             certain  PCR  changes   as  not  causing      this   counter

244     //             to  increment.

245     UINT32                       pcrCounter;

246

247  }  PCR_SAVE;

     Family "2.0"                                  TCG Published                                                    Page 15

     Level 00 Revision 01.16                Copyright © TCG 2006-2014                                     October 30, 2014
     Trusted Platform Module Library                                                              Part 4: Supporting Routines

     5.8.7.2       PCR_POLICY

     This structure holds the PCR       policies, one for each group of PCR controlled            by  policy.

248  typedef       struct

249  {

250        TPMI_ALG_HASH                hashAlg[NUM_POLICY_PCR_GROUP];

251        TPM2B_DIGEST                 a;

252        TPM2B_DIGEST                 policy[NUM_POLICY_PCR_GROUP];

253  }   PCR_POLICY;

     5.8.7.3       PCR_AUTHVALUE

     This structure holds the PCR policies, one for each group of PCR controlled by policy.

254  typedef       struct

255  {

256        TPM2B_DIGEST                 auth[NUM_AUTHVALUE_PCR_GROUP];

257  }   PCR_AUTHVALUE;

     5.8.8         Startup

     5.8.8.1       SHUTDOWN_NONE

     Part   2  defines      the   two   shutdown/startup     types        that  may   be    used  in  TPM2_Shutdown()            and

     TPM2_Starup(). This additional define is used by the TPM to indicate that no shutdown was received.

     NOTE:               This is a reserved value.

258  #define       SHUTDOWN_NONE        (TPM_SU)(0xFFFF)

     5.8.8.2       STARTUP_TYPE

     This   enumeration       is  the   possible    startup  types.  The        type  is  determined  by       the  combination  of

     TPM2_ShutDown() and TPM2_Startup().

259  typedef       enum

260  {

261        SU_RESET,

262        SU_RESTART,

263        SU_RESUME

264  }   STARTUP_TYPE;

     5.8.9         NV

     5.8.9.1       NV_RESERVE

     This enumeration defines the master list of the elements of a reserved portion of NV. This list includes all

     the   pre-defined     data   that  takes  space  in     NV,  either  as    persistent  data  or  as  state     save  data.  The

     enumerations are used as indexes into an array of offset values. The offset values then are used to index

     into NV. This is method provides an imperfect analog to an actual NV implementation.

265  typedef       enum

266  {

267  //   Entries      below  mirror    the    PERSISTENT_DATA       structure.           These  values   are  written

268  //   to   NV  as    individual     items.

269        //  hierarchy

     Page 16                                                 TCG Published                                          Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                    Trusted Platform  Module  Library

270      NV_DISABLE_CLEAR,

271      NV_OWNER_ALG,

272      NV_ENDORSEMENT_ALG,

273      NV_LOCKOUT_ALG,

274      NV_OWNER_POLICY,

275      NV_ENDORSEMENT_POLICY,

276      NV_LOCKOUT_POLICY,

277      NV_OWNER_AUTH,

278      NV_ENDORSEMENT_AUTH,

279      NV_LOCKOUT_AUTH,

280

281      NV_EP_SEED,

282      NV_SP_SEED,

283      NV_PP_SEED,

284

285      NV_PH_PROOF,

286      NV_SH_PROOF,

287      NV_EH_PROOF,

288

289      //   Time

290      NV_TOTAL_RESET_COUNT,

291      NV_RESET_COUNT,

292

293      //   PCR

294      NV_PCR_POLICIES,

295      NV_PCR_ALLOCATED,

296

297      //   Physical   Presence

298      NV_PP_LIST,

299

300      //   Dictionary     Attack

301      NV_FAILED_TRIES,

302      NV_MAX_TRIES,

303      NV_RECOVERY_TIME,

304      NV_LOCKOUT_RECOVERY,

305      NV_LOCKOUT_AUTH_ENABLED,

306

307      //   Orderly   State  flag

308      NV_ORDERLY,

309

310      //   Command   Audit

311      NV_AUDIT_COMMANDS,

312      NV_AUDIT_HASH_ALG,

313      NV_AUDIT_COUNTER,

314

315      //   Algorithm   Set

316      NV_ALGORITHM_SET,

317

318      NV_FIRMWARE_V1,

319      NV_FIRMWARE_V2,

320

321  //  The  entries   above  are   in  PERSISTENT_DATA.          The  entries  below    represent

322  //  structures    that  are  read   and  written      as  a   unit.

323

324  //  ORDERLY_DATA    data  structure      written  on      each  orderly  shutdown

325      NV_ORDERLY_DATA,

326

327  //  STATE_CLEAR_DATA      structure  written      on  each      Shutdown(STATE)

328      NV_STATE_CLEAR,

329

330  //  STATE_RESET_DATA      structure  written      on  each      Shutdown(STATE)

331      NV_STATE_RESET,

332

333      NV_RESERVE_LAST                      //  end  of      NV  reserved   data  list

334  }   NV_RESERVE;

     Family "2.0"                                 TCG Published                                       Page 17

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                       October 30, 2014
     Trusted Platform Module Library                                                            Part 4: Supporting Routines

     5.8.9.2       NV_INDEX

     The   NV_INDEX         structure  defines  the  internal  format    for  an  NV  index.    The   indexData     size  varies

     according to the type of the index. In this implementation, all of the index is manipulated as a unit.

335  typedef   struct

336  {

337        TPMS_NV_PUBLIC              publicArea;

338        TPM2B_AUTH                  authValue;

339  }  NV_INDEX;

     5.8.10    COMMIT_INDEX_MASK

     This is the define for the mask value that is used when manipulating the bits in the commit bit array. The

     commit counter is a 64-bit value and the low order bits are used to index the commitArray. This mask

     value is applied to the commit counter to extract the bit number in the array.

340  #ifdef    TPM_ALG_ECC

341  #define   COMMIT_INDEX_MASK       ((UINT16)((sizeof(gr.commitArray)*8)-1))

342  #endif

     5.8.11    RAM Global Values

     5.8.11.1      Description

     The values in this section are only extant in RAM. They are defined here and instanced in Global.c.

     5.8.11.2      g_rcIndex

     This array is used to contain the array of values that are added to a return code when it is a parameter-,

     handle-, or session-related error. This is an implementation choice and the same result can be achieved

     by using a macro.

343  extern    const   UINT16          g_rcIndex[15];

     5.8.11.3      g_exclusiveAuditSession

     This location holds the session handle for the current exclusive             audit    session.  If  there  is  no  exclusive

     audit session, the location is set to TPM_RH_UNASSIGNED.

344  extern    TPM_HANDLE              g_exclusiveAuditSession;

     5.8.11.4      g_time

     This  value   is  the  count  of  milliseconds  since     the  TPM  was      powered  up.  This     value  is  initialized  at

     _TPM_Init().

345  extern    UINT64                  g_time;

     5.8.11.5      g_phEnable

     This is the platform hierarchy control and determines if the platform            hierarchy  is available. This value is

     SET on each TPM2_Startup(). The default value is SET.

346  extern    BOOL                    g_phEnable;

     Page 18                                         TCG Published                                                  Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                              Trusted Platform Module Library

     5.8.11.6        g_pceReConfig

     This     value  is  SET   if  a  TPM2_PCR_Allocate()         command  successfully  executed     since  the    last

     TPM2_Startup(). If so, then the next shutdown is required to be Shutdown(CLEAR).

347  extern    BOOL                   g_pcrReConfig;

     5.8.11.7        g_DRTMHandle

     This location indicates the sequence object handle that holds the DRTM sequence data. When not used,

     it is set to TPM_RH_UNASSIGNED. A sequence DRTM sequence is started on either _TPM_Init() or

     _TPM_Hash_Start().

348  extern    TPMI_DH_OBJECT         g_DRTMHandle;

     5.8.11.8        g_DrtmPreStartup

     This value indicates that an H-CRTM occurred after _TPM_Init() but before TPM2_Startup(). The define

     for PRE_STARTUP_FLAG is used to add the g_DrtmPreStartup value to gp_orderlyState at shutdown.

     This hack is to avoid adding another NV variable.

349  extern       BOOL                g_DrtmPreStartup;

350  #define      PRE_STARTUP_FLAG         0x8000

     5.8.11.9        g_StartupLocality3

     This value indicates that a TPM2_Startup() occured at locality 3. Otherwise, it at locality 0. The define for

     STARTUP_LOCALITY_3 is to indicate that the startup was not at locality 0. This hack is to avoid adding

     another NV variable.

351  extern       BOOL                g_StartupLocality3;

352  #define      STARTUP_LOCALITY_3                 0x4000

     5.8.11.10       g_updateNV

     This flag indicates if NV should be updated at the end of a command. This flag is set to FALSE at the

     beginning of each command in ExecuteCommand(). This flag is checked in ExecuteCommand() after the

     detailed actions of a command complete. If the command execution was successful and this flag is SET,

     any pending NV writes will be committed to NV.

353  extern    BOOL                   g_updateNV;

     5.8.11.11       g_clearOrderly

     This flag indicates if the execution of a command should cause the orderly state to be cleared.         This flag

     is  set  to  FALSE    at  the    beginning  of  each     command  in  ExecuteCommand()   and     is  checked   in

     ExecuteCommand()          after  the  detailed  actions  of  a  command  complete   but  before  the    check  of

     g_updateNV. If this flag is TRUE, and the orderly state is not SHUTDOWN_NONE, then the orderly state

     in NV memory will be changed to SHUTDOWN_NONE.

354  extern    BOOL                   g_clearOrderly;

     Family "2.0"                                    TCG Published                                           Page 19

     Level 00 Revision 01.16               Copyright © TCG 2006-2014                          October 30, 2014
     Trusted Platform Module Library                                                                Part 4: Supporting Routines

     5.8.11.12     g_prevOrderlyState

     This location indicates how the TPM was shut down before the most recent TPM2_Startup(). This value,

     along   with  the  startup   type,  determines      if  the  TPM   should  do     a  TPM      Reset,  TPM  Restart,     or  TPM

     Resume.

355  extern    TPM_SU                    g_prevOrderlyState;

     5.8.11.13     g_nvOk

     This value indicates if the NV integrity check was successful or not. If not and the failure was severe, then

     the TPM would have been put into failure mode after it had been re-manufactured. If the NV failure was in

     the area where the state-save data is kept, then this variable will have a value of FALSE indicating that a

     TPM2_Startup(CLEAR) is required.

356  extern    BOOL                      g_nvOk;

     5.8.11.14     g_platformUnique

     This   location    contains   the   unique    value(s)       used  to   identify     the  TPM.  It    is  loaded    on      every

     _TPM2_Startup()     The     first  value  is  used  to  seed  the    RNG.  The       second   value   is  used  as   a  vendor

     authValue. The value used by the RNG would be the value derived from the chip unique value (such as

     fused) with a dependency on the authorities of the code in the TPM boot path. The second would be

     derived from the chip unique value with a dependency on the details of the code in the boot path. That is,

     the first value depends on the various signers of the code and the second depends on what was signed.

     The TPM vendor should not be able to know the first value but they are expected to know the second.

357  extern    TPM2B_AUTH                g_platformUniqueAuthorities;               //    Reserved   for   RNG

358  extern    TPM2B_AUTH                g_platformUniqueDetails;               //  referenced       by    VENDOR_PERMANENT

     5.8.12      Persistent Global Values

     5.8.12.1      Description

     The values in this section are global values that are persistent across power events. The lifetime of the

     values determines the structure in which the value is placed.

     5.8.12.2      PERSISTENT_DATA

     This structure holds the persistent values that only change as a consequence of a specific Protected

     Capability and are not affected by TPM power events (TPM2_Startup() or TPM2_Shutdown().

359  typedef     struct

360  {

361  //*********************************************************************************

362  //               Hierarchy

363  //*********************************************************************************

364  //  The   values    in  this  section         are  related   to    the  hierarchies.

365

366        BOOL                          disableClear;                //  TRUE  if      TPM2_Clear()       using

367                                                                   //  lockoutAuth          is  disabled

368

369        //  Hierarchy     authPolicies

370        TPMI_ALG_HASH                 ownerAlg;

371        TPMI_ALG_HASH                 endorsementAlg;

372        TPMI_ALG_HASH                 lockoutAlg;

373        TPM2B_DIGEST                  ownerPolicy;

     Page 20                                                 TCG Published                                           Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                            Trusted Platform Module Library

374         TPM2B_DIGEST                       endorsementPolicy;

375         TPM2B_DIGEST                       lockoutPolicy;

376

377         //  Hierarchy          authValues

378         TPM2B_AUTH                         ownerAuth;

379         TPM2B_AUTH                         endorsementAuth;

380         TPM2B_AUTH                         lockoutAuth;

381

382         //  Primary          Seeds

383         TPM2B_SEED                         EPSeed;

384         TPM2B_SEED                         SPSeed;

385         TPM2B_SEED                         PPSeed;

386         //  Note        there    is  a  nullSeed        in   the  state_reset             memory.

387

388         //  Hierarchy          proofs

389         TPM2B_AUTH                         phProof;

390         TPM2B_AUTH                         shProof;

391         TPM2B_AUTH                         ehProof;

392         //  Note        there    is  a  nullProof       in   the  state_reset             memory.

393

394  //*********************************************************************************

395  //                     Reset    Events

396  //*********************************************************************************

397  //  A   count      that     increments       at     each    TPM  reset       and     never    get      reset      during       the  life

398  //  time       of  TPM.       The   value    of     this    counter      is  initialized           to      1  during       TPM

399  //  manufacture             process.

400         UINT64                             totalResetCount;

401

402  //  This       counter      increments       on     each    TPM  Reset.      The     counter       is      reset      by

403  //  TPM2_Clear().

404         UINT32                             resetCount;

405

406  //*********************************************************************************

407  //                     PCR

408  //*********************************************************************************

409  //  This       structure        hold   the   policies       for  those       PCR     that     have     an     update       policy.

410  //  This       implementation          only    supports      a   single      group       of   PCR      controlled          by

411  //  policy.        If   more      are  required,       then      this    structure       would         be     changed      to

412  //  an     array.

413         PCR_POLICY                         pcrPolicies;

414

415  //  This       structure        indicates      the     allocation        of  PCR.        The  structure           contains      a

416  //  list       of  PCR      allocations      for    each    implemented           algorithm.           If     no  PCR     are

417  //  allocated          for    an    algorithm,      a  list      entry   still       exists       but      the    bit     map

418  //  will       contain      no    SET  bits.

419         TPML_PCR_SELECTION                 pcrAllocated;

420

421  //*********************************************************************************

422  //                     Physical     Presence

423  //*********************************************************************************

424  //  The    PP_LIST          type    contains     a  bit     map  of    the   commands         that     require         physical

425  //  to     be  asserted         when   the   authorization           is  evaluated.           Physical            presence      will  be

426  //  checked        if   the     corresponding          bit  in   the     array       is  SET      and  if     the     authorization

427  //  handle         is  TPM_RH_PLATFORM.

428  //

429  //  These      bits     may     be  changed      with      TPM2_PP_Commands().

430         BYTE                               ppList[((TPM_CC_PP_LAST                 -  TPM_CC_PP_FIRST               +   1)  +    7)/8];

431

432  //*********************************************************************************

433  //                     Dictionary      attack       values

434  //*********************************************************************************

435  //  These      values       are     used  for    dictionary      attack      tracking             and  control.

436         UINT32                             failedTries;                   //  the         current       count      of   unexpired

437                                                                           //  authorization                 failures

438

439         UINT32                             maxTries;                      //  number           of  unexpired           authorization

     Family "2.0"                                                TCG Published                                                               Page 21

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                              October 30, 2014
     Trusted Platform Module Library                                                                      Part 4: Supporting Routines

440                                                                      //  failures         before     the     TPM   is    in

441                                                                      //  lockout

442

443         UINT32                         recoveryTime;                 //  time     between      authorization             failures

444                                                                      //  before       failedTries         is   decremented

445

446         UINT32                         lockoutRecovery;              //  time     that    must    expire       between

447                                                                      //  authorization           failures         associated

448                                                                      //  with     lockoutAuth

449

450         BOOL                           lockOutAuthEnabled;           //  TRUE     if  use  of     lockoutAuth            is

451                                                                      //  allowed

452

453  //*****************************************************************************

454  //                   Orderly     State

455  //*****************************************************************************

456  //  The   orderly      state     for  current      cycle

457         TPM_SU                         orderlyState;

458

459  //*****************************************************************************

460  //                 Command       audit     values.

461  //*****************************************************************************

462         BYTE                           auditComands[((TPM_CC_LAST              -  TPM_CC_FIRST            +   1)   +     7)  /   8];

463         TPMI_ALG_HASH                  auditHashAlg;

464         UINT64                         auditCounter;

465

466  //*****************************************************************************

467  //                 Algorithm         selection

468  //*****************************************************************************

469  //

470  //  The   'algorithmSet'         value     indicates         the  collection     of      algorithms         that     are

471  //  currently      in     used   on   the  TPM.      The     interpretation      of      value   is     vendor       dependent.

472         UINT32                         algorithmSet;

473

474  //*****************************************************************************

475  //                 Firmware      version

476  //*****************************************************************************

477  //  The   firmwareV1       and   firmwareV2        values     are   instanced        in  TimeStamp.c.            This       is

478  //  a   scheme     used    in   development      to  allow        determination      of   the    linker       build         time

479  //  of   the   TPM.    An  actual     implementation          would     implement        these   values       in     a  way     that

480  //  is   consistent        with  vendor    needs.        The  values    are   maintained         in     RAM   for       simplified

481  //  access     with    a   master     version    in  NV.      These     values   are     modified        in   a

482  //  vendor-specific            way.

483

484  //  g_firmwareV1          contains    the  more      significant        32-bits      of  the    vendor       version        number.

485  //  In   the   reference        implementation,          if   this  value    is  printed        as   a   hex

486  //  value,     it  will    have      the   format    of   yyyymmdd

487         UINT32                         firmwareV1;

488

489  //  g_firmwareV1          contains    the  less      significant        32-bits      of  the    vendor       version        number.

490  //  In   the   reference        implementation,          if   this  value    is  printed        as   a   hex

491  //  value,     it  will    have      the   format    of   00  hh    mm  ss

492         UINT32                         firmwareV2;

493

494  }   PERSISTENT_DATA;

495  extern    PERSISTENT_DATA             gp;

     5.8.12.3       ORDERLY_DATA

     The data in this structure is saved to NV on each TPM2_Shutdown().

496  typedef      struct    orderly_data

497  {

498

     Page 22                                                  TCG Published                                                      Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                      Trusted Platform Module Library

499  //*****************************************************************************

500  //                  TIME

501  //*****************************************************************************

502

503  //  Clock   has     two   parts.      One  is   the    state      save     part     and   one   is  the      NV   part.    The

504  //  state   save     version     is   updated      on    each     command.       When     the   clock    rolls      over,       the

505  //  NV   version     is   updated.       When   the    TPM    starts       up,   if  the    TPM     was  shutdown          in   and

506  //  orderly     way,     then  the    sClock       value     is   used     to   initialize       the     clock.     If     the

507  //  TPM   shutdown       was   not    orderly,     then      the  persistent         value      is  used      and   the    safe

508  //  attribute       is   clear.

509

510       UINT64                           clock;                           //  The      orderly     version       of   clock

511       TPMI_YES_NO                      clockSafe;                       //  Indicates        if   the     clock     value       is

512                                                                         //  safe.

513  //*********************************************************************************

514  //               DRBG

515  //*********************************************************************************

516  #ifdef    _DRBG_STATE_SAVE

517       //   This   is     DRBG   state     data.     This   is     saved     each     time  the    value       of   clock    is

518       //   updated.

519       DRBG_STATE                       drbgState;

520  #endif

521

522  }   ORDERLY_DATA;

523  extern    ORDERLY_DATA                go;

     5.8.12.4       ST AT E _CL E AR _ D AT A

     This structure contains the data that is saved on Shutdown(STATE). and restored on Startup(STATE).

     The  values    are   set  to   their  default   settings     on   any   Startup(Clear).         In  other    words     the     data  is  only

     persistent across TPM Resume.

     If the comments associated with a parameter indicate a default reset value, the value is applied on each

     Startup(CLEAR).

524  typedef    struct       state_clear_data

525  {

526  //*****************************************************************************

527  //                  Hierarchy       Control

528  //*****************************************************************************

529       BOOL                             shEnable;                        //  default        reset     is   SET

530       BOOL                             ehEnable;                        //  default        reset     is   SET

531       BOOL                             phEnableNV;                      //  default        reset     is   SET

532       TPMI_ALG_HASH                    platformAlg;                     //  default        reset     is   TPM_ALG_NULL

533       TPM2B_DIGEST                     platformPolicy;                  //  default        reset     is   an   Empty     Buffer

534       TPM2B_AUTH                       platformAuth;                    //  default        reset     is   an   Empty     Buffer

535

536  //*****************************************************************************

537  //                  PCR

538  //*****************************************************************************

539  //  The   set   of   PCR  to   be     saved    on  Shutdown(STATE)

540       PCR_SAVE                         pcrSave;                         //  default        reset     is   0...0

541

542  //  This   structure      hold      the    authorization          values       for   those     PCR  that      have     an

543  //  update     authorization.

544  //  This   implementation           only   supports       a   single       group     of   PCR   controlled         by

545  //  authorization.        If   more      are   required,         then   this     structure       would       be   changed       to

546  //  an   array.

547       PCR_AUTHVALUE                    pcrAuthValues;

548

549  }   STATE_CLEAR_DATA;

550  extern    STATE_CLEAR_DATA            gc;

     Family "2.0"                                             TCG Published                                                              Page 23

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                             Part 4: Supporting Routines

     5.8.12.5         State Reset Data

     This   structure  contains       data     is  that  is  saved   on  Shutdown(STATE)              and    restored      on   the     subsequent

     Startup(ANY). That is, the data is preserved across TPM Resume and TPM Restart.

     If a default value is specified in the comments this value is applied on TPM Reset.

551  typedef      struct    state_reset_data

552  {

553  //*****************************************************************************

554  //                Hierarchy          Control

555  //*****************************************************************************

556         TPM2B_AUTH                      nullProof;                        //   The   proof      value      associated          with

557                                                                           //   the   TPM_RH_NULL           hierarchy.          The

558                                                                           //   default      reset       value     is   from       the   RNG.

559

560         TPM2B_SEED                      nullSeed;                         //   The   seed       value   for    the     TPM_RN_NULL

561                                                                           //   hierarchy.         The   default        reset       value

562                                                                           //   is   from    the     RNG.

563

564  //*****************************************************************************

565  //                    Context

566  //*****************************************************************************

567  //  The   'clearCount'           counter      is    incremented         each   time    the     TPM     successfully           executes

568  //  a   TPM  Resume.        The     counter   is      included     in    each     saved    context        that    has     'stClear'

569  //  SET   (including        descendants           of    keys  that      have   'stClear'         SET).      This     prevents         these

570  //  objects      from     being      loaded   after     a     TPM  Resume.

571  //  If   'clearCount'           at   its   maximum      value      when  the      TPM  receives        a    Shutdown(STATE),

572  //  the   TPM    will     return     TPM_RC_RANGE          and     the   TPM   will    only      accept     Shutdown(CLEAR).

573         UINT32                          clearCount;                       //   The   default        reset    value      is     0.

574

575         UINT64                          objectContextID;                  //   This     is  the     context       ID   for     a   saved

576                                                                           //    object      context.         The   default         reset

577                                                                           //    value       is  0.

578

579         CONTEXT_SLOT                    contextArray[MAX_ACTIVE_SESSIONS];

580                                                                           //   This     is  the     value    from      which       the

581                                                                           //   'contextID'          is  derived.        The

582                                                                           //   default      reset       value     is   {0}.

583

584         CONTEXT_COUNTER                 contextCounter;                   //   This     array     contains        contains         the

585                                                                           //   values       used    to  track      the     version

586                                                                           //   numbers      of    saved      contexts       (see

587                                                                           //   Session.c        in    for    details).         The

588                                                                           //   default      reset       value     is   0.

589

590  //*****************************************************************************

591  //                    Command       Audit

592  //*****************************************************************************

593  //  When     an  audited        command       completes,      ExecuteCommand()             checks      the    return

594  //  value.       If   it    is   TPM_RC_SUCCESS,           and     the   command       is  an    audited      command,           the

595  //  TPM   will    extend        the  cpHash       and   rpHash     for   the      command      to    this   value.        If     this

596  //  digest       was  the   Zero     Digest       before      the  cpHash      was     extended,       the    audit       counter

597  //  is   incremented.

598

599         TPM2B_DIGEST                    commandAuditDigest;               //   This     value     is    set  to    an   Empty       Digest

600                                                                           //   by   TPM2_GetCommandAuditDigest()                        or  a

601                                                                           //   TPM   Reset.

602

603  //*****************************************************************************

604  //                    Boot  counter

605  //*****************************************************************************

606

607         UINT32                          restartCount;                     //   This     counter       counts      TPM   Restarts.

608                                                                           //   The   default        reset    value      is     0.

     Page 24                                                    TCG Published                                                          Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                        Trusted Platform Module Library

609

610  //*********************************************************************************

611  //                   PCR

612  //*********************************************************************************

613  //   This   counter     increments       whenever          the  PCR      are  updated.       This  counter       is     preserved

614  //   across     TPM  Resume       even   though       the  PCR      are  not  preserved.           This   is   because

615  //   sessions    remain      active      across       TPM  Restart       and  the      count     value    in   the   session

616  //   is  compared     to     this  counter        so  this      counter       must     have  values      that   are     unique

617  //   as  long    as  the     sessions    are      active.

618  //   NOTE:   A   platform-specific            specification           may     designate      that  certain       PCR    changes

619  //           do  not    increment        this     counter       to  increment.

620       UINT32                        pcrCounter;                           //   The   default      reset    value     is  0.

621

622  #ifdef     TPM_ALG_ECC

623

624  //*****************************************************************************

625  //               ECDAA

626  //*****************************************************************************

627       UINT64                        commitCounter;                        //   This     counter     increments       each       time

628                                                                           //   TPM2_Commit()        returns

629                                                                           //   TPM_RC_SUCCESS.        The      default       reset

630                                                                           //   value    is    0.

631

632       TPM2B_NONCE                   commitNonce;                          //   This     random    value    is   used     to     compute

633                                                                           //   the   commit       values.  The    default       reset

634                                                                           //   value    is    from  the    RNG.

635

636  //   This   implementation         relies      on     the  number        of   bits     in  g_commitArray        being       a

637  //   power   of  2   (8,     16,   32,   64,   etc.)       and  no    greater       than     64K.

638       BYTE                               commitArray[16];                 //   The   default      reset    value     is  {0}.

639

640  #endif     //TPM_ALG_ECC

641

642  }   STATE_RESET_DATA;

643  extern     STATE_RESET_DATA        gr;

     5.8.13      Global Macro Definitions

     This macro is used to ensure that a handle, session, or parameter number is only added if the response

     code is FMT1.

644  #define     RcSafeAddToResult(r,              v)   \

645       ((r)    +   (((r)    &  RC_FMT1)    ?     (v)    :    0))

     This macro is used when a parameter is not otherwise referenced in a function. This macro is normally

     not used by itself but is paired with a pAssert() within a #ifdef pAssert. If pAssert is not defined, then a

     parameter might not otherwise be referenced. This macro uses the parameter from the perspective of the

     compiler so it doesn't complain.

646  #define     UNREFERENCED(a)        ((void)(a))

     5.8.14      Private data

647  #if  defined     SESSION_PROCESS_C             ||     defined       GLOBAL_C       ||  defined     MANUFACTURE_C

     From SessionProcess.c

     The  following       arrays  are   used       to   save    command            sessions       information  so     that   the    command

     handle/session buffer does not have to be preserved for the duration of the command. These arrays are

     indexed    by   the  session      index  in   accordance        with     the  order    of  sessions  in   the   session        area  of  the

     command.

     Family "2.0"                                               TCG Published                                                        Page 25

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                           Part 4: Supporting Routines

     Array of the authorization session handles

648  extern   TPM_HANDLE       s_sessionHandles[MAX_SESSION_NUM];

     Array of authorization session attributes

649  extern   TPMA_SESSION     s_attributes[MAX_SESSION_NUM];

     Array   of   handles  authorized   by  the  corresponding  authorization  sessions;  and        if  none,  then

     TPM_RH_UNASSIGNED value is used

650  extern   TPM_HANDLE       s_associatedHandles[MAX_SESSION_NUM];

     Array of nonces provided by the caller for the corresponding sessions

651  extern   TPM2B_NONCE      s_nonceCaller[MAX_SESSION_NUM];

     Array of authorization values (HMAC's or passwords) for the corresponding sessions

652  extern   TPM2B_AUTH       s_inputAuthValues[MAX_SESSION_NUM];

     Special value to indicate an undefined session index

653  #define                   UNDEFINED_INDEX        (0xFFFF)

     Index of the session used for encryption of a response parameter

654  extern   UINT32           s_encryptSessionIndex;

     Index of the session used for decryption of a command parameter

655  extern   UINT32           s_decryptSessionIndex;

     Index of a session used for audit

656  extern   UINT32           s_auditSessionIndex;

     The cpHash for an audit session

657  extern   TPM2B_DIGEST     s_cpHashForAudit;

     The cpHash for command audit

658  #ifdef      TPM_CC_GetCommandAuditDigest

659  extern   TPM2B_DIGEST     s_cpHashForCommandAudit;

660  #endif

     Number of authorization sessions present in the command

661  extern   UINT32           s_sessionNum;

     Flag indicating if NV update is pending for the lockOutAuthEnabled or failedTries DA parameter

662  extern   BOOL             s_DAPendingOnNV;

663  #endif   //  SESSION_PROCESS_C

664  #if  defined   DA_C   ||  defined  GLOBAL_C  ||  defined   MANUFACTURE_C

     From DA.c

     Page 26                                      TCG Published                                          Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                     Trusted Platform Module Library

     This variable holds the accumulated time since the last time that failedTries was decremented. This value

     is in millisecond.

665  extern  UINT64            s_selfHealTimer;

     This variable holds the accumulated time that the lockoutAuth has been blocked.

666  extern  UINT64            s_lockoutTimer;

667  #endif  //  DA_C

668  #if  defined    NV_C  ||  defined    GLOBAL_C

     From NV.c

     List of pre-defined address of reserved data

669  extern  UINT32            s_reservedAddr[NV_RESERVE_LAST];

     List of pre-defined reserved data size in byte

670  extern  UINT32            s_reservedSize[NV_RESERVE_LAST];

     Size of data in RAM index buffer

671  extern  UINT32            s_ramIndexSize;

     Reserved RAM space for frequently updated NV Index. The data layout in ram buffer is {NV_handle(),

     size of data, data} for each NV index data stored in RAM

672  extern  BYTE          s_ramIndex[RAM_INDEX_SPACE];

     Address of size of RAM index space in NV

673  extern  UINT32        s_ramIndexSizeAddr;

     Address of NV copy of RAM index space

674  extern  UINT32        s_ramIndexAddr;

     Address of maximum counter value; an auxiliary variable to implement NV counters

675  extern  UINT32        s_maxCountAddr;

     Beginning   of  NV  dynamic   area;  starts     right  after  the  s_maxCountAddr  and    s_evictHandleMapAddr

     variables

676  extern  UINT32        s_evictNvStart;

     Beginning of NV dynamic area; also the beginning of the predefined reserved data area.

677  extern  UINT32        s_evictNvEnd;

     NV availability is sampled as the start of each        command     and  stored  here  so  that  its  value  remains

     consistent during the command execution

678  extern  TPM_RC        s_NvStatus;

679  #endif

680  #if  defined    OBJECT_C  ||  defined  GLOBAL_C

     From Object.c

     Family "2.0"                                    TCG Published                                               Page 27

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                                  October 30, 2014
     Trusted Platform Module Library                                                         Part 4: Supporting  Routines

     This type is the container for an object.

681  typedef    struct

682  {

683       BOOL             occupied;

684       ANY_OBJECT             object;

685  }  OBJECT_SLOT;

     This is the memory that holds the loaded objects.

686  extern   OBJECT_SLOT        s_objects[MAX_LOADED_OBJECTS];

687  #endif   //   OBJECT_C

688  #if  defined   PCR_C    ||  defined    GLOBAL_C

     From PCR.c

689  typedef    struct

690  {

691  #ifdef   TPM_ALG_SHA1

692       //  SHA1  PCR

693       BYTE      sha1Pcr[SHA1_DIGEST_SIZE];

694  #endif

695  #ifdef   TPM_ALG_SHA256

696       //  SHA256    PCR

697       BYTE      sha256Pcr[SHA256_DIGEST_SIZE];

698  #endif

699  #ifdef   TPM_ALG_SHA384

700       //  SHA384    PCR

701       BYTE      sha384Pcr[SHA384_DIGEST_SIZE];

702  #endif

703  #ifdef   TPM_ALG_SHA512

704       //  SHA512    PCR

705       BYTE      sha512Pcr[SHA512_DIGEST_SIZE];

706  #endif

707  #ifdef   TPM_ALG_SM3_256

708       //  SHA256    PCR

709       BYTE      sm3_256Pcr[SM3_256_DIGEST_SIZE];

710  #endif

711  }  PCR;

712  typedef    struct

713  {

714       unsigned    int        stateSave  :   1;                //       if   the  PCR  value    should  be

715                                                               //       saved     in  state  save

716       unsigned    int        resetLocality      :     5;      //       The  locality     that  the  PCR

717                                                               //       can  be   reset

718       unsigned    int        extendLocality        :  5;      //       The  locality     that  the  PCR

719                                                               //       can  be   extend

720  }  PCR_Attributes;

721  extern   PCR                s_pcrs[IMPLEMENTATION_PCR];

722  #endif   //   PCR_C

723  #if  defined   SESSION_C    ||   defined   GLOBAL_C

     From Session.c

     Container for HMAC or policy session tracking information

724  typedef    struct

725  {

726       BOOL                       occupied;

727       SESSION                    session;                 //  session  structure

728  }  SESSION_SLOT;

729  extern   SESSION_SLOT           s_sessions[MAX_LOADED_SESSIONS];

     Page 28                                              TCG Published                                      Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                                             Trusted Platform Module Library

     The index in conextArray that has the value of the oldest saved session context. When                            no  context   is

     saved, this will have a value that is greater than or equal to MAX_ACTIVE_SESSIONS.

730  extern    UINT32                    s_oldestSavedSession;

     The number of available session slot openings.         When this is 1, a session can't be created or loaded if the

     GAP   is  maxed    out.    The  exception  is  that    the  oldest     saved  session   context      can     always  be    loaded

     (assuming that there is a space in memory to put it)

731  extern    int                       s_freeSessionSlots;

732  #endif    //   SESSION_C

     From Manufacture.c

733  extern    BOOL                      g_manufactured;

734  #if   defined   POWER_C    ||   defined    GLOBAL_C

     From Power.c

     This value indicates if a TPM2_Startup() commands has been receive since the power on event.                               This

     flag is maintained in power simulation module because this is the only place that may reliably set this flag

     to FALSE.

735  extern    BOOL                      s_initialized;

736  #endif    //   POWER_C

737  #if   defined   MEMORY_LIB_C        ||  defined  GLOBAL_C

     The s_actionOutputBuffer should not be modifiable by the host system until the TPM has returned a

     response code. The s_actionOutputBuffer should not be accessible until response parameter encryption,

     if any, is complete.

738  extern    UINT32       s_actionInputBuffer[1024];                             //  action      input    buffer

739  extern    UINT32       s_actionOutputBuffer[1024];                            //  action      output     buffer

740  extern    BYTE         s_responseBuffer[MAX_RESPONSE_SIZE];//                     response    buffer

741  #endif    //   MEMORY_LIB_C

     From TPMFail.c

     This  value   holds   the  address  of  the    string  containing      the  name    of  the   function   in  which   the   failure

     occurred. This address value isn't useful for anything other than helping the vendor to know in which file

     the failure occurred.

742  extern    jmp_buf        g_jumpBuffer;                 //   the        jump   buffer

743  extern    BOOL           g_inFailureMode;              //   Indicates         that      the   TPM  is    in  failure     mode

744  extern    BOOL           g_forceFailureMode;           //   flag       to    force  failure        mode  during      test

745  #if   defined   TPM_FAIL_C      ||  defined    GLOBAL_C     ||      1

746  extern    UINT32         s_failFunction;

747  extern    UINT32         s_failLine;                   //   the        line   in  the   file  at     which

748                                                         //   the        error  was   signaled

749  extern    UINT32         s_failCode;                   //   the        error  code      used

750  #endif    //   TPM_FAIL_C

751  #endif    //   GLOBAL_H

     5.9     Tpm.h

     Root header file for building any TPM.lib code

1    #ifndef         _TPM_H_

2    #define         _TPM_H_

3    #include        "bool.h"

     Family "2.0"                                     TCG Published                                                        Page 29

     Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                         October 30, 2014
    Trusted Platform Module Library                                                      Part 4: Supporting Routines

4   #include     "Implementation.h"

5   #include     "TPM_Types.h"

6   #include     "swap.h"

7   #endif   //  _TPM_H_

    5.10    swap.h

1   #ifndef   _SWAP_H

2   #define   _SWAP_H

3   #include     "Implementation.h"

4   #if      NO_AUTO_ALIGN  ==    YES  ||  LITTLE_ENDIAN_TPM    ==    YES

    The aggregation macros for machines      that do not allow unaligned access          or for little-endian  machines.

    Aggregate bytes into an UINT

5   #define   BYTE_ARRAY_TO_UINT8(b)           (UINT8)((b)[0])

6   #define   BYTE_ARRAY_TO_UINT16(b)          (UINT16)(     ((b)[0]  <<      8)  \

7                                                         +  (b)[1])

8   #define   BYTE_ARRAY_TO_UINT32(b)          (UINT32)(     ((b)[0]  <<   24)    \

9                                                         +  ((b)[1]  <<   16)    \

10                                                        +  ((b)[2]  <<   8  )   \

11                                                        +  (b)[3])

12  #define   BYTE_ARRAY_TO_UINT64(b)          (UINT64)(     ((UINT64)(b)[0]         <<  56)   \

13                                                        +  ((UINT64)(b)[1]         <<  48)   \

14                                                        +  ((UINT64)(b)[2]         <<  40)   \

15                                                        +  ((UINT64)(b)[3]         <<  32)   \

16                                                        +  ((UINT64)(b)[4]         <<  24)   \

17                                                        +  ((UINT64)(b)[5]         <<  16)   \

18                                                        +  ((UINT64)(b)[6]         <<  8)    \

19                                                        +  (UINT64)(b)[7])

    Disaggregate a UINT into a byte array

20  #define   UINT8_TO_BYTE_ARRAY(i,       b)  ((b)[0]       =  (BYTE)(i),        i)

21  #define   UINT16_TO_BYTE_ARRAY(i,      b)  ((b)[0]       =  (BYTE)((i)        >>     8),   \

22                                             (b)[1]        =  (BYTE)     (i),                \

23                                             (i))

24  #define   UINT32_TO_BYTE_ARRAY(i,      b)  ((b)[0]       =  (BYTE)((i)        >>     24),  \

25                                             (b)[1]        =  (BYTE)((i)        >>     16),  \

26                                             (b)[2]        =  (BYTE)((i)        >>     8),   \

27                                             (b)[3]        =  (BYTE)     (i),                \

28                                             (i))

29  #define   UINT64_TO_BYTE_ARRAY(i,      b)  ((b)[0]       =  (BYTE)((i)        >>     56),  \

30                                             (b)[1]        =  (BYTE)((i)        >>     48),  \

31                                             (b)[2]        =  (BYTE)((i)        >>     40),  \

32                                             (b)[3]        =  (BYTE)((i)        >>     32),  \

33                                             (b)[4]        =  (BYTE)((i)        >>     24),  \

34                                             (b)[5]        =  (BYTE)((i)        >>     16),  \

35                                             (b)[6]        =  (BYTE)((i)        >>     8),   \

36                                             (b)[7]        =  (BYTE)     (i),                \

37                                             (i))

38  #else

    the big-endian macros for machines that    allow unaligned  memory     access        Aggregate  a  byte    array  into  a

    UINT

39  #define   BYTE_ARRAY_TO_UINT8(b)           *((UINT8         *)(b))

40  #define   BYTE_ARRAY_TO_UINT16(b)          *((UINT16        *)(b))

41  #define   BYTE_ARRAY_TO_UINT32(b)          *((UINT32        *)(b))

42  #define   BYTE_ARRAY_TO_UINT64(b)          *((UINT64        *)(b))

    Disaggregate a UINT into a byte array

    Page 30                                    TCG Published                                           Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014                     Level 00 Revision 01.16
    Part 4: Supporting Routines                                             Trusted  Platform Module Library

43  #define   UINT8_TO_BYTE_ARRAY(i,       b)  (*((UINT8   *)(b))  =  (i))

44  #define   UINT16_TO_BYTE_ARRAY(i,      b)  (*((UINT16  *)(b))  =  (i))

45  #define   UINT32_TO_BYTE_ARRAY(i,      b)  (*((UINT32  *)(b))  =  (i))

46  #define   UINT64_TO_BYTE_ARRAY(i,      b)  (*((UINT64  *)(b))  =  (i))

47  #endif    //  NO_AUTO_ALIGN   ==  YES

48  #endif    //  _SWAP_H

    5.11    InternalRoutines.h

1   #ifndef       INTERNAL_ROUTINES_H

2   #define       INTERNAL_ROUTINES_H

    NULL definition

3   #ifndef          NULL

4   #define          NULL             (0)

5   #endif

    UNUSED_PARAMETER

6   #ifndef          UNUSED_PARAMETER

7   #define          UNUSED_PARAMETER(param)   (void)(param);

8   #endif

    Internal data definition

9   #include  "Global.h"

10  #include  "VendorString.h"

    Error Reporting

11  #include  "TpmError.h"

    DRTM functions

12  #include  "_TPM_Hash_Start_fp.h"

13  #include  "_TPM_Hash_Data_fp.h"

14  #include  "_TPM_Hash_End_fp.h"

    Internal subsystem functions

15  #include  "Object_fp.h"

16  #include  "Entity_fp.h"

17  #include  "Session_fp.h"

18  #include  "Hierarchy_fp.h"

19  #include  "NV_fp.h"

20  #include  "PCR_fp.h"

21  #include  "DA_fp.h"

22  #include  "TpmFail_fp.h"

    Internal support functions

23  #include  "CommandCodeAttributes_fp.h"

24  #include  "MemoryLib_fp.h"

25  #include  "marshal_fp.h"

26  #include  "Time_fp.h"

27  #include  "Locality_fp.h"

28  #include  "PP_fp.h"

29  #include  "CommandAudit_fp.h"

30  #include  "Manufacture_fp.h"

31  #include  "Power_fp.h"

    Family "2.0"                               TCG Published                         Page 31

    Level 00 Revision 01.16            Copyright © TCG 2006-2014                     October 30, 2014
    Trusted Platform Module Library                                                                 Part 4: Supporting Routines

32  #include  "Handle_fp.h"

33  #include  "Commands_fp.h"

34  #include  "AlgorithmCap_fp.h"

35  #include  "PropertyCap_fp.h"

36  #include  "Bits_fp.h"

    Internal crypto functions

37  #include  "Ticket_fp.h"

38  #include  "CryptUtil_fp.h"

39  #include  "CryptSelfTest_fp.h"

40  #endif

    5.12    TpmBuildSwitches.h

    This file contains the build switches. This contains switches for multiple versions of the crypto-library so

    some may not apply to your environment.

1   #ifndef   _TPM_BUILD_SWITCHES_H

2   #define   _TPM_BUILD_SWITCHES_H

3   #define   SIMULATION

4   #define   FIPS_COMPLIANT

    Define the alignment macro appropriate for the build environment For MS C compiler

5   #define   ALIGN_TO(boundary)     __declspec(align(boundary))

    For ISO 9899:2011

6   //  #define   ALIGN_TO(boundary)         _Alignas(boundary)

    This switch enables the RNG state save and restore

7   #undef    _DRBG_STATE_SAVE

8   #define   _DRBG_STATE_SAVE        //     Comment       this  out  if                 no  state  save  is  wanted

    Set the alignment size for the crypto. It would be nice to set this according to macros automatically

    defined by the build environment, but that doesn't seem possible because there isn't any simple set for

    that. So, this is just a plugged value. Your compiler should complain if this alignment isn't possible.

    NOTE:            this value can be set at the command line or just plugged in here.

9   #ifdef   CRYPTO_ALIGN_16

10  #     define  CRYPTO_ALIGNMENT    16

11  #elif   defined  CRYPTO_ALIGN_8

12  #     define  CRYPTO_ALIGNMENT    8

13  #eliF   defined  CRYPTO_ALIGN_2

14  #     define  CRYPTO_ALIGNMENT    2

15  #elif   defined  CRTYPO_ALIGN_1

16  #     define  CRYPTO_ALIGNMENT    1

17  #else

18  #     define  CRYPTO_ALIGNMENT    4      //       For  32-bit     builds

19  #endif

20  #define   CRYPTO_ALIGNED    ALIGN_TO(CRYPTO_ALIGNMENT)

    This macro is used to handle LIB_EXPORT of function and variable names in lieu of a .def file

21  #define   LIB_EXPORT       __declspec(dllexport)

22  //  #define   LIB_EXPORT

    Page 32                                  TCG Published                                                    Family "2.0"

    October 30, 2014                  Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
    Part 4: Supporting Routines                                                          Trusted Platform Module Library

    For import of a variable

23  #define   LIB_IMPORT      __declspec(dllimport)

24  //#define     LIB_IMPORT

    This is defined to indicate a function that does not return. This is used in static  code     anlaysis.

25  #define   _No_Return_      __declspec(noreturn)

26  //#define     _No_Return_

27  #ifdef    SELF_TEST

28  #pragma   comment(lib,     "algorithmtests.lib")

29  #endif

    The switches in this group can only be  enabled      when  running  a    simulation

30  #ifdef    SIMULATION

31  #     define  RSA_KEY_CACHE

32  #     define  TPM_RNG_FOR_DEBUG

33  #else

34  #     undef   RSA_KEY_CACHE

35  #     undef   TPM_RNG_FOR_DEBUG

36  #endif    //  SIMULATION

37  #define   INLINE     __inline

38  #endif    //  _TPM_BUILD_SWITCHES_H

    5.13      VendorString.h

1   #ifndef       _VENDOR_STRING_H

2   #define       _VENDOR_STRING_H

    Define    up  to  4-byte   values  for  MANUFACTURER.                  This  value   defines  the  response  for

    TPM_PT_MANUFACTURER in TPM2_GetCapability(). The following line should be un-commented and a

    vendor specific string should be provided here.

3   #define       MANUFACTURER         "MSFT"

    The following #if macro may be deleted after a proper MANUFACTURER is provided.

4   #ifndef   MANUFACTURER

5   #error    MANUFACTURER    is  not  provided.     \

6   Please    modify  include\VendorString.h         to  provide   a    specific  \

7   manufacturer      name.

8   #endif

    Define up to 4, 4-byte values. The values must each be 4 bytes long and the last value used may contain

    trailing  zeros.  These    values  define     the    response       for  TPM_PT_VENDOR_STRING_(1-4)          in

    TPM2_GetCapability(). The following line should be un-commented and a vendor specific string should

    be provided here. The vendor strings 2-4 may also be defined as appropriately.

9   #define           VENDOR_STRING_1             "xCG      "

10  #define           VENDOR_STRING_2             "fTPM"

11  //  #define           VENDOR_STRING_3

12  //  #define           VENDOR_STRING_4

    The following #if macro may be deleted after a proper VENDOR_STRING_1 is provided.

13  #ifndef   VENDOR_STRING_1

14  #error    VENDOR_STRING_1     is   not  provided.    \

15  Please    modify  include\VendorString.h         to  provide   a    vednor   specific  \

16  string.

    Family "2.0"                                  TCG Published                                              Page 33

    Level 00 Revision 01.16                 Copyright © TCG 2006-2014                             October 30, 2014
    Trusted Platform Module Library                                           Part 4: Supporting Routines

17  #endif

    the more significant 32-bits of a vendor-specific value indicating the version of the firmware The following

    line  should  be  un-commented   and  a  vendor  specific  firmware   V1  should  be            provided  here.  The

    FIRMWARE_V2 may also be defined as appropriate.

18  #define       FIRMWARE_V1        (0x20140504)

    the less significant 32-bits of a vendor-specific value indicating the version of the firmware

19  #define       FIRMWARE_V2        (0x00200136)

    The following #if macro may be deleted after a proper FIRMWARE_V1 is provided.

20  #ifndef  FIRMWARE_V1

21  #error   FIRMWARE_V1  is   not   provided.  \

22  Please   modify   include\VendorString.h    to   provide   a  vendor  specific    firmware      \

23  version

24  #endif

25  #endif

    Page 34                                     TCG Published                                       Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                   Level 00 Revision 01.16
    Part 4: Supporting Routines                                                     Trusted Platform Module Library

    6      Main

    6.1        CommandDispatcher()

    In the reference implementation, a program that uses TPM 2.0 Part 3 as input automatically generates

    the command dispatch code. The function prototype header file (CommandDispatcher_fp.h) is shown

    here.

    CommandDispatcher() performs the following operations:

         unmarshals command parameters from the input buffer;

         invokes the function that performs the command actions;

         marshals the returned handles, if any; and

         marshals the returned parameters, if any, into the output buffer putting in the parameterSize field if

         authorization sessions are present.

1   #ifndef          _COMMANDDISPATCHER_FP_H_

2   #define          _COMMANDDISPATCHER_FP_H_

3   TPM_RC

4   CommandDispatcher(

5          TPMI_ST_COMMAND_TAG           tag,   //   IN:   Input   command     tag

6          TPM_CC          commandCode,         //   IN:   Command       code

7          INT32           *parmBufferSize,     //   IN:   size   of     parameter  buffer

8          BYTE            *parmBufferStart,    //   IN:   pointer       to  start  of  parameter   buffer

9          TPM_HANDLE      handles[],           //   IN:   handle     array

10         UINT32          *responseHandleSize,//    OUT:  size    of    handle     buffer  in  response

11         UINT32          *respParmSize        //   OUT:  size    of    parameter      buffer  in  response

12         );

13  #endif       //  _COMMANDDISPATCHER_FP_H_

    6.2        ExecCommand.c

    6.2.1        Introduction

    This file contains the entry function ExecuteCommand() which provides the main control flow for TPM

    command execution.

    6.2.2        Includes

1   #include      "InternalRoutines.h"

2   #include      "HandleProcess_fp.h"

3   #include      "SessionProcess_fp.h"

4   #include      "CommandDispatcher_fp.h"

    Uncomment this next #include if doing static command/response buffer sizing

5   //   #include    "CommandResponseSizes_fp.h"

    6.2.3        ExecuteCommand()

    The function performs the following steps.

    a)   Parses the command header from input buffer.

    b)   Calls ParseHandleBuffer() to parse the handle area of the command.

    c)   Validates that each of the handles references a loaded entity.

    Family "2.0"                                     TCG Published                                          Page 35

    Level 00 Revision 01.16               Copyright © TCG 2006-2014                                 October 30, 2014
    Trusted Platform Module Library                                                                 Part 4: Supporting Routines

    d)  Calls ParseSessionBuffer() () to:

        1)  unmarshal and parse the session area;

        2)  check the authorizations; and

        3)  when necessary, decrypt a parameter.

    e)  Calls CommandDispatcher() to:

        1)  unmarshal the command parameters from the command buffer;

        2)  call the routine that performs the command actions; and

        3)  marshal the responses into the response buffer.

    f)  If any error occurs in any of the steps above create the error response and return.

    g)  Calls BuildResponseSession() to:

        1)  when necessary, encrypt a parameter

        2)  build the response authorization sessions

        3)  update the audit sessions and nonces

    h)  Assembles handle, parameter and session buffers for response and return.

6   LIB_EXPORT  void

7   ExecuteCommand(

8       unsigned  int         requestSize,       //    IN:       command   buffer       size

9       unsigned  char        *request,          //    IN:       command   buffer

10      unsigned  int         *responseSize,     //    OUT:      response    buffer         size

11      unsigned  char        **response         //    OUT:      response    buffer

12      )

13  {

14      //   Command   local  variables

15      TPM_ST                tag;                               //  these   first      three       variables         are   the

16      UINT32                commandSize;

17      TPM_CC                commandCode         =    0;

18

19      BYTE                  *parmBufferStart;                  //  pointer     to     the     first  byte       of   an

20                                                               //  optional       parameter        buffer

21

22      UINT32                parmBufferSize              =  0;//    number     of   bytes      in   parameter         area

23

24      UINT32                handleNum       =   0;             //  number     of   handles        unmarshaled         into

25                                                               //  the   handles      array

26

27      TPM_HANDLE            handles[MAX_HANDLE_NUM];//                    array       to   hold    handles       in   the

28                                                               //  command.       Only     handles      in   the     handle

29                                                               //  area   are     stored      here,     not     handles

30                                                               //  passed     as   parameters.

31

32      //   Response  local  variables

33      TPM_RC                result;                            //  return     code    for     the    command

34

35      TPM_ST                resTag;                            //  tag   for   the    response

36

37      UINT32                resHandleSize            =     0;  //  size   of   the    handle       area     in   the

38                                                               //  response.       This       is  needed     so     that   the

39                                                               //  handle     area    can     be   skipped       when

40                                                               //  generating         the     rpHash.

41

42      UINT32                resParmSize         =    0;        //  the   size     of  the     response       parameters

43                                                               //  These   values         go  in   the   rpHash.

44

45      UINT32                resAuthSize         =    0;        //  size   of   authorization            area     in   the

    Page 36                                       TCG Published                                                        Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                      Trusted Platform Module Library

46                                                                                      //     response

47

48       INT32                                       size;                              //     remaining         data     to     be     unmarshaled

49                                                                                      //     or   remaining         space       in    the      marshaling

50                                                                                      //     buffer

51

52       BYTE                                     *buffer;                              //     pointer         into   the     buffer        being     used

53                                                                                      //     for     marshaling         or     unmarshaling

54

55       UINT32                                      i;                                    //   local      temp

56

57   //  This     next     function           call       is   used       in   development           to     size     the   command           and  response

58   //  buffers.         The     values       printed           are     the     sizes     of   the       internal       structures          and

59   //  not   the    sizes        of     the     canonical           forms       of  the      command         response       structures.          Also,

60   //  the   sizes       do     not     include         the     tag,       commandCode,           requestSize,             or   the       authorization

61   //  fields.

62   //CommandResponseSizes();

63

64       //    Set    flags        for     NV     access         state.       This    should        happen       before       any       other

65       //    operation           that       may     require         a   NV     write.     Note,         that   this     needs         to  be   done

66       //    even       when     in     failure         mode.       Otherwise,           g_updateNV           would     stay       SET    while     in

67       //    Failure         mode       and     the     NB     would       be   written       on     each     call.

68       g_updateNV            =   FALSE;

69       g_clearOrderly                =   FALSE;

70

71       //    As     of   Sept       25,     2013,       the     failure         mode     handling        has      been     incorporated          in     the

72       //    reference           code.       This       implementation              requires            that   the     system         support

73       //    setjmp/longjmp.                 This       code       is   put     here     because         of   the   complexity            being

74       //    added       to     the     platform           and     simulator        code      to     deal     with     all     the    variations

75       //    of     errors.

76       if(g_inFailureMode)

77       {

78                //  Do      failure         mode       processing

79                TpmFailureMode               (requestSize,                 request,       responseSize,             response);

80                return;

81       }

82       if(setjmp(g_jumpBuffer)                          !=     0)

83       {

84                //  Get      here       if   we     got     a   longjump           putting       us     into   failure         mode

85                g_inFailureMode                 =   TRUE;

86                result       =   TPM_RC_FAILURE;

87                goto     Fail;

88       }

89

90       //    Assume         that     everything             is     going       to   work.

91       result       =    TPM_RC_SUCCESS;

92

93       //    Query       platform           to     get     the     NV   state.        The     result         state     is   saved         internally

94       //    and    will        be   reported           by     NvIsAvailable().               The       reference       code       requires      that

95       //    accessibility               of     NV     does     not     change      during        the    execution          of     a  command.

96       //    Specifically,               if     NV     is   available           when     the     command       execution           starts      and   then

97       //    is     not     available           later       when       it   is     necessary         to  write      to     NV,     then    the   TPM

98       //    will       go   into       failure         mode.

99       NvCheckState();

100

101      //    Due    to      the     limitations             of     the     simulation,           TPM     clock     must     be     explicitly

102      //    synchronized               with       the     system       clock       whenever         a   command       is   received.

103      //    This       function         call       is     not     necessary        in    a   hardware         TPM.     However,          taking

104      //    a   snapshot           of   the       hardware         timer       at  the      beginning         of   the     command        allows

105      //    the    time        value       to     be   consistent             for  the      duration         of   the     command        execution.

106      TimeUpdateToCurrent();

107

108      //    Any    command          through           this     function           will   unceremoniously               end     the

109      //    _TPM_Hash_Data/_TPM_Hash_End                               sequence.

110      if(g_DRTMHandle                  !=   TPM_RH_UNASSIGNED)

111               ObjectTerminateEvent();

     Family "2.0"                                                         TCG Published                                                                   Page 37

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                                     October 30, 2014
     Trusted Platform Module Library                                                                              Part 4: Supporting Routines

112

113       //  Get        command         buffer       size     and   command        buffer.

114       size     =     requestSize;

115       buffer         =   request;

116

117       //  Parse          command         header:       tag,     commandSize         and      commandCode.

118       //  First          parse       the     tag.  The     unmarshaling             routine  will      validate

119       //  that          it   is     either       TPM_ST_SESSIONS            or  TPM_ST_NO_SESSIONS.

120       result         =   TPMI_ST_COMMAND_TAG_Unmarshal(&tag,                              &buffer,     &size);

121       if(result             !=   TPM_RC_SUCCESS)

122             goto         Cleanup;

123

124       //  Unmarshal              the     commandSize           indicator.

125       result         =   UINT32_Unmarshal(&commandSize,                         &buffer,     &size);

126       if(result             !=   TPM_RC_SUCCESS)

127             goto         Cleanup;

128

129       //  On      a     TPM     that     receives       bytes       on   a  port,    the     number    of   bytes   that  were

130       //  received              on   that    port      is  requestSize          it   must    be    identical    to   commandSize.

131       //  In      addition,             commandSize        must        not  be  larger       than  MAX_COMMAND_SIZE       allowed

132       //  by      the       implementation.             The     check       against     MAX_COMMAND_SIZE        may  be   redundant

133       //  as      the       input       processing         (the     function        that     receives  the  command       bytes  and

134       //  places            them     in     the   input    buffer)          would   likely   have      the  input    truncated   when

135       //  it      reaches           MAX_COMMAND_SIZE,               and     requestSize      would     not  equal    commandSize.

136       if(commandSize                 !=     requestSize         ||     commandSize        >  MAX_COMMAND_SIZE)

137       {

138             result           =   TPM_RC_COMMAND_SIZE;

139             goto         Cleanup;

140       }

141

142       //  Unmarshal              the     command       code.

143       result         =   TPM_CC_Unmarshal(&commandCode,                         &buffer,     &size);

144       if(result             !=   TPM_RC_SUCCESS)

145             goto         Cleanup;

146

147       //  Check          to     see     if   the   command       is     implemented.

148       if(!CommandIsImplemented(commandCode))

149       {

150             result           =   TPM_RC_COMMAND_CODE;

151             goto         Cleanup;

152       }

153

154  #if     FIELD_UPGRADE_IMPLEMENTED                         ==    YES

155       //  If      the       TPM     is   in  FUM,      then     the     only    allowed      command   is

156       //  TPM_CC_FieldUpgradeData.

157       if(IsFieldUgradeMode()                       &&   (commandCode            !=  TPM_CC_FieldUpgradeData))

158       {

159             result           =   TPM_RC_UPGRADE;

160             goto         Cleanup;

161       }

162       else

163  #endif

164             //       Excepting           FUM,     the   TPM     only     accepts     TPM2_Startup()         after

165             //       _TPM_Init.             After  getting          a   TPM2_Startup(),          TPM2_Startup()

166             //       is     no   longer      allowed.

167             if((             !TPMIsStarted()               &&   commandCode         !=    TPM_CC_Startup)

168                         ||   (TPMIsStarted()               &&   commandCode         ==    TPM_CC_Startup))

169             {

170                         result       =   TPM_RC_INITIALIZE;

171                         goto     Cleanup;

172             }

173

174       //  Start          regular         command       process.

175       //  Parse          Handle         buffer.

176       result         =   ParseHandleBuffer(commandCode,                         &buffer,     &size,        handles,  &handleNum);

177       if(result             !=   TPM_RC_SUCCESS)

     Page 38                                                            TCG Published                                                Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                              Trusted Platform Module Library

178           goto          Cleanup;
          
179       
          
180       //  Number         of  handles            retrieved           from     handle      area      should  be     less     than
          
181       //  MAX_HANDLE_NUM.
          
182       pAssert(handleNum               <=        MAX_HANDLE_NUM);
          
183       
          
184       //  All       handles       in  the       handle          area     are     required      to  reference          TPM-resident
          
185       //  entities.
          
186       for(i    =    0;    i  <    handleNum;            i++)
          
187       {
          
188           result          =  EntityGetLoadStatus(&handles[i],                                  commandCode);
          
189           if(result             !=    TPM_RC_SUCCESS)
          
190           {
          
191                     if(result         ==        TPM_RC_REFERENCE_H0)
          
192                              result       =     result       +   i;
          
193                     else
          
194                              result       =     RcSafeAddToResult(result,                      TPM_RC_H        +  g_rcIndex[i]);
          
195                     goto     Cleanup;
          
196           }
          
197       }
          
198       
          
199       //  Authorization               session           handling         for     the     command.
          
200       if(tag        ==   TPM_ST_SESSIONS)
          
201       {
          
202           BYTE                       *sessionBufferStart;//                       address      of  the     session        area   first     byte
          
203                                                                              //   in     the   input  buffer
          
204       
          
205           UINT32                     authorizationSize;                      //   number       of  bytes   in     the     session      area
          
206       
          
207           //        Find     out     session           buffer       size.
          
208           result          =  UINT32_Unmarshal(&authorizationSize,                                  &buffer,           &size);
          
209           if(result             !=    TPM_RC_SUCCESS)
          
210                     goto     Cleanup;
          
211       
          
212           //        Perform       sanity        check        on     the   unmarshaled          value.      If     it  is   smaller     than
          
213           //        the   smallest           possible           session       or  larger       than   the      remaining        size   of
          
214           //        the   command,           then       it   is     an   error.       NOTE:    This   check       could      pass  but     the
          
215           //        session       size       could      still        be   wrong.         That  will   be   determined           after      the
          
216           //        sessions         are     unmarshaled.
          
217           if(            authorizationSize                   <   9
          
218                     ||   authorizationSize                   >   (UINT32)         size)
          
219           {
          
220                     result        =   TPM_RC_SIZE;
          
221                     goto     Cleanup;
          
222           }
          
223       
          
224           //        The   sessions,             if     any,     follows       authorizationSize.
          
225           sessionBufferStart                        =   buffer;
          
226       
          
227           //        The   parameters            follow          the     session       area.
          
228           parmBufferStart                    =  sessionBufferStart                    +  authorizationSize;
          
229       
          
230           //        Any   data       left       over    after        removing         the     authorization           sessions     is
          
231           //        parameter         data.         If  the      command         does    not   have   parameters,            then  an
          
232           //        error    will     be        returned         if     the   remaining        size   is   not        zero.  This      is
          
233           //        checked       later.
          
234           parmBufferSize                  =     size    -    authorizationSize;
          
235       
          
236           //        The   actions         of    ParseSessionBuffer()                     are   described          in  the    introduction.
          
237           result          =  ParseSessionBuffer(commandCode,
          
238                                                                      handleNum,
          
239                                                                      handles,
          
240                                                                      sessionBufferStart,
          
241                                                                      authorizationSize,
          
242                                                                      parmBufferStart,
          
243                                                                      parmBufferSize);

     Family "2.0"                                                   TCG Published                                                              Page 39

     Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                                October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

244                 if(result      !=    TPM_RC_SUCCESS)
          
245                         goto   Cleanup;
          
246       }
          
247       else
          
248       {
          
249                 //   Whatever       remains        in      the  input     buffer   is    used      for     the  parameters        of  the
          
250                 //   command.
          
251                 parmBufferStart             =  buffer;
          
252                 parmBufferSize           =     size;
          
253       
          
254                 //   The  command        has       no  authorization          sessions.
          
255                 //   If   the  command         requires         authorizations,          then      CheckAuthNoSession()               will
          
256                 //   return    an    error.
          
257                 result    =    CheckAuthNoSession(commandCode,                     handleNum,              handles,
          
258                                                                    parmBufferStart,          parmBufferSize);
          
259                 if(result      !=    TPM_RC_SUCCESS)
          
260                         goto   Cleanup;
          
261       }
          
262       
          
263       //       CommandDispatcher               returns     a    response      handle     buffer       and   a   response      parameter
          
264       //       buffer     if   it   succeeds.          It  will    also       set  the   parameterSize            field  in   the
          
265       //       buffer     if   the   tag       is  TPM_RC_SESSIONS.
          
266       result         =   CommandDispatcher(tag,
          
267                                                            commandCode,
          
268                                                            (INT32  *)     &parmBufferSize,
          
269                                                            parmBufferStart,
          
270                                                            handles,
          
271                                                            &resHandleSize,
          
272                                                            &resParmSize);
          
273       if(result           !=   TPM_RC_SUCCESS)
          
274                 goto     Cleanup;
          
275       
          
276       //       Build     the   session         area    at  the     end    of  the  parameter          area.
          
277       BuildResponseSession(tag,
          
278                                                commandCode,
          
279                                                resHandleSize,
          
280                                                resParmSize,
          
281                                                &resAuthSize);
          
282       
          
283       Cleanup:
          
284       //       This     implementation             loads   an      "evict"    object     to     a  transient      object      slot    in
          
285       //       RAM   whenever       an   "evict"           object  handle     is   used      in    a  command     so    that  the
          
286       //       access     to   any   object        is      the  same.     These    temporary          objects     need   to   be
          
287       //       cleared    from      RAM     whether        the     command    succeeds       or    fails.
          
288       ObjectCleanupEvict();
          
289       
          
290       Fail:
          
291       //       The   response       will       contain     at      least  a   response       header.
          
292       *responseSize            =    sizeof(TPM_ST)              +  sizeof(UINT32)        +      sizeof(TPM_RC);
          
293       
          
294       //       If   the   command       completed          successfully,           then  build        the   rest  of    the   response.
          
295       if(result           ==   TPM_RC_SUCCESS)
          
296       {
          
297                 //   Outgoing       tag     will       be  the     same   as  the  incoming           tag.
          
298                 resTag    =    tag;
          
299                 //   The  overall        response          will    include    the  handles,           parameters,
          
300                 //   and  authorizations.
          
301                 *responseSize           +=     resHandleSize         +    resParmSize        +     resAuthSize;
          
302       
          
303                 //   Adding    parameter           size    field.
          
304                 if(tag    ==   TPM_ST_SESSIONS)
          
305                         *responseSize          +=      sizeof(UINT32);
          
306       
          
307                 if(       g_clearOrderly               ==  TRUE
          
308                      &&   gp.orderlyState              !=  SHUTDOWN_NONE)
          
309                 {

     Page 40                                                      TCG Published                                                  Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                             Trusted Platform Module Library

310                     gp.orderlyState                   =  SHUTDOWN_NONE;

311                     NvWriteReserved(NV_ORDERLY,                        &gp.orderlyState);

312                     g_updateNV           =     TRUE;

313              }

314        }

315        else

316        {

317              //  The       command       failed.

318              //  If     this    was      a     failure       due  to   a   bad      command     tag,    then    need   to   return

319              //  a    TPM      1.2   compatible              response

320              if(result          ==   TPM_RC_BAD_TAG)

321                     resTag      =    TPM_ST_RSP_COMMAND;

322              else

323                     //     return    2.0          compatible      response

324                     resTag      =    TPM_ST_NO_SESSIONS;

325        }

326        //  Try   to     commit       all       the       writes   to  NV   if   any  NV     write     happened       during     this

327        //  command         execution.             This   check    should       be   made    for     both  succeeded        and     failed

328        //  commands,           because         a  failed     one      may  trigger       a  NV   write    in    DA   logic     as  well.

329        //  This     is     the  only        place        in  the  command       execution        path     that  may    call     the    NV

330        //  commit.         If   the  NV        commit        fails,   the      TPM  should      be  put   in    failure     mode.

331        if(g_updateNV            &&   !g_inFailureMode)

332        {

333              g_updateNV         =    FALSE;

334              if(!NvCommit())

335                     FAIL(FATAL_ERROR_INTERNAL);

336        }

337

338        //  Marshal         the  response              header.

339        buffer    =    MemoryGetResponseBuffer(commandCode);

340        TPM_ST_Marshal(&resTag,                        &buffer,    NULL);

341        UINT32_Marshal((UINT32                     *)responseSize,              &buffer,     NULL);

342        pAssert(*responseSize                      <=     MAX_RESPONSE_SIZE);

343        TPM_RC_Marshal(&result,                        &buffer,    NULL);

344

345        *response        =  MemoryGetResponseBuffer(commandCode);

346

347        //  Clear      unused        bit     in    response        buffer.

348        MemorySet(*response                  +     *responseSize,           0,  MAX_RESPONSE_SIZE            -   *responseSize);

349

350        return;

351  }

     6.3       ParseHandleBuffer()

     In the reference implementation, the routine for unmarshaling the command handles is automatically

     generated      from  TPM       2.0  Part         3   command     tables.      The   prototype      header     file  (HandleProcess_fp.h)    is

     shown here.

1    #ifndef         _HANDLEPROCESS_FP_H_

2    #define         _HANDLEPROCESS_FP_H_

3    TPM_RC

4    ParseHandleBuffer(

5          TPM_CC              commandCode,                                        //   IN:     Command     being   processed

6          BYTE                **handleBufferStart,                                //   IN/OUT:      command       buffer  where       handles

7                                                                                  //    are     located.       Updated    as      handles

8                                                                                  //    are     unmarshaled

9          INT32               *bufferRemainingSize,                               //   IN/OUT:      indicates      the    amount      of  data

10                                                                                 //    left       in  the   command      buffer.

11                                                                                 //    Updated        as    handles     are   unmarshaled

12         TPM_HANDLE          handles[],                                          //   OUT:    Array     that     receives     the    handles

13         UINT32              *handleCount                                        //   OUT:    Receives      the   count      of   handles

14         );

15   #endif      //  _HANDLEPROCESS_FP_H_

     Family "2.0"                                                     TCG Published                                                        Page 41

     Level 00 Revision 01.16                                 Copyright © TCG 2006-2014                                         October 30, 2014
    Trusted Platform Module Library                                                     Part 4: Supporting Routines

    6.4      SessionProcess.c

    6.4.1       Introduction

    This file contains the subsystem that process the authorization sessions including implementation of the

    Dictionary Attack logic. ExecCommand() uses ParseSessionBuffer() to process the authorization session

    area of a command and BuildResponseSession() to create the authorization session area of a response.

    6.4.2       Includes and Data Definitions

1   #define     SESSION_PROCESS_C

2   #include       "InternalRoutines.h"

3   #include       "SessionProcess_fp.h"

4   #include       "Platform.h"

    6.4.3       Authorization Support Functions

    6.4.3.1         IsDAExempted()

    This function indicates if a handle is exempted from DA logic. A handle    is    exempted    if  it  is

    a)   a primary seed handle,

    b)   an object with noDA bit SET,

    c)   an NV Index with TPMA_NV_NO_DA bit SET, or

    d)   a PCR handle.

    Return Value                       Meaning

    TRUE                               handle is exempted from DA logic

    FALSE                              handle is not exempted from DA logic

5   BOOL

6   IsDAExempted(

7         TPM_HANDLE              handle            //  IN:    entity  handle

8         )

9   {

10        BOOL            result  =    FALSE;

11

12        switch(HandleGetType(handle))

13        {

14              case  TPM_HT_PERMANENT:

15                    //  All  permanent    handles,    other  than    TPM_RH_LOCKOUT,      are  exempt      from

16                    //  DA   protection.

17                    result   =  (handle    !=  TPM_RH_LOCKOUT);

18                    break;

19

20              //  When  this    function   is  called,  a    persistent    object  will   have     been    loaded

21              //  into  an   object  slot    and  assigned   a  transient    handle.

22              case  TPM_HT_TRANSIENT:

23              {

24                    OBJECT         *object;

25                    object   =  ObjectGet(handle);

26                    result   =  (object->publicArea.objectAttributes.noDA             ==  SET);

27                    break;

28              }

29              case  TPM_HT_NV_INDEX:

30              {

31                    NV_INDEX            nvIndex;

    Page 42                                         TCG Published                                            Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                      Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                           Trusted Platform    Module  Library

32                      NvGetIndexInfo(handle,                     &nvIndex);

33                      result         =  (nvIndex.publicArea.attributes.TPMA_NV_NO_DA                              ==  SET);

34                      break;

35              }

36              case       TPM_HT_PCR:

37                      //  PCRs          are    always      exempted      from  DA.

38                      result         =  TRUE;

39                      break;

40              default:

41                      break;

42        }

43        return       result;

44  }

    6.4.3.2         IncrementLockout()

    This  function      is  called        after    an  authorization   failure   that    involves     use  of   an  authValue.    If  the  entity

    referenced      by     the  handle         is  not    exempt       from  DA  protection,      then     the  failedTries  counter   will  be

    incremented.

    Error Returns                                  Meaning

    TPM_RC_AUTH_FAIL                               authorization failure that caused DA lockout to increment

    TPM_RC_BAD_AUTH                                authorization failure did not cause DA lockout to increment

45  static    TPM_RC

46  IncrementLockout(

47        UINT32                          sessionIndex

48        )

49  {

50        TPM_HANDLE                      handle       =     s_associatedHandles[sessionIndex];

51        TPM_HANDLE                      sessionHandle            =   s_sessionHandles[sessionIndex];

52        TPM_RC                          result;

53        SESSION                         *session        =  NULL;

54

55        //  Don't        increment           lockout       unless    the     handle    associated      with   the     session

56        //  is    DA     protected           or  the       session   is    bound   to  a  DA    protected     entity.

57        if(sessionHandle                ==     TPM_RS_PW)

58        {

59              if(IsDAExempted(handle))

60                      return         TPM_RC_BAD_AUTH;

61

62        }

63        else

64        {

65              session         =  SessionGet(sessionHandle);

66              //     If   the    session         is     bound    to  lockout,      then   use    that    as   the     relevant

67              //     handle.         This      means       that  an  auth    failure      with   a  bound     session

68              //     bound       to     lockoutAuth        will      take    precedence      over   any  other

69              //     lockout         check

70              if(session->attributes.isLockoutBound                                ==  SET)

71                      handle         =  TPM_RH_LOCKOUT;

72

73              if(         session->attributes.isDaBound                        ==  CLEAR

74                     &&   IsDAExempted(handle)

75                  )

76                     //   If     the    handle       was   changed       to  TPM_RH_LOCKOUT,          this    will    not  return

77                     //   TPM_RC_BAD_AUTH

78                      return         TPM_RC_BAD_AUTH;

79

80        }

81

82        if(handle         ==     TPM_RH_LOCKOUT)

    Family "2.0"                                                      TCG Published                                                   Page 43

    Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                   October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

83        {

84              pAssert(gp.lockOutAuthEnabled);

85              gp.lockOutAuthEnabled          =    FALSE;

86              //  For  TPM_RH_LOCKOUT,          if   lockoutRecovery         is   0,      no  need  to  update    NV    since

87              //  the  lockout     auth     will     be  reset     at   startup.

88              if(gp.lockoutRecovery          !=      0)

89              {

90                  result     =   NvIsAvailable();

91                  if(result        !=  TPM_RC_SUCCESS)

92                  {

93                         //  No    NV  access     for    now.   Put     the  TPM  in      pending   mode.

94                         s_DAPendingOnNV          =  TRUE;

95                  }

96                  else

97                  {

98                         //  Update    NV.

99                         NvWriteReserved(NV_LOCKOUT_AUTH_ENABLED,                         &gp.lockOutAuthEnabled);

100                        g_updateNV      =   TRUE;

101                 }

102             }

103       }

104       else

105       {

106             if(gp.recoveryTime         !=  0)

107             {

108                 gp.failedTries++;

109                 result     =   NvIsAvailable();

110                 if(result        !=  TPM_RC_SUCCESS)

111                 {

112                        //  No    NV  access     for    now.      Put  the  TPM      in  pending      mode.

113                        s_DAPendingOnNV          =  TRUE;

114                 }

115                 else

116                 {

117                        //  Record    changes       to  NV.

118                        NvWriteReserved(NV_FAILED_TRIES,                    &gp.failedTries);

119                        g_updateNV      =   TRUE;

120                 }

121             }

122       }

123

124       //  Register     a   DA  failure     and     reset   the   timers.

125       DARegisterFailure(handle);

126

127       return    TPM_RC_AUTH_FAIL;

128  }

     6.4.3.3        IsSessionBindEntity()

     This function indicates if the entity associated with the handle is the entity, to which this session is bound.

     The  binding   would     occur  by  making     the    bind     parameter  in   TPM2_StartAuthSession()         not   equal      to

     TPM_RH_NULL.        The   binding   only  occurs      if  the   session   is   an  HMAC    session.     The    bind  value  is  a

     combination of the Name and the authValue of the entity.

     Return Value                        Meaning

     TRUE                                handle points to the session start entity

     FALSE                               handle does not point to the session start entity

129  static   BOOL

130  IsSessionBindEntity(

131       TPM_HANDLE               associatedHandle,             //  IN:  handle        to  be  authorized

132       SESSION                  *session                      //  IN:  associated            session

     Page 44                                               TCG Published                                                Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                                 Level  00  Revision 01.16
     Part  4: Supporting Routines                                                                Trusted Platform  Module  Library

133        )

134  {

135        TPM2B_NAME                entity;                         //   The  bind  value  for  the  entity

136

137        //  If        the  session     is  not    bound,     return    FALSE.

138        if(!session->attributes.isBound)

139                return     FALSE;

140

141        //  Compute        the    bind     value  for   the      entity.

142        SessionComputeBoundEntity(associatedHandle,                           &entity);

143

144        //  Compare        to     the  bind   value     in   the  session.

145        session->attributes.requestWasBound                       =

146                      Memory2BEqual(&entity.b,               &session->u1.boundEntity.b);

147        return        session->attributes.requestWasBound;

148  }

     6.4.3.4             IsPolicySessionRequired()

     Checks    if     a  policy  session   is    required  for  a    command.    If  a  command  requires  DUP     or  ADMIN  role

     authorization, then the handle that requires that role is the first handle in the command. This simplifies

     this checking. If a new command is created that requires multiple ADMIN role authorizations, then it will

     have to be special-cased in this function. A policy session is required if:

     a)    the command requires the DUP role,

     b)    the command requires the ADMIN role and the authorized entity is an object and its adminWithPolicy

           bit is SET, or

     c)    the command requires the ADMIN role and the authorized entity is a permanent handle or an NV

           Index.

     d)    The authorized entity is a PCR belonging to a policy group, and has its policy initialized

     Return Value                                Meaning

     TRUE                                        policy session is required

     FALSE                                       policy session is not required

149  static    BOOL

150  IsPolicySessionRequired(

151        TPM_CC                         commandCode,          //   IN:  command    code

152        UINT32                         sessionIndex          //   IN:  session    index

153        )

154  {

155        AUTH_ROLE                 role     =  CommandAuthRole(commandCode,               sessionIndex);

156        TPM_HT                    type     =  HandleGetType(s_associatedHandles[sessionIndex]);

157

158        if(role       ==   AUTH_DUP)

159                return     TRUE;

160

161        if(role       ==   AUTH_ADMIN)

162        {

163                if(type       ==  TPM_HT_TRANSIENT)

164                {

165                      OBJECT               *object   =  ObjectGet(s_associatedHandles[sessionIndex]);

166

167                      if(object->publicArea.objectAttributes.adminWithPolicy                       ==    CLEAR)

168                              return    FALSE;

169                }

170                return     TRUE;

171        }

172

     Family "2.0"                                               TCG Published                                          Page 45

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting    Routines

173     if(type      ==  TPM_HT_PCR)

174     {

175           if(PCRPolicyIsAvailable(s_associatedHandles[sessionIndex]))

176           {

177                  TPM2B_DIGEST                  policy;

178                  TPMI_ALG_HASH                 policyAlg;

179                  policyAlg     =  PCRGetAuthPolicy(s_associatedHandles[sessionIndex],

180                                                               &policy);

181                  if(policyAlg         !=  TPM_ALG_NULL)

182                      return       TRUE;

183           }

184     }

185     return       FALSE;

186  }

     6.4.3.5      IsAuthValueAvailable()

     This function indicates if authValue is available and allowed for USER role authorization of an entity.

     This function is similar to IsAuthPolicyAvailable() except that it does not check the size of the authValue

     as IsAuthPolicyAvailable() does (a null authValue is a valid auth, but a null policy is not a valid policy).

     This function does not check that the handle reference is valid or if the entity is in an enabled hierarchy.

     Those checks are assumed to have been performed during the handle unmarshaling.

     Return Value                         Meaning

     TRUE                                 authValue is available

     FALSE                                authValue is not available

187  static   BOOL

188  IsAuthValueAvailable(

189     TPM_HANDLE              handle,                    //  IN:  handle     of    entity

190     TPM_CC                  commandCode,               //  IN:  commandCode

191     UINT32                  sessionIndex               //  IN:  session      index

192     )

193  {

194     BOOL                    result        =    FALSE;

195     //    If  a  policy    session        is   required,   the     entity    can  not    be   authorized  by

196     //    authValue.     However,         at   this  point,     the   policy     session     requirement  should

197     //    already    have  been       checked.

198     pAssert(!IsPolicySessionRequired(commandCode,                          sessionIndex));

199

200     switch(HandleGetType(handle))

201     {

202           case      TPM_HT_PERMANENT:

203                  switch(handle)

204                  {

205                            //     At  this     point   hierarchy      availability        has  already    been

206                            //     checked      so    primary    seed  handles     are    always    available     here

207                      case   TPM_RH_OWNER:

208                      case   TPM_RH_ENDORSEMENT:

209                      case   TPM_RH_PLATFORM:

210  #ifdef   VENDOR_PERMANENT

211                            //     This    vendor     defined    handle     associated        with  the

212                            //     manufacturer's           shared    secret

213                      case   VENDOR_PERMANENT:

214  #endif

215                            //     NullAuth     is    always     available.

216                      case   TPM_RH_NULL:

217                             //    At      the  point   when     authValue      availability        is  checked,  control

218                            //     path    has  already     passed     the    DA   check   so   LockOut  auth     is

219                            //     always       available   here

220                      case   TPM_RH_LOCKOUT:

     Page 46                                               TCG Published                                             Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                 Trusted Platform Module Library

221

222                                result      =  TRUE;

223                                break;

224                        default:

225                                //  Otherwise         authValue      is   not     available.

226                                break;

227                 }

228                 break;

229           case     TPM_HT_TRANSIENT:

230                 //  A     persistent          object     has   already    been     loaded  and   the  internal

231                 //  handle         changed.

232                 {

233                        OBJECT                        *object;

234                        object      =   ObjectGet(handle);

235

236                        //   authValue         is     always    available      for  a   sequence  object.

237                        if(ObjectIsSequence(object))

238                        {

239                                result      =      TRUE;

240                                break;

241                        }

242                        //   authValue         is     available      for  an   object   if  it   has   its  sensitive

243                        //   portion        loaded     and

244                        //      1.  userWithAuth           bit  is   SET,     or

245                        //      2.  ADMIN      role    is   required

246                        if(         object->attributes.publicOnly                   ==  CLEAR

247                             &&         (object->publicArea.objectAttributes.userWithAuth                           ==    SET

248                                    ||  (CommandAuthRole(commandCode,                   sessionIndex)       ==  AUTH_ADMIN

249                                        &&     object->publicArea.objectAttributes.adminWithPolicy

250                                               ==  CLEAR)))

251                                result      =  TRUE;

252                 }

253                 break;

254           case     TPM_HT_NV_INDEX:

255                 //  NV     Index.

256                 {

257                        NV_INDEX                      nvIndex;

258                        NvGetIndexInfo(handle,                  &nvIndex);

259                        if(IsWriteOperation(commandCode))

260                        {

261                                if  (nvIndex.publicArea.attributes.TPMA_NV_AUTHWRITE                            ==  SET)

262                                        result     =  TRUE;

263

264                        }

265                        else

266                        {

267                                if  (nvIndex.publicArea.attributes.TPMA_NV_AUTHREAD                             ==  SET)

268                                        result     =  TRUE;

269                        }

270                 }

271                 break;

272           case     TPM_HT_PCR:

273                 //  PCR     handle.

274                 //  authValue          is     always     allowed    for   PCR

275                 result      =      TRUE;

276                 break;

277           default:

278                 //  Otherwise,         authValue          is   not  available

279                 break;

280        }

281        return  result;

282  }

     Family "2.0"                                             TCG Published                                                  Page 47

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                             Part 4: Supporting Routines

     6.4.3.6    IsAuthPolicyAvailable()

     This function indicates if an authPolicy is available and allowed.

     This function does not check that the handle reference is valid or if the entity is in an            enabled   hierarchy.

     Those checks are assumed to have been performed during the handle unmarshaling.

     Return Value                      Meaning

     TRUE                              authPolicy is available

     FALSE                             authPolicy is not available

283  static   BOOL

284  IsAuthPolicyAvailable(

285     TPM_HANDLE              handle,             //     IN:  handle      of    entity

286     TPM_CC                  commandCode,        //     IN:  commandCode

287     UINT32                  sessionIndex        //     IN:  session         index

288     )

289  {

290     BOOL                 result     =  FALSE;

291     switch(HandleGetType(handle))

292     {

293           case     TPM_HT_PERMANENT:

294                 switch(handle)

295                 {

296                    //   At   this   point       hierarchy   availability           has   already  been  checked.

297                    case     TPM_RH_OWNER:

298                          if  (gp.ownerPolicy.t.size              !=     0)

299                              result       =     TRUE;

300                          break;

301

302                    case     TPM_RH_ENDORSEMENT:

303                          if  (gp.endorsementPolicy.t.size                   !=  0)

304                              result       =     TRUE;

305                          break;

306

307                    case     TPM_RH_PLATFORM:

308                          if  (gc.platformPolicy.t.size                  !=  0)

309                              result       =     TRUE;

310                          break;

311                    case     TPM_RH_LOCKOUT:

312                          if(gp.lockoutPolicy.t.size                 !=  0)

313                              result       =     TRUE;

314                          break;

315                    default:

316                          break;

317                 }

318                 break;

319           case     TPM_HT_TRANSIENT:

320                 {

321                    //   Object     handle.

322                    //   An   evict     object   would    already        have    been    loaded  and   given  a

323                    //   transient      object   handle      by   this       point.

324                    OBJECT    *object         =  ObjectGet(handle);

325                    //   Policy     authorization       is   not     available       for  an  object   with   only

326                    //   public     portion      loaded.

327                    if(object->attributes.publicOnly                     ==  CLEAR)

328                    {

329                          //  Policy    authorization        is      always      available    for  an  object    but

330                          //  is    never     available      for  a   sequence.

331                          if(!ObjectIsSequence(object))

332                              result       =     TRUE;

333                    }

334                    break;

     Page 48                                        TCG Published                                                Family "2.0"

     October 30, 2014                      Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                         Trusted Platform Module  Library

335                    }

336              case     TPM_HT_NV_INDEX:

337                    //  An   NV     Index.

338                    {

339                        NV_INDEX                         nvIndex;

340                        NvGetIndexInfo(handle,                  &nvIndex);

341                        //   If      the       policy    size   is  not  zero,      check      if      policy  can  be  used.

342                        if(nvIndex.publicArea.authPolicy.t.size                                !=  0)

343                        {

344                                 //     If     policy    session    is   required      for     this    handle,      always

345                                 //     uses      policy    regardless       of   the  attributes      bit      setting

346                                 if(IsPolicySessionRequired(commandCode,                               sessionIndex))

347                                           result     =  TRUE;

348                                 //     Otherwise,        the   presence      of  the      policy      depends  on  the     NV

349                                 //     attributes.

350                                 else       if(IsWriteOperation(commandCode))

351                                 {

352                                           if  (      nvIndex.publicArea.attributes.TPMA_NV_POLICYWRITE

353                                                  ==  SET)

354                                                  result    =  TRUE;

355                                 }

356                                 else

357                                 {

358                                           if  (         nvIndex.publicArea.attributes.TPMA_NV_POLICYREAD

359                                                  ==     SET)

360                                                  result    =  TRUE;

361                                 }

362                        }

363                    }

364                    break;

365              case     TPM_HT_PCR:

366                    //  PCR  handle.

367                    if(PCRPolicyIsAvailable(handle))

368                        result          =   TRUE;

369                    break;

370              default:

371                    break;

372        }

373        return  result;

374  }

     6.4.4       Session Parsing Functions

     6.4.4.1       ComputeCpHash()

     This function computes     the cpHash as defined              in  Part 2 and described in Part 1.

375  static   void

376  ComputeCpHash(

377        TPMI_ALG_HASH               hashAlg,                        //  IN:   hash     algorithm

378        TPM_CC                      commandCode,                    //  IN:   command      code

379        UINT32                      handleNum,                      //  IN:   number       of  handle

380        TPM_HANDLE                  handles[],                      //  IN:   array    of      handle

381        UINT32                      parmBufferSize,                 //  IN:   size     of  input       parameter    area

382        BYTE                     *parmBuffer,                       //  IN:   input    parameter       area

383        TPM2B_DIGEST             *cpHash,                           //  OUT:     cpHash

384        TPM2B_DIGEST             *nameHash                          //  OUT:     name  hash        of  command

385        )

386  {

387        UINT32                      i;

388        HASH_STATE                  hashState;

389        TPM2B_NAME                  name;

390

     Family "2.0"                                                 TCG Published                                                    Page 49

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                     October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting  Routines

391     //    cpHash        =     hash(commandCode                [  ||      authName1

392     //                                                        [  ||      authName2

393     //                                                        [  ||      authName   3  ]]]

394     //                                                        [  ||      parameters])

395     //    A     cpHash        can     contain       just      a  commandCode        only    if   the  lone  session  is

396     //    an     audit        session.

397

398     //    Start       cpHash.

399     cpHash->t.size                 =     CryptStartHash(hashAlg,                  &hashState);

400

401     //       Add    commandCode.

402     CryptUpdateDigestInt(&hashState,                                  sizeof(TPM_CC),        &commandCode);

403

404     //       Add    authNames               for     each  of     the     handles.

405     for(i        =  0;     i  <    handleNum;             i++)

406     {

407              name.t.size              =     EntityGetName(handles[i],                  &name.t.name);

408              CryptUpdateDigest2B(&hashState,                             &name.b);

409     }

410

411     //       Add    the       parameters.

412     CryptUpdateDigest(&hashState,                                parmBufferSize,         parmBuffer);

413

414     //       Complete         the        hash.

415     CryptCompleteHash2B(&hashState,                              &cpHash->b);

416

417     //    If     the    nameHash            is      needed,      compute      it  here.

418     if(nameHash               !=   NULL)

419     {

420              //     Start     name          hash.   hashState            may  be  reused.

421              nameHash->t.size                    =  CryptStartHash(hashAlg,                &hashState);

422

423              //     Adding         names.

424              for(i      =     0;   i     <  handleNum;           i++)

425              {

426                     name.t.size             =       EntityGetName(handles[i],               &name.t.name);

427                     CryptUpdateDigest2B(&hashState,                               &name.b);

428              }

429              //     Complete             hash.

430              CryptCompleteHash2B(&hashState,                             &nameHash->b);

431     }

432     return;

433  }

     6.4.4.2         CheckPWAuthSession()

     This function validates the authorization provided in a PWAP session.                                 It  compares the input value to

     authValue      of  the    authorized            entity.  Argument            sessionIndex   is  used  to   get  handles    handle  of  the

     referenced entities from s_inputAuthValues[] and s_associatedHandles[].

     Error Returns                                      Meaning

     TPM_RC_AUTH_FAIL                                   auth fails and increments DA failure count

     TPM_RC_BAD_AUTH                                    auth fails but DA does not apply

434  static   TPM_RC

435  CheckPWAuthSession(

436     UINT32                               sessionIndex            //      IN:  index    of   session    to   be   processed

437     )

438  {

439     TPM2B_AUTH                        authValue;

440     TPM_HANDLE                        associatedHandle                =  s_associatedHandles[sessionIndex];

441

     Page 50                                                         TCG Published                                              Family "2.0"

     October 30, 2014                                         Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                           Trusted Platform Module Library

442        //   Strip     trailing         zeros        from     the   password.

443        MemoryRemoveTrailingZeros(&s_inputAuthValues[sessionIndex]);

444

445        //   Get   the   auth       value         and    size.

446        authValue.t.size             =   EntityGetAuthValue(associatedHandle,                            &authValue.t.buffer);

447

448        //   Success     if     the     digests          are   identical.

449        if(Memory2BEqual(&s_inputAuthValues[sessionIndex].b,                                            &authValue.b))

450        {

451              return     TPM_RC_SUCCESS;

452        }

453        else                                         //  if    the     digests        are  not     identical

454        {

455              //   Invoke       DA   protection            if   applicable.

456              return     IncrementLockout(sessionIndex);

457        }

458  }

     6.4.4.3         ComputeCommandHMAC()

     This function computes the HMAC for an authorization session in a command.

459  static     void

460  ComputeCommandHMAC(

461        UINT32                       sessionIndex,                 //  IN:   index         of  session   to    be  processed

462        TPM2B_DIGEST                *cpHash,                       //  IN:   cpHash

463        TPM2B_DIGEST                *hmac                          //  OUT:       authorization          HMAC

464        )

465  {

466        TPM2B_TYPE(KEY,             (sizeof(AUTH_VALUE)                   *  2));

467        TPM2B_KEY                    key;

468        BYTE                         marshalBuffer[sizeof(TPMA_SESSION)];

469        BYTE                        *buffer;

470        UINT32                       marshalSize;

471        HMAC_STATE                   hmacState;

472        TPM2B_NONCE                 *nonceDecrypt;

473        TPM2B_NONCE                 *nonceEncrypt;

474        SESSION                     *session;

475        TPM_HT                       sessionHandleType                 =

476                                                     HandleGetType(s_sessionHandles[sessionIndex]);

477

478        nonceDecrypt         =   NULL;

479        nonceEncrypt         =   NULL;

480

481        //   Determine       if     extra         nonceTPM      values       are      going    to   be   required.

482        //   If   this   is     the     first        session       (sessionIndex           =   0)   and  it    is  an  authorization

483        //   session     that       uses       an    HMAC,     then    check      if  additional         session       nonces  are  to  be

484        //   included.

485        if(       sessionIndex           ==       0

486             &&   s_associatedHandles[sessionIndex]                               !=  TPM_RH_UNASSIGNED)

487        {

488              //   If   there       is   a     decrypt        session        and  if  this      is  not  the       decrypt  session,

489              //   then  an      extra         nonce     may    be     needed.

490              if(       s_decryptSessionIndex                      !=  UNDEFINED_INDEX

491                   &&   s_decryptSessionIndex                      !=  sessionIndex)

492              {

493                    //   Will       add     the      nonce     for     the   decrypt       session.

494                    SESSION         *decryptSession

495                                            =     SessionGet(s_sessionHandles[s_decryptSessionIndex]);

496                    nonceDecrypt               =     &decryptSession->nonceTPM;

497              }

498              //   Now   repeat         for       the    encrypt       session.

499              if(       s_encryptSessionIndex                      !=  UNDEFINED_INDEX

500                   &&   s_encryptSessionIndex                      !=  sessionIndex

     Family "2.0"                                                     TCG Published                                                    Page 51

     Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                                      Part 4: Supporting Routines

501                         &&   s_encryptSessionIndex                          !=   s_decryptSessionIndex)
           
502                 {
           
503                         //      Have     to     have        the   nonce         for     the   encrypt       session.
           
504                         SESSION          *encryptSession
           
505                                                    =     SessionGet(s_sessionHandles[s_encryptSessionIndex]);
           
506                         nonceEncrypt                  =     &encryptSession->nonceTPM;
           
507                 }
           
508        }
           
509        
           
510        //       Continue         with     the         HMAC       processing.
           
511        session          =    SessionGet(s_sessionHandles[sessionIndex]);
           
512        
           
513        //       Generate         HMAC     key.
           
514        MemoryCopy2B(&key.b,                           &session->sessionKey.b,                      sizeof(key.t.buffer));
           
515        
           
516        //       Check       if   the     session            has   an     associated           handle        and  if   the     associated     entity
           
517        //       is  the      one     to   which             the  session         is     bound.     If   not,     add  the      authValue     of
           
518        //       this    entity        to     the         HMAC    key.
           
519        //       If  the      session         is       bound      to    the      object        or   the  session       is   a   policy  session
           
520        //       with    no      authValue             required,          do     not     include    the      authValue         in  the  HMAC  key.
           
521        //       Note:       For   a   policy             session,        its     isBound          attribute      is   CLEARED.
           
522        
           
523        //       If  the      session         isn't          used     for     authorization,             then     there     is     no  auth  value
           
524        //       to  add
           
525        if(s_associatedHandles[sessionIndex]                                            !=     TPM_RH_UNASSIGNED)
           
526        {
           
527                 //      used     for     auth         so    see   if     this       is     a  policy    session       with     authValue     needed
           
528                 //      or   an   hmac       session             that    is     not     bound
           
529                 if(                      sessionHandleType                      ==     TPM_HT_POLICY_SESSION
           
530                                  &&      session->attributes.isAuthValueNeeded                                   ==   SET
           
531                         ||               sessionHandleType                      ==     TPM_HT_HMAC_SESSION
           
532                                  &&   !IsSessionBindEntity(s_associatedHandles[sessionIndex],                                                session)
           
533                     )
           
534                 {
           
535                         //      add   the       authValue            to     the     HMAC      key
           
536                         pAssert((sizeof(AUTH_VALUE)                                 +   key.t.size)         <=   sizeof(key.t.buffer));
           
537                         key.t.size              =           key.t.size
           
538                                                       +     EntityGetAuthValue(s_associatedHandles[sessionIndex],
           
539                                                                                        (AUTH_VALUE          *)&(key.t.buffer[key.t.size]));
           
540                 }
           
541        }
           
542        
           
543           //    if      the     HMAC     key       size     is    0,     a   NULL       string     HMAC     is   allowed
           
544           if(           key.t.size              ==       0
           
545                     &&  s_inputAuthValues[sessionIndex].t.size                                          ==  0)
           
546           {
           
547                     hmac->t.size             =     0;
           
548                     return;
           
549           }
           
550        
           
551        //       Start       HMAC
           
552        hmac->t.size               =   CryptStartHMAC2B(session->authHashAlg,                                     &key.b,          &hmacState);
           
553        
           
554        //       Add     cpHash
           
555        CryptUpdateDigest2B(&hmacState,                                      &cpHash->b);
           
556        
           
557        //       Add     nonceCaller
           
558        CryptUpdateDigest2B(&hmacState,                                      &s_nonceCaller[sessionIndex].b);
           
559        
           
560        //       Add     nonceTPM
           
561        CryptUpdateDigest2B(&hmacState,                                      &session->nonceTPM.b);
           
562        
           
563        //       If      needed,       add       nonceTPM          for       decrypt           session
           
564        if(nonceDecrypt                   !=     NULL)
           
565                 CryptUpdateDigest2B(&hmacState,                                     &nonceDecrypt->b);
           
566        

     Page 52                                                              TCG Published                                                    Family "2.0"

     October 30, 2014                                          Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
     Part  4: Supporting Routines                                                           Trusted Platform  Module  Library

567        //  If    needed,      add  nonceTPM    for     encrypt       session

568        if(nonceEncrypt        !=   NULL)

569            CryptUpdateDigest2B(&hmacState,                   &nonceEncrypt->b);

570

571        //  Add      sessionAttributes

572        buffer    =   marshalBuffer;

573        marshalSize       =  TPMA_SESSION_Marshal(&(s_attributes[sessionIndex]),

574                                                             &buffer,    NULL);

575        CryptUpdateDigest(&hmacState,                marshalSize,      marshalBuffer);

576

577        //  Complete      the  HMAC   computation

578        CryptCompleteHMAC2B(&hmacState,                 &hmac->b);

579

580        return;

581  }

     6.4.4.4       CheckSessio nHM AC()

     This  function  checks     the    HMAC   of   in  a   session.  It  uses  ComputeCommandHMAC()           to  compute  the

     expected HMAC value and then compares the result with the HMAC in the authorization session. The

     authorization is successful if they are the same.

     If the authorizations are not the same, IncrementLockout() is called. It will return TPM_RC_AUTH_FAIL if

     the failure caused the failureCount to increment. Otherwise, it will return TPM_RC_BAD_AUTH.

     Error Returns                           Meaning

     TPM_RC_AUTH_FAIL                        auth failure caused failureCount increment

     TPM_RC_BAD_AUTH                         auth failure did not cause failureCount increment

582  static    TPM_RC

583  CheckSessionHMAC(

584        UINT32                     sessionIndex,        //   IN:  index     of  session  to   be   processed

585        TPM2B_DIGEST           *cpHash                  //   IN:  cpHash    of  the   command

586        )

587  {

588        TPM2B_DIGEST                  hmac;                   //  authHMAC      for  comparing

589

590        //  Compute   authHMAC

591        ComputeCommandHMAC(sessionIndex,                cpHash,       &hmac);

592

593        //  Compare   the      input  HMAC     with     the  authHMAC    computed     above.

594        if(!Memory2BEqual(&s_inputAuthValues[sessionIndex].b,                            &hmac.b))

595        {

596            //    If  an     HMAC   session    has   a  failure,      invoke    the  anti-hammering

597            //    if  it     applies  to   the  authorized        entity    or  the   session.

598            //    Otherwise,        just  indicate      that  the     authorization      is  bad.

599            return    IncrementLockout(sessionIndex);

600        }

601        return    TPM_RC_SUCCESS;

602  }

     6.4.4.5       CheckPolicyAuthSession()

     This function is used to validate the authorization in a policy session. This function performs the following

     comparisons to see if a policy authorization is properly provided. The check are:

     a)    compare policyDigest in session with authPolicy associated with the entity to be authorized;

     b)    compare timeout if applicable;

     c)    compare commandCode if applicable;

     Family "2.0"                                          TCG Published                                          Page 53

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                             October 30, 2014
     Trusted Platform Module Library                                                                         Part 4: Supporting Routines

     d)  compare cpHash if applicable; and

     e)  see if PCR values have changed since computed.

     If  all  the  above     checks     succeed,         the  handle    is  authorized.    The  order    of  these  comparisons  is  not

     important because any failure will result in the same error code.

     Error Returns                                Meaning

     TPM_RC_PCR_CHANGED                           PCR value is not current

     TPM_RC_POLICY_FAIL                           policy session fails

     TPM_RC_LOCALITY                              command locality is not allowed

     TPM_RC_POLICY_CC                             CC doesn't match

     TPM_RC_EXPIRED                               policy session has expired

     TPM_RC_PP                                    PP is required but not asserted

     TPM_RC_NV_UNAVAILABLE                        NV is not available for write

     TPM_RC_NV_RATE                               NV is rate limiting

603  static        TPM_RC

604  CheckPolicyAuthSession(

605           UINT32                    sessionIndex,              //  IN:  index    of    session   to  be  processed

606           TPM_CC                    commandCode,               //  IN:  command      code

607           TPM2B_DIGEST            *cpHash,                     //  IN:  cpHash   using      the  algorithm      of  this

608                                                                //       session

609           TPM2B_DIGEST            *nameHash                    //  IN:  nameHash       using  the    session    algorithm

610           )

611  {

612           TPM_RC                    result        =  TPM_RC_SUCCESS;

613           SESSION                 *session;

614           TPM2B_DIGEST              authPolicy;

615           TPMI_ALG_HASH             policyAlg;

616           UINT8                     locality;

617

618           //   Initialize     pointer         to     the  auth     session.

619           session   =    SessionGet(s_sessionHandles[sessionIndex]);

620

621           //   If   the  command      is  TPM_RC_PolicySecret(),                 make  sure   that

622           //   either    password     or      authValue        is  required

623           if(       commandCode           ==  TPM_CC_PolicySecret

624                &&   session->attributes.isPasswordNeeded                         ==    CLEAR

625                &&   session->attributes.isAuthValueNeeded                        ==    CLEAR)

626                return       TPM_RC_MODE;

627

628           //   See  if   the  PCR     counter        for  the      session   is  still     valid.

629           if(  !SessionPCRValueIsCurrent(s_sessionHandles[sessionIndex])                                 )

630                return       TPM_RC_PCR_CHANGED;

631

632           //   Get  authPolicy.

633           policyAlg      =   EntityGetAuthPolicy(s_associatedHandles[sessionIndex],

634                                                                &authPolicy);

635           //   Compare      authPolicy.

636           if(!Memory2BEqual(&session->u2.policyDigest.b,                             &authPolicy.b))

637                return       TPM_RC_POLICY_FAIL;

638

639           //   Policy    is   OK  so  check          if   the  other    factors  are    correct

640

641           //   Compare      policy    hash    algorithm.

642           if(policyAlg        !=  session->authHashAlg)

643                return       TPM_RC_POLICY_FAIL;

644

645           //   Compare      timeout.

     Page 54                                                       TCG Published                                        Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                             Trusted Platform Module Library

646     if(session->timeOut                     !=    0)
        
647     {
        
648             //    Cannot          compare         time     if     clock     stop       advancing.      An   TPM_RC_NV_UNAVAILABLE
        
649             //    or    TPM_RC_NV_RATE                 error       may     be  returned         here.
        
650             result         =   NvIsAvailable();
        
651             if(result             !=   TPM_RC_SUCCESS)
        
652                     return         result;
        
653     
        
654             if(session->timeOut                   <     go.clock)
        
655                     return         TPM_RC_EXPIRED;
        
656     }
        
657     
        
658     //   If     command           code    is      provided         it   must       match
        
659     if(session->commandCode                       !=       0)
        
660     {
        
661             if(session->commandCode                           !=   commandCode)
        
662                     return         TPM_RC_POLICY_CC;
        
663     }
        
664     else
        
665     {
        
666             //    If    command           requires         a   DUP     or   ADMIN      authorization,       the  session    must   have
        
667             //    command          code     set.
        
668             AUTH_ROLE                 role     =  CommandAuthRole(commandCode,                         sessionIndex);
        
669             if(role           ==   AUTH_ADMIN           ||     role     ==     AUTH_DUP)
        
670                     return         TPM_RC_POLICY_FAIL;
        
671     }
        
672     //   Check         command         locality.
        
673     {
        
674             BYTE                       sessionLocality[sizeof(TPMA_LOCALITY)];
        
675             BYTE                      *buffer     =     sessionLocality;
        
676     
        
677             //    Get      existing         locality           setting         in  canonical     form
        
678             TPMA_LOCALITY_Marshal(&session->commandLocality,                                           &buffer,    NULL);
        
679     
        
680             //    See      if     the     locality         has     been     set
        
681             if(sessionLocality[0]                       !=     0)
        
682             {
        
683                     //     If     so,     get     the   current         locality
        
684                     locality           =  _plat__LocalityGet();
        
685                     if     (locality           <  5)
        
686                     {
        
687                               if(         ((sessionLocality[0]                     &   (1   <<   locality))  ==    0)
        
688                                       ||  sessionLocality[0]                   >   31)
        
689                                       return      TPM_RC_LOCALITY;
        
690                     }
        
691                     else       if     (locality         >     31)
        
692                     {
        
693                               if(sessionLocality[0]                     !=     locality)
        
694                                       return      TPM_RC_LOCALITY;
        
695                     }
        
696                     else
        
697                     {
        
698                               //   Could       throw       an     assert       here    but  a    locality   error  is  just
        
699                               //   as     good.   It       just     means      that,       whatever    the  locality   is,   it   isn't
        
700                               //   the    locality            requested        so...
        
701                               return      TPM_RC_LOCALITY;
        
702                     }
        
703             }
        
704     }   //     end     of     locality         check
        
705     
        
706     //   Check         physical           presence.
        
707     if(         session->attributes.isPPRequired                                   ==  SET
        
708          &&     !_plat__PhysicalPresenceAsserted())
        
709             return         TPM_RC_PP;
        
710     
        
711     //   Compare           cpHash/nameHash                 if     defined,         or  if   the  command    requires   an   ADMIN  or

     Family "2.0"                                                    TCG Published                                                  Page 55

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting      Routines

712     //    DUP  role  for   this      handle.

713     if(session->u1.cpHash.b.size                 !=  0)

714     {

715           if(session->attributes.iscpHashDefined)

716           {

717                 //   Compare      cpHash.

718                 if(!Memory2BEqual(&session->u1.cpHash.b,                     &cpHash->b))

719                      return       TPM_RC_POLICY_FAIL;

720           }

721           else

722           {

723                 //   Compare      nameHash.

724                 //   When  cpHash       is  not  defined,      nameHash      is  placed    in    its   space.

725                 if(!Memory2BEqual(&session->u1.cpHash.b,                     &nameHash->b))

726                      return       TPM_RC_POLICY_FAIL;

727           }

728     }

729     if(session->attributes.checkNvWritten)

730     {

731           NV_INDEX                nvIndex;

732

733           //   If   this   is  not   an     NV  index,   the   policy    makes    no  sense      so   fail  it.

734           if(HandleGetType(s_associatedHandles[sessionIndex])!=                            TPM_HT_NV_INDEX)

735                 return     TPM_RC_POLICY_FAIL;

736

737           //   Get   the   index     data

738           NvGetIndexInfo(s_associatedHandles[sessionIndex],                           &nvIndex);

739

740           //   Make  sure      that  the    TPMA_WRITTEN_ATTRIBUTE           has      the  desired     state

741           if(       (nvIndex.publicArea.attributes.TPMA_NV_WRITTEN                         ==  SET)

742                !=   (session->attributes.nvWrittenState                  ==  SET))

743                return     TPM_RC_POLICY_FAIL;

744     }

745

746     return     TPM_RC_SUCCESS;

747  }

     6.4.4.6       RetrieveSessionData()

     This function will unmarshal the sessions in the session area of a command. The values are placed                     in  the

     arrays that are defined at the beginning of this file. The normal unmarshaling errors are possible.

     Error Returns                       Meaning

     TPM_RC_SUCCSS                       unmarshaled without error

     TPM_RC_SIZE                         the number of bytes unmarshaled         is  not  the  same  as   the  value  for

                                         authorizationSize in the command

748  static   TPM_RC

749  RetrieveSessionData           (

750     TPM_CC                     commandCode,          //  IN:   command   code

751     UINT32                 *sessionCount,            //  OUT:  number    of      sessions      found

752     BYTE                   *sessionBuffer,           //  IN:   pointer   to      the  session    buffer

753     INT32                      bufferSize            //  IN:   size  of  the     session       buffer

754     )

755  {

756     int                sessionIndex;

757     int                i;

758     TPM_RC             result;

759     SESSION          *session;

760     TPM_HT             sessionType;

761

762     s_decryptSessionIndex            =   UNDEFINED_INDEX;

     Page 56                                             TCG Published                                                Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                             Trusted Platform Module Library

763  s_encryptSessionIndex                         =  UNDEFINED_INDEX;

764  s_auditSessionIndex                      =    UNDEFINED_INDEX;

765

766  for(sessionIndex                   =     0;   bufferSize       >   0;     sessionIndex++)

767  {

768     //         If   maximum            allowed      number      of     sessions        has     been  parsed,  return      a    size

769     //         error         with      a  session      number       that       is  larger      than      the  number  of  allowed

770     //         sessions

771     if(sessionIndex                       ==      MAX_SESSION_NUM)

772                return            TPM_RC_SIZE        +     TPM_RC_S         +   g_rcIndex[sessionIndex+1];

773

774     //         make       sure      that       the  associated          handle         for  each     session  starts      out

775     //         unassigned

776     s_associatedHandles[sessionIndex]                                      =   TPM_RH_UNASSIGNED;

777

778     //         First         parameter:           Session   handle.

779     result             =     TPMI_SH_AUTH_SESSION_Unmarshal(&s_sessionHandles[sessionIndex],

780                                                                                        &sessionBuffer,        &bufferSize,     TRUE);

781     if(result                !=     TPM_RC_SUCCESS)

782                return            result        +  TPM_RC_S      +   g_rcIndex[sessionIndex];

783

784     //         Second        parameter:             Nonce.

785     result             =     TPM2B_NONCE_Unmarshal(&s_nonceCaller[sessionIndex],

786                                                                     &sessionBuffer,                &bufferSize);

787     if(result                !=     TPM_RC_SUCCESS)

788                return            result        +  TPM_RC_S      +   g_rcIndex[sessionIndex];

789

790     //         Third         parameter:           sessionAttributes.

791     result             =     TPMA_SESSION_Unmarshal(&s_attributes[sessionIndex],

792                                                                        &sessionBuffer,             &bufferSize);

793     if(result                !=     TPM_RC_SUCCESS)

794                return            result        +  TPM_RC_S      +   g_rcIndex[sessionIndex];

795

796     //         Fourth        parameter:             authValue       (PW       or   HMAC).

797     result             =     TPM2B_AUTH_Unmarshal(&s_inputAuthValues[sessionIndex],

798                                                                    &sessionBuffer,             &bufferSize);

799     if(result                !=     TPM_RC_SUCCESS)

800                return            result        +  TPM_RC_S      +   g_rcIndex[sessionIndex];

801

802     if(s_sessionHandles[sessionIndex]                                      ==     TPM_RS_PW)

803     {

804                //      A     PWAP      session      needs   additional             processing.

805                //                Can't        have  any    attributes             set  other       than  continueSession       bit

806                if(           s_attributes[sessionIndex].encrypt

807                        ||    s_attributes[sessionIndex].decrypt

808                        ||    s_attributes[sessionIndex].audit

809                        ||    s_attributes[sessionIndex].auditExclusive

810                        ||    s_attributes[sessionIndex].auditReset

811                     )

812                           return          TPM_RC_ATTRIBUTES             +     TPM_RC_S      +  g_rcIndex[sessionIndex];

813

814                //                The      nonce     size   must     be     zero.

815                if(s_nonceCaller[sessionIndex].t.size                                   !=      0)

816                           return          TPM_RC_NONCE      +      TPM_RC_S        +   g_rcIndex[sessionIndex];

817

818                continue;

819     }

820     //         For     not       password         sessions...

821

822     //         Find       out    if       the     session   is     loaded.

823     if(!SessionIsLoaded(s_sessionHandles[sessionIndex]))

824                return            TPM_RC_REFERENCE_S0                +   sessionIndex;

825

826     sessionType                  =     HandleGetType(s_sessionHandles[sessionIndex]);

827     session               =  SessionGet(s_sessionHandles[sessionIndex]);

828     //         Check         if  the      session      is   an     HMAC/policy         session.

     Family "2.0"                                               TCG Published                                                            Page 57

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted  Platform Module Library                                                                               Part 4: Supporting Routines

829           if(         (         session->attributes.isPolicy                       ==    SET

830                          &&     sessionType     ==      TPM_HT_HMAC_SESSION

831                       )

832                  ||   (         session->attributes.isPolicy                       ==    CLEAR

833                          &&     sessionType         ==     TPM_HT_POLICY_SESSION

834                       )

835               )

836                  return         TPM_RC_HANDLE           +     TPM_RC_S         +   g_rcIndex[sessionIndex];

837

838           //     Check       that     this  handle         has       not     previously           been   used.

839           for(i       =     0;  i  <   sessionIndex;              i++)

840           {

841                  if(s_sessionHandles[i]                       ==     s_sessionHandles[sessionIndex])

842                             return     TPM_RC_HANDLE              +   TPM_RC_S       +   g_rcIndex[sessionIndex];

843           }

844

845           //     If   the       session     is  used       for       parameter       encryption          or  audit    as  well,  set

846           //     the     corresponding          indices.

847

848           //     First       process     decrypt.

849           if(s_attributes[sessionIndex].decrypt)

850           {

851                  //      Check     if  the      commandCode            allows      command          parameter   encryption.

852                  if(DecryptSize(commandCode)                           ==    0)

853                             return     TPM_RC_ATTRIBUTES                  +  TPM_RC_S          +  g_rcIndex[sessionIndex];

854

855                  //      Encrypt       attribute        can       only       appear     in     one  session

856                  if(s_decryptSessionIndex                         !=   UNDEFINED_INDEX)

857                             return     TPM_RC_ATTRIBUTES                  +  TPM_RC_S          +  g_rcIndex[sessionIndex];

858

859                  //      Can't     decrypt      if  the        session's           symmetric        algorithm     is  TPM_ALG_NULL

860                  if(session->symmetric.algorithm                               ==  TPM_ALG_NULL)

861                             return     TPM_RC_SYMMETRIC                +     TPM_RC_S       +     g_rcIndex[sessionIndex];

862

863                  //      All    checks      passed,        so     set     the     index     for     the  session    used  to  decrypt

864                  //      a   command     parameter.

865                  s_decryptSessionIndex                     =   sessionIndex;

866           }

867

868           //     Now     process       encrypt.

869           if(s_attributes[sessionIndex].encrypt)

870           {

871                  //      Check     if  the      commandCode            allows      response         parameter     encryption.

872                  if(EncryptSize(commandCode)                           ==    0)

873                             return     TPM_RC_ATTRIBUTES                  +  TPM_RC_S          +  g_rcIndex[sessionIndex];

874

875                  //      Encrypt       attribute        can       only       appear     in     one  session.

876                  if(s_encryptSessionIndex                         !=   UNDEFINED_INDEX)

877                             return     TPM_RC_ATTRIBUTES                  +  TPM_RC_S          +  g_rcIndex[sessionIndex];

878

879                  //      Can't     encrypt      if  the        session's           symmetric        algorithm     is  TPM_ALG_NULL

880                  if(session->symmetric.algorithm                               ==  TPM_ALG_NULL)

881                             return     TPM_RC_SYMMETRIC                +     TPM_RC_S       +     g_rcIndex[sessionIndex];

882

883                  //      All    checks      passed,        so     set     the     index     for     the  session    used  to  encrypt

884                  //      a   response       parameter.

885                  s_encryptSessionIndex                     =   sessionIndex;

886           }

887

888           //     At   last      process     audit.

889           if(s_attributes[sessionIndex].audit)

890           {

891                  //      Audit     attribute        can       only     appear      in    one      session.

892                  if(s_auditSessionIndex                       !=     UNDEFINED_INDEX)

893                             return     TPM_RC_ATTRIBUTES                  +  TPM_RC_S          +  g_rcIndex[sessionIndex];

894

     Page 58                                                       TCG Published                                                     Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                           Trusted Platform Module      Library

895                      //     An   audit       session       can     not  be        policy    session.

896                      if(         HandleGetType(s_sessionHandles[sessionIndex])

897                             ==   TPM_HT_POLICY_SESSION)

898                              return       TPM_RC_ATTRIBUTES                 +     TPM_RC_S    +   g_rcIndex[sessionIndex];

899

900                      //     If   this     is   a  reset        of  the      audit      session,    or   the   first  use

901                      //     of   the     session       as     an   audit       session,      it   doesn't    matter  what

902                      //     the     exclusive       state         is.   The       session    will  become     exclusive.

903                      if(         s_attributes[sessionIndex].auditReset                             ==   CLEAR

904                             &&   session->attributes.isAudit                           ==  SET)

905                      {

906                              //     Not   first     use       or   reset.         If   auditExlusive    is    SET,   then   this

907                              //     session       must     be     the   current        exclusive   session.

908                              if(         s_attributes[sessionIndex].auditExclusive                               ==  SET

909                                     &&   g_exclusiveAuditSession                       !=  s_sessionHandles[sessionIndex])

910                                     return     TPM_RC_EXCLUSIVE;

911                      }

912

913                      s_auditSessionIndex                   =   sessionIndex;

914              }

915

916              //  Initialize              associated           handle    as        undefined.      This  will     be  changed   when

917              //  the        handles       are     processed.

918              s_associatedHandles[sessionIndex]                                 =  TPM_RH_UNASSIGNED;

919

920        }

921

922        //  Set   the        number       of   sessions         found.

923        *sessionCount             =  sessionIndex;

924        return    TPM_RC_SUCCESS;

925  }

     6.4.4.7         CheckLockedOut()

     This function checks to see if the TPM is in lockout. This function should only be called if the entity being

     checked is subject to DA protection. The TPM is in lockout if the NV is not available and a DA write is

     pending. Otherwise the TPM is locked out if checking for lockoutAuth (lockoutAuthCheck == TRUE) and

     use of lockoutAuth is disabled, or failedTries >= maxTries

     Error Returns                                 Meaning

     TPM_RC_NV_RATE                                NV is rate limiting

     TPM_RC_NV_UNAVAILABLE                         NV is not available at this time

     TPM_RC_LOCKOUT                                TPM is in lockout

926  static    TPM_RC

927  CheckLockedOut(

928        BOOL                             lockoutAuthCheck                //        IN:  TRUE   if   checking      is  for  lockoutAuth

929        )

930  {

931        TPM_RC                result;

932

933        //  If    NV     is   unavailable,           and       current       cycle      state     recorded    in  NV  is   not

934        //  SHUTDOWN_NONE,                refuse     to     check       any     authorization       because       we  would

935        //  not   be      able       to   handle     a   DA     failure.

936        result    =      NvIsAvailable();

937        if(result         !=     TPM_RC_SUCCESS             &&     gp.orderlyState            !=   SHUTDOWN_NONE)

938              return         result;

939

940        //  Check        if   DA     info     needs     to     be   updated        in   NV.

941        if(s_DAPendingOnNV)

942        {

     Family "2.0"                                                      TCG Published                                                     Page 59

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting    Routines

943           //  If    NV  is   accessible,     ...

944           if(result      ==  TPM_RC_SUCCESS)

945           {

946                 //  ...     write  the      pending  DA  data      and  proceed.

947                 NvWriteReserved(NV_LOCKOUT_AUTH_ENABLED,

948                                          &gp.lockOutAuthEnabled);

949                 NvWriteReserved(NV_FAILED_TRIES,                   &gp.failedTries);

950                 g_updateNV   =     TRUE;

951                 s_DAPendingOnNV          =   FALSE;

952           }

953           else

954           {

955                 //  Otherwise      no    authorization        can  be   checked.

956                 return      result;

957           }

958     }

959

960     //    Lockout   is   in  effect      if  checking    for   lockoutAuth         and    use  of    lockoutAuth

961     //    is  disabled...

962     if(lockoutAuthCheck)

963     {

964           if(gp.lockOutAuthEnabled           ==      FALSE)

965                 return      TPM_RC_LOCKOUT;

966     }

967     else

968     {

969           //  ...   or   if  the   number    of   failed      tries     has  been     maxed    out.

970           if(gp.failedTries          >=     gp.maxTries)

971                 return      TPM_RC_LOCKOUT;

972     }

973     return    TPM_RC_SUCCESS;

974  }

     6.4.4.8      CheckAuthSession()

     This function checks that the authorization session properly authorizes the use of the associated                   handle.

     Error Returns                       Meaning

     TPM_RC_LOCKOUT                      entity is protected by DA and TPM is in lockout, or TPM is locked out

                                         on NV update pending on DA parameters

     TPM_RC_PP                           Physical Presence is required but not provided

     TPM_RC_AUTH_FAIL                    HMAC    or  PW      authorization  failed  with  DA  side-effects  (can  be  a

                                         policy session)

     TPM_RC_BAD_AUTH                     HMAC or PW authorization failed without DA side-effects (can be a

                                         policy session)

     TPM_RC_POLICY_FAIL                  if policy session fails

     TPM_RC_POLICY_CC                    command code of policy was wrong

     TPM_RC_EXPIRED                      the policy session has expired

     TPM_RC_PCR                          ???

     TPM_RC_AUTH_UNAVAILABLE             authValue or authPolicy unavailable

975  static   TPM_RC

976  CheckAuthSession(

977     TPM_CC                   commandCode,            //  IN:  commandCode

978     UINT32                   sessionIndex,           //  IN:  index     of   session      to   be  processed

979     TPM2B_DIGEST             *cpHash,                //  IN:  cpHash

980     TPM2B_DIGEST             *nameHash               //  IN:  nameHash

     Page 60                                             TCG Published                                            Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                             Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                          Trusted Platform Module Library

981      )

982   {

983      TPM_RC                        result;

984      SESSION                      *session         =   NULL;

985      TPM_HANDLE                    sessionHandle           =   s_sessionHandles[sessionIndex];

986      TPM_HANDLE                    associatedHandle                =     s_associatedHandles[sessionIndex];

987      TPM_HT                        sessionHandleType                  =   HandleGetType(sessionHandle);

988

989      pAssert(sessionHandle                    !=   TPM_RH_UNASSIGNED);

990

991      if(sessionHandle              !=     TPM_RS_PW)

992           session        =  SessionGet(sessionHandle);

993

994      pAssert(sessionHandleType                        !=  TPM_HT_POLICY_SESSION                ||  session     !=  NULL);

995

996      //   If  the     authorization               session      is     not   a   policy    session,     or  if  the    policy

997      //   session     requires            authorization,              then     check    lockout.

998      if(         sessionHandleType                 !=     TPM_HT_POLICY_SESSION

999           ||  session->attributes.isAuthValueNeeded

1000          ||  session->attributes.isPasswordNeeded)

1001     {

1002          //     See  if    entity         is     subject      to     lockout.

1003          if(!IsDAExempted(associatedHandle))

1004          {

1005                 //   If    NV     is     unavailable,         and        current       cycle  state   recorded     in  NV   is  not

1006                 //   SHUTDOWN_NONE,                  refuse   to        check     any  authorization      because      we   would

1007                 //   not      be     able     to     handle   a      DA   failure.

1008                 result        =   CheckLockedOut(associatedHandle                        ==    TPM_RH_LOCKOUT);

1009                 if(result            !=   TPM_RC_SUCCESS)

1010                         return        result;

1011          }

1012     }

1013

1014     if(associatedHandle                  ==   TPM_RH_PLATFORM)

1015     {

1016          //     If   the   physical           presence        is     required     for    this     command,    check    for  PP

1017          //     assertion.           If   it     isn't   asserted,            no  point  going    any     further.

1018          if(         PhysicalPresenceIsRequired(commandCode)

1019                 &&   !_plat__PhysicalPresenceAsserted()

1020              )

1021                 return        TPM_RC_PP;

1022     }

1023     //   If  a  policy        session         is     required,          make   sure    that   it  is  being   used.

1024     if(      IsPolicySessionRequired(commandCode,                                 sessionIndex)

1025          &&  sessionHandleType                   !=   TPM_HT_POLICY_SESSION)

1026          return      TPM_RC_AUTH_TYPE;

1027

1028     //   If  this    is    a     PW   authorization,              check       it  and  return.

1029     if(sessionHandle              ==     TPM_RS_PW)

1030     {

1031          if(IsAuthValueAvailable(associatedHandle,                                     commandCode,       sessionIndex))

1032                 return        CheckPWAuthSession(sessionIndex);

1033          else

1034                 return        TPM_RC_AUTH_UNAVAILABLE;

1035     }

1036     //   If  this    is    a     policy       session,        ...

1037     if(sessionHandleType                  ==     TPM_HT_POLICY_SESSION)

1038     {

1039          //     ...  see      if     the     entity      has  a      policy,      ...

1040          if(    !IsAuthPolicyAvailable(associatedHandle,                                 commandCode,         sessionIndex))

1041                 return        TPM_RC_AUTH_UNAVAILABLE;

1042          //     ...  and      check       the     policy      session.

1043          result      =     CheckPolicyAuthSession(sessionIndex,                               commandCode,

1044                                                                         cpHash,   nameHash);

1045          if     (result       !=     TPM_RC_SUCCESS)

1046                 return        result;

      Family "2.0"                                                 TCG Published                                                     Page 61

      Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                                            Part 4: Supporting Routines

1047     }

1048     else

1049     {

1050           //   For    non     policy,      the     entity        being  accessed         must   allow       authorization

1051           //   with   an      auth       value.    This      is    required      even    if     the  auth     value       is    not

1052           //   going      to     be  used      in  an      HMAC    because   it     is   bound.

1053           if(!IsAuthValueAvailable(associatedHandle,                                 commandCode,           sessionIndex))

1054                 return        TPM_RC_AUTH_UNAVAILABLE;

1055     }

1056     //    At   this   point,         the  session          must    be  either    a   policy     or      an  HMAC      session.

1057     session     =    SessionGet(s_sessionHandles[sessionIndex]);

1058

1059     if(         sessionHandleType                  ==  TPM_HT_POLICY_SESSION

1060           &&    session->attributes.isPasswordNeeded                             ==     SET)

1061     {

1062           //   For    policy         session       that    requires     a    password,          check   it    as      PWAP    session.

1063           return      CheckPWAuthSession(sessionIndex);

1064     }

1065     else

1066     {

1067           //   For    other      policy        or  HMAC      sessions,       have    its     HMAC    checked.

1068           return      CheckSessionHMAC(sessionIndex,                         cpHash);

1069     }

1070  }

1071  #ifdef   TPM_CC_GetCommandAuditDigest

      6.4.4.9       CheckCommandAudit()

      This function checks if the current command may trigger                       command          audit,  and   if  it  is  safe  to   perform  the

      action.

      Error Returns                            Meaning

      TPM_RC_NV_UNAVAILABLE                    NV is not available for write

      TPM_RC_NV_RATE                           NV is rate limiting

1072  static   TPM_RC

1073  CheckCommandAudit(

1074     TPM_CC                       commandCode,                      //   IN:  Command         code

1075     UINT32                       handleNum,                        //   IN:  number         of  element       in      handle      array

1076     TPM_HANDLE                   handles[],                        //   IN:  array       of     handle

1077     BYTE                         *parmBufferStart,                 //   IN:  start       of     parameter     buffer

1078     UINT32                       parmBufferSize                    //   IN:  size       of   parameter        buffer

1079     )

1080  {

1081     TPM_RC            result         =    TPM_RC_SUCCESS;

1082

1083     //    If   audit  is      implemented,             need    to  check     to  see     if     auditing      is      being     done

1084     //    for  this   command.

1085     if(CommandAuditIsRequired(commandCode))

1086     {

1087           //   If    the   audit         digest    is      clear   and  command         audit   is      required,         NV    must  be

1088           //   available         so      that  TPM2_GetCommandAuditDigest()                     is      able  to      increment

1089           //   audit      counter.        If   NV      is  not     available,       the     function        bails     out     to  prevent

1090           //   the    TPM     from       attempting        an    operation       that    would       fail   anyway.

1091           if(         gr.commandAuditDigest.t.size                      ==   0

1092                ||    commandCode          ==   TPM_CC_GetCommandAuditDigest)

1093           {

1094                 result        =  NvIsAvailable();

1095                 if(result            !=   TPM_RC_SUCCESS)

1096                       return         result;

1097           }

1098           ComputeCpHash(gp.auditHashAlg,                           commandCode,         handleNum,

      Page 62                                                     TCG Published                                                        Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                          Trusted Platform Module Library

1099                                          handles,     parmBufferSize,          parmBufferStart,

1100                                          &s_cpHashForCommandAudit,                NULL);

1101     }

1102

1103     return       TPM_RC_SUCCESS;

1104  }

1105  #endif

      6.4.4.10     ParseSessionBuffer()

      This function is the entry function for command session processing. It iterates sessions in session area

      and reports if the required authorization has been properly provided. It also processes audit session and

      passes the information of encryption sessions to parameter encryption module.

      Error Returns                                 Meaning

      various                                       parsing failure or authorization failure

1106  TPM_RC

1107  ParseSessionBuffer(

1108     TPM_CC                               commandCode,                     //   IN:     Command     code

1109     UINT32                               handleNum,                       //   IN:     number     of  element      in  handle  array

1110     TPM_HANDLE                           handles[],                       //   IN:     array   of     handle

1111     BYTE                             *sessionBufferStart,                 //   IN:     start   of     session  buffer

1112     UINT32                               sessionBufferSize,               //   IN:     size   of   session     buffer

1113     BYTE                             *parmBufferStart,                    //   IN:     start   of     parameter    buffer

1114     UINT32                               parmBufferSize                   //   IN:     size   of   parameter       buffer

1115     )

1116  {

1117     TPM_RC                               result;

1118     UINT32                               i;

1119     INT32                                size  =  0;

1120     TPM2B_AUTH                           extraKey;

1121     UINT32                               sessionIndex;

1122     SESSION                          *session;

1123     TPM2B_DIGEST                         cpHash;

1124     TPM2B_DIGEST                         nameHash;

1125     TPM_ALG_ID                           cpHashAlg    =     TPM_ALG_NULL;         //   algID   for    the    last  computed

1126                                                                                   //   cpHash

1127

1128     //     Check    if      a     command      allows       any  session   in     its  session        area.

1129     if(!IsSessionAllowed(commandCode))

1130            return       TPM_RC_AUTH_CONTEXT;

1131

1132     //     Default-initialization.

1133     s_sessionNum               =     0;

1134     cpHash.t.size                 =  0;

1135

1136     result       =  RetrieveSessionData(commandCode,                          &s_sessionNum,

1137                                                             sessionBufferStart,          sessionBufferSize);

1138     if(result           !=     TPM_RC_SUCCESS)

1139            return       result;

1140

1141     //     There    is      no       command      in  the   TPM  spec  that       has  more    handles       than

1142     //     MAX_SESSION_NUM.

1143     pAssert(handleNum                    <=    MAX_SESSION_NUM);

1144

1145     //     Associate           the       session      with  an   authorization         handle.

1146     for(i     =     0;  i      <     handleNum;       i++)

1147     {

1148            if(CommandAuthRole(commandCode,                       i)    !=     AUTH_NONE)

1149            {

1150                     //  If        the    received     session    number       is  less    than     the    number   of  handle

1151                     //  that         requires         authorization,      an   error     should       be  returned.

      Family "2.0"                                                    TCG Published                                                 Page 63

      Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                        October 30, 2014
      Trusted Platform Module Library                                                                                       Part 4: Supporting Routines

1152                     //   Note:        for     all       the   TPM     2.0    commands,              handles      requiring
          
1153                     //   authorization                  come     first       in   a   command          input.
          
1154                     if(i     >  (s_sessionNum                 -  1))
          
1155                             return       TPM_RC_AUTH_MISSING;
          
1156      
          
1157                     //   Record          the     handle       associated             with    the       authorization           session
          
1158                     s_associatedHandles[i]                       =    handles[i];
          
1159               }
          
1160      }
          
1161      
          
1162      //       Consistency       checks           are    done     first       to      avoid       auth      failure    when      the    command
          
1163      //       will  not     be  executed               anyway.
          
1164      for(sessionIndex                 =  0;      sessionIndex             <  s_sessionNum;                 sessionIndex++)
          
1165      {
          
1166               //    PW  session          must       be  an    authorization                 session
          
1167               if(s_sessionHandles[sessionIndex]                                  ==   TPM_RS_PW            )
          
1168               {
          
1169                     if(s_associatedHandles[sessionIndex]                                     ==     TPM_RH_UNASSIGNED)
          
1170                             return       TPM_RC_HANDLE                +   g_rcIndex[sessionIndex];
          
1171               }
          
1172               else
          
1173               {
          
1174                     session        =     SessionGet(s_sessionHandles[sessionIndex]);
          
1175      
          
1176                     //   A   trial       session        can      not      appear         in  session          area,   because          it  cannot
          
1177                     //   be     used     for        authorization,               audit       or     encrypt/decrypt.
          
1178                     if(session->attributes.isTrialPolicy                                     ==     SET)
          
1179                             return       TPM_RC_ATTRIBUTES                   +    TPM_RC_S          +   g_rcIndex[sessionIndex];
          
1180      
          
1181                     //   See    if       the     session         is   bound       to     a   DA     protected         entity
          
1182                     //   NOTE:        Since         a   policy       session         is     never      bound,      a  policy       is  still
          
1183                     //   usable          even       if  the      object      is      DA     protected         and     the  TPM     is  in
          
1184                     //   lockout.
          
1185                     if(session->attributes.isDaBound                                  ==     SET)
          
1186                     {
          
1187                             result       =    CheckLockedOut(session->attributes.isLockoutBound                                            ==  SET);
          
1188                             if(result            !=     TPM_RC_SUCCESS)
          
1189                                    return           result;
          
1190                     }
          
1191                     //   If     the      current        cpHash        is     the     right       one,      don't      re-compute.
          
1192                     if(cpHashAlg              !=       session->authHashAlg)                        //     different       so   compute
          
1193                     {
          
1194                             cpHashAlg            =     session->authHashAlg;                        //     save    this    new     algID
          
1195                             ComputeCpHash(session->authHashAlg,                                     commandCode,           handleNum,
          
1196                                                         handles,          parmBufferSize,                  parmBufferStart,
          
1197                                                         &cpHash,          &nameHash);
          
1198                     }
          
1199                     //   If     this     session        is       for     auditing,           save      the    cpHash.
          
1200                     if(s_attributes[sessionIndex].audit)
          
1201                             s_cpHashForAudit                  =  cpHash;
          
1202               }
          
1203      
          
1204               //    if  the     session          has    an    associated             handle,        check     the     auth
          
1205               if(s_associatedHandles[sessionIndex]                                    !=     TPM_RH_UNASSIGNED)
          
1206               {
          
1207                     result      =     CheckAuthSession(commandCode,                                 sessionIndex,
          
1208                                                                          &cpHash,           &nameHash);
          
1209                     if(result            !=   TPM_RC_SUCCESS)
          
1210                             return       RcSafeAddToResult(result,
          
1211                                                                              TPM_RC_S            +  g_rcIndex[sessionIndex]);
          
1212               }
          
1213               else
          
1214               {
          
1215                     //   a   session          that      is    not     for    authorization                 must    either      be  encrypt,
          
1216                     //   decrypt,            or     audit
          
1217                     if(            s_attributes[sessionIndex].audit                                    ==     CLEAR

      Page 64                                                         TCG Published                                                         Family "2.0"

      October 30, 2014                                   Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                          Trusted Platform Module Library

1218                              &&      s_attributes[sessionIndex].encrypt                      ==     CLEAR

1219                              &&      s_attributes[sessionIndex].decrypt                      ==     CLEAR)

1220                              return      TPM_RC_ATTRIBUTES             +  TPM_RC_S        +  g_rcIndex[sessionIndex];

1221

1222                      //   check      HMAC     for  encrypt/decrypt/audit                  only    sessions

1223                      result       =      CheckSessionHMAC(sessionIndex,                      &cpHash);

1224                      if(result           !=  TPM_RC_SUCCESS)

1225                              return      RcSafeAddToResult(result,

1226                                                                        TPM_RC_S        +  g_rcIndex[sessionIndex]);

1227            }

1228     }

1229

1230  #ifdef    TPM_CC_GetCommandAuditDigest

1231     //     Check      if     the     command  should         be  audited.

1232     result        =   CheckCommandAudit(commandCode,                          handleNum,     handles,

1233                                                        parmBufferStart,             parmBufferSize);

1234     if(result            !=  TPM_RC_SUCCESS)

1235            return         result;                            //    No     session      number     to  reference

1236  #endif

1237

1238     //     Decrypt        the     first      parameter       if  applicable.           This  should        be   the  last  operation

1239     //     in  session           processing.

1240     //     If  the       encrypt         session   is  associated             with  a     handle    and    the   handle's

1241     //     authValue         is      available,        then  authValue        is    concatenated           with  sessionAuth  to

1242     //     generate          encryption       key,     no    matter       if  the   handle      is    the  session   bound  entity

1243     //     or  not.

1244     if(s_decryptSessionIndex                       !=  UNDEFINED_INDEX)

1245     {

1246            //     Get     size       of  the  leading        size  field      in    decrypt       parameter

1247            if(           s_associatedHandles[s_decryptSessionIndex]                               !=  TPM_RH_UNASSIGNED

1248                   &&     IsAuthValueAvailable(s_associatedHandles[s_decryptSessionIndex],

1249                                                              commandCode,

1250                                                              s_decryptSessionIndex)

1251                )

1252            {

1253                      extraKey.b.size=

1254                              EntityGetAuthValue(s_associatedHandles[s_decryptSessionIndex],

1255                                                              &extraKey.t.buffer);

1256            }

1257            else

1258            {

1259                      extraKey.b.size          =    0;

1260            }

1261            size       =   DecryptSize(commandCode);

1262            result         =  CryptParameterDecryption(

1263                                      s_sessionHandles[s_decryptSessionIndex],

1264                                      &s_nonceCaller[s_decryptSessionIndex].b,

1265                                      parmBufferSize,             (UINT16)size,

1266                                      &extraKey,

1267                                      parmBufferStart);

1268            if(result             !=  TPM_RC_SUCCESS)

1269                      return       RcSafeAddToResult(result,

1270                                                                  TPM_RC_S     +     g_rcIndex[s_decryptSessionIndex]);

1271     }

1272

1273     return        TPM_RC_SUCCESS;

1274  }

      6.4.4.11      CheckAuthNoSession()

      Function to process a command with no session associated. The function makes sure all the handles in

      the command require no authorization.

      Family "2.0"                                                TCG Published                                                    Page 65

      Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                         October 30, 2014
      Trusted Platform Module Library                                                                       Part 4: Supporting Routines

      Error Returns                             Meaning

      TPM_RC_AUTH_MISSING                       failure - one or more handles require auth

1275  TPM_RC

1276  CheckAuthNoSession(

1277     TPM_CC                            commandCode,                //  IN:   Command     Code

1278     UINT32                            handleNum,                  //  IN:   number     of  handles     in  command

1279     TPM_HANDLE                        handles[],                  //  IN:   array   of     handle

1280     BYTE                          *parmBufferStart,               //  IN:   start   of     parameter   buffer

1281     UINT32                            parmBufferSize              //  IN:   size   of   parameter      buffer

1282     )

1283  {

1284     UINT32        i;

1285     TPM_RC                            result  =     TPM_RC_SUCCESS;

1286

1287     //    Check       if     the  commandCode       requires      authorization

1288     for(i      =     0;   i  <    handleNum;        i++)

1289     {

1290           if(CommandAuthRole(commandCode,                         i)  !=   AUTH_NONE)

1291                      return       TPM_RC_AUTH_MISSING;

1292     }

1293

1294  #ifdef   TPM_CC_GetCommandAuditDigest

1295     //    Check       if     the  command     should      be  audited.

1296     result        =   CheckCommandAudit(commandCode,                     handleNum,     handles,

1297                                                     parmBufferStart,        parmBufferSize);

1298     if(result            !=  TPM_RC_SUCCESS)        return        result;

1299  #endif

1300

1301     //    Initialize             number   of  sessions        to  be  0

1302     s_sessionNum             =    0;

1303

1304     return        TPM_RC_SUCCESS;

1305  }

      6.4.5    Response Session Processing

      6.4.5.1       Introduction

      The following functions build the session area in a response, and handle the audit sessions (if present).

      6.4.5.2       ComputeRpHash()

      Function to compute rpHash (Response Parameter Hash). The rpHash is only computed if there                               is  an

      HMAC authorization session and the return code is TPM_RC_SUCCESS.

1306  static   void

1307  ComputeRpHash(

1308     TPM_ALG_ID                        hashAlg,                    //  IN:   hash   algorithm       to  compute    rpHash

1309     TPM_CC                            commandCode,                //  IN:   commandCode

1310     UINT32                            resParmBufferSize,          //  IN:   size   of   response       parameter  buffer

1311     BYTE                          *resParmBuffer,                 //  IN:   response       parameter   buffer

1312     TPM2B_DIGEST                  *rpHash                         //  OUT:  rpHash

1313     )

1314  {

1315     //    The     command         result  in     rpHash   is      always   TPM_RC_SUCCESS.

1316     TPM_RC                   responseCode        =  TPM_RC_SUCCESS;

1317     HASH_STATE               hashState;

1318

1319     //     rpHash            :=   hash(responseCode           ||  commandCode      ||   parameters)

      Page 66                                                  TCG Published                                             Family "2.0"

      October 30, 2014                                   Copyright © TCG 2006-2014                          Level 00 Revision 01.16
      Part 4: Supporting Routines                                                              Trusted Platform Module Library

1320

1321     //    Initiate       hash  creation.

1322     rpHash->t.size         =   CryptStartHash(hashAlg,                &hashState);

1323

1324     //    Add   hash     constituents.

1325     CryptUpdateDigestInt(&hashState,                    sizeof(TPM_RC),         &responseCode);

1326     CryptUpdateDigestInt(&hashState,                    sizeof(TPM_CC),         &commandCode);

1327     CryptUpdateDigest(&hashState,                  resParmBufferSize,           resParmBuffer);

1328

1329     //    Complete       hash  computation.

1330     CryptCompleteHash2B(&hashState,                     &rpHash->b);

1331

1332     return;

1333  }

      6.4.5.3       InitAuditSession()

      This function initializes the audit data in an audit session.

1334  static   void

1335  InitAuditSession(

1336     SESSION                    *session                 //  session    to  be   initialized

1337     )

1338  {

1339     //    Mark   session       as  an  audit    session.

1340     session->attributes.isAudit                 =  SET;

1341

1342     //    Audit  session       can     not  be  bound.

1343     session->attributes.isBound                 =  CLEAR;

1344

1345     //    Size   of   the  audit       log  is  the     size  of  session      hash  algorithm     digest.

1346     session->u2.auditDigest.t.size                   =  CryptGetHashDigestSize(session->authHashAlg);

1347

1348     //    Set   the   original      digest      value   to    be  0.

1349     MemorySet(&session->u2.auditDigest.t.buffer,

1350                      0,

1351                      session->u2.auditDigest.t.size);

1352

1353     return;

1354  }

      6.4.5.4       Audit()

      This function updates the audit digest in an audit session.

1355  static   void

1356  Audit(

1357     SESSION                    *auditSession,                 //  IN:  loaded      audit  session

1358     TPM_CC                     commandCode,                   //  IN:  commandCode

1359     UINT32                     resParmBufferSize,             //  IN:  size    of  response  parameter      buffer

1360     BYTE                       *resParmBuffer                 //  IN:  response      parameter  buffer

1361     )

1362  {

1363     TPM2B_DIGEST               rpHash;                        //  rpHash   for     response

1364     HASH_STATE                 hashState;

1365

1366     //    Compute     rpHash

1367     ComputeRpHash(auditSession->authHashAlg,

1368                            commandCode,

1369                            resParmBufferSize,

1370                            resParmBuffer,

1371                            &rpHash);

1372

      Family "2.0"                                           TCG Published                                       Page 67

      Level 00 Revision 01.16                    Copyright © TCG 2006-2014                              October 30, 2014
      Trusted Platform Module Library                                                                           Part 4:    Supporting   Routines

1373     //    auditDigestnew           :=   hash    (auditDigestold                ||  cpHash        ||  rpHash)

1374

1375     //    Start    hash   computation.

1376     CryptStartHash(auditSession->authHashAlg,                                 &hashState);

1377

1378     //    Add  old   digest.

1379     CryptUpdateDigest2B(&hashState,                      &auditSession->u2.auditDigest.b);

1380

1381     //    Add  cpHash     and      rpHash.

1382     CryptUpdateDigest2B(&hashState,                      &s_cpHashForAudit.b);

1383     CryptUpdateDigest2B(&hashState,                      &rpHash.b);

1384

1385     //    Finalize    the     hash.

1386     CryptCompleteHash2B(&hashState,                      &auditSession->u2.auditDigest.b);

1387

1388     return;

1389  }

1390  #ifdef   TPM_CC_GetCommandAuditDigest

      6.4.5.5       CommandAudit()

      This function updates the command audit digest.

1391  static   void

1392  CommandAudit(

1393     TPM_CC                      commandCode,                    //     IN:     commandCode

1394     UINT32                      resParmBufferSize,              //     IN:     size     of   response      parameter        buffer

1395     BYTE                      *resParmBuffer                    //     IN:     response       parameter        buffer

1396     )

1397  {

1398     if(CommandAuditIsRequired(commandCode))

1399     {

1400           TPM2B_DIGEST                 rpHash;                 //     rpHash       for   response

1401           HASH_STATE                   hashState;

1402

1403           //   Compute        rpHash.

1404           ComputeRpHash(gp.auditHashAlg,                       commandCode,             resParmBufferSize,

1405                                    resParmBuffer,          &rpHash);

1406

1407           //   If    the  digest.size           is   one,   it     indicates         the     special       case  of     changing

1408           //   the   audit      hash    algorithm.         For     this       case,     no   audit   is    done     on  exit.

1409           //   NOTE:      When     the  hash    algorithm          is     changed,       g_updateNV        is    set    in  order   to

1410           //   force      an  update        to  the  NV    on   exit       so  that      the     change    in    digest     will

1411           //   be    recorded.         So,  it  is   safe      to     exit     here     without      setting     any    flags

1412           //   because        the  digest       change     will       be   written       to   NV     when  this     code    exits.

1413           if(gr.commandAuditDigest.t.size                       ==     1)

1414           {

1415                  gr.commandAuditDigest.t.size                      =   0;

1416                  return;

1417           }

1418

1419           //   If    the  digest        size    is   zero,     need       to   start     a   new     digest    and    increment

1420           //   the   audit      counter.

1421           if(gr.commandAuditDigest.t.size                       ==     0)

1422           {

1423                  gr.commandAuditDigest.t.size                      =   CryptGetHashDigestSize(gp.auditHashAlg);

1424                  MemorySet(gr.commandAuditDigest.t.buffer,

1425                                    0,

1426                                    gr.commandAuditDigest.t.size);

1427

1428                  //  Bump     the      counter      and  save      its     value     to     NV.

1429                  gp.auditCounter++;

1430                  NvWriteReserved(NV_AUDIT_COUNTER,                            &gp.auditCounter);

1431                  g_updateNV        =    TRUE;

      Page 68                                                 TCG Published                                                      Family "2.0"

      October 30, 2014                               Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                     Trusted Platform   Module  Library

1432            }

1433

1434            //  auditDigestnew               :=  hash       (auditDigestold          ||   cpHash  ||    rpHash)

1435

1436            //     Start       hash     computation.

1437            CryptStartHash(gp.auditHashAlg,                        &hashState);

1438

1439            //     Add    old     digest.

1440            CryptUpdateDigest2B(&hashState,                        &gr.commandAuditDigest.b);

1441

1442            //     Add    cpHash

1443            CryptUpdateDigest2B(&hashState,                        &s_cpHashForCommandAudit.b);

1444

1445            //     Add    rpHash

1446            CryptUpdateDigest2B(&hashState,                        &rpHash.b);

1447

1448            //     Finalize         the  hash.

1449            CryptCompleteHash2B(&hashState,                        &gr.commandAuditDigest.b);

1450      }

1451      return;

1452  }

1453  #endif

      6.4.5.6       UpdateAuditSessionStatus()

      Function to update the internal audit related states of a session. It

      a)  initializes the session as audit session and sets it to be exclusive if this is the first time it is used              for

          audit or audit reset was requested;

      b)  reports exclusive audit session;

      c)  extends audit log; and

      d)  clears exclusive audit session if no audit session found in the command.

1454  static   void

1455  UpdateAuditSessionStatus(

1456      TPM_CC                        commandCode,                   //  IN:     commandCode

1457      UINT32                        resParmBufferSize,             //  IN:     size  of   response      parameter    buffer

1458      BYTE                        *resParmBuffer                   //  IN:     response   parameter       buffer

1459      )

1460  {

1461      UINT32                        i;

1462      TPM_HANDLE                    auditSession       =     TPM_RH_UNASSIGNED;

1463

1464      //   Iterate        through       sessions

1465      for   (i  =   0;    i    <  s_sessionNum;        i++)

1466      {

1467            SESSION               *session;

1468

1469            //  PW     session       do  not     have  a     loaded    session       and  can  not    be  an  audit

1470            //  session           either.        Skip  it.

1471            if(s_sessionHandles[i]                 ==  TPM_RS_PW)          continue;

1472

1473            session       =    SessionGet(s_sessionHandles[i]);

1474

1475            //  If     a  session        is  used      for   audit

1476            if(s_attributes[i].audit                   ==    SET)

1477            {

1478                   //     An   audit     session       has   been   found

1479                   auditSession          =   s_sessionHandles[i];

1480

1481                   //     If   the   session     has   not   been      an   audit    session      yet,    or

1482                   //     the     auditSetting         bits  indicate       a  reset,     initialize      it  and  set

      Family "2.0"                                               TCG Published                                              Page 69

      Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines

1483                     //     it  to  be  the    exclusive        session

1484                     if(        session->attributes.isAudit                     ==    CLEAR

1485                            ||  s_attributes[i].auditReset                     ==     SET

1486                         )

1487                     {

1488                            InitAuditSession(session);

1489                            g_exclusiveAuditSession                 =   auditSession;

1490                     }

1491                     else

1492                     {

1493                            //  Check      if  the      audit   session         is    the   current     exclusive  audit

1494                            //  session        and,     if  not,    clear       previous        exclusive   audit  session.

1495                            if(g_exclusiveAuditSession                     !=   auditSession)

1496                                    g_exclusiveAuditSession                =    TPM_RH_UNASSIGNED;

1497                     }

1498

1499                     //     Report      audit  session      exclusivity.

1500                     if(g_exclusiveAuditSession                   ==    auditSession)

1501                     {

1502                            s_attributes[i].auditExclusive                         =  SET;

1503                     }

1504                     else

1505                     {

1506                            s_attributes[i].auditExclusive                         =  CLEAR;

1507                     }

1508

1509                     //     Extend      audit  log.

1510                     Audit(session,            commandCode,         resParmBufferSize,               resParmBuffer);

1511              }

1512     }

1513

1514     //    If    no     audit   session        is  found    in    the      command,        and  the    command  allows

1515     //    a     session        then,   clear      the     current     exclusive

1516     //    audit        session.

1517     if(auditSession                ==  TPM_RH_UNASSIGNED              &&  IsSessionAllowed(commandCode))

1518     {

1519              g_exclusiveAuditSession                   =   TPM_RH_UNASSIGNED;

1520     }

1521

1522     return;

1523  }

      6.4.5.7        ComputeResponseHMAC()

      Function to compute HMAC for authorization session in a response.

1524  static   void

1525  ComputeResponseHMAC(

1526     UINT32                         sessionIndex,                   //     IN:     session      index   to  be  processed

1527     SESSION                        *session,                       //     IN:     loaded      session

1528     TPM_CC                         commandCode,                    //     IN:     commandCode

1529     TPM2B_NONCE                    *nonceTPM,                      //     IN:     nonceTPM

1530     UINT32                         resParmBufferSize,              //     IN:     size    of   response    parameter   buffer

1531     BYTE                           *resParmBuffer,                 //     IN:     response     parameter       buffer

1532     TPM2B_DIGEST                   *hmac                           //     OUT:       authHMAC

1533     )

1534  {

1535     TPM2B_TYPE(KEY,                (sizeof(AUTH_VALUE)             *   2));

1536     TPM2B_KEY                      key;                //  HMAC    key

1537     BYTE                           marshalBuffer[sizeof(TPMA_SESSION)];

1538     BYTE                           *buffer;

1539     UINT32                         marshalSize;

1540     HMAC_STATE                     hmacState;

1541     TPM2B_DIGEST                   rp_hash;

      Page 70                                                   TCG Published                                                  Family "2.0"

      October 30, 2014                                 Copyright © TCG 2006-2014                                Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                       Trusted Platform Module Library

1542

1543     //    Compute       rpHash.

1544     ComputeRpHash(session->authHashAlg,                            commandCode,       resParmBufferSize,

1545                               resParmBuffer,              &rp_hash);

1546

1547     //    Generate      HMAC      key

1548     MemoryCopy2B(&key.b,                   &session->sessionKey.b,            sizeof(key.t.buffer));

1549

1550     //    Check     if  the       session         has  an  associated         handle  and     the  associated      entity  is

1551     //    the  one      that      the    session       is  bound     to.

1552     //    If   not  bound,        add      the    authValue      of    this   entity      to  the  HMAC    key.

1553     if(        s_associatedHandles[sessionIndex]                          !=  TPM_RH_UNASSIGNED

1554           &&        !(  HandleGetType(s_sessionHandles[sessionIndex])

1555                               ==  TPM_HT_POLICY_SESSION

1556                &&       session->attributes.isAuthValueNeeded                         ==      CLEAR)

1557           &&   !session->attributes.requestWasBound)

1558     {

1559           pAssert((sizeof(AUTH_VALUE)                      +     key.t.size)  <=      sizeof(key.t.buffer));

1560           key.t.size          =   key.t.size           +

1561                                          EntityGetAuthValue(s_associatedHandles[sessionIndex],

1562                                                                        (AUTH_VALUE        *)&key.t.buffer[key.t.size]);

1563     }

1564

1565     //    if   the  HMAC      key      size       for  a   policy    session  is      0,  the  response    HMAC    is

1566     //    computed      according             to  the     input  HMAC

1567     if(HandleGetType(s_sessionHandles[sessionIndex])                                  ==      TPM_HT_POLICY_SESSION

1568           &&   key.t.size            ==    0

1569           &&   s_inputAuthValues[sessionIndex].t.size                         ==      0)

1570     {

1571           hmac->t.size            =    0;

1572           return;

1573     }

1574

1575     //    Start     HMAC      computation.

1576     hmac->t.size           =  CryptStartHMAC2B(session->authHashAlg,                           &key.b,     &hmacState);

1577

1578     //    Add  hash     components.

1579     CryptUpdateDigest2B(&hmacState,                        &rp_hash.b);

1580     CryptUpdateDigest2B(&hmacState,                        &nonceTPM->b);

1581     CryptUpdateDigest2B(&hmacState,                        &s_nonceCaller[sessionIndex].b);

1582

1583     //    Add  session        attributes.

1584     buffer     =    marshalBuffer;

1585     marshalSize         =     TPMA_SESSION_Marshal(&s_attributes[sessionIndex],                            &buffer,    NULL);

1586     CryptUpdateDigest(&hmacState,                          marshalSize,       marshalBuffer);

1587

1588     //    Finalize      HMAC.

1589     CryptCompleteHMAC2B(&hmacState,                        &hmac->b);

1590

1591     return;

1592  }

      6.4.5.8       BuildSingleResponseAuth()

      Function to compute response for an authorization session.

1593  static   void

1594  BuildSingleResponseAuth(

1595     UINT32                        sessionIndex,                    //  IN:    session     index    to  be  processed

1596     TPM_CC                        commandCode,                     //  IN:    commandCode

1597     UINT32                        resParmBufferSize,               //  IN:    size    of  response     parameter   buffer

1598     BYTE                          *resParmBuffer,                  //  IN:    response        parameter    buffer

1599     TPM2B_AUTH                    *auth                            //  OUT:   authHMAC

1600     )

      Family "2.0"                                              TCG Published                                                   Page 71

      Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                      October 30, 2014
      Trusted Platform Module Library                                                                     Part 4: Supporting Routines

1601  {

1602     //     For     password          authorization,           field   is  empty.

1603     if(s_sessionHandles[sessionIndex]                             ==  TPM_RS_PW)

1604     {

1605            auth->t.size              =  0;

1606     }

1607     else

1608     {

1609            //      Fill     in       policy/HMAC      based     session    response.

1610            SESSION                   *session      =  SessionGet(s_sessionHandles[sessionIndex]);

1611

1612            //      If   the       session      is  a  policy      session  with    isPasswordNeeded   SET,      the  auth

1613            //      field       is    empty.

1614            if(HandleGetType(s_sessionHandles[sessionIndex])                                ==  TPM_HT_POLICY_SESSION

1615                             &&       session->attributes.isPasswordNeeded                  ==  SET)

1616                    auth->t.size             =  0;

1617            else

1618                    //    Compute        response      HMAC.

1619                    ComputeResponseHMAC(sessionIndex,

1620                                                       session,

1621                                                       commandCode,

1622                                                       &session->nonceTPM,

1623                                                       resParmBufferSize,

1624                                                       resParmBuffer,

1625                                                       auth);

1626     }

1627

1628     return;

1629  }

      6.4.5.9        UpdateTPMNonce()

      Updates TPM nonce in both internal session or response if applicable.

1630  static    void

1631  UpdateTPMNonce(

1632     UINT16                           noncesSize,              //  IN:     number  of  elements  in    'nonces'  array

1633     TPM2B_NONCE                      nonces[]                 //  OUT:    nonceTPM

1634     )

1635  {

1636     UINT32                  i;

1637     pAssert(noncesSize                  >=     s_sessionNum);

1638     for(i       =  0;    i     <     s_sessionNum;        i++)

1639     {

1640            SESSION                   *session;

1641            //      For   PW       session,     nonce      is  0.

1642            if(s_sessionHandles[i]                     ==    TPM_RS_PW)

1643            {

1644                    nonces[i].t.size                =  0;

1645                    continue;

1646            }

1647            session          =     SessionGet(s_sessionHandles[i]);

1648            //      Update         nonceTPM     in     both    internal    session     and  response.

1649            CryptGenerateRandom(session->nonceTPM.t.size,                              session->nonceTPM.t.buffer);

1650            nonces[i]              =  session->nonceTPM;

1651     }

1652     return;

1653  }

      6.4.5.10       UpdateInternalSession()

      Updates internal sessions:

      Page 72                                                      TCG Published                                          Family "2.0"

      October 30, 2014                                     Copyright © TCG 2006-2014                       Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                        Trusted Platform Module Library

      a)  Restarts session time, and

      b)  Clears a policy session since nonce is rolling.

1654  static    void

1655  UpdateInternalSession(

1656        void

1657        )

1658  {

1659        UINT32               i;

1660        for(i     =  0;   i   <     s_sessionNum;        i++)

1661        {

1662              //     For  PW     session,        no  update.

1663              if(s_sessionHandles[i]                 ==   TPM_RS_PW)           continue;

1664

1665              if(s_attributes[i].continueSession                           ==   CLEAR)

1666              {

1667                     //   Close     internal         session.

1668                     SessionFlush(s_sessionHandles[i]);

1669              }

1670              else

1671              {

1672                     //   If     nonce      is   rolling  in      a  policy      session,     the    policy  related     data

1673                     //   will      be    re-initialized.

1674                     if(HandleGetType(s_sessionHandles[i])                           ==     TPM_HT_POLICY_SESSION)

1675                     {

1676                             SESSION             *session      =     SessionGet(s_sessionHandles[i]);

1677

1678                             //     When    the  nonce    rolls      it    starts    a   new  timing  interval  for      the

1679                             //     policy      session.

1680                             SessionResetPolicyData(session);

1681                             session->startTime           =    go.clock;

1682                     }

1683              }

1684        }

1685        return;

1686  }

      6.4.5.11        BuildResponseSession()

      Function to build Session buffer in a response.

1687  void

1688  BuildResponseSession(

1689        TPM_ST                      tag,                      //     IN:   tag

1690        TPM_CC                      commandCode,              //     IN:   commandCode

1691        UINT32                      resHandleSize,            //     IN:   size  of     response     handle  buffer

1692        UINT32                      resParmSize,              //     IN:   size  of     response     parameter  buffer

1693        UINT32                      *resSessionSize           //     OUT:  response         session  area

1694        )

1695  {

1696        BYTE                        *resParmBuffer;

1697        TPM2B_NONCE           responseNonces[MAX_SESSION_NUM];

1698

1699        //  Compute       response          parameter     buffer     start.

1700        resParmBuffer            =  MemoryGetResponseBuffer(commandCode)                        +  sizeof(TPM_ST)     +

1701                                    sizeof(UINT32)        +    sizeof(TPM_RC)            +  resHandleSize;

1702

1703        //  For      TPM_ST_SESSIONS,            there    is   parameterSize            field.

1704        if(tag       ==   TPM_ST_SESSIONS)

1705              resParmBuffer             +=  sizeof(UINT32);

1706

1707        //  Session       nonce     should       be  updated         before     parameter     encryption

1708        if(tag       ==   TPM_ST_SESSIONS)

      Family "2.0"                                                TCG Published                                                    Page 73

      Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                  October        30, 2014
      Trusted Platform Module Library                                                                                Part 4: Supporting Routines

1709        {
            
1710                    UpdateTPMNonce(MAX_SESSION_NUM,                          responseNonces);
            
1711        
            
1712                    //  Encrypt         first     parameter         if    applicable.      Parameter            encryption         should
            
1713                    //  happen          after     nonce      update     and   before      any   rpHash         is   computed.
            
1714                    //  If    the       encrypt       session     is    associated        with     a   handle,         the   authValue     of
            
1715                    //  this     handle        will     be   concatenated          with   sessionAuth              to  generate
            
1716                    //  encryption            key,    no     matter     if   the   handle      is     the     session       bound  entity
            
1717                    //  or    not.      The    authValue        is    added   to   sessionAuth             only     when     the   authValue
            
1718                    //  is    available.
            
1719                    if(s_encryptSessionIndex                    !=    UNDEFINED_INDEX)
            
1720                    {
            
1721                          UINT32                        size;
            
1722                          TPM2B_AUTH                    extraKey;
            
1723        
            
1724                          //     Get    size      of  the    leading        size   field
            
1725                          if(           s_associatedHandles[s_encryptSessionIndex]                                 !=  TPM_RH_UNASSIGNED
            
1726                                 &&     IsAuthValueAvailable(s_associatedHandles[s_encryptSessionIndex],
            
1727                                                                            commandCode,        s_encryptSessionIndex)
            
1728                              )
            
1729                          {
            
1730                                 extraKey.b.size             =
            
1731                                           EntityGetAuthValue(s_associatedHandles[s_encryptSessionIndex],
            
1732                                                                            &extraKey.t.buffer);
            
1733                          }
            
1734                          else
            
1735                          {
            
1736                                 extraKey.b.size             =    0;
            
1737                          }
            
1738                          size       =  EncryptSize(commandCode);
            
1739                          CryptParameterEncryption(s_sessionHandles[s_encryptSessionIndex],
            
1740                                                                        &s_nonceCaller[s_encryptSessionIndex].b,
            
1741                                                                        (UINT16)size,
            
1742                                                                        &extraKey,
            
1743                                                                        resParmBuffer);
            
1744        
            
1745                    }
            
1746        
            
1747        }
            
1748        //       Audit       session       should       be   updated        first  regardless             of   the     tag.
            
1749        //       A     command       with     no  session       may     trigger    a  change          of   the     exclusivity     state.
            
1750        UpdateAuditSessionStatus(commandCode,                                 resParmSize,             resParmBuffer);
            
1751        
            
1752        //       Audit       command.
            
1753        CommandAudit(commandCode,                            resParmSize,         resParmBuffer);
            
1754        
            
1755        //       Process         command       with     sessions.
            
1756        if(tag          ==    TPM_ST_SESSIONS)
            
1757        {
            
1758                    UINT32                        i;
            
1759                    BYTE                          *buffer;
            
1760                    TPM2B_DIGEST                  responseAuths[MAX_SESSION_NUM];
            
1761        
            
1762                    pAssert(s_sessionNum                  >  0);
            
1763        
            
1764                    //  Iterate         over      each    session       in   the   command      session         area,       and   create
            
1765                    //  corresponding             sessions        for     response.
            
1766                    for(i     =  0;     i  <   s_sessionNum;            i++)
            
1767                    {
            
1768                          BuildSingleResponseAuth(
            
1769                                                                      i,
            
1770                                                                      commandCode,
            
1771                                                                      resParmSize,
            
1772                                                                      resParmBuffer,
            
1773                                                                      &responseAuths[i]);
            
1774                          //     Make      sure   that       continueSession          is  SET      on     any   Password         session.

      Page 74                                                       TCG Published                                                       Family "2.0"

      October 30, 2014                                     Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
      Part  4: Supporting Routines                                                           Trusted Platform Module Library

1775                  //     This      makes  it  marginally      easier  for    the  management     software

1776                  //     to     keep  track   of     the  closed    sessions.

1777                  if(           s_attributes[i].continueSession            ==  CLEAR

1778                         &&     s_sessionHandles[i]       ==     TPM_RS_PW)

1779                  {

1780                            s_attributes[i].continueSession           =    SET;

1781                  }

1782              }

1783

1784              //  Assemble         Response   Sessions.

1785              *resSessionSize         =   0;

1786              buffer     =   resParmBuffer        +  resParmSize;

1787              for(i   =     0;  i  <  s_sessionNum;       i++)

1788              {

1789                  *resSessionSize             +=  TPM2B_NONCE_Marshal(&responseNonces[i],

1790                                                                             &buffer,    NULL);

1791                  *resSessionSize             +=  TPMA_SESSION_Marshal(&s_attributes[i],

1792                                                                               &buffer,  NULL);

1793                  *resSessionSize             +=  TPM2B_DIGEST_Marshal(&responseAuths[i],

1794                                                                               &buffer,  NULL);

1795              }

1796

1797              //  Update        internal  sessions        after   completing   response  buffer  computation.

1798              UpdateInternalSession();

1799        }

1800        else

1801        {

1802              //  Process       command   with       no   session.

1803              *resSessionSize         =   0;

1804        }

1805

1806        return;

1807  }

      Family "2.0"                                            TCG Published                                    Page 75

      Level 00 Revision 01.16                         Copyright © TCG 2006-2014                      October 30, 2014
    Trusted Platform Module Library                                                               Part 4: Supporting Routines

    7    Command Support Functions

    7.1      Introduction

    This clause contains support routines that are called by the command action code in TPM 2.0 Part 3. The

    functions are grouped by the command group that is supported by the functions.

    7.2      Attestation Command Support (Attest_spt.c)

    7.2.1      Includes

1   #include   "InternalRoutines.h"

2   #include   "Attest_spt_fp.h"

    7.2.2      Functions

    7.2.2.1        FillInAttestInfo()

    Fill in common fields of TPMS_ATTEST structure.

    Error Returns                      Meaning

    TPM_RC_KEY                         key referenced by signHandle is not a signing key

    TPM_RC_SCHEME                      both     scheme  and    key's    default  scheme  are  empty;  or  scheme  is

                                       empty while key's default scheme requires explicit input scheme (split

                                       signing); or non-empty default key scheme differs from scheme

3   TPM_RC

4   FillInAttestInfo(

5        TPMI_DH_OBJECT                signHandle,             //  IN:   handle  of      signing  object

6        TPMT_SIG_SCHEME               *scheme,                //  IN/OUT:       scheme  to   be  used  for  signing

7        TPM2B_DATA                    *data,                  //  IN:   qualifying      data

8        TPMS_ATTEST                   *attest                 //  OUT:  attest     structure

9        )

10  {

11       TPM_RC                            result;

12       TPMI_RH_HIERARCHY                 signHierarhcy;

13

14       result    =   CryptSelectSignScheme(signHandle,                 scheme);

15       if(result      !=   TPM_RC_SUCCESS)

16             return   result;

17

18       //  Magic     number

19       attest->magic       =   TPM_GENERATED_VALUE;

20

21       if(signHandle       ==  TPM_RH_NULL)

22       {

23             BYTE         *buffer;

24             //  For  null     sign  handle,   the    QN     is  TPM_RH_NULL

25             buffer   =    attest->qualifiedSigner.t.name;

26             attest->qualifiedSigner.t.size               =

27                    TPM_HANDLE_Marshal(&signHandle,              &buffer,      NULL);

28       }

29       else

30       {

31             //  Certifying    object    qualified        name

32             //  if   the  scheme    is  anonymous,       this   is    an  empty   buffer

33             if(CryptIsSchemeAnonymous(scheme->scheme))

    Page 76                                             TCG Published                                             Family "2.0"

    October 30, 2014                           Copyright © TCG 2006-2014                          Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                          Trusted Platform Module Library

34                    attest->qualifiedSigner.t.size                          =    0;

35              else

36                    ObjectGetQualifiedName(signHandle,                               &attest->qualifiedSigner);

37        }

38

39        //  current     clock        in     plain      text

40        TimeFillInfo(&attest->clockInfo);

41

42        //  Firmware        version         in     plain    text

43        attest->firmwareVersion                    =   ((UINT64)        gp.firmwareV1          <<  (sizeof(UINT32)        *  8));

44        attest->firmwareVersion                    +=  gp.firmwareV2;

45

46        //  Get   the   hierarchy            of    sign     object.         For    NULL    sign    handle,  the     hierarchy

47        //  will    be  TPM_RH_NULL

48        signHierarhcy       =     EntityGetHierarchy(signHandle);

49        if(signHierarhcy             !=     TPM_RH_PLATFORM             &&  signHierarhcy          !=   TPM_RH_ENDORSEMENT)

50        {

51              //  For   sign      object           is  not     in   platform       or  endorsement      hierarchy,

52              //  obfuscate          the     clock     and     firmwereVersion             information

53              UINT64                        obfuscation[2];

54              TPMI_ALG_HASH                 hashAlg;

55

56              //  Get   hash      algorithm

57              if(signHandle             ==   TPM_RH_NULL            ||  signHandle         ==  TPM_RH_OWNER)

58              {

59                    hashAlg       =     CONTEXT_INTEGRITY_HASH_ALG;

60              }

61              else

62              {

63                    OBJECT                         *signObject          =   NULL;

64                    signObject           =   ObjectGet(signHandle);

65                    hashAlg       =     signObject->publicArea.nameAlg;

66              }

67              KDFa(hashAlg,             &gp.shProof.b,              "OBFUSCATE",

68                      &attest->qualifiedSigner.b,                           NULL,    128,  (BYTE   *)&obfuscation[0],             NULL);

69

70              //  Obfuscate          data

71              attest->firmwareVersion                     +=   obfuscation[0];

72              attest->clockInfo.resetCount                          +=  (UINT32)(obfuscation[1]             >>   32);

73              attest->clockInfo.restartCount                            +=  (UINT32)obfuscation[1];

74        }

75

76        //  External        data

77        if(CryptIsSchemeAnonymous(scheme->scheme))

78              attest->extraData.t.size                      =  0;

79        else

80        {

81              //  If    we  move        the     data   to      the  attestation          structure,     then    we  will     not  use

82              //  it    in  the      signing           operation        except     as  part    of  the  signed      data

83              attest->extraData                 =  *data;

84              data->t.size           =   0;

85        }

86

87        return    TPM_RC_SUCCESS;

88  }

    7.2.2.2         SignAttestInfo()

    Sign a TPMS_ATTEST structure. If signHandle is TPM_RH_NULL, a null signature is returned.

    Family "2.0"                                                     TCG Published                                                   Page 77

    Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                      Part 4: Supporting Routines

     Error Returns                         Meaning

     TPM_RC_ATTRIBUTES                     signHandle references not a signing key

     TPM_RC_SCHEME                         scheme is not compatible with signHandle type

     TPM_RC_VALUE                          digest generated for the given scheme is greater than the modulus of

                                           signHandle       (for  an  RSA      key);  invalid  commit     status    or  failed  to

                                           generate r value (for an ECC key)

89   TPM_RC

90   SignAttestInfo(

91      TPMI_DH_OBJECT                     signHandle,                     //   IN:   handle     of   sign     object

92      TPMT_SIG_SCHEME                    *scheme,                        //   IN:   sign     scheme

93      TPMS_ATTEST                        *certifyInfo,                   //   IN:   the   data     to   be   signed

94      TPM2B_DATA                         *qualifyingData,                //   IN:   extra    data      for   the    signing       proce

95      TPM2B_ATTEST                       *attest,                        //   OUT:  marshaled          attest     blob    to  be

96                                                                         //         signed

97      TPMT_SIGNATURE                     *signature                      //   OUT:  signature

98      )

99   {

100     TPM_RC                                 result;

101     TPMI_ALG_HASH                          hashAlg;

102     BYTE                                   *buffer;

103     HASH_STATE                             hashState;

104     TPM2B_DIGEST                           digest;

105

106     //    Marshal    TPMS_ATTEST           structure    for       hash

107     buffer    =   attest->t.attestationData;

108     attest->t.size          =  TPMS_ATTEST_Marshal(certifyInfo,                        &buffer,       NULL);

109

110     if(signHandle          ==  TPM_RH_NULL)

111     {

112           signature->sigAlg            =   TPM_ALG_NULL;

113     }

114     else

115     {

116           //  Attestation             command  may     cause      the   orderlyState         to   be  cleared       due     to

117           //  the    reporting         of  clock    info.         If   this  is   the      case,     check    if    NV  is

118           //  available        first

119           if(gp.orderlyState               !=  SHUTDOWN_NONE)

120           {

121                  //  The    command        needs   NV   update.         Check     if   NV  is    available.

122                  //  A     TPM_RC_NV_UNAVAILABLE              or  TPM_RC_NV_RATE           error      may   be    returned      at

123                  //  this      point

124                  result     =  NvIsAvailable();

125                  if(result         !=  TPM_RC_SUCCESS)

126                         return        result;

127           }

128

129           //  Compute       hash

130           hashAlg       =  scheme->details.any.hashAlg;

131           digest.t.size            =   CryptStartHash(hashAlg,               &hashState);

132           CryptUpdateDigest(&hashState,                 attest->t.size,                attest->t.attestationData);

133           CryptCompleteHash2B(&hashState,                     &digest.b);

134

135           //  If     there     is     qualifying    data,     need      to   rehash     the    the    data

136           //  hash(qualifyingData              ||   hash(attestationData))

137           if(qualifyingData->t.size                 !=  0)

138           {

139                  CryptStartHash(hashAlg,                &hashState);

140                  CryptUpdateDigest(&hashState,

141                                                qualifyingData->t.size,

142                                                qualifyingData->t.buffer);

143                  CryptUpdateDigest(&hashState,                    digest.t.size,           digest.t.buffer);

144                  CryptCompleteHash2B(&hashState,                       &digest.b);

     Page 78                                                TCG Published                                                       Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                           Trusted Platform Module Library

145              }

146

147              //     Sign   the     hash.     A     TPM_RC_VALUE,      TPM_RC_SCHEME,               or

148              //     TPM_RC_ATTRIBUTES               error  may   be   returned         at   this       point

149              return       CryptSign(signHandle,

150                                            scheme,

151                                            &digest,

152                                            signature);

153        }

154

155        return       TPM_RC_SUCCESS;

156  }

     7.3       Context Management Command Support (Context_spt.c)

     7.3.1       Includes

1    #include       "InternalRoutines.h"

2    #include       "Context_spt_fp.h"

     7.3.2       Functions

     7.3.2.1         ComputeContextProtectionKey()

     This     function  retrieves         the    symmetric      protection    key          for   context     encryption     It  is  used  by

     TPM2_ConextSave() and TPM2_ContextLoad() to create the symmetric encryption key and iv

3    void

4    ComputeContextProtectionKey(

5          TPMS_CONTEXT                *contextBlob,            //   IN:   context         blob

6          TPM2B_SYM_KEY               *symKey,                 //   OUT:     the     symmetric        key

7          TPM2B_IV                    *iv                      //   OUT:     the     IV.

8          )

9    {

10         UINT16                         symKeyBits;           //   number   of      bits      in     the  parent's

11                                                              //       symmetric         key

12         TPM2B_AUTH                  *proof       =   NULL;   //   the   proof      value      to    use.  Is   null   for

13                                                              //       everything        but      a  primary    object    in

14                                                              //       the  Endorsement              Hierarchy

15

16         BYTE                           kdfResult[sizeof(TPMU_HA)                *  2];//      Value      produced    by  the  KDF

17

18         TPM2B_DATA                     sequence2B,       handle2B;

19

20         //  Get      proof   value

21         proof     =  HierarchyGetProof(contextBlob->hierarchy);

22

23         //  Get      sequence       value     in     2B  format

24         sequence2B.t.size              =  sizeof(contextBlob->sequence);

25         MemoryCopy(sequence2B.t.buffer,                      &contextBlob->sequence,

26                            sizeof(contextBlob->sequence),

27                            sizeof(sequence2B.t.buffer));

28

29         //  Get      handle  value        in     2B  format

30         handle2B.t.size             =  sizeof(contextBlob->savedHandle);

31         MemoryCopy(handle2B.t.buffer,                       &contextBlob->savedHandle,

32                            sizeof(contextBlob->savedHandle),

33                            sizeof(handle2B.t.buffer));

34

35         //  Get      the   symmetric        encryption       key  size

36         symKey->t.size           =     CONTEXT_ENCRYPT_KEY_BYTES;

     Family "2.0"                                               TCG Published                                                       Page 79

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                        October 30, 2014
    Trusted Platform Module Library                                                                         Part 4: Supporting  Routines

37        symKeyBits       =   CONTEXT_ENCRYPT_KEY_BITS;

38        //  Get     the  size     of     the  IV  for     the     algorithm

39        iv->t.size       =   CryptGetSymmetricBlockSize(CONTEXT_ENCRYPT_ALG,                              symKeyBits);

40

41        //  KDFa    to   generate        symmetric        key     and     IV   value

42        KDFa(CONTEXT_INTEGRITY_HASH_ALG,                       &proof->b,         "CONTEXT",      &sequence2B.b,

43                &handle2B.b,          (symKey->t.size             +  iv->t.size)         *  8,   kdfResult,     NULL);

44

45        //  Copy    part     of   the    returned      value         as   the  key

46        MemoryCopy(symKey->t.buffer,                   kdfResult,             symKey->t.size,

47                         sizeof(symKey->t.buffer));

48

49        //  Copy    the     rest  as     the  IV

50        MemoryCopy(iv->t.buffer,                  &kdfResult[symKey->t.size],                    iv->t.size,

51                         sizeof(iv->t.buffer));

52

53        return;

54  }

    7.3.2.2        ComputeContextIntegrity()

    Generate the integrity hash for a context It is used by TPM2_ContextSave() to create an integrity                           hash

    and by TPM2_ContextLoad() to compare an integrity hash

55  void

56  ComputeContextIntegrity(

57        TPMS_CONTEXT              *contextBlob,               //     IN:   context    blob

58        TPM2B_DIGEST              *integrity                  //     OUT:     integrity

59        )

60  {

61        HMAC_STATE                       hmacState;

62        TPM2B_AUTH                       *proof;

63        UINT16                           integritySize;

64

65        //  Get     proof    value

66        proof    =  HierarchyGetProof(contextBlob->hierarchy);

67

68        //  Start   HMAC

69        integrity->t.size             =  CryptStartHMAC2B(CONTEXT_INTEGRITY_HASH_ALG,

70                                                                         &proof->b,      &hmacState);

71

72        //  Compute      integrity       size     at   the     beginning          of  context    blob

73        integritySize         =   sizeof(integrity->t.size)                    +  integrity->t.size;

74

75        //  Adding       total    reset       counter     so   that       the  context      cannot  be

76        //  used    after     a   TPM    Reset

77        CryptUpdateDigestInt(&hmacState,                       sizeof(gp.totalResetCount),

78                                         &gp.totalResetCount);

79

80        //  If   this    is   a   ST_CLEAR        object,      add       the   clear  count

81        //  so   that    this     contest     cannot      be      loaded       after  a     TPM  Restart

82        if(contextBlob->savedHandle                   ==  0x80000002)

83            CryptUpdateDigestInt(&hmacState,                             sizeof(gr.clearCount),           &gr.clearCount);

84

85        //  Adding       sequence        number   to   the     HMAC       to   make   sure  that    it  doesn't

86        //  get     changed

87        CryptUpdateDigestInt(&hmacState,                       sizeof(contextBlob->sequence),

88                                         &contextBlob->sequence);

89

90        //  Protect      the     handle

91        CryptUpdateDigestInt(&hmacState,                       sizeof(contextBlob->savedHandle),

92                                         &contextBlob->savedHandle);

93

94        //  Adding       sensitive       contextData,          skip       the  leading      integrity     area

    Page 80                                                     TCG Published                                             Family "2.0"

    October 30, 2014                                Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                             Trusted Platform Module Library

95         CryptUpdateDigest(&hmacState,              contextBlob->contextBlob.t.size                -    integritySize,

96                                 contextBlob->contextBlob.t.buffer                 +   integritySize);

97

98         //   Complete     HMAC

99         CryptCompleteHMAC2B(&hmacState,                &integrity->b);

100

101        return;

102  }

     7.3.2.3       SequenceDataImportExport()

     This   function  is  used  scan   through   the  sequence        object    and  either  modify  the  hash  state  data  for

     LIB_EXPORT or to import it into the internal format

103  void

104  SequenceDataImportExport(

105        OBJECT                  *object,               //     IN:  the  object    containing      the  sequence    data

106        OBJECT                  *exportObject,         //     IN/OUT:   the  object   structure        that  will  get

107                                                       //          the  exported  hash    state

108        IMPORT_EXPORT           direction

109        )

110  {

111        int                            count  =    1;

112        HASH_OBJECT                 *internalFmt           =   (HASH_OBJECT       *)object;

113        HASH_OBJECT                 *externalFmt           =   (HASH_OBJECT       *)exportObject;

114

115        if(object->attributes.eventSeq)

116             count     =  HASH_COUNT;

117        for(;   count;    count--)

118             CryptHashStateImportExport(&internalFmt->state.hashState[count                            -     1],

119                                           externalFmt->state.hashState,                  direction);

120  }

     7.4       Policy Command Support            (Policy_spt.c)

1    #include     "InternalRoutines.h"

2    #include     "Policy_spt_fp.h"

3    #include     "PolicySigned_fp.h"

4    #include     "PolicySecret_fp.h"

5    #include     "PolicyTicket_fp.h"

     7.4.1      PolicyParameterChecks()

     This function validates the common parameters of TPM2_PolicySiged()                     and  TPM2_PolicySecret().       The

     common parameters are nonceTPM, expiration, and cpHashA.

6    TPM_RC

7    PolicyParameterChecks(

8          SESSION                 *session,

9          UINT64                  authTimeout,

10         TPM2B_DIGEST            *cpHashA,

11         TPM2B_NONCE             *nonce,

12         TPM_RC                  nonceParameterNumber,

13         TPM_RC                  cpHashParameterNumber,

14         TPM_RC                  expirationParameterNumber

15         )

16   {

17         TPM_RC                  result;

18

19         //   Validate     that  input    nonceTPM      is     correct   if   present

20         if(nonce    !=    NULL  &&  nonce->t.size          !=  0)

     Family "2.0"                                         TCG Published                                                Page 81

     Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                 October 30, 2014
    Trusted Platform Module Library                                                                            Part 4: Supporting Routines

21        {

22            if(!Memory2BEqual(&nonce->b,                          &session->nonceTPM.b))

23                   return       TPM_RC_NONCE             +   RC_PolicySigned_nonceTPM;

24        }

25        //  If  authTimeout            is   set     (expiration           !=   0...

26        if(authTimeout          !=     0)

27        {

28            //   ...then        nonce       must    be      present

29            //   nonce      present         isn't     checked         in   PolicyTicket

30            if(nonce        !=  NULL        &&   nonce->t.size             ==   0)

31                   //  This     error       says      that      the   time      has  expired      but    it  is  pointing

32                   //  at   the        nonceTPM       value.

33                   return       TPM_RC_EXPIRED               +  nonceParameterNumber;

34

35            //   Validate       input       expiration.

36            //   Cannot     compare         time      if     clock    stop      advancing.        A  TPM_RC_NV_UNAVAILABLE

37            //   or    TPM_RC_NV_RATE               error       may   be   returned       here.

38            result     =    NvIsAvailable();

39            if(result       !=      TPM_RC_SUCCESS)

40                   return       result;

41

42            if(authTimeout              <   go.clock)

43                   return       TPM_RC_EXPIRED               +  expirationParameterNumber;

44        }

45        //  If  the    cpHash       is     present,         then     check     it

46        if(cpHashA     !=   NULL        &&  cpHashA->t.size                !=   0)

47        {

48            //   The   cpHash          input     has     to     have  the      correct     size

49            if(cpHashA->t.size                  !=  session->u2.policyDigest.t.size)

50                   return       TPM_RC_SIZE           +     cpHashParameterNumber;

51

52            //   If    the  cpHash          has     already       been     set,     then   this   input      value

53            //   must     match        the  current          value.

54            if(           session->u1.cpHash.b.size                        !=   0

55                   &&     !Memory2BEqual(&cpHashA->b,                          &session->u1.cpHash.b))

56                          return        TPM_RC_CPHASH;

57        }

58        return   TPM_RC_SUCCESS;

59  }

    7.4.2     PolicyContextUpdate()

    Update policy hash Update the policyDigest in policy session by extending policyRef and objectName                                  to

    it. This will also update the cpHash if it is present.

60  void

61  PolicyContextUpdate(

62        TPM_CC                      commandCode,                //    IN:     command     code

63        TPM2B_NAME              *name,                          //    IN:     name   of   entity

64        TPM2B_NONCE             *ref,                           //    IN:     the   reference     data

65        TPM2B_DIGEST            *cpHash,                        //    IN:     the   cpHash  (optional)

66        UINT64                      policyTimeout,

67        SESSION                 *session                        //    IN/OUT:       policy  session      to  be     updated

68        )

69  {

70        HASH_STATE                          hashState;

71        UINT16                              policyDigestSize;

72

73        //  Start    hash

74        policyDigestSize            =   CryptStartHash(session->authHashAlg,                             &hashState);

75

76        //  policyDigest        size        should       always       be   the     digest   size     of  session    hash  algorithm.

77        pAssert(session->u2.policyDigest.t.size                                ==   policyDigestSize);

78

    Page 82                                                       TCG Published                                                Family "2.0"

    October 30, 2014                                  Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                  Trusted Platform  Module  Library

79         //  add   old    digest

80         CryptUpdateDigest2B(&hashState,                        &session->u2.policyDigest.b);

81

82         //  add   commandCode

83         CryptUpdateDigestInt(&hashState,                       sizeof(commandCode),            &commandCode);

84

85         //  add   name       if   applicable

86         if(name      !=  NULL)

87             CryptUpdateDigest2B(&hashState,                         &name->b);

88

89         //  Complete         the     digest  and      get    the   results

90         CryptCompleteHash2B(&hashState,                        &session->u2.policyDigest.b);

91

92         //  Start     second         hash  computation

93         CryptStartHash(session->authHashAlg,                         &hashState);

94

95         //  add   policyDigest

96         CryptUpdateDigest2B(&hashState,                        &session->u2.policyDigest.b);

97

98         //  add   policyRef

99         if(ref    !=     NULL)

100            CryptUpdateDigest2B(&hashState,                         &ref->b);

101

102        //  Complete         second  digest

103        CryptCompleteHash2B(&hashState,                        &session->u2.policyDigest.b);

104

105        //  Deal     with     the    cpHash.      If   the     cpHash   value     is  present

106        //  then     it  would       have    already         been  checked   to    make   sure  that

107        //  it   is   compatible           with   the     current    value   so    all    we  need

108        //  to   do   here       is  copy    it   and     set  the   iscoHashDefined          attribute

109        if(cpHash        !=   NULL   &&    cpHash->t.size           !=  0)

110        {

111            session->u1.cpHash               =    *cpHash;

112            session->attributes.iscpHashDefined                           =  SET;

113        }

114

115        //  update       the     timeout     if   it   is    specified

116        if(policyTimeout!=           0)

117        {

118        //  If   the     timeout     has     not     been    set,   then     set  it  to  the   new  value

119            if(session->timeOut                  ==   0)

120                     session->timeOut             =   policyTimeout;

121            else      if(session->timeOut                 >  policyTimeout)

122                     session->timeOut             =    policyTimeout;

123        }

124        return;

125  }

     7.5       NV Command Support (NV_spt.c)

     7.5.1     Includes

1    #include      "InternalRoutines.h"

2    #include      "NV_spt_fp.h"

     7.5.2     Fuctions

     7.5.2.1        NvReadAccessChecks()

     Common        routine      for  validating      a   read     Used     by   TPM2_NV_Read(),         TPM2_NV_ReadLock()   and

     TPM2_PolicyNV()

     Family "2.0"                                                 TCG Published                                      Page 83

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                              October 30, 2014
    Trusted Platform Module Library                                                                           Part 4: Supporting Routines

    Error Returns                             Meaning

    TPM_RC_NV_AUTHORIZATION                   autHandle is not allowed to authorize read of the index

    TPM_RC_NV_LOCKED                          Read locked

    TPM_RC_NV_UNINITIALIZED                   Try to read an uninitialized index

3   TPM_RC

4   NvReadAccessChecks(

5       TPM_HANDLE                      authHandle,             //  IN:      the  handle     that    provided       the

6                                                               //           authorization

7       TPM_HANDLE                      nvHandle                //  IN:      the  handle     of   the     NV  index      to   be   written

8       )

9   {

10      NV_INDEX                        nvIndex;

11

12      //    Get     NV  index      info

13      NvGetIndexInfo(nvHandle,                    &nvIndex);

14

15  //  This     check    may    be     done  before      doing     authorization         checks         as   is   done   in  this

16  //  version       of  the    reference       code.      If  not      done     there,  then       uncomment      the      next

17  //  three     lines.

18  //       //   If   data     is   read     locked,     returns        an  error

19  //       if(nvIndex.publicArea.attributes.TPMA_NV_READLOCKED                                     ==   SET)

20  //               return     TPM_RC_NV_LOCKED;

21

22      //    If     the  authorization          was    provided         by  the   owner     or   platform,        then      check

23      //    that     the   attributes          allow    the   read.        If   the    authorization            handle

24      //    is     the  same      as  the   index,      then      the  checks     were     made    when     the   authorization

25      //    was     checked..

26      if(authHandle            ==     TPM_RH_OWNER)

27      {

28               //   If  Owner      provided       auth    then    ONWERWRITE         must   be     SET

29               if(!     nvIndex.publicArea.attributes.TPMA_NV_OWNERREAD)

30                     return       TPM_RC_NV_AUTHORIZATION;

31      }

32      else      if(authHandle           ==  TPM_RH_PLATFORM)

33      {

34               //   If  Platform        provided      auth    then     PPWRITE       must   be     SET

35               if(!nvIndex.publicArea.attributes.TPMA_NV_PPREAD)

36                     return       TPM_RC_NV_AUTHORIZATION;

37      }

38      //    If     neither     Owner      nor  Platform       provided          auth,   make    sure       that  it    was

39      //    provided       by     this    index.

40      else      if(authHandle           !=  nvHandle)

41                     return       TPM_RC_NV_AUTHORIZATION;

42

43      //    If     the  index      has    not  been     written,       then     the    value    cannot      be   read

44      //    NOTE:       This   has    to    come  after       other    access     checks       to  make     sure     that

45      //    the     proper     authorization          is  given        to  TPM2_NV_ReadLock()

46      if(nvIndex.publicArea.attributes.TPMA_NV_WRITTEN                                  ==     CLEAR)

47               return     TPM_RC_NV_UNINITIALIZED;

48

49      return        TPM_RC_SUCCESS;

50  }

    7.5.2.2          NvWriteAccessChecks()

    Common        routine       for     validating  a     write     Used       by   TPM2_NV_Write(),               TPM2_NV_Increment(),

    TPM2_SetBits(), and TPM2_NV_WriteLock()

    Page 84                                                     TCG Published                                                      Family "2.0"

    October 30, 2014                                Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                    Trusted Platform Module Library

    Error Returns                             Meaning

    TPM_RC_NV_AUTHORIZATION                   Authorization fails

    TPM_RC_NV_LOCKED                          Write locked

51  TPM_RC

52  NvWriteAccessChecks(

53       TPM_HANDLE                     authHandle,          //  IN:      the   handle   that   provided     the

54                                                           //           authorization

55       TPM_HANDLE                     nvHandle             //  IN:      the   handle   of   the   NV  index      to   be   written

56       )

57  {

58       NV_INDEX                       nvIndex;

59

60       //    Get     NV  index     info

61       NvGetIndexInfo(nvHandle,                 &nvIndex);

62

63  //   This    check     may   be     done  before    doing    authorization          checks     as   is   done  in   this

64  //   version       of  the   reference      code.   If    not     done     there,   then   uncomment     the       next

65  //   three     lines.

66  //       //    If  data     is   write    locked,   returns       an    error

67  //       if(nvIndex.publicArea.attributes.TPMA_NV_WRITELOCKED                               ==     SET)

68  //               return     TPM_RC_NV_LOCKED;

69

70       //    If    the   authorization        was    provided       by  the   owner    or   platform,      then      check

71       //    that    the   attributes         allow   the   write.        If  the    authorization         handle

72       //    is    the   same     as  the   index,    then     the  checks    were     made   when    the  authorization

73       //    was     checked..

74       if(authHandle           ==     TPM_RH_OWNER)

75       {

76               //    If  Owner     provided     auth  then     ONWERWRITE        must  be    SET

77               if(!      nvIndex.publicArea.attributes.TPMA_NV_OWNERWRITE)

78                     return       TPM_RC_NV_AUTHORIZATION;

79       }

80       else      if(authHandle          ==  TPM_RH_PLATFORM)

81       {

82               //    If  Platform       provided     auth   then    PPWRITE      must  be    SET

83               if(!nvIndex.publicArea.attributes.TPMA_NV_PPWRITE)

84                     return       TPM_RC_NV_AUTHORIZATION;

85       }

86       //    If    neither     Owner     nor  Platform      provided         auth,   make   sure     that  it    was

87       //    provided      by     this   index.

88       else      if(authHandle          !=  nvHandle)

89                     return       TPM_RC_NV_AUTHORIZATION;

90

91       return        TPM_RC_SUCCESS;

92  }

    7.6      Object Command Support (Object_spt.c)

    7.6.1        Includes

1   #include       "InternalRoutines.h"

2   #include       "Object_spt_fp.h"

3   #include       <Platform.h>

    Family "2.0"                                             TCG Published                                                    Page 85

    Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                       October 30, 2014
    Trusted Platform Module Library                                                            Part 4: Supporting Routines

    7.6.2    Local Functions

    7.6.2.1    EqualCryptSet()

    Check if the crypto sets in two public areas are equal

    Error Returns                      Meaning

    TPM_RC_ASYMMETRIC                  mismatched parameters

    TPM_RC_HASH                        mismatched name algorithm

    TPM_RC_TYPE                        mismatched type

4   static   TPM_RC

5   EqualCryptSet(

6      TPMT_PUBLIC             *publicArea1,        //    IN:     public    area  1

7      TPMT_PUBLIC             *publicArea2         //    IN:     public    area  2

8      )

9   {

10     UINT16                        size1;

11     UINT16                        size2;

12     BYTE                          params1[sizeof(TPMU_PUBLIC_PARMS)];

13     BYTE                          params2[sizeof(TPMU_PUBLIC_PARMS)];

14     BYTE                          *buffer;

15

16     //    Compare     name  hash

17     if(publicArea1->nameAlg           !=   publicArea2->nameAlg)

18           return      TPM_RC_HASH;

19

20     //    Compare     algorithm

21     if(publicArea1->type          !=  publicArea2->type)

22           return      TPM_RC_TYPE;

23

24     //    TPMU_PUBLIC_PARMS       field    should      be  identical

25     buffer     =  params1;

26     size1   =     TPMU_PUBLIC_PARMS_Marshal(&publicArea1->parameters,                       &buffer,

27                                                        NULL,   publicArea1->type);

28     buffer     =  params2;

29     size2   =     TPMU_PUBLIC_PARMS_Marshal(&publicArea2->parameters,                       &buffer,

30                                                        NULL,   publicArea2->type);

31

32     if(size1      !=  size2  ||   !MemoryEqual(params1,             params2,       size1))

33           return      TPM_RC_ASYMMETRIC;

34

35     return     TPM_RC_SUCCESS;

36  }

    7.6.2.2    GetIV2BSize()

    Get the size of TPM2B_IV in canonical form that               will be append to the start of the sensitive  data.       It

    includes both size of size field and size of iv data

    Return Value                       Meaning

37  static   UINT16

38  GetIV2BSize(

39     TPM_HANDLE               protectorHandle               //  IN:  the  protector      handle

40     )

41  {

42     OBJECT                        *protector  =    NULL;       //   Pointer    to  the  protector  object

43     TPM_ALG_ID                    symAlg;

    Page 86                                         TCG Published                                        Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                              Trusted Platform Module Library

44        UINT16                                 keyBits;

45

46        //   Determine         the       symmetric        algorithm        and   size     of   key

47        if(protectorHandle                  ==  TPM_RH_NULL)

48        {

49              //  Use   the          context       encryption      algorithm         and      key     size

50              symAlg    =      CONTEXT_ENCRYPT_ALG;

51              keyBits       =     CONTEXT_ENCRYPT_KEY_BITS;

52        }

53        else

54        {

55              protector           =  ObjectGet(protectorHandle);

56              symAlg    =      protector->publicArea.parameters.asymDetail.symmetric.algorithm;

57              keyBits=         protector->publicArea.parameters.asymDetail.symmetric.keyBits.sym;

58        }

59

60        //   The  IV   size          is  a     UINT16     size     field    plus     the   block      size  of    the  symmetric

61        //   algorithm

62        return    sizeof(UINT16)                +  CryptGetSymmetricBlockSize(symAlg,                         keyBits);

63  }

    7.6.2.3         ComputeProtectionKeyParms()

    This function retrieves the symmetric protection key parameters for the sensitive data The parameters

    retrieved   from    this  function           include    encryption      algorithm,      key     size  in  bit,  and  a    TPM2B_SYM_KEY

    containing the key material as well as the key size in bytes This function is used for any action that

    requires encrypting or decrypting of the sensitive area of an object or a credential blob

64  static     void

65  ComputeProtectionKeyParms(

66        TPM_HANDLE                       protectorHandle,               //   IN:     the   protector        handle

67        TPM_ALG_ID                       hashAlg,                       //   IN:     hash     algorithm     for       KDFa

68        TPM2B_NAME                   *name,                             //   IN:     name     of   the  object

69        TPM2B_SEED                   *seedIn,                           //   IN:     optional         seed  for   duplication         blob.

70                                                                        //           For   non     duplication        blob,     this

71                                                                        //           parameter        should      be  NULL

72        TPM_ALG_ID                   *symAlg,                           //   OUT:    the      symmetric     algorithm

73        UINT16                       *keyBits,                          //   OUT:    the      symmetric     key       size  in  bits

74        TPM2B_SYM_KEY                *symKey                            //   OUT:    the      symmetric     key

75        )

76  {

77        TPM2B_SEED                             *seed   =  NULL;

78        OBJECT                                 *protector       =  NULL;     //   Pointer         to  the   protector

79

80        //   Determine         the       algorithms       for      the  KDF     and  the      encryption/decryption

81        //   For  TPM_RH_NULL,                 using   context     settings

82        if(protectorHandle                  ==  TPM_RH_NULL)

83        {

84              //  Use   the          context       encryption      algorithm         and      key     size

85              *symAlg       =     CONTEXT_ENCRYPT_ALG;

86              symKey->t.size                =   CONTEXT_ENCRYPT_KEY_BYTES;

87              *keyBits         =     CONTEXT_ENCRYPT_KEY_BITS;

88        }

89        else

90        {

91              TPMT_SYM_DEF_OBJECT                  *symDef;

92              protector           =  ObjectGet(protectorHandle);

93              symDef    =      &protector->publicArea.parameters.asymDetail.symmetric;

94              *symAlg       =     symDef->algorithm;

95              *keyBits=           symDef->keyBits.sym;

96              symKey->t.size                =   (*keyBits       +  7)   /   8;

97        }

98

99        //   Get  seed      for      KDF

    Family "2.0"                                                     TCG Published                                                      Page 87

    Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                Part 4: Supporting Routines

100     seed  =     GetSeedForKDF(protectorHandle,                seedIn);

101

102     //    KDFa   to   generate      symmetric     key   and   IV  value

103     KDFa(hashAlg,          (TPM2B      *)seed,   "STORAGE",       (TPM2B  *)name,        NULL,

104           symKey->t.size            *  8,   symKey->t.buffer,       NULL);

105

106     return;

107  }

     7.6.2.4       ComputeOuterIntegrity()

     The sensitive area parameter is a buffer that holds a space for the integrity value and the marshaled

     sensitive area. The caller should skip over the area set aside for the integrity value and compute the hash

     of the remainder of the object. The size field of sensitive is in unmarshaled form and the sensitive area

     contents is an array of bytes.

108  static   void

109  ComputeOuterIntegrity(

110     TPM2B_NAME                 *name,                   //    IN:   the   name    of     the   object

111     TPM_HANDLE                  protectorHandle,        //    IN:   The   handle      of   the   object       that

112                                                         //          provides      protection.            For  object,  it

113                                                         //          is    parent     handle.     For     credential,   it

114                                                         //          is    the  handle      of   encrypt       object.  For

115                                                         //          a   Temporary        Object,     it   is  TPM_RH_NULL

116     TPMI_ALG_HASH               hashAlg,                //    IN:   algorithm        to   use   for   integrity

117     TPM2B_SEED                 *seedIn,                 //    IN:   an    external       seed   may   be  provided     for

118                                                         //          duplication          blob.   For     non  duplication

119                                                         //          blob,      this   parameter       should  be    NULL

120     UINT32                      sensitiveSize,          //    IN:   size   of   the      marshaled       sensitive     data

121     BYTE                       *sensitiveData,          //    IN:   sensitive        area

122     TPM2B_DIGEST               *integrity               //    OUT:     integrity

123     )

124  {

125     HMAC_STATE                      hmacState;

126

127     TPM2B_DIGEST                    hmacKey;

128     TPM2B_SEED                      *seed   =    NULL;

129

130     //    Get   seed  for      KDF

131     seed  =     GetSeedForKDF(protectorHandle,                seedIn);

132

133     //    Determine       the   HMAC   key  bits

134     hmacKey.t.size          =   CryptGetHashDigestSize(hashAlg);

135

136     //    KDFa   to   generate      HMAC    key

137     KDFa(hashAlg,          (TPM2B      *)seed,   "INTEGRITY",      NULL,   NULL,

138           hmacKey.t.size            *  8,   hmacKey.t.buffer,       NULL);

139

140     //    Start   HMAC     and  get    the  size  of    the   digest    which   will      become     the  integrity

141     integrity->t.size           =   CryptStartHMAC2B(hashAlg,             &hmacKey.b,         &hmacState);

142

143     //    Adding     the   marshaled       sensitive    area  to   the    integrity       value

144     CryptUpdateDigest(&hmacState,                 sensitiveSize,        sensitiveData);

145

146     //    Adding     name

147     CryptUpdateDigest2B(&hmacState,               (TPM2B      *)name);

148

149     //    Compute     HMAC

150     CryptCompleteHMAC2B(&hmacState,               &integrity->b);

151

152     return;

153  }

     Page 88                                              TCG Published                                                 Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                              Trusted Platform Module Library

     7.6.2.5       ComputeInnerIntegrity()

     This function computes the integrity of an inner wrap

154  static   void

155  ComputeInnerIntegrity(

156     TPM_ALG_ID                hashAlg,              //  IN:     hash    algorithm        for   inner  wrap

157     TPM2B_NAME              *name,                  //  IN:     the     name    of  the   object

158     UINT16                    dataSize,             //  IN:     the     size    of  sensitive       data

159     BYTE                    *sensitiveData,         //  IN:     sensitive         data

160     TPM2B_DIGEST            *integrity              //  OUT:    inner       integrity

161     )

162  {

163     HASH_STATE              hashState;

164

165     //    Start   hash   and  get   the    size  of     the     digest    which     will  become      the  integrity

166     integrity->t.size         =   CryptStartHash(hashAlg,               &hashState);

167

168     //    Adding   the   marshaled     sensitive        area    to   the    integrity     value

169     CryptUpdateDigest(&hashState,                dataSize,      sensitiveData);

170

171     //    Adding   name

172     CryptUpdateDigest2B(&hashState,                 &name->b);

173

174     //    Compute  hash

175     CryptCompleteHash2B(&hashState,                 &integrity->b);

176

177     return;

178

179  }

     7.6.2.6       ProduceInnerIntegrity()

     This function produces an inner integrity for regular private, credential or duplication blob It requires the

     sensitive data being marshaled to the innerBuffer, with the leading bytes reserved for integrity hash.                       It

     assume the sensitive data starts at address (innerBuffer + integrity size). This function integrity at the

     beginning of the inner buffer It returns the total size of buffer with the inner wrap

180  static   UINT16

181  ProduceInnerIntegrity(

182     TPM2B_NAME              *name,                  //  IN:     the     name    of  the   object

183     TPM_ALG_ID                hashAlg,              //  IN:     hash    algorithm        for   inner  wrap

184     UINT16                    dataSize,             //  IN:     the     size    of  sensitive       data,  excluding    the

185                                                     //          leading       integrity       buffer  size

186     BYTE                    *innerBuffer            //  IN/OUT:         inner     buffer  with      sensitive     data  in

187                                                     //          it.     At    input,     the   leading     bytes  of    this

188                                                     //          buffer      is    reserved     for  integrity

189     )

190  {

191     BYTE                          *sensitiveData;           //  pointer       to    the  sensitive    data

192

193     TPM2B_DIGEST                  integrity;

194     UINT16                        integritySize;

195     BYTE                          *buffer;                  //  Auxiliary         buffer  pointer

196

197     //    sensitiveData       points   to  the   beginning          of  sensitive        data  in   innerBuffer

198     integritySize        =  sizeof(UINT16)       +   CryptGetHashDigestSize(hashAlg);

199     sensitiveData        =  innerBuffer     +    integritySize;

200

201     ComputeInnerIntegrity(hashAlg,               name,       dataSize,        sensitiveData,        &integrity);

202

203     //    Add  integrity      at  the  beginning        of   inner      buffer

204     buffer     =  innerBuffer;

     Family "2.0"                                       TCG Published                                                       Page 89

     Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

205        TPM2B_DIGEST_Marshal(&integrity,           &buffer,          NULL);

206

207        return    dataSize      +  integritySize;

208  }

     7.6.2.7         CheckInnerIntegrity()

     This function check integrity of inner blob

     Error Returns                          Meaning

     TPM_RC_INTEGRITY                       if the outer blob integrity is bad

     unmarshal errors                       unmarshal errors while unmarshaling integrity

209  static    TPM_RC

210  CheckInnerIntegrity(

211        TPM2B_NAME              *name,             //     IN:  the   name      of  the    object

212        TPM_ALG_ID                 hashAlg,        //     IN:  hash  algorithm          for  inner   wrap

213        UINT16                     dataSize,       //     IN:  the   size      of  sensitive      data,  including  the

214                                                   //          leading       integrity       buffer  size

215        BYTE                    *innerBuffer       //     IN/OUT:    inner     buffer     with    sensitive  data   in

216                                                   //          it

217        )

218  {

219        TPM_RC                  result;

220

221        TPM2B_DIGEST            integrity;

222        TPM2B_DIGEST            integrityToCompare;

223        BYTE                    *buffer;                         //  Auxiliary     buffer       pointer

224        INT32                   size;

225

226        //  Unmarshal    integrity

227        buffer    =  innerBuffer;

228        size   =  (INT32)    dataSize;

229        result    =  TPM2B_DIGEST_Unmarshal(&integrity,              &buffer,      &size);

230        if(result    ==  TPM_RC_SUCCESS)

231        {

232              //  Compute    integrity       to  compare

233              ComputeInnerIntegrity(hashAlg,              name,    (UINT16)        size,  buffer,

234                                              &integrityToCompare);

235

236              //  Compare    outer     blob   integrity

237              if(!Memory2BEqual(&integrity.b,             &integrityToCompare.b))

238                     result  =     TPM_RC_INTEGRITY;

239        }

240        return    result;

241  }

     7.6.3       Public Functions

     7.6.3.1         AreAttributesForParent()

     This function is called by create, load, and import functions.

     Return Value                           Meaning

     TRUE                                   properties are those of a parent

     FALSE                                  properties are not those of a parent

242  BOOL

     Page 90                                          TCG Published                                             Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                      Trusted  Platform   Module   Library

243  AreAttributesForParent(

244        OBJECT                  *parentObject            //    IN:    parent        handle

245        )

246  {

247        //  This   function     is    only     called    when      a  parent        is  needed.       Any

248        //  time   a  "parent"        is  used,   it     must  be     authorized.            When

249        //  the   authorization           is   checked,      both     the  public       and      sensitive

250        //  areas     must  be  loaded.        Just   make     sure...

251        pAssert(parentObject->attributes.publicOnly                             ==  CLEAR);

252

253        if(ObjectDataIsStorage(&parentObject->publicArea))

254              return    TRUE;

255        else

256              return    FALSE;

257  }

     7.6.3.2         SchemeChecks()

     This  function   validates    the   schemes        in  the   public      area     of  an   object.  This    function  is     called  by

     TPM2_LoadExternal() and PublicAttributesValidation().

     Error Returns                           Meaning

     TPM_RC_ASYMMETRIC                       non-duplicable      storage      key  and     its  parent   have  different  public

                                             parameters

     TPM_RC_ATTRIBUTES                       attempt to inject sensitive data for an asymmetric key; or attempt to

                                             create a symmetric cipher key that is not a decryption key

     TPM_RC_HASH                             non-duplicable      storage      key  and     its  parent   have  different  name

                                             algorithm

     TPM_RC_KDF                              incorrect KDF specified for decrypting keyed hash object

     TPM_RC_KEY                              invalid key size values in an asymmetric key public area

     TPM_RC_SCHEME                           inconsistent attributes decrypt, sign, restricted and key's scheme ID;

                                             or hash algorithm is inconsistent with the scheme ID for keyed hash

                                             object

     TPM_RC_SYMMETRIC                        a storage key with no symmetric algorithm specified; or non-storage

                                             key with symmetric algorithm different from TPM_ALG_NULL

     TPM_RC_TYPE                             unexpected object type; or non-duplicable storage key and its parent

                                             have different types

258  TPM_RC

259  SchemeChecks(

260        BOOL                    load,                    //    IN:    TRUE      if  load     checks,       FALSE  if

261                                                         //           TPM2_Create()

262        TPMI_DH_OBJECT          parentHandle,            //    IN:    input     parent       handle

263        TPMT_PUBLIC             *publicArea              //    IN:    public        area     of  the  object

264        )

265  {

266

267        //  Checks    for   an  asymmetric        key

268        if(CryptIsAsymAlgorithm(publicArea->type))

269        {

270              TPMT_ASYM_SCHEME                    *keyScheme;

271              keyScheme     =   &publicArea->parameters.asymDetail.scheme;

272

273              //  An  asymmetric          key  can't     be  injected

274              //  This  is      only  checked     when       creating      an   object

275              if(!load      &&  (publicArea->objectAttributes.sensitiveDataOrigin                                 ==   CLEAR))

276                   return       TPM_RC_ATTRIBUTES;

277

     Family "2.0"                                           TCG Published                                                         Page 91

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                                         Part 4: Supporting Routines

278           if(load          &&      !CryptAreKeySizesConsistent(publicArea))

279                     return         TPM_RC_KEY;

280

281           //     Keys      that        are     both       signing         and       decrypting         must     have    TPM_ALG_NULL

282           //     for       scheme

283           if(              publicArea->objectAttributes.sign                                   ==  SET

284                  &&     publicArea->objectAttributes.decrypt                                       ==  SET

285                  &&     keyScheme->scheme                     !=   TPM_ALG_NULL)

286                     return         TPM_RC_SCHEME;

287

288           //     A     restrict         sign       key     must       have       a   non-NULL      scheme

289           if(              publicArea->objectAttributes.restricted                                          ==  SET

290                     &&     publicArea->objectAttributes.sign                                   ==      SET

291                     &&     keyScheme->scheme                      ==   TPM_ALG_NULL)

292                     return         TPM_RC_SCHEME;

293

294           //     Keys      must        have     a     valid       sign       or     decrypt    scheme,          or  a   TPM_ALG_NULL

295           //     scheme

296           //     NOTE:         The     unmarshaling               for     a     public    area     will      unmarshal        based     on  the

297           //     object         type.       If     the     type       is     an     RSA  key,      then     only    RSA     schemes     will  be

298           //     allowed           because         a  TPMI_ALG_RSA_SCHEME                      will    be    unmarshaled          and   it

299           //     consists           only       of     those       algorithms             that  are     allowed         with   an   RSA  key.

300           //     This      means        that       there       is     no     need    to   again        make     sure    that  the      algorithm

301           //     is     compatible             with       the     object         type.

302           if(           keyScheme->scheme                     !=   TPM_ALG_NULL

303                  &&     (       (       publicArea->objectAttributes.sign                                   ==  SET

304                                    &&   !CryptIsSignScheme(keyScheme->scheme)

305                                 )

306                            ||   (       publicArea->objectAttributes.decrypt                                    ==     SET

307                                    &&   !CryptIsDecryptScheme(keyScheme->scheme)

308                                 )

309                         )

310               )

311                     return         TPM_RC_SCHEME;

312

313           //     Special           checks       for       an   ECC     key

314  #ifdef   TPM_ALG_ECC

315           if(publicArea->type                         ==   TPM_ALG_ECC)

316           {

317                     TPM_ECC_CURVE                              curveID           =   publicArea->parameters.eccDetail.curveID;

318                     const       TPMT_ECC_SCHEME                    *curveScheme           =    CryptGetCurveSignScheme(curveID);

319                     //     The     curveId         must       be   valid         or  the  unmarshaling              is   busted.

320                     pAssert(curveScheme                       !=   NULL);

321

322                     //     If   the     curveID           requires           a   specific      scheme,          then    the   key  must     select

323                     //     the     same     scheme

324                     if(curveScheme->scheme                         !=     TPM_ALG_NULL)

325                     {

326                            if(keyScheme->scheme                        !=       curveScheme->scheme)

327                                     return         TPM_RC_SCHEME;

328                            //      The     scheme         can     allow         any  hash,     or      not...

329                            if(          curveScheme->details.anySig.hashAlg                                     !=  TPM_ALG_NULL

330                                    &&   (       keyScheme->details.anySig.hashAlg

331                                            !=   curveScheme->details.anySig.hashAlg

332                                         )

333                                 )

334                                     return         TPM_RC_SCHEME;

335                     }

336                     //     For     now,     the       KDF     must     be       TPM_ALG_NULL

337                     if(publicArea->parameters.eccDetail.kdf.scheme                                              !=     TPM_ALG_NULL)

338                            return          TPM_RC_KDF;

339           }

340  #endif

341

342           //     Checks         for     a   storage           key     (restricted         +    decryption)

343           if(           publicArea->objectAttributes.restricted                                        ==    SET

     Page 92                                                              TCG Published                                                         Family "2.0"

     October 30, 2014                                         Copyright © TCG 2006-2014                                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                              Trusted Platform Module Library

344                &&    publicArea->objectAttributes.decrypt                                  ==  SET)

345          {

346                  //     A   storage       key   must      have      a   valid     protection          key

347                  if(           publicArea->parameters.asymDetail.symmetric.algorithm

348                         ==     TPM_ALG_NULL)

349                            return       TPM_RC_SYMMETRIC;

350

351                  //     A   storage       key   must      have      a   null    scheme

352                  if(publicArea->parameters.asymDetail.scheme.scheme                                           !=   TPM_ALG_NULL)

353                            return       TPM_RC_SCHEME;

354

355                  //     A   storage       key   must      match        its   parent        algorithms         unless

356                  //     it     is   duplicable        or    a  primary          (including        Temporary        Primary     Objects)

357                  if(           HandleGetType(parentHandle)                      !=    TPM_HT_PERMANENT

358                         &&     publicArea->objectAttributes.fixedParent                               ==      SET

359                      )

360                  {

361                            //   If   the    object      to     be   created       is    a  storage        key,     and   is  fixedParent,

362                            //   its     crypto    set     has      to   match     its      parent's       crypto   set.      TPM_RC_TYPE,

363                            //   TPM_RC_HASH         or    TPM_RC_ASYMMETRIC                may    be  returned          at   this  point

364                            return       EqualCryptSet(publicArea,

365                                                                &(ObjectGet(parentHandle)->publicArea));

366                  }

367          }

368          else

369          {

370                  //     Non-storage          keys     must     have     TPM_ALG_NULL            for   the     symmetric        algorithm

371                  if(           publicArea->parameters.asymDetail.symmetric.algorithm

372                         !=     TPM_ALG_NULL)

373                            return       TPM_RC_SYMMETRIC;

374

375          }//     End       of   asymmetric        decryption            key     checks

376  }   //     End     of     asymmetric        checks

377

378  //  Check          for     bit     attributes

379  else       if(publicArea->type                 ==    TPM_ALG_KEYEDHASH)

380  {

381          TPMT_KEYEDHASH_SCHEME                        *scheme

382                  =   &publicArea->parameters.keyedHashDetail.scheme;

383          //    If    both       sign    and     decrypt        are     set   the    scheme      must      be  TPM_ALG_NULL

384          //    and      the     scheme      selected        when       the   key    is     used.

385          //    If    neither         sign    nor    decrypt         is  set,      the      scheme     must    be   TPM_ALG_NULL

386          //    because          this    is   a  data      object.

387          if(               publicArea->objectAttributes.sign

388                  ==        publicArea->objectAttributes.decrypt)

389          {

390                  if(scheme->scheme                !=    TPM_ALG_NULL)

391                            return       TPM_RC_SCHEME;

392                  return         TPM_RC_SUCCESS;

393          }

394          //    If    this       is   a  decryption          key,       make     sure    that    is    is   XOR     and   that  there

395          //    is    a     KDF

396          else       if(publicArea->objectAttributes.decrypt)

397          {

398                  if(           scheme->scheme           !=     TPM_ALG_XOR

399                         ||     scheme->details.xor.hashAlg                      ==    TPM_ALG_NULL)

400                            return       TPM_RC_SCHEME;

401                  if(scheme->details.xor.kdf                         ==  TPM_ALG_NULL)

402                            return       TPM_RC_KDF;

403                  return         TPM_RC_SUCCESS;

404

405          }

406          //    only        supported        signing       scheme        for     keyedHash       object        is   HMAC

407          if(         scheme->scheme             !=    TPM_ALG_HMAC

408                ||    scheme->details.hmac.hashAlg                           ==  TPM_ALG_NULL)

409                  return         TPM_RC_SCHEME;

     Family "2.0"                                                  TCG Published                                                          Page 93

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                                  October 30, 2014
     Trusted Platform Module Library                                                                      Part 4: Supporting Routines

410

411              //     end   of  the     checks  for  keyedHash

412              return       TPM_RC_SUCCESS;

413        }

414        else  if     (publicArea->type         ==   TPM_ALG_SYMCIPHER)

415        {

416              //     Must  be  a    decrypting      key  and    may   not   be  a   signing       key

417              if(         publicArea->objectAttributes.decrypt                  ==    CLEAR

418                     ||   publicArea->objectAttributes.sign                 ==  SET

419                  )

420                     return    TPM_RC_ATTRIBUTES;

421        }

422        else

423              return       TPM_RC_TYPE;

424

425        return       TPM_RC_SUCCESS;

426  }

     7.6.3.3         PublicAttributesValidation()

     This  function     validates      the  values     in  the  public    area     of  an   object.  This    function  is      called  by

     TPM2_Create(), TPM2_Load(), and TPM2_CreatePrimary()

     Error Returns                            Meaning

     TPM_RC_ASYMMETRIC                        non-duplicable    storage   key   and    its  parent   have  different   public

                                              parameters

     TPM_RC_ATTRIBUTES                        fixedTPM,     fixedParent,  or    encryptedDuplication       attributes  are

                                              inconsistent between themselves or with those of the parent object;

                                              inconsistent restricted, decrypt and sign attributes; attempt to inject

                                              sensitive data for an asymmetric key; attempt to create a symmetric

                                              cipher key that is not a decryption key

     TPM_RC_HASH                              non-duplicable    storage   key   and    its  parent   have  different   name

                                              algorithm

     TPM_RC_KDF                               incorrect KDF specified for decrypting keyed hash object

     TPM_RC_KEY                               invalid key size values in an asymmetric key public area

     TPM_RC_SCHEME                            inconsistent attributes decrypt, sign, restricted and key's scheme ID;

                                              or hash algorithm is inconsistent with the scheme ID for keyed hash

                                              object

     TPM_RC_SIZE                              authPolicy size does not match digest size of the name algorithm in

                                              publicArea

     TPM_RC_SYMMETRIC                         a storage key with no symmetric algorithm specified; or non-storage

                                              key with symmetric algorithm different from TPM_ALG_NULL

     TPM_RC_TYPE                              unexpected object type; or non-duplicable storage key and its parent

                                              have different types

427  TPM_RC

428  PublicAttributesValidation(

429        BOOL                        load,                //     IN:  TRUE   if  load     checks,       FALSE  if

430                                                         //          TPM2_Create()

431        TPMI_DH_OBJECT              parentHandle,        //     IN:  input   parent      handle

432        TPMT_PUBLIC               *publicArea            //     IN:  public     area     of  the  object

433        )

434  {

435        OBJECT                           *parentObject       =  NULL;

436

437        if(HandleGetType(parentHandle)                   !=  TPM_HT_PERMANENT)

438              parentObject          =  ObjectGet(parentHandle);

     Page 94                                                TCG Published                                              Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                 Trusted Platform Module Library

439

440        //     Check           authPolicy       digest       consistency

441        if(           publicArea->authPolicy.t.size                         !=  0

442               &&     (         publicArea->authPolicy.t.size

443                         !=     CryptGetHashDigestSize(publicArea->nameAlg)

444                      )

445            )

446                  return           TPM_RC_SIZE;

447

448        //     If     the       parent     is   fixedTPM      (including           a   Primary       Object)   the     object  must  have

449        //     the       same      value    for     fixedTPM       and  fixedParent

450        if(              parentObject           ==  NULL

451                  ||     parentObject->publicArea.objectAttributes.fixedTPM                                    ==     SET)

452        {

453                  if(           publicArea->objectAttributes.fixedParent

454                         !=     publicArea->objectAttributes.fixedTPM

455                      )

456                            return    TPM_RC_ATTRIBUTES;

457        }

458        else

459                  //     The       parent   is   not     fixedTPM       so  the       object    can't     be  fixedTPM

460                  if(publicArea->objectAttributes.fixedTPM                                  ==  SET)

461                            return      TPM_RC_ATTRIBUTES;

462

463        //     A   restricted           object      cannot    be    both        sign      and   decrypt   and     it   can't   be  neither

464        //     sign         nor    decrypt

465        if     (         publicArea->objectAttributes.restricted                                ==   SET

466                  &&     (         publicArea->objectAttributes.decrypt

467                            ==     publicArea->objectAttributes.sign)

468               )

469                  return           TPM_RC_ATTRIBUTES;

470

471        //     A   fixedTPM           object     can     not  have      encryptedDuplication              bit     SET

472        if(              publicArea->objectAttributes.fixedTPM                              ==  SET

473                  &&     publicArea->objectAttributes.encryptedDuplication                                    ==   SET)

474                  return           TPM_RC_ATTRIBUTES;

475

476        //     If     a     parent    object        has  fixedTPM       CLEAR,         the     child  must    have     the

477        //     same         encryptedDuplication              value     as      its    parent.

478        //     Primary             objects     are  considered          to  have       a  fixedTPM        parent   (the     seeds).

479     if(                    (      parentObject          !=   NULL

480                               &&  parentObject->publicArea.objectAttributes.fixedTPM                                  ==   CLEAR)

481               //     Get       here  if    parent       is   not   fixed       TPM

482               &&        (         publicArea->objectAttributes.encryptedDuplication

483                            !=     parentObject->publicArea.objectAttributes.encryptedDuplication

484                         )

485            )

486                  return           TPM_RC_ATTRIBUTES;

487

488     return           SchemeChecks(load,                 parentHandle,          publicArea);

489  }

     7.6.3.4             FillInCreationData()

     Fill in creation data for an object.

490  void

491  FillInCreationData(

492        TPMI_DH_OBJECT                                   parentHandle,             //     IN:   handle    of  parent

493        TPMI_ALG_HASH                                    nameHashAlg,              //     IN:   name  hash    algorithm

494        TPML_PCR_SELECTION                            *creationPCR,                //     IN:   PCR   selection

495        TPM2B_DATA                                    *outsideData,                //     IN:   outside   data

496        TPM2B_CREATION_DATA                           *outCreation,                //     OUT:  creation      data     for  output

497        TPM2B_DIGEST                                  *creationDigest              //     OUT:  creation      digest

     Family "2.0"                                                      TCG Published                                                    Page 95

     Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                     Part 4: Supporting Routines

498     )

499  {

500     BYTE                                creationBuffer[sizeof(TPMS_CREATION_DATA)];

501     BYTE                             *buffer;

502     HASH_STATE                          hashState;

503

504     //    Fill     in  TPMS_CREATION_DATA              in     outCreation

505

506     //    Compute      PCR      digest

507     PCRComputeCurrentDigest(nameHashAlg,                             creationPCR,

508                                               &outCreation->t.creationData.pcrDigest);

509

510     //    Put   back       PCR  selection        list

511     outCreation->t.creationData.pcrSelect                            =  *creationPCR;

512

513     //    Get   locality

514     outCreation->t.creationData.locality

515           =    LocalityGetAttributes(_plat__LocalityGet());

516

517     outCreation->t.creationData.parentNameAlg                              =     TPM_ALG_NULL;

518

519     //    If   the     parent   is   is    either      a   primary      seed     or  TPM_ALG_NULL,         then  the  Name

520     //    and   QN     of  the  parent        are    the   parent's        handle.

521     if(HandleGetType(parentHandle)                        ==  TPM_HT_PERMANENT)

522     {

523           BYTE                  *buffer       =  &outCreation->t.creationData.parentName.t.name[0];

524           outCreation->t.creationData.parentName.t.size                                  =

525                    TPM_HANDLE_Marshal(&parentHandle,                       &buffer,         NULL);

526

527           //    Parent      qualified         name   of    a  Temporary          Object     is  the  same  as    parent's

528           //    name

529           MemoryCopy2B(&outCreation->t.creationData.parentQualifiedName.b,

530                                 &outCreation->t.creationData.parentName.b,

531                                 sizeof(outCreation->t.creationData.parentQualifiedName.t.name));

532

533     }

534     else                   //   Regular       object

535     {

536           OBJECT                     *parentObject            =  ObjectGet(parentHandle);

537

538           //    Set    name     algorithm

539           outCreation->t.creationData.parentNameAlg                              =

540                    parentObject->publicArea.nameAlg;

541           //    Copy       parent    name

542           outCreation->t.creationData.parentName                              =  parentObject->name;

543

544           //    Copy       parent    qualified       name

545           outCreation->t.creationData.parentQualifiedName                                   =

546                    parentObject->qualifiedName;

547     }

548

549     //    Copy     outside      information

550     outCreation->t.creationData.outsideInfo                             =  *outsideData;

551

552     //    Marshal      creation      data        to  canonical       form

553     buffer      =   creationBuffer;

554     outCreation->t.size              =   TPMS_CREATION_DATA_Marshal(&outCreation->t.creationData,

555                                          &buffer,         NULL);

556

557     //    Compute      hash     for  creation        field       in  public      template

558     creationDigest->t.size                 =     CryptStartHash(nameHashAlg,                    &hashState);

559     CryptUpdateDigest(&hashState,                      outCreation->t.size,                 creationBuffer);

560     CryptCompleteHash2B(&hashState,                        &creationDigest->b);

561

562     return;

563  }

     Page 96                                                   TCG Published                                              Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                             Trusted Platform Module Library

     7.6.3.5        GetSeedForKDF()

     Get a seed for KDF.      The KDF for encryption and HMAC key use the same seed. It returns a                          pointer  to

     the seed

564  TPM2B_SEED*

565  GetSeedForKDF(

566      TPM_HANDLE              protectorHandle,             //   IN:   the   protector      handle

567      TPM2B_SEED             *seedIn                       //   IN:   the   optional      input     seed

568      )

569  {

570      OBJECT                        *protector   =   NULL;      //   Pointer     to  the   protector

571

572      //    Get  seed   for  encryption   key.       Use   input      seed   if  provided.

573      //    Otherwise,     using    protector   object's        seedValue.       TPM_RH_NULL        is     the  only

574      //    exception   that    we  may   not  have     a  loaded     object     as  protector.         In     such  a

575      //    case,  use  nullProof     as  seed.

576      if(seedIn     !=  NULL)

577      {

578            return     seedIn;

579      }

580      else

581      {

582            if(protectorHandle        ==  TPM_RH_NULL)

583            {

584                   return    (TPM2B_SEED  *)    &gr.nullProof;

585            }

586            else

587            {

588                   protector    =   ObjectGet(protectorHandle);

589                   return    (TPM2B_SEED  *)    &protector->sensitive.seedValue;

590            }

591      }

592  }

     7.6.3.6        ProduceOuterWrap()

     This function produce outer wrap for a buffer containing the sensitive data. It requires the sensitive data

     being marshaled to the outerBuffer, with the leading bytes reserved for integrity hash.                       If iv is used, iv

     space should be reserved at the beginning of the buffer.             It assumes the sensitive data starts at address

     (outerBuffer + integrity size {+ iv size}). This function performs:

     a)  Add IV before sensitive area if required

     b)  encrypt sensitive data, if iv is required, encrypt by iv.       otherwise, encrypted by a NULL iv

     c)  add HMAC integrity at the beginning of the buffer It returns the total size of blob with outer wrap

593  UINT16

594  ProduceOuterWrap(

595      TPM_HANDLE              protector,            //     IN:  The   handle     of  the   object      that     provides

596                                                    //          protection.          For  object,      it   is  parent

597                                                    //          handle.     For  credential,        it     is   the  handle

598                                                    //          of   encrypt     object.

599      TPM2B_NAME             *name,                 //     IN:  the   name   of  the      object

600      TPM_ALG_ID              hashAlg,              //     IN:  hash   algorithm      for  outer       wrap

601      TPM2B_SEED             *seed,                 //     IN:  an   external    seed     may   be  provided         for

602                                                    //          duplication      blob.     For    non   duplication

603                                                    //          blob,  this      parameter      should      be  NULL

604      BOOL                    useIV,                //     IN:  indicate     if  an   IV   is   used

605      UINT16                  dataSize,             //     IN:  the   size   of  sensitive        data,     excluding     the

606                                                    //          leading     integrity      buffer      size     or   the

607                                                    //          optional     iv  size

608      BYTE                   *outerBuffer           //     IN/OUT:    outer   buffer      with    sensitive         data  in

     Family "2.0"                                      TCG Published                                                         Page 97

     Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                                Part 4: Supporting Routines

609                                                                 //             it

610     )

611  {

612     TPM_ALG_ID                 symAlg;

613     UINT16                     keyBits;

614     TPM2B_SYM_KEY              symKey;

615     TPM2B_IV                   ivRNG;                           //     IV  from    RNG

616     TPM2B_IV                   *iv        =  NULL;

617     UINT16                     ivSize          =  0;            //     size    of  iv      area,   including        the  size    field

618

619     BYTE                       *sensitiveData;                  //     pointer     to      the  sensitive       data

620

621     TPM2B_DIGEST               integrity;

622     UINT16                     integritySize;

623     BYTE                       *buffer;                         //     Auxiliary       buffer      pointer

624

625     //    Compute      the     beginning          of     sensitive         data.       The      outer   integrity        should

626     //    always     exist     if      this       function         function        is  called      to   make    an   outer   wrap

627     integritySize           =  sizeof(UINT16)                +     CryptGetHashDigestSize(hashAlg);

628     sensitiveData           =  outerBuffer               +   integritySize;

629

630     //    If   iv  is     used,       adjust      the        pointer       of  sensitive        data    and   add    iv  before    it

631     if(useIV)

632     {

633           ivSize       =   GetIV2BSize(protector);

634

635           //    Generate       IV      from       RNG.       The    iv     data    size    should      be  the  total    IV    area

636           //    size      minus       the    size        of  size      field

637           ivRNG.t.size             =   ivSize         -  sizeof(UINT16);

638           CryptGenerateRandom(ivRNG.t.size,                                ivRNG.t.buffer);

639

640           //    Marshal        IV     to     buffer

641           buffer       =   sensitiveData;

642           TPM2B_IV_Marshal(&ivRNG,                           &buffer,      NULL);

643

644           //    adjust      sensitive             data       starting      after       IV  area

645           sensitiveData               +=     ivSize;

646

647           //    Use    iv   for       encryption

648           iv    =  &ivRNG;

649     }

650

651     //    Compute      symmetric             key  parameters            for    outer       buffer  encryption

652     ComputeProtectionKeyParms(protector,                                   hashAlg,        name,   seed,

653                                                       &symAlg,         &keyBits,       &symKey);

654     //    Encrypt      inner       buffer         in     place

655     CryptSymmetricEncrypt(sensitiveData,                                   symAlg,     keyBits,

656                                              TPM_ALG_CFB,              symKey.t.buffer,            iv,     dataSize,

657                                              sensitiveData);

658

659     //    Compute      outer       integrity.                Integrity         computation        includes      the     optional   IV

660     //    area

661     ComputeOuterIntegrity(name,                          protector,            hashAlg,     seed,      dataSize      +   ivSize,

662                                              outerBuffer            +   integritySize,            &integrity);

663

664     //    Add   integrity          at     the     beginning         of     outer   buffer

665     buffer      =  outerBuffer;

666     TPM2B_DIGEST_Marshal(&integrity,                               &buffer,        NULL);

667

668     //    return     the    total         size    in     outer      wrap

669     return      dataSize       +      integritySize             +   ivSize;

670

671  }

     Page 98                                                        TCG Published                                                     Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

     7.6.3.7       UnwrapOuter()

     This function remove the outer wrap of a blob containing sensitive data This function performs:

     a)  check integrity of outer blob

     b)  decrypt outer blob

     Error Returns                         Meaning

     TPM_RC_INSUFFICIENT                   error during sensitive data unmarshaling

     TPM_RC_INTEGRITY                      sensitive data integrity is broken

     TPM_RC_SIZE                           error during sensitive data unmarshaling

     TPM_RC_VALUE                          IV size for CFB does not match the encryption algorithm block size

672  TPM_RC

673  UnwrapOuter(

674      TPM_HANDLE              protector,          //       IN:  The   handle      of   the     object       that    provides

675                                                  //            protection.           For   object,         it  is  parent

676                                                  //            handle.     For     credential,          it     is  the  handle

677                                                  //            of   encrypt      object.

678      TPM2B_NAME              *name,              //       IN:  the   name  of      the    object

679      TPM_ALG_ID              hashAlg,            //       IN:  hash   algorithm          for  outer        wrap

680      TPM2B_SEED              *seed,              //       IN:  an   external       seed    may     be   provided        for

681                                                  //            duplication         blob.      For   non     duplication

682                                                  //            blob,  this       parameter         should      be  NULL.

683      BOOL                    useIV,              //       IN:  indicates       if    an   IV  is    used

684      UINT16                  dataSize,           //       IN:  size   of   sensitive          data     in   outerBuffer,

685                                                  //            including       the    leading       integrity      buffer

686                                                  //            size,  and      an    optional       iv     area

687      BYTE                    *outerBuffer        //       IN/OUT:    sensitive        data

688      )

689  {

690      TPM_RC                  result;

691      TPM_ALG_ID              symAlg    =     TPM_ALG_NULL;

692      TPM2B_SYM_KEY           symKey;

693      UINT16                  keyBits      =  0;

694      TPM2B_IV                ivIn;                        //   input  IV   retrieved          from      input      buffer

695      TPM2B_IV                *iv    =  NULL;

696

697      BYTE                    *sensitiveData;              //   pointer     to    the     sensitive         data

698

699      TPM2B_DIGEST            integrityToCompare;

700      TPM2B_DIGEST            integrity;

701      INT32                   size;

702

703      //   Unmarshal     integrity

704      sensitiveData        =  outerBuffer;

705      size   =  (INT32)       dataSize;

706      result    =  TPM2B_DIGEST_Unmarshal(&integrity,                  &sensitiveData,              &size);

707      if(result      ==  TPM_RC_SUCCESS)

708      {

709            //  Compute       integrity       to  compare

710            ComputeOuterIntegrity(name,           protector,          hashAlg,        seed,

711                                              (UINT16)     size,    sensitiveData,

712                                              &integrityToCompare);

713

714            //  Compare       outer     blob  integrity

715            if(!Memory2BEqual(&integrity.b,                &integrityToCompare.b))

716                   return     TPM_RC_INTEGRITY;

717

718            //  Get  the      symmetric       algorithm    parameters       used    for    encryption

719            ComputeProtectionKeyParms(protector,                    hashAlg,      name,     seed,

     Family "2.0"                                    TCG Published                                                               Page 99

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

720                                                               &symAlg,    &keyBits,   &symKey);

721

722              //  Retrieve             IV  if  it     is  used

723              if(useIV)

724              {

725                      result        =  TPM2B_IV_Unmarshal(&ivIn,                 &sensitiveData,         &size);

726                      if(result            ==  TPM_RC_SUCCESS)

727                      {

728                             //     The    input      iv  size  for  CFB    must    match    the    encryption    algorithm

729                             //     block      size

730                             if(ivIn.t.size               !=   CryptGetSymmetricBlockSize(symAlg,             keyBits))

731                                       result      =  TPM_RC_VALUE;

732                             else

733                                       iv  =   &ivIn;

734                      }

735              }

736        }

737        //  If    no     errors,       decrypt        private   in   place

738        if(result        ==     TPM_RC_SUCCESS)

739              CryptSymmetricDecrypt(sensitiveData,                          symAlg,    keyBits,

740                                                      TPM_ALG_CFB,         symKey.t.buffer,         iv,

741                                                      (UINT16)       size,  sensitiveData);

742

743        return    result;

744

745  }

     7.6.3.8         SensitiveToPrivate()

     This function prepare the private blob for off the chip storage The operations in this function:

     a)  marshal TPM2B_SENSITIVE structure into the buffer of TPM2B_PRIVATE

     b)  apply encryption to the sensitive area.

     c)  apply outer integrity computation.

746  void

747  SensitiveToPrivate(

748        TPMT_SENSITIVE                 *sensitive,              //   IN:   sensitive   structure

749        TPM2B_NAME                     *name,                   //   IN:   the   name  of  the    object

750        TPM_HANDLE                     parentHandle,            //   IN:   The   parent's    handle

751        TPM_ALG_ID                     nameAlg,                 //   IN:   hash   algorithm     in   public   area.      This

752                                                                //         parameter   is    used    when     parentHandle     is

753                                                                //         NULL,  in   which    case     the  object  is

754                                                                //         temporary.

755        TPM2B_PRIVATE                  *outPrivate              //   OUT:   output     private    structure

756        )

757  {

758        BYTE                                   *buffer;                     //   Auxiliary     buffer    pointer

759        BYTE                                   *sensitiveData;              //   pointer   to   the   sensitive   data

760        UINT16                                 dataSize;                    //   data  blob    size

761        TPMI_ALG_HASH                          hashAlg;                     //   hash  algorithm      for     integrity

762        UINT16                                 integritySize;

763        UINT16                                 ivSize;

764

765        pAssert(name            !=     NULL    &&     name->t.size   !=     0);

766

767        //  Find      the    hash      algorithm          for  integrity    computation

768        if(parentHandle                ==  TPM_RH_NULL)

769        {

770              //  For      Temporary           Object,        using  self   name  algorithm

771              hashAlg        =   nameAlg;

772        }

773        else

     Page 100                                                      TCG Published                                             Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                   Trusted Platform Module     Library

774        {

775            //   Otherwise,       using         parent's   name        algorithm

776            hashAlg      =    ObjectGetNameAlg(parentHandle);

777        }

778

779        //  Starting     of      sensitive       data   without        wrappers

780        sensitiveData         =   outPrivate->t.buffer;

781

782        //  Compute      the     integrity       size

783        integritySize         =   sizeof(UINT16)        +  CryptGetHashDigestSize(hashAlg);

784

785        //  Reserve      space    for    integrity

786        sensitiveData         +=  integritySize;

787

788        //  Get  iv     size

789        ivSize   =   GetIV2BSize(parentHandle);

790

791        //  Reserve      space    for    iv

792        sensitiveData         +=  ivSize;

793

794        //  Marshal      sensitive       area,   leaving       the     leading      2  bytes     for  size

795        buffer   =   sensitiveData           +   sizeof(UINT16);

796        dataSize     =   TPMT_SENSITIVE_Marshal(sensitive,                    &buffer,           NULL);

797

798        //  Adding      size     before   the    data   area

799        buffer   =   sensitiveData;

800        UINT16_Marshal(&dataSize,                &buffer,      NULL);

801

802        //  Adjust      the   dataSize       to  include       the     size   field

803        dataSize     +=  sizeof(UINT16);

804

805        //  Adjust      the   pointer     to     inner  buffer         including       the  iv

806        sensitiveData         =   outPrivate->t.buffer              +  ivSize;

807

808        //Produce       outer     wrap,   including        encryption         and   HMAC

809        outPrivate->t.size          =    ProduceOuterWrap(parentHandle,                     name,     hashAlg,  NULL,

810                                                                       TRUE,  dataSize,          outPrivate->t.buffer);

811

812        return;

813  }

     7.6.3.9        PrivateToSensitive()

     Unwrap a input private area.           Check the integrity, decrypt and retrieve data to a sensitive structure.            The

     operations in this function:

     a)    check the integrity HMAC of the input private area

     b)    decrypt the private buffer

     c)    unmarshal TPMT_SENSITIVE structure into the buffer of TPMT_SENSITIVE

     Error Returns                           Meaning

     TPM_RC_INTEGRITY                        if the private area integrity is bad

     TPM_RC_SENSITIVE                        unmarshal errors while unmarshaling TPMS_ENCRYPT                      from  input

                                             private

     TPM_RC_VALUE                            outer wrapper does not have an iV of the correct size

814  TPM_RC

815  PrivateToSensitive(

816        TPM2B_PRIVATE             *inPrivate,              //  IN:     input  private       structure

817        TPM2B_NAME                *name,                   //  IN:     the    name     of   the  object

     Family "2.0"                                             TCG Published                                                     Page 101

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                                                 Part 4: Supporting Routines

818     TPM_HANDLE                       parentHandle,              //  IN:      The   parent's       handle

819     TPM_ALG_ID                       nameAlg,                   //  IN:      hash   algorithm          in   public     area.  It    is

820                                                                 //           passed       separately        because    we  only    pass

821                                                                 //           name,     rather     than      the    whole   public   area

822                                                                 //           of   the     object.        This    parameter    is   used   in

823                                                                 //           the   following           two  cases:     1.  primary

824                                                                 //           objects.         2.  duplication       blob   with    inner

825                                                                 //           wrap.        In   other     cases,    this    parameter

826                                                                 //           will   be    ignored

827     TPMT_SENSITIVE                   *sensitive                 //  OUT:     sensitive            structure

828     )

829  {

830     TPM_RC                           result;

831

832     BYTE                             *buffer;

833     INT32                            size;

834     BYTE                             *sensitiveData;            //  pointer        to     the     sensitive      data

835     UINT16                           dataSize;

836     UINT16                           dataSizeInput;

837     TPMI_ALG_HASH                    hashAlg;                   //  hash     algorithm            for  integrity

838     OBJECT                           *parent      =   NULL;

839

840     UINT16                           integritySize;

841     UINT16                           ivSize;

842

843     //  Make       sure       that       name     is  provided

844     pAssert(name              !=     NULL   &&    name->t.size           !=  0);

845

846     //  Find       the     hash      algorithm        for    integrity           computation

847     if(parentHandle                  ==  TPM_RH_NULL)

848     {

849           //    For     Temporary           Object,     using       self     name      algorithm

850           hashAlg          =  nameAlg;

851     }

852     else

853     {

854           //    Otherwise,               using    parent's      name     algorithm

855           hashAlg          =  ObjectGetNameAlg(parentHandle);

856     }

857

858     //  unwrap         outer

859     result      =   UnwrapOuter(parentHandle,                       name,        hashAlg,         NULL,     TRUE,

860                                             inPrivate->t.size,               inPrivate->t.buffer);

861     if(result          !=     TPM_RC_SUCCESS)

862           return        result;

863

864     //  Compute         the       inner     integrity        size.

865     integritySize             =      sizeof(UINT16)          +  CryptGetHashDigestSize(hashAlg);

866

867     //  Get     iv     size

868     ivSize      =   GetIV2BSize(parentHandle);

869

870     //  The     starting             of  sensitive      data        and  data      size       without       outer  wrapper

871     sensitiveData             =      inPrivate->t.buffer            +    integritySize            +    ivSize;

872     dataSize        =   inPrivate->t.size               -    integritySize             -  ivSize;

873

874     //  Unmarshal             input      data     size

875     buffer      =   sensitiveData;

876     size     =  (INT32)           dataSize;

877     result      =   UINT16_Unmarshal(&dataSizeInput,                              &buffer,        &size);

878     if(result          ==     TPM_RC_SUCCESS)

879     {

880           if((dataSizeInput                    +  sizeof(UINT16))            !=    dataSize)

881                    result         =  TPM_RC_SENSITIVE;

882           else

883           {

     Page 102                                                       TCG Published                                                     Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                 Trusted Platform Module Library

884                  //  Unmarshal       sensitive     buffer      to  sensitive        structure

885                  result    =   TPMT_SENSITIVE_Unmarshal(sensitive,                     &buffer,         &size);

886                  if(result     !=    TPM_RC_SUCCESS        ||     size   !=   0)

887                  {

888                        pAssert(          (parent   ==      NULL)

889                                     ||   parent->publicArea.objectAttributes.fixedTPM                             ==   CLEAR);

890                        result    =   TPM_RC_SENSITIVE;

891                  }

892                  else

893                  {

894                        //  Always       remove     trailing    zeros     at   load     so  that     it  is   not      necessary

895                        //  to  check

896                        //  each     time     auth  is  checked.

897                        MemoryRemoveTrailingZeros(&(sensitive->authValue));

898                  }

899              }

900        }

901        return    result;

902  }

     7.6.3.10       SensitiveToDuplicate()

     This function prepare the duplication blob from the sensitive area. The operations in this function:

     a)    marshal TPMT_SENSITIVE structure into the buffer of TPM2B_PRIVATE

     b)    apply inner wrap to the sensitive area if required

     c)    apply outer wrap if required

903  void

904  SensitiveToDuplicate(

905        TPMT_SENSITIVE                     *sensitive,              //   IN:   sensitive       structure

906        TPM2B_NAME                         *name,                   //   IN:   the   name      of  the   object

907        TPM_HANDLE                            parentHandle,         //   IN:   The   new    parent's         handle

908        TPM_ALG_ID                            nameAlg,              //   IN:   hash     algorithm        in  public     area.        It

909                                                                    //         is   passed     separately          because       we

910                                                                    //         only     pass   name,     rather        than     the

911                                                                    //         whole    public       area    of    the  object.

912        TPM2B_SEED                         *seed,                   //   IN:   the   external        seed.    If   external

913                                                                    //         seed     is  provided         with  size      of   0,

914                                                                    //         no   outer      wrap  should        be   applied

915                                                                    //         to   duplication          blob.

916        TPMT_SYM_DEF_OBJECT                *symDef,                 //   IN:   Symmetric       key   definition.            If   the

917                                                                    //         symmetric       key   algorithm          is   NULL,

918                                                                    //         no   inner      wrap  should        be   applied.

919        TPM2B_DATA                         *innerSymKey,            //   IN/OUT:     a  symmetric        key     may    be

920                                                                    //         provided        to  encrypt       the    inner

921                                                                    //         wrap     of  a  duplication         blob.        May

922                                                                    //         be   generated        here    if    needed.

923        TPM2B_PRIVATE                      *outPrivate              //   OUT:   output      private      structure

924        )

925  {

926        BYTE                   *buffer;                 //  Auxiliary        buffer     pointer

927        BYTE                   *sensitiveData;          //  pointer      to   the   sensitive        data

928        TPMI_ALG_HASH          outerHash      =  TPM_ALG_NULL;//          The   hash    algorithm        for     outer      wrap

929        TPMI_ALG_HASH          innerHash      =  TPM_ALG_NULL;//          The   hash    algorithm        for     inner      wrap

930        UINT16                 dataSize;                //  data    blob     size

931        BOOL                   doInnerWrap       =  FALSE;

932        BOOL                   doOuterWrap       =  FALSE;

933

934        //  Make  sure  that    name      is  provided

935        pAssert(name    !=     NULL   &&   name->t.size       !=    0);

936

937        //  Make  sure  symDef       and   innerSymKey      are     not   NULL

     Family "2.0"                                          TCG Published                                                        Page 103

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                          October 30, 2014
      Trusted Platform Module Library                                                                                Part 4: Supporting Routines

938        pAssert(symDef              !=  NULL       &&     innerSymKey             !=  NULL);
           
939        
           
940        //  Starting      of        sensitive          data       without         wrappers
           
941        sensitiveData            =  outPrivate->t.buffer;
           
942        
           
943        //  Find     out  if        inner      wrap       is     required
           
944        if(symDef->algorithm                   !=     TPM_ALG_NULL)
           
945        {
           
946            doInnerWrap             =   TRUE;
           
947            //    Use     self      nameAlg           as  inner          hash     algorithm
           
948            innerHash            =  nameAlg;
           
949            //    Adjust         sensitive            data       pointer
           
950            sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(innerHash);
           
951        }
           
952        
           
953        //  Find     out  if        outer      wrap       is     required
           
954        if(seed->t.size             !=    0)
           
955        {
           
956            doOuterWrap             =   TRUE;
           
957            //    Use     parent        nameAlg           as     outer      hash      algorithm
           
958            outerHash            =  ObjectGetNameAlg(parentHandle);
           
959            //    Adjust         sensitive            data       pointer
           
960            sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
           
961        }
           
962        
           
963        //  Marshal       sensitive            area,      leaving           the      leading  2  bytes        for   size
           
964        buffer    =  sensitiveData                 +   sizeof(UINT16);
           
965        dataSize     =    TPMT_SENSITIVE_Marshal(sensitive,                                  &buffer,    NULL);
           
966        
           
967        //  Adding       size       before      the       data     area
           
968        buffer    =  sensitiveData;
           
969        UINT16_Marshal(&dataSize,                         &buffer,          NULL);
           
970        
           
971        //  Adjust       the     dataSize          to     include           the   size   field
           
972        dataSize     +=   sizeof(UINT16);
           
973        
           
974        //  Apply    inner          wrap    for       duplication             blob.      It   includes        both     integrity      and
           
975        //  encryption
           
976        if(doInnerWrap)
           
977        {
           
978            BYTE                            *innerBuffer                 =  NULL;
           
979            BOOL                            symKeyInput               =     TRUE;
           
980            innerBuffer             =   outPrivate->t.buffer;
           
981            //    Skip    outer         integrity             space
           
982            if(doOuterWrap)
           
983                     innerBuffer            +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
           
984            dataSize          =     ProduceInnerIntegrity(name,                          innerHash,      dataSize,
           
985                                                                                 innerBuffer);
           
986        
           
987            //    Generate          inner       encryption               key     if   needed
           
988            if(innerSymKey->t.size                        ==      0)
           
989            {
           
990                     innerSymKey->t.size                      =   (symDef->keyBits.sym                +  7)   /    8;
           
991                     CryptGenerateRandom(innerSymKey->t.size,                                    innerSymKey->t.buffer);
           
992        
           
993                     //   TPM       generates          symmetric            encryption.          Set     the  flag        to  FALSE
           
994                     symKeyInput            =   FALSE;
           
995            }
           
996            else
           
997            {
           
998                     //   assume        the     input         key     size       should  matches         the  symmetric          definition
           
999                     pAssert(innerSymKey->t.size                              ==     (symDef->keyBits.sym              +  7)  /  8);
           
1000       
           
1001           }
           
1002       
           
1003           //    Encrypt           inner      buffer         in   place

      Page 104                                                      TCG Published                                                   Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                                       Level 00 Revision 01.16
      Part  4: Supporting Routines                                                            Trusted Platform Module              Library

1004            CryptSymmetricEncrypt(innerBuffer,                symDef->algorithm,

1005                                            symDef->keyBits.sym,             TPM_ALG_CFB,

1006                                            innerSymKey->t.buffer,               NULL,    dataSize,

1007                                            innerBuffer);

1008

1009            //    If  the     symmetric     encryption   key  is   imported,        clear     the    buffer       for

1010            //    output

1011            if(symKeyInput)

1012                   innerSymKey->t.size      =       0;

1013        }

1014

1015        //  Apply     outer   wrap     for  duplication  blob.     It        includes     both     integrity      and

1016        //  encryption

1017        if(doOuterWrap)

1018        {

1019            dataSize       =  ProduceOuterWrap(parentHandle,                 name,  outerHash,         seed,      FALSE,

1020                                                        dataSize,  outPrivate->t.buffer);

1021        }

1022

1023        //  Data   size    for  output

1024        outPrivate->t.size          =  dataSize;

1025

1026        return;

1027  }

      7.6.3.11      DuplicateToSensitive()

      Unwrap a duplication blob.           Check the integrity, decrypt and retrieve data to a             sensitive    structure.    The

      operations in this function:

      a)    check the integrity HMAC of the input private area

      b)    decrypt the private buffer

      c)    unmarshal TPMT_SENSITIVE structure into the buffer of TPMT_SENSITIVE

      Error Returns                          Meaning

      TPM_RC_INSUFFICIENT                    unmarshaling sensitive data from inPrivate failed

      TPM_RC_INTEGRITY                       inPrivate data integrity is broken

      TPM_RC_SIZE                            unmarshaling sensitive data from inPrivate failed

1028  TPM_RC

1029  DuplicateToSensitive(

1030        TPM2B_PRIVATE                       *inPrivate,       //   IN:       input  private        structure

1031        TPM2B_NAME                          *name,            //   IN:       the    name  of    the    object

1032        TPM_HANDLE                          parentHandle,     //   IN:       The    parent's       handle

1033        TPM_ALG_ID                          nameAlg,          //   IN:       hash   algorithm        in  public        area.

1034        TPM2B_SEED                          *seed,            //   IN:       an   external      seed     may  be    provided.

1035                                                              //             If   external      seed     is   provided      with

1036                                                              //             size   of    0,  no   outer      wrap     is

1037                                                              //             applied

1038        TPMT_SYM_DEF_OBJECT                 *symDef,          //   IN:       Symmetric        key  definition.          If  the

1039                                                              //             symmetric        key  algorithm        is     NULL,

1040                                                              //             no   inner   wrap     is    applied

1041        TPM2B_DATA                          *innerSymKey,     //   IN:       a   symmetric      key    may    be  provided

1042                                                              //             to   decrypt     the    inner    wrap      of  a

1043                                                              //             duplication        blob.

1044        TPMT_SENSITIVE                      *sensitive        //   OUT:         sensitive     structure

1045        )

1046  {

1047        TPM_RC                  result;

1048

      Family "2.0"                                          TCG Published                                                      Page 105

      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                         October 30, 2014
      Trusted Platform Module Library                                                                          Part 4: Supporting Routines

1049        BYTE                            *buffer;
            
1050        INT32                           size;
            
1051        BYTE                            *sensitiveData;                //  pointer      to  the  sensitive       data
            
1052        UINT16                          dataSize;
            
1053        UINT16                          dataSizeInput;
            
1054        
            
1055        //  Make        sure    that        name     is  provided
            
1056        pAssert(name            !=      NULL    &&   name->t.size             !=   0);
            
1057        
            
1058        //  Make        sure    symDef          and  innerSymKey           are     not   NULL
            
1059        pAssert(symDef                 !=   NULL     &&  innerSymKey          !=   NULL);
            
1060        
            
1061        //  Starting            of     sensitive         data
            
1062        sensitiveData               =   inPrivate->t.buffer;
            
1063        dataSize        =    inPrivate->t.size;
            
1064        
            
1065        //  Find        out     if     outer    wrap     is    applied
            
1066        if(seed->t.size                 !=  0)
            
1067        {
            
1068              TPMI_ALG_HASH                     outerHash        =     TPM_ALG_NULL;
            
1069        
            
1070              //     Use     parent         nameAlg      as    outer       hash    algorithm
            
1071              outerHash             =   ObjectGetNameAlg(parentHandle);
            
1072              result         =  UnwrapOuter(parentHandle,                         name,     outerHash,  seed,       FALSE,
            
1073                                                         dataSize,         sensitiveData);
            
1074              if(result             !=     TPM_RC_SUCCESS)
            
1075                        return         result;
            
1076        
            
1077              //     Adjust         sensitive        data      pointer        and  size
            
1078              sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(outerHash);
            
1079              dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(outerHash);
            
1080        }
            
1081        //  Find        out     if     inner    wrap     is    applied
            
1082        if(symDef->algorithm                    !=   TPM_ALG_NULL)
            
1083        {
            
1084              TPMI_ALG_HASH                     innerHash        =     TPM_ALG_NULL;
            
1085        
            
1086              //     assume         the     input    key     size      should      matches     the  symmetric       definition
            
1087              pAssert(innerSymKey->t.size                              ==  (symDef->keyBits.sym         +    7)  /  8);
            
1088        
            
1089              //     Decrypt           inner    buffer       in     place
            
1090              CryptSymmetricDecrypt(sensitiveData,                                 symDef->algorithm,
            
1091                                                         symDef->keyBits.sym,               TPM_ALG_CFB,
            
1092                                                         innerSymKey->t.buffer,                  NULL,  dataSize,
            
1093                                                         sensitiveData);
            
1094        
            
1095              //     Use     self       nameAlg      as   inner        hash   algorithm
            
1096              innerHash             =   nameAlg;
            
1097        
            
1098              //     Check      inner       integrity
            
1099              result         =  CheckInnerIntegrity(name,                         innerHash,     dataSize,       sensitiveData);
            
1100              if(result             !=     TPM_RC_SUCCESS)
            
1101                        return         result;
            
1102        
            
1103              //     Adjust         sensitive        data      pointer        and  size
            
1104              sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(innerHash);
            
1105              dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(innerHash);
            
1106        }
            
1107        
            
1108        //  Unmarshal           input       data     size
            
1109        buffer       =  sensitiveData;
            
1110        size      =  (INT32)           dataSize;
            
1111        result       =  UINT16_Unmarshal(&dataSizeInput,                               &buffer,     &size);
            
1112        if(result          ==   TPM_RC_SUCCESS)
            
1113        {
            
1114              if((dataSizeInput                   +  sizeof(UINT16))               !=   dataSize)

      Page 106                                                       TCG Published                                            Family "2.0"

      October 30, 2014                                 Copyright © TCG 2006-2014                               Level 00 Revision 01.16
      Part  4: Supporting Routines                                                                          Trusted Platform Module       Library

1115                      result        =     TPM_RC_SIZE;

1116              else

1117              {

1118                      //     Unmarshal           sensitive     buffer      to  sensitive         structure

1119                      result        =     TPMT_SENSITIVE_Unmarshal(sensitive,                        &buffer,    &size);

1120                      //     if  the      results     is   OK  make    sure        that    all   the   data     was  unmarshaled

1121                      if(result           ==     TPM_RC_SUCCESS        &&  size    !=      0)

1122                              result      =      TPM_RC_SIZE;

1123              }

1124        }

1125        //   Always       remove          trailing    zeros    at  load        so  that    it    is   not   necessary      to  check

1126        //   each     time       auth     is     checked.

1127        if(result         ==     TPM_RC_SUCCESS)

1128              MemoryRemoveTrailingZeros(&(sensitive->authValue));

1129        return     result;

1130  }

      7.6.3.12        SecretToCredential()

      This  function    prepare         the   credential    blob   from    a   secret      (a  TPM2B_DIGEST)             The  operations  in  this

      function:

      a)    marshal TPM2B_DIGEST structure into the buffer of TPM2B_ID_OBJECT

      b)    encrypt the private buffer, excluding the leading integrity HMAC area

      c)    compute integrity HMAC and append to the beginning of the buffer.

      d)    Set the total size of TPM2B_ID_OBJECT buffer

1131  void

1132  SecretToCredential(

1133        TPM2B_DIGEST                          *secret,                 //  IN:     secret       information

1134        TPM2B_NAME                            *name,                   //  IN:     the     name  of    the   object

1135        TPM2B_SEED                            *seed,                   //  IN:     an    external      seed.

1136        TPM_HANDLE                               protector,            //  IN:     The     protector's       handle

1137        TPM2B_ID_OBJECT                       *outIDObject             //  OUT:    output        credential

1138        )

1139  {

1140        BYTE                                  *buffer;                 //  Auxiliary           buffer   pointer

1141        BYTE                                  *sensitiveData;          //  pointer         to   the   sensitive      data

1142        TPMI_ALG_HASH                            outerHash;            //  The     hash    algorithm        for  outer     wrap

1143        UINT16                                   dataSize;             //  data    blob        size

1144

1145        pAssert(secret              !=    NULL   &&   outIDObject          !=  NULL);

1146

1147        //   use   protector's            name   algorithm         as  outer       hash

1148        outerHash         =   ObjectGetNameAlg(protector);

1149

1150        //   Marshal         secret       area   to   credential       buffer,         leave     space     for   integrity

1151        sensitiveData            =     outIDObject->t.credential

1152                                       +  sizeof(UINT16)       +   CryptGetHashDigestSize(outerHash);

1153

1154        //   Marshal         secret       area

1155        buffer     =  sensitiveData;

1156        dataSize      =      TPM2B_DIGEST_Marshal(secret,                      &buffer,        NULL);

1157

1158        //   Apply    outer         wrap

1159        outIDObject->t.size                   =  ProduceOuterWrap(protector,

1160                                                                           name,

1161                                                                           outerHash,

1162                                                                           seed,

1163                                                                           FALSE,

1164                                                                           dataSize,

1165                                                                           outIDObject->t.credential);

      Family "2.0"                                                 TCG Published                                                     Page 107

      Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                           October 30, 2014
      Trusted Platform Module Library                                                                            Part 4: Supporting Routines

1166      return;

1167  }

      7.6.3.13       CredentialToSecret()

      Unwrap a credential.           Check the integrity, decrypt and retrieve data to a TPM2B_DIGEST                         structure.  The

      operations in this function:

      a)  check the integrity HMAC of the input credential area

      b)  decrypt the credential buffer

      c)  unmarshal TPM2B_DIGEST structure into the buffer of TPM2B_DIGEST

      Error Returns                               Meaning

      TPM_RC_INSUFFICIENT                         error during credential unmarshaling

      TPM_RC_INTEGRITY                            credential integrity is broken

      TPM_RC_SIZE                                 error during credential unmarshaling

      TPM_RC_VALUE                                IV size does not match the encryption algorithm block size

1168  TPM_RC

1169  CredentialToSecret(

1170      TPM2B_ID_OBJECT                      *inIDObject,                 //  IN:   input    credential        blob

1171      TPM2B_NAME                           *name,                       //  IN:   the   name  of    the  object

1172      TPM2B_SEED                           *seed,                       //  IN:   an   external     seed.

1173      TPM_HANDLE                              protector,                //  IN:   The   protector's      handle

1174      TPM2B_DIGEST                         *secret                      //  OUT:  secret      information

1175      )

1176  {

1177      TPM_RC                                          result;

1178      BYTE                                        *buffer;

1179      INT32                                           size;

1180      TPMI_ALG_HASH                                   outerHash;            //    The   hash  algorithm      for   outer  wrap

1181      BYTE                                        *sensitiveData;           //    pointer     to  the    sensitive  data

1182      UINT16                                          dataSize;

1183

1184      //    use  protector's               name   algorithm         as  outer     hash

1185      outerHash         =     ObjectGetNameAlg(protector);

1186

1187      //    Unwrap      outer,       a     TPM_RC_INTEGRITY             error    may   be  returned      at  this  point

1188      result     =   UnwrapOuter(protector,                    name,        outerHash,     seed,    FALSE,

1189                                              inIDObject->t.size,              inIDObject->t.credential);

1190      if(result         ==    TPM_RC_SUCCESS)

1191      {

1192            //   Compute         the       beginning     of    sensitive         data

1193            sensitiveData               =  inIDObject->t.credential

1194                                           +  sizeof(UINT16)            +   CryptGetHashDigestSize(outerHash);

1195            dataSize          =  inIDObject->t.size

1196                                 -   (sizeof(UINT16)             +  CryptGetHashDigestSize(outerHash));

1197

1198            //   Unmarshal           secret       buffer     to     TPM2B_DIGEST        structure

1199            buffer         =  sensitiveData;

1200            size     =     (INT32)         dataSize;

1201            result         =  TPM2B_DIGEST_Unmarshal(secret,                      &buffer,        &size);

1202            //   If     there        were     no  other      unmarshaling         errors,     make  sure     that  the

1203            //   expected            amount       of  data   was    recovered

1204            if(result            ==  TPM_RC_SUCCESS            &&   size    !=    0)

1205                    return       TPM_RC_SIZE;

1206      }

1207      return     result;

1208  }

      Page 108                                                     TCG Published                                              Family "2.0"

      October 30, 2014                                    Copyright © TCG 2006-2014                              Level 00 Revision 01.16
    Part 4: Supporting Routines                                                             Trusted Platform Module Library

    8     Subsystem

    8.1       CommandAudit.c

    8.1.1       Introduction

    This file contains the functions that support command audit.

    8.1.2       Includes

1   #include    "InternalRoutines.h"

    8.1.3       Functions

    8.1.3.1        CommandAuditPreInstall_Init()

    This function initializes the command audit list. This function is simulates the behavior of manufacturing. A

    function is used instead of a structure definition because this is easier than figuring out the initialization

    value for a bit array.

    This function would not be implemented outside of a manufacturing or simulation environment.

2   void

3   CommandAuditPreInstall_Init(

4         void

5         )

6   {

7         //  Clear    all  the     audit  commands

8         MemorySet(gp.auditComands,           0x00,

9                      ((TPM_CC_LAST       -   TPM_CC_FIRST     +   1)  +   7)     /  8);

10

11        //  TPM_CC_SetCommandCodeAuditStatus            always        being      audited

12        if(CommandIsImplemented(TPM_CC_SetCommandCodeAuditStatus))

13              CommandAuditSet(TPM_CC_SetCommandCodeAuditStatus);

14

15        //  Set  initial    command      audit   hash   algorithm     to     be     context  integrity  hash

16        //  algorithm

17        gp.auditHashAlg        =  CONTEXT_INTEGRITY_HASH_ALG;

18

19        //  Set  up  audit     counter   to  be  0

20        gp.auditCounter        =  0;

21

22        //  Write    command      audit  persistent     data  to  NV

23        NvWriteReserved(NV_AUDIT_COMMANDS,              &gp.auditComands);

24        NvWriteReserved(NV_AUDIT_HASH_ALG,              &gp.auditHashAlg);

25        NvWriteReserved(NV_AUDIT_COUNTER,               &gp.auditCounter);

26

27        return;

28  }

    8.1.3.2        CommandAuditStartup()

    This function clears the command audit digest on a TPM Reset.

29  void

30  CommandAuditStartup(

31        STARTUP_TYPE              type              //  IN:   start      up   type

32        )

    Family "2.0"                                      TCG Published                                             Page 109

    Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                  October 30, 2014
    Trusted Platform Module Library                                                                Part 4: Supporting Routines

33  {

34        if(type   ==   SU_RESET)

35        {

36            //    Reset      the   digest    size   to  initialize      the  digest

37            gr.commandAuditDigest.t.size                  =  0;

38        }

39

40  }

    8.1.3.3       CommandAuditSet()

    This function will SET the audit flag for a command. This function will                        not  SET  the      audit  flag  for a

    command       that  is     not    implemented.       This    ensures  that     the  audit      status    is   not  SET         when

    TPM2_GetCapability() is used to read the list of audited commands.

    This function is only used by TPM2_SetCommandCodeAuditStatus().

    The actions in TPM2_SetCommandCodeAuditStatus() are expected to cause the changes to be saved to

    NV after it is setting and clearing bits.

    Return Value                               Meaning

    TRUE                                       the command code audit status was changed

    FALSE                                      the command code audit status was not changed

41  BOOL

42  CommandAuditSet(

43        TPM_CC                     commandCode          //   IN:    command  code

44        )

45  {

46        UINT32            bitPos;

47

48        //  Only  SET     a   bit   if  the  corresponding          command  is  implemented

49        if(CommandIsImplemented(commandCode))

50        {

51            //    Can't      audit  shutdown

52            if(commandCode          !=   TPM_CC_Shutdown)

53            {

54                  bitPos      =    commandCode      -   TPM_CC_FIRST;

55                  if(!BitIsSet(bitPos,              &gp.auditComands[0],         sizeof(gp.auditComands)))

56                  {

57                          //  Set   bit

58                          BitSet(bitPos,      &gp.auditComands[0],            sizeof(gp.auditComands));

59                          return    TRUE;

60                  }

61            }

62        }

63        //  No  change

64        return    FALSE;

65  }

    8.1.3.4       CommandAuditClear()

    This  function  will    CLEAR         the  audit  flag  for    a  command.     It   will  not  CLEAR         the  audit  flag  for

    TPM_CC_SetCommandCodeAuditStatus().

    This function is only used by TPM2_SetCommandCodeAuditStatus().

    The actions in TPM2_SetCommandCodeAuditStatus() are expected to cause the changes to be saved to

    NV after it is setting and clearing bits.

    Page 110                                                TCG Published                                              Family "2.0"

    October 30, 2014                            Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                Trusted Platform Module Library

     Return Value                                Meaning

     TRUE                                        the command code audit status was changed

     FALSE                                       the command code audit status was not changed

66   BOOL

67   CommandAuditClear(

68         TPM_CC                       commandCode             //   IN:  command     code

69         )

70   {

71         UINT32               bitPos;

72

73         //  Do    nothing        if  the   command     is    not     implemented

74         if(CommandIsImplemented(commandCode))

75         {

76               //  The   bit      associated       with       TPM_CC_SetCommandCodeAuditStatus()  cannot         be

77               //  cleared

78               if(commandCode          !=      TPM_CC_SetCommandCodeAuditStatus)

79               {

80                      bitPos      =   commandCode       -     TPM_CC_FIRST;

81                      if(BitIsSet(bitPos,            &gp.auditComands[0],             sizeof(gp.auditComands)))

82                      {

83                              //  Clear     bit

84                              BitClear(bitPos,          &gp.auditComands[0],          sizeof(gp.auditComands));

85                              return   TRUE;

86                      }

87               }

88         }

89         //  No    change

90         return    FALSE;

91   }

     8.1.3.5         CommandAuditIsRequired()

     This function indicates if the audit flag is SET for a command.

     Return Value                                Meaning

     TRUE                                        if command is audited

     FALSE                                       if command is not audited

92   BOOL

93   CommandAuditIsRequired(

94         TPM_CC                       commandCode             //   IN:  command     code

95         )

96   {

97         UINT32               bitPos;

98

99         bitPos    =     commandCode        -  TPM_CC_FIRST;

100

101        //  Check       the  bit     map.     If  the     bit    is   SET,  command  audit   is  required

102        if((gp.auditComands[bitPos/8]                     &  (1   <<   (bitPos  %  8)))  !=  0)

103              return    TRUE;

104        else

105              return    FALSE;

106

107  }

     8.1.3.6         CommandAuditCapGetCCList()

     This function returns a list of commands that have their audit bit SET.

     Family "2.0"                                               TCG Published                                      Page 111

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

     The list starts at the input commandCode.

     Return Value                                Meaning

     YES                                         if there are more command code available

     NO                                          all the available command code has been returned

108  TPMI_YES_NO

109  CommandAuditCapGetCCList(

110        TPM_CC                     commandCode,                //  IN:     start    command  code

111        UINT32                     count,                      //  IN:     count    of  returned   TPM_CC

112        TPML_CC                   *commandList                 //  OUT:    list     of  TPM_CC

113        )

114  {

115        TPMI_YES_NO               more     =   NO;

116        UINT32                    i;

117

118        //  Initialize         output      handle     list

119        commandList->count            =    0;

120

121        //  The     maximum    count       of  command         we  may     return   is  MAX_CAP_CC

122        if(count       >  MAX_CAP_CC)          count     =     MAX_CAP_CC;

123

124        //  If   the      command     code     is   smaller        than    TPM_CC_FIRST,     start     from  TPM_CC_FIRST

125        if(commandCode         <   TPM_CC_FIRST)               commandCode       =  TPM_CC_FIRST;

126

127        //  Collect       audit    commands

128        for(i    =  commandCode;           i   <=   TPM_CC_LAST;           i++)

129        {

130            if(CommandAuditIsRequired(i))

131            {

132                    if(commandList->count                   <  count)

133                    {

134                           //  If     we   have     not     filled     up  the      return  list,  add  this  command

135                           //  code       to   it

136                           commandList->commandCodes[commandList->count]                            =   i;

137                           commandList->count++;

138                    }

139                    else

140                    {

141                           //  If     the     return     list      is  full   but   we  still   have    command

142                           //  available,           report     this      and  stop      iterating

143                           more    =  YES;

144                           break;

145                    }

146            }

147        }

148

149        return      more;

150

151  }

     8.1.3.7        CommandAuditGetDigest

     This command is used to create a digest of the commands being audited. The commands are processed

     in ascending numeric order with a list of TPM_CC being added to a hash. This operates as if all the

     audited command codes were concatenated and then hashed.

152  void

153  CommandAuditGetDigest(

154        TPM2B_DIGEST              *digest                      //  OUT:    command      digest

155        )

156  {

     Page 112                                                     TCG Published                                     Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part  4: Supporting Routines                                                           Trusted  Platform  Module  Library

157        TPM_CC                                        i;

158        HASH_STATE                                    hashState;

159

160        //  Start   hash

161        digest->t.size       =      CryptStartHash(gp.auditHashAlg,             &hashState);

162

163        //  Add     command  code

164        for(i    =  TPM_CC_FIRST;          i   <=  TPM_CC_LAST;    i++)

165        {

166              if(CommandAuditIsRequired(i))

167              {

168                    CryptUpdateDigestInt(&hashState,                   sizeof(i),  &i);

169              }

170        }

171

172        //  Complete  hash

173        CryptCompleteHash2B(&hashState,                   &digest->b);

174

175        return;

176  }

     8.2       DA.c

     8.2.1       Introduction

     This file contains the functions and data definitions relating to the dictionary attack logic.

     8.2.2       Includes and Data Definitions

1    #define     DA_C

2    #include       "InternalRoutines.h"

     8.2.3       Functions

     8.2.3.1        DAPreInstall_Init()

     This function initializes the DA parameters to their manufacturer-default values. The default             values  are

     determined by a platform-specific specification.

     This function should not be called outside of a manufacturing or simulation environment.

     The DA parameters will be restored to these initial values by TPM2_Clear().

3    void

4    DAPreInstall_Init(

5          void

6          )

7    {

8          gp.failedTries       =      0;

9          gp.maxTries   =      3;

10         gp.recoveryTime          =  1000;                 //  in   seconds  (~16.67  minutes)

11         gp.lockoutRecovery              =  1000;          //  in   seconds

12         gp.lockOutAuthEnabled              =   TRUE;      //  Use  of  lockoutAuth   is  enabled

13

14         //  Record  persistent             DA  parameter      changes  to   NV

15         NvWriteReserved(NV_FAILED_TRIES,                  &gp.failedTries);

16         NvWriteReserved(NV_MAX_TRIES,                 &gp.maxTries);

17         NvWriteReserved(NV_RECOVERY_TIME,                     &gp.recoveryTime);

18         NvWriteReserved(NV_LOCKOUT_RECOVERY,                      &gp.lockoutRecovery);

19         NvWriteReserved(NV_LOCKOUT_AUTH_ENABLED,                       &gp.lockOutAuthEnabled);

20

     Family "2.0"                                            TCG Published                                     Page 113

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                      October 30, 2014
    Trusted Platform Module Library                                                                     Part 4: Supporting Routines

21        return;

22  }

    8.2.3.2         DAStartup()

    This function is called by TPM2_Startup() to initialize the DA parameters. In the case of Startup(CLEAR),

    use of lockoutAuth will be enabled if the lockout recovery time is 0. Otherwise, lockoutAuth will not be

    enabled until the TPM has been continuously powered for the lockoutRecovery time.

    This function requires that NV be available and not rate limiting.

23  void

24  DAStartup(

25        STARTUP_TYPE                  type                      //  IN:    startup   type

26        )

27  {

28        //   For  TPM     Reset,      if     lockoutRecovery           is  0,  enable    use  of  lockoutAuth.

29        if(type       ==  SU_RESET)

30        {

31              if(gp.lockoutRecovery                 ==  0)

32              {

33                      gp.lockOutAuthEnabled                 =   TRUE;

34                      //  Record      the    changes        to  NV

35                      NvWriteReserved(NV_LOCKOUT_AUTH_ENABLED,                           &gp.lockOutAuthEnabled);

36              }

37        }

38

39        //   If   DA  has     not     been   disabled          and  the    previous  shutdown     is  not  orderly

40        //   failedTries      is      not    already        at  its    maximum     then  increment    'failedTries'

41        if(       gp.recoveryTime               !=  0

42              &&  g_prevOrderlyState                ==  SHUTDOWN_NONE

43              &&  gp.failedTries             <  gp.maxTries)

44        {

45              gp.failedTries++;

46              //  Record      the     change        to  NV

47              NvWriteReserved(NV_FAILED_TRIES,                         &gp.failedTries);

48        }

49

50        //   Reset    self    healing        timers

51        s_selfHealTimer            =  g_time;

52        s_lockoutTimer        =       g_time;

53

54        return;

55  }

    8.2.3.3         DARegisterFailure()

    This function is called when a authorization failure occurs on an entity that is subject to dictionary-attack

    protection. When a DA failure is triggered, register the failure by resetting the relevant self-healing timer

    to the current time.

56  void

57  DARegisterFailure(

58        TPM_HANDLE                    handle                    //  IN:    handle   for  failure

59        )

60  {

61        //   Reset    the     timer   associated            with    lockout    if   the  handle   is  the  lockout  auth.

62        if(handle         ==  TPM_RH_LOCKOUT)

63              s_lockoutTimer          =      g_time;

64        else

65              s_selfHealTimer             =  g_time;

66

    Page 114                                                      TCG Published                                       Family "2.0"

    October 30, 2014                                  Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                         Trusted Platform Module Library

67         return;

68   }

     8.2.3.4         DASelfHeal()

     This function is called to check if sufficient time has passed to allow decrement of failedTries or to                                re-

     enable use of lockoutAuth.

     This function should be called when the time interval is updated.

69   void

70   DASelfHeal(

71         void

72         )

73   {

74         //  Regular       auth      self   healing              logic

75         //  If    no  failed        authorization                tries,    do    nothing.    Otherwise,           try  to

76         //  decrease        failedTries

77         if(gp.failedTries             !=   0)

78         {

79               //  if      recovery      time       is     0,     DA  logic     has     been  disabled.       Clear     failed    tries

80               //  immediately

81               if(gp.recoveryTime                ==     0)

82               {

83                       gp.failedTries            =   0;

84                       //  Update      NV   record

85                       NvWriteReserved(NV_FAILED_TRIES,                           &gp.failedTries);

86               }

87               else

88               {

89                       UINT64                       decreaseCount;

90

91                       //  In    the   unlikely            event      that    failedTries     should        become      larger    than

92                       //  maxTries

93                       if(gp.failedTries                >     gp.maxTries)

94                             gp.failedTries                =     gp.maxTries;

95

96                       //  How     much     can     failedTried           be    decreased

97                       decreaseCount        =       ((g_time          -  s_selfHealTimer)           /  1000)    /  gp.recoveryTime;

98

99                       if(gp.failedTries                <=       (UINT32)     decreaseCount)

100                            //    should   not         set       failedTries        below    zero

101                            gp.failedTries                =     0;

102                      else

103                            gp.failedTries                -=     (UINT32)      decreaseCount;

104

105                      //  the     cast     prevents             overflow     of  the   product

106                      s_selfHealTimer              +=     (decreaseCount            *  (UINT64)gp.recoveryTime)             *    1000;

107                      if(decreaseCount              !=       0)

108                            //    If  there        was       a   change    to    the   failedTries,        record      the  changes

109                            //    to  NV

110                            NvWriteReserved(NV_FAILED_TRIES,                           &gp.failedTries);

111              }

112        }

113

114        //  LockoutAuth           self     healing           logic

115        //  If    lockoutAuth         is   enabled,              do  nothing.          Otherwise,     try  to     see  if   we

116        //  may   enable        it

117        if(!gp.lockOutAuthEnabled)

118        {

119              //  if      lockout     authorization                  recovery    time  is    0,    a  reboot      is   required  to

120              //  re-enable           use  of      lockout           authorization.          Self-healing         would     not

121              //  apply       in    this   case.

122              if(gp.lockoutRecovery                    !=       0)

     Family "2.0"                                                       TCG Published                                               Page 115

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                Part 4: Supporting Routines

123              {

124                   if(((g_time          -  s_lockoutTimer)/1000)             >=  gp.lockoutRecovery)

125                   {

126                        gp.lockOutAuthEnabled                  =    TRUE;

127                        //     Record      the     changes     to   NV

128                        NvWriteReserved(NV_LOCKOUT_AUTH_ENABLED,                           &gp.lockOutAuthEnabled);

129                   }

130              }

131        }

132

133        return;

134  }

     8.3       Hierarchy.c

     8.3.1       Introduction

     This file contains the functions used for managing and accessing the hierarchy-related values.

     8.3.2       Includes

1    #include       "InternalRoutines.h"

     8.3.3       Functions

     8.3.3.1        HierarchyPreInstall()

     This   function  performs    the      initialization     functions  for  the  hierarchy  when  the  TPM  is  simulated.  This

     function should not be called if the TPM is not in a manufacturing mode at the manufacturer, or                          in a

     simulated environment.

2    void

3    HierarchyPreInstall_Init(

4          void

5          )

6    {

7          //  Allow     lockout     clear       command

8          gp.disableClear        =     FALSE;

9

10         //  Initialize      Primary        Seeds

11         gp.EPSeed.t.size          =     PRIMARY_SEED_SIZE;

12         CryptGenerateRandom(PRIMARY_SEED_SIZE,                          gp.EPSeed.t.buffer);

13         gp.SPSeed.t.size          =     PRIMARY_SEED_SIZE;

14         CryptGenerateRandom(PRIMARY_SEED_SIZE,                          gp.SPSeed.t.buffer);

15         gp.PPSeed.t.size          =     PRIMARY_SEED_SIZE;

16         CryptGenerateRandom(PRIMARY_SEED_SIZE,                          gp.PPSeed.t.buffer);

17

18         //  Initialize      owner,         endorsement         and  lockout     auth

19         gp.ownerAuth.t.size             =  0;

20         gp.endorsementAuth.t.size                  =   0;

21         gp.lockoutAuth.t.size              =   0;

22

23         //  Initialize      owner,         endorsement,        and    lockout    policy

24         gp.ownerAlg     =   TPM_ALG_NULL;

25         gp.ownerPolicy.t.size              =   0;

26         gp.endorsementAlg            =  TPM_ALG_NULL;

27         gp.endorsementPolicy.t.size                    =   0;

28         gp.lockoutAlg       =  TPM_ALG_NULL;

29         gp.lockoutPolicy.t.size                =   0;

30

     Page 116                                                     TCG Published                                   Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                     Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                    Trusted  Platform  Module  Library

31        //  Initialize        ehProof,      shProof           and  phProof

32        gp.phProof.t.size          =  PROOF_SIZE;

33        gp.shProof.t.size          =  PROOF_SIZE;

34        gp.ehProof.t.size          =  PROOF_SIZE;

35        CryptGenerateRandom(gp.phProof.t.size,                          gp.phProof.t.buffer);

36        CryptGenerateRandom(gp.shProof.t.size,                          gp.shProof.t.buffer);

37        CryptGenerateRandom(gp.ehProof.t.size,                          gp.ehProof.t.buffer);

38

39        //  Write  hierarchy          data     to  NV

40        NvWriteReserved(NV_DISABLE_CLEAR,                          &gp.disableClear);

41        NvWriteReserved(NV_EP_SEED,                   &gp.EPSeed);

42        NvWriteReserved(NV_SP_SEED,                   &gp.SPSeed);

43        NvWriteReserved(NV_PP_SEED,                   &gp.PPSeed);

44        NvWriteReserved(NV_OWNER_AUTH,                        &gp.ownerAuth);

45        NvWriteReserved(NV_ENDORSEMENT_AUTH,                        &gp.endorsementAuth);

46        NvWriteReserved(NV_LOCKOUT_AUTH,                          &gp.lockoutAuth);

47        NvWriteReserved(NV_OWNER_ALG,                      &gp.ownerAlg);

48        NvWriteReserved(NV_OWNER_POLICY,                          &gp.ownerPolicy);

49        NvWriteReserved(NV_ENDORSEMENT_ALG,                        &gp.endorsementAlg);

50        NvWriteReserved(NV_ENDORSEMENT_POLICY,                          &gp.endorsementPolicy);

51        NvWriteReserved(NV_LOCKOUT_ALG,                       &gp.lockoutAlg);

52        NvWriteReserved(NV_LOCKOUT_POLICY,                         &gp.lockoutPolicy);

53        NvWriteReserved(NV_PH_PROOF,                    &gp.phProof);

54        NvWriteReserved(NV_SH_PROOF,                    &gp.shProof);

55        NvWriteReserved(NV_EH_PROOF,                    &gp.ehProof);

56

57        return;

58  }

    8.3.3.2       HierarchyStartup()

    This function is called at TPM2_Startup() to initialize the hierarchy related values.

59  void

60  HierarchyStartup(

61        STARTUP_TYPE               type                       //   IN:  start   up     type

62        )

63  {

64        //  phEnable      is  SET     on  any      startup

65        g_phEnable     =  TRUE;

66

67        //  Reset  platformAuth,            platformPolicy;             enable     SH  and    EH  at  TPM_RESET  and

68        //  TPM_RESTART

69        if(type    !=  SU_RESUME)

70        {

71            gc.platformAuth.t.size                 =    0;

72            gc.platformPolicy.t.size                    =     0;

73

74            //   enable       the  storage         and     endorsement      hierarchies       and     the  platformNV

75            gc.shEnable        =   gc.ehEnable             =  gc.phEnableNV        =   TRUE;

76        }

77

78        //  nullProof     and      nullSeed        are     updated      at  every     TPM_RESET

79        if(type    ==  SU_RESET)

80        {

81            gr.nullProof.t.size                =   PROOF_SIZE;

82            CryptGenerateRandom(gr.nullProof.t.size,

83                                               gr.nullProof.t.buffer);

84            gr.nullSeed.t.size              =     PRIMARY_SEED_SIZE;

85            CryptGenerateRandom(PRIMARY_SEED_SIZE,                          gr.nullSeed.t.buffer);

86        }

87

88        return;

89  }

    Family "2.0"                                                TCG Published                                            Page 117

    Level 00 Revision 01.16                          Copyright © TCG 2006-2014                               October 30, 2014
     Trusted Platform Module Library                                         Part 4: Supporting Routines

     8.3.3.3      HierarchyGetProof()

     This function finds the proof value associated with a   hierarchy.It returns a pointer  to  the  proof  value.

90   TPM2B_AUTH   *

91   HierarchyGetProof(

92      TPMI_RH_HIERARCHY         hierarchy        //        IN:  hierarchy  constant

93      )

94   {

95      TPM2B_AUTH                *auth  =  NULL;

96

97      switch(hierarchy)

98      {

99      case   TPM_RH_PLATFORM:

100           //  phProof  for  TPM_RH_PLATFORM

101           auth   =  &gp.phProof;

102           break;

103     case   TPM_RH_ENDORSEMENT:

104           //  ehProof  for  TPM_RH_ENDORSEMENT

105           auth   =  &gp.ehProof;

106           break;

107     case   TPM_RH_OWNER:

108           //  shProof  for  TPM_RH_OWNER

109           auth   =  &gp.shProof;

110           break;

111     case   TPM_RH_NULL:

112           //  nullProof  for  TPM_RH_NULL

113           auth   =  &gr.nullProof;

114           break;

115     default:

116           pAssert(FALSE);

117           break;

118     }

119     return    auth;

120

121  }

     8.3.3.4      HierarchyGetPrimarySeed()

     This function returns the primary seed of a hierarchy.

122  TPM2B_SEED   *

123  HierarchyGetPrimarySeed(

124     TPMI_RH_HIERARCHY         hierarchy        //        IN:  hierarchy

125     )

126  {

127     TPM2B_SEED                *seed  =  NULL;

128     switch(hierarchy)

129     {

130     case   TPM_RH_PLATFORM:

131           seed   =  &gp.PPSeed;

132           break;

133     case   TPM_RH_OWNER:

134           seed   =  &gp.SPSeed;

135           break;

136     case   TPM_RH_ENDORSEMENT:

137           seed   =  &gp.EPSeed;

138           break;

139     case   TPM_RH_NULL:

140           return    &gr.nullSeed;

141     default:

142           pAssert(FALSE);

143           break;

144     }

     Page 118                                  TCG Published                                                 Family "2.0"

     October 30, 2014                    Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

145        return   seed;

146  }

     8.3.3.5       HierarchyIsEnabled()

     This function checks to see if a hierarchy is enabled.

     NOTE:             The TPM_RH_NULL hierarchy is always enabled.

     Return Value                       Meaning

     TRUE                               hierarchy is enabled

     FALSE                              hierarchy is disabled

147  BOOL

148  HierarchyIsEnabled(

149        TPMI_RH_HIERARCHY          hierarchy        //      IN:   hierarchy

150        )

151  {

152        BOOL                enabled     =  FALSE;

153

154        switch(hierarchy)

155        {

156        case  TPM_RH_PLATFORM:

157              enabled   =   g_phEnable;

158              break;

159        case  TPM_RH_OWNER:

160              enabled   =   gc.shEnable;

161              break;

162        case  TPM_RH_ENDORSEMENT:

163              enabled   =   gc.ehEnable;

164              break;

165        case  TPM_RH_NULL:

166              enabled   =   TRUE;

167              break;

168        default:

169              pAssert(FALSE);

170              break;

171        }

172        return   enabled;

173  }

     8.4      NV.c

     8.4.1       Introduction

     The NV memory is divided into two area: dynamic space for user defined NV Indices and evict objects,

     and reserved space for TPM persistent and state save data.

     8.4.2       Includes, Defines and Data Definitions

1    #define     NV_C

2    #include    "InternalRoutines.h"

3    #include    <Platform.h>

     NV Index/evict object iterator value

4    typedef           UINT32              NV_ITER;            //    type  of  a  NV  iterator

5    #define           NV_ITER_INIT        0xFFFFFFFF          //    initial   value  to  start  an

     Family "2.0"                                     TCG Published                                  Page 119

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                          October 30, 2014
    Trusted Platform Module Library                                                   Part 4: Supporting Routines

6                                                           //     iterator

    8.4.3       NV Utility Functions

    8.4.3.1       NvCheckState()

    Function to check the NV state by accessing the platform-specific function to get the NV state.  The result

    state is registered in s_NvIsAvailable that will be reported by NvIsAvailable().

    This function is called at the beginning of ExecuteCommand() before any potential call to NvIsAvailable().

7   void

8   NvCheckState(void)

9   {

10        int      func_return;

11

12        func_return  =    _plat__IsNvAvailable();

13        if(func_return    ==  0)

14        {

15              s_NvStatus  =   TPM_RC_SUCCESS;

16        }

17        else  if(func_return      ==  1)

18        {

19              s_NvStatus  =   TPM_RC_NV_UNAVAILABLE;

20        }

21        else

22        {

23              s_NvStatus  =   TPM_RC_NV_RATE;

24        }

25

26        return;

27  }

    8.4.3.2       NvIsAvailable()

    This function returns the NV availability parameter.

    Error Returns                       Meaning

    TPM_RC_SUCCESS                      NV is available

    TPM_RC_NV_RATE                      NV is unavailable because  of  rate  limit

    TPM_RC_NV_UNAVAILABLE               NV is inaccessible

28  TPM_RC

29  NvIsAvailable(

30        void

31        )

32  {

33        return   s_NvStatus;

34  }

    8.4.3.3       NvCommit

    This is a wrapper for the platform function to commit pending NV writes.

35  BOOL

36  NvCommit(

37        void

38        )

    Page 120                                     TCG Published                                       Family "2.0"

    October 30, 2014                        Copyright © TCG 2006-2014                 Level 00 Revision 01.16
    Part 4: Supporting Routines                                               Trusted Platform Module Library

39  {

40     BOOL           success  =  (_plat__NvCommit()  ==  0);

41     return     success;

42  }

    8.4.3.4     NvReadMaxCount()

    This function returns the max NV counter value.

43  static      UINT64

44  NvReadMaxCount(

45     void

46     )

47  {

48     UINT64             countValue;

49     _plat__NvMemoryRead(s_maxCountAddr,            sizeof(UINT64),         &countValue);

50     return     countValue;

51  }

    8.4.3.5     NvWriteMaxCount()

    This function updates the max counter value to NV memory.

52  static      void

53  NvWriteMaxCount(

54     UINT64                     maxCount

55     )

56  {

57     _plat__NvMemoryWrite(s_maxCountAddr,           sizeof(UINT64),         &maxCount);

58     return;

59  }

    8.4.4       NV Index and Persistent Object Access Functions

    8.4.4.1     Introduction

    These functions are used to access an NV Index and persistent object memory. In this implementation,

    the memory is simulated with RAM. The data in dynamic area is organized as a linked list, starting from

    address s_evictNvStart.    The first 4 bytes of a node in this link list is the offset of next node, followed by

    the data entry.   A 0-valued offset value indicates the end of the list.  If the data entry area of the last node

    happens to reach the end of the dynamic area without space left for an additional 4 byte end marker, the

    end address, s_evictNvEnd, should serve as the mark of list end

    8.4.4.2     NvNext()

    This function provides a method to traverse every data entry in NV dynamic area.

    To begin with, parameter iter should be initialized to NV_ITER_INIT indicating the first element.             Every

    time this function is called, the value in iter would be adjusted pointing to the next element in traversal.       If

    there is no next element, iter value would be 0. This function returns the address of the 'data entry'

    pointed by the iter.  If there is no more element in the set, a 0 value is returned indicating the end of

    traversal.

60  static      UINT32

61  NvNext(

62     NV_ITER                 *iter

63     )

64  {

    Family "2.0"                            TCG Published                                              Page 121

    Level 00 Revision 01.16                 Copyright © TCG 2006-2014                        October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

65      NV_ITER             currentIter;

66

67      //    If  iterator      is  at     the       beginning   of      list

68      if(*iter      ==    NV_ITER_INIT)

69      {

70            //    Initialize      iterator

71            *iter      =  s_evictNvStart;

72      }

73

74      //    If  iterator      reaches       the       end  of  NV  space,        or  iterator   indicates  list  end

75      if(*iter      +     sizeof(UINT32)           >  s_evictNvEnd         ||    *iter  ==  0)

76            return        0;

77

78      //    Save  the     current     iter         offset

79      currentIter         =   *iter;

80

81      //    Adjust     iter   pointer       pointing       to  next    entity

82      //    Read  pointer     value

83      _plat__NvMemoryRead(*iter,                      sizeof(UINT32),          iter);

84

85      if(*iter      ==    0)  return        0;

86

87      return      currentIter      +     sizeof(UINT32);                     //  entity     stores  after  the  pointer

88   }

     8.4.4.3      NvGetEnd()

     Function to find the end of the NV dynamic data list

89   static   UINT32

90   NvGetEnd(

91      void

92      )

93   {

94      NV_ITER                 iter       =  NV_ITER_INIT;

95      UINT32                  endAddr           =  s_evictNvStart;

96      UINT32                  currentAddr;

97

98      while((currentAddr           =     NvNext(&iter))            !=  0)

99            endAddr       =   currentAddr;

100

101     if(endAddr          !=  s_evictNvStart)

102     {

103           //    Read    offset

104           endAddr       -=  sizeof(UINT32);

105           _plat__NvMemoryRead(endAddr,                       sizeof(UINT32),          &endAddr);

106     }

107

108     return      endAddr;

109  }

     8.4.4.4      NvGetFreeByte

     This function returns the number of free octets in NV space.

110  static   UINT32

111  NvGetFreeByte(

112     void

113     )

114  {

115     return      s_evictNvEnd        -     NvGetEnd();

116  }

     Page 122                                                TCG Published                                         Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                         Trusted Platform Module Library

     8.4.4.5       NvGetEvictObjectSize

     This function returns the size of an evict object in NV space

117  static   UINT32

118  NvGetEvictObjectSize(

119     void

120     )

121  {

122     return     sizeof(TPM_HANDLE)              +     sizeof(OBJECT)              +   sizeof(UINT32);

123  }

     8.4.4.6       NvGetCounterSize

     This function returns the size of a counter index in NV space.

124  static   UINT32

125  NvGetCounterSize(

126     void

127     )

128  {

129     //    It   takes    an  offset        field,        a     handle    and  the        sizeof(NV_INDEX)          and

130     //    sizeof(UINT64)          for     counter          data

131     return     sizeof(TPM_HANDLE)              +     sizeof(NV_INDEX)                +  sizeof(UINT64)         +   sizeof(UINT32);

132  }

     8.4.4.7       NvTestSpace()

     This function will test if there is enough space to add a new entity.

     Return Value                             Meaning

     TRUE                                     space available

     FALSE                                    no enough space

133  static   BOOL

134  NvTestSpace(

135     UINT32                      size,                         //   IN:   size       of  the  entity    to    be    added

136     BOOL                        isIndex                       //   IN:   TRUE       if  the  entity    is    an    index

137     )

138  {

139     UINT32              remainByte        =    NvGetFreeByte();

140

141     //    For  NV   Index,      need      to   make        sure    that  we      do     not  allocate    and      Index   if  this

142     //    would    mean     that     the  TPM     cannot          allocate       the    minimum      number    of  evict

143     //    objects.

144     if(isIndex)

145     {

146           //   Get    the   number        of   persistent          objects          allocated

147           UINT32            persistentNum                  =  NvCapGetPersistentNumber();

148

149           //   If   we   have     not     allocated           the  requisite            number   of  evict     objects,       then  we

150           //   need     to  reserve       space         for   them.

151           //   NOTE:     some     of   this    is       not   written        as     simply   as  it  might        seem   because

152           //   the    values      are     all  unsigned            and   subtracting         needs   to    be     done   carefully

153           //   so   that    an    underflow          doesn't       cause     problems.

154           if(persistentNum             <  MIN_EVICT_OBJECTS)

155           {

156                  UINT32               needed      =     (MIN_EVICT_OBJECTS              -    persistentNum)

157                                                      *     NvGetEvictObjectSize();

158                  if(needed        >   remainByte)

     Family "2.0"                                                 TCG Published                                                   Page 123

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                                October 30, 2014
     Trusted Platform Module Library                                                                                   Part 4: Supporting   Routines

159                             remainByte           =     0;

160                    else

161                             remainByte           -=     needed;

162           }

163           //    if       the      requisite         number      of      evict   objects         have  been     allocated      then

164           //    no       need      to   reserve         additional           space

165     }

166     //    This     checks          for     the   size       of  the      value     being    added     plus     the     index  value.

167     //    NOTE:       This        does     not   check      to      see  if    the   end    marker    can      be   placed    in

168     //    memory         because        the     end     marker      will      not   be  written       if   it   will   not    fit.

169     return      (size          +   sizeof(UINT32)               <=  remainByte);

170  }

     8.4.4.8       NvAdd()

     This function adds a new entity to NV.

     This function requires that there is enough space to add a new entity (i.e., that NvTestSpace() has                                          been

     called and the available space is at least as large as the required space).

171  static   void

172  NvAdd(

173     UINT32                             totalSize,                   //   IN:   total    size    needed      for     this   entity    For

174                                                                     //         evict    object,       totalSize        is  the    same  as

175                                                                     //         bufferSize.            For  NV   Index,     totalSize      is

176                                                                     //         bufferSize       plus       index    data   size

177     UINT32                             bufferSize,                  //   IN:   size     of  initial        buffer

178     BYTE                            *entity                         //   IN:   initial      buffer

179     )

180  {

181     UINT32                          endAddr;

182     UINT32                          nextAddr;

183     UINT32                          listEnd         =   0;

184

185     //    Get   the      end       of   data     list

186     endAddr        =     NvGetEnd();

187

188     //    Calculate            the     value     of     next    pointer,        which       is  the   size     of   a  pointer    +

189     //    the   entity            data     size

190     nextAddr          =  endAddr           +  sizeof(UINT32)             +    totalSize;

191

192     //    Write       next        pointer

193     _plat__NvMemoryWrite(endAddr,                               sizeof(UINT32),             &nextAddr);

194

195     //    Write       entity        data

196     _plat__NvMemoryWrite(endAddr                            +   sizeof(UINT32),             bufferSize,         entity);

197

198     //    Write       the      end     of     list     if   it  is      not   going     to  exceed    the      NV   space

199     if(nextAddr             +     sizeof(UINT32)            <=      s_evictNvEnd)

200           _plat__NvMemoryWrite(nextAddr,                                 sizeof(UINT32),        &listEnd);

201

202     //    Set   the      flag       so     that     NV     changes       are   committed        before     the     command    completes.

203     g_updateNV           =     TRUE;

204  }

     8.4.4.9       NvDelete()

     This function is  used        to  delete an NV Index           or persistent object from NV memory.

205  static   void

206  NvDelete(

207     UINT32                             entityAddr                   //   IN:   address      of  entity      to     be  deleted

208     )

     Page 124                                                           TCG Published                                                   Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                             Trusted Platform Module Library

209  {

210        UINT32                         next;

211        UINT32                         entrySize;

212        UINT32                         entryAddr           =   entityAddr       -  sizeof(UINT32);

213        UINT32                         listEnd         =   0;

214

215        //  Get   the       offset           of   the     next     entry.

216        _plat__NvMemoryRead(entryAddr,                                sizeof(UINT32),        &next);

217

218        //  The   size         of     this       entry     is   the    difference       between       the  current      entry    and  the

219        //  next     entry.

220        entrySize        =     next       -  entryAddr;

221

222        //  Move     each         entry      after        the   current     one    to   fill     the  freed     space.

223        //  Stop     when         we   have       reached       the    end  of     all  the    indexes.        There  are   two

224        //  ways     to     detect           the  end      of   the    list.    The     first    is   to   notice     that  there

225        //  is   no  room          for       anything         else     because     we   are  at  the      end  of  NV.  The    other

226        //  indication             is     that    we      find     an  end  marker.

227

228        //  The   loop         condition          checks        for    the  end    of   NV.

229        while(next          +     sizeof(UINT32)               <=     s_evictNvEnd)

230        {

231            UINT32                     size,      oldAddr,            newAddr;

232

233            //    Now       check         for     the     end   marker

234            _plat__NvMemoryRead(next,                              sizeof(UINT32),           &oldAddr);

235            if(oldAddr                ==     0)

236                     break;

237

238            size     =      oldAddr          -    next;

239

240            //    Move         entry

241            _plat__NvMemoryMove(next,                              next  -  entrySize,         size);

242

243            //    Update           forward        link

244            newAddr            =   oldAddr        -    entrySize;

245            _plat__NvMemoryWrite(next                              -   entrySize,       sizeof(UINT32),         &newAddr);

246            next     =      oldAddr;

247        }

248        //  Mark     the       end     of    list

249        _plat__NvMemoryWrite(next                          -   entrySize,       sizeof(UINT32),            &listEnd);

250

251        //  Set   the       flag       so    that      NV     changes    are    committed        before    the     command   completes.

252        g_updateNV          =     TRUE;

253  }

     8.4.5     RAM-based NV Index Data Access Functions

     8.4.5.1        Introduction

     The data layout in ram buffer is {size of(NV_handle() + data), NV_handle(), data} for each NV Index data

     stored in RAM.

     NV storage is updated when a NV Index is added or deleted.                                 We do NOT updated NV storage when the

     data is updated/

     8.4.5.2        NvTestRAMSpace()

     This function indicates if there is enough RAM space to add a data for a new NV Index.

     Family "2.0"                                                         TCG Published                                                  Page 125

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                        October 30, 2014
     Trusted Platform Module Library                                                                         Part 4: Supporting Routines

     Return Value                                Meaning

     TRUE                                        space available

     FALSE                                       no enough space

254  static   BOOL

255  NvTestRAMSpace(

256     UINT32                      size                           //  IN:  size     of  the   data     to  be  added  to  RAM

257     )

258  {

259     BOOL              success          =     (      s_ramIndexSize

260                                                 +   size

261                                                 +   sizeof(TPM_HANDLE)            +  sizeof(UINT32)

262                                                 <=      RAM_INDEX_SPACE);

263     return     success;

264  }

     8.4.5.3      NvGetRamIndexOffset

     This function returns the offset of NV data in the RAM buffer

     This function requires that NV Index is in RAM. That is, the index must be known to exist.

265  static   UINT32

266  NvGetRAMIndexOffset(

267     TPMI_RH_NV_INDEX                      handle                   //   IN:   NV     handle

268     )

269  {

270     UINT32            currAddr            =     0;

271

272     while(currAddr        <     s_ramIndexSize)

273     {

274           TPMI_RH_NV_INDEX                      currHandle;

275           UINT32                                currSize;

276           currHandle      =     *  (TPM_HANDLE              *)     &s_ramIndex[currAddr          +  sizeof(UINT32)];

277

278           //   Found  a   match

279           if(currHandle            ==     handle)

280

281                 //  data     buffer             follows     the    handle    and     size  field

282                 break;

283

284           currSize    =   *     (UINT32             *)  &s_ramIndex[currAddr];

285           currAddr    +=     sizeof(UINT32)                 +   currSize;

286     }

287

288     //    We  assume  the       index           data    is  existing    in    RAM    space

289     pAssert(currAddr            <  s_ramIndexSize);

290     return     currAddr      +     sizeof(TPMI_RH_NV_INDEX)                   +   sizeof(UINT32);

291  }

     8.4.5.4      N v Ad d R AM ( )

     This function adds a new data area to RAM.

     This function requires that enough free RAM space is available to add the                          new  data.

292  static   void

293  NvAddRAM(

294     TPMI_RH_NV_INDEX                      handle,                  //   IN:   NV     handle

295     UINT32                                size                     //   IN:   size   of    data

296     )

     Page 126                                                      TCG Published                                           Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                               Level  00  Revision 01.16
     Part  4: Supporting Routines                                                                       Trusted Platform Module Library

297  {

298        //  Add   data       space  at    the      end  of   reserved          RAM    buffer

299        *   (UINT32     *)    &s_ramIndex[s_ramIndexSize]                      =  size     +  sizeof(TPMI_RH_NV_INDEX);

300        *   (TPMI_RH_NV_INDEX           *)     &s_ramIndex[s_ramIndexSize                     +  sizeof(UINT32)]      =   handle;

301        s_ramIndexSize        +=    sizeof(UINT32)               +  sizeof(TPMI_RH_NV_INDEX)                +  size;

302

303        pAssert(s_ramIndexSize                 <=  RAM_INDEX_SPACE);

304

305        //  Update      NV    version     of      s_ramIndexSize

306        _plat__NvMemoryWrite(s_ramIndexSizeAddr,                               sizeof(UINT32),       &s_ramIndexSize);

307

308        //  Write    reserved       RAM     space       to   NV     to  reflect       the     newly  added     NV  Index

309        _plat__NvMemoryWrite(s_ramIndexAddr,                            RAM_INDEX_SPACE,             s_ramIndex);

310

311        return;

312  }

     8.4.5.5        NvDeleteRAM()

     This function is used to delete a RAM-backed NV Index data area.

     This function assumes the data of NV Index exists in RAM

313  static    void

314  NvDeleteRAM(

315        TPMI_RH_NV_INDEX                  handle                        //  IN:   NV  handle

316        )

317  {

318        UINT32                     nodeOffset;

319        UINT32                     nextNode;

320        UINT32                     size;

321

322        nodeOffset        =   NvGetRAMIndexOffset(handle);

323

324        //  Move     the     pointer    back       to   get  the        size   field    of    this   node

325        nodeOffset        -=  sizeof(UINT32)            +    sizeof(TPMI_RH_NV_INDEX);

326

327        //  Get   node       size

328        size  =   *  (UINT32        *)  &s_ramIndex[nodeOffset];

329

330        //  Get   the     offset    of    next     node

331        nextNode     =    nodeOffset        +     sizeof(UINT32)            +  size;

332

333        //  Move     data

334        MemoryMove(s_ramIndex               +     nodeOffset,           s_ramIndex      +     nextNode,

335                          s_ramIndexSize           -    nextNode,           s_ramIndexSize       -   nextNode);

336

337        //  Update      RAM   size

338        s_ramIndexSize        -=    size       +   sizeof(UINT32);

339

340        //  Update      NV    version     of      s_ramIndexSize

341        _plat__NvMemoryWrite(s_ramIndexSizeAddr,                               sizeof(UINT32),       &s_ramIndexSize);

342

343        //  Write    reserved       RAM     space       to   NV     to  reflect       the     newly  delete    NV  Index

344        _plat__NvMemoryWrite(s_ramIndexAddr,                            RAM_INDEX_SPACE,             s_ramIndex);

345

346        return;

347  }

     Family "2.0"                                               TCG Published                                                Page 127

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                               Part 4: Supporting Routines

     8.4.6    Utility Functions

     8.4.6.1       NvInitStatic()

     This function initializes the static variables used in the NV subsystem.

348  static   void

349  NvInitStatic(

350     void

351     )

352  {

353     UINT16               i;

354     UINT32               reservedAddr;

355

356     s_reservedSize[NV_DISABLE_CLEAR]                                 =     sizeof(gp.disableClear);

357     s_reservedSize[NV_OWNER_ALG]                         =     sizeof(gp.ownerAlg);

358     s_reservedSize[NV_ENDORSEMENT_ALG]                                     =     sizeof(gp.endorsementAlg);

359     s_reservedSize[NV_LOCKOUT_ALG]                             =     sizeof(gp.lockoutAlg);

360     s_reservedSize[NV_OWNER_POLICY]                               =     sizeof(gp.ownerPolicy);

361     s_reservedSize[NV_ENDORSEMENT_POLICY]                                           =   sizeof(gp.endorsementPolicy);

362     s_reservedSize[NV_LOCKOUT_POLICY]                                   =     sizeof(gp.lockoutPolicy);

363     s_reservedSize[NV_OWNER_AUTH]                           =     sizeof(gp.ownerAuth);

364     s_reservedSize[NV_ENDORSEMENT_AUTH]                                       =     sizeof(gp.endorsementAuth);

365     s_reservedSize[NV_LOCKOUT_AUTH]                               =     sizeof(gp.lockoutAuth);

366     s_reservedSize[NV_EP_SEED]                     =     sizeof(gp.EPSeed);

367     s_reservedSize[NV_SP_SEED]                     =     sizeof(gp.SPSeed);

368     s_reservedSize[NV_PP_SEED]                     =     sizeof(gp.PPSeed);

369     s_reservedSize[NV_PH_PROOF]                       =     sizeof(gp.phProof);

370     s_reservedSize[NV_SH_PROOF]                       =     sizeof(gp.shProof);

371     s_reservedSize[NV_EH_PROOF]                       =     sizeof(gp.ehProof);

372     s_reservedSize[NV_TOTAL_RESET_COUNT]                                         =     sizeof(gp.totalResetCount);

373     s_reservedSize[NV_RESET_COUNT]                             =     sizeof(gp.resetCount);

374     s_reservedSize[NV_PCR_POLICIES]                               =     sizeof(gp.pcrPolicies);

375     s_reservedSize[NV_PCR_ALLOCATED]                                 =     sizeof(gp.pcrAllocated);

376     s_reservedSize[NV_PP_LIST]                     =     sizeof(gp.ppList);

377     s_reservedSize[NV_FAILED_TRIES]                               =     sizeof(gp.failedTries);

378     s_reservedSize[NV_MAX_TRIES]                         =     sizeof(gp.maxTries);

379     s_reservedSize[NV_RECOVERY_TIME]                                 =     sizeof(gp.recoveryTime);

380     s_reservedSize[NV_LOCKOUT_RECOVERY]                                       =     sizeof(gp.lockoutRecovery);

381     s_reservedSize[NV_LOCKOUT_AUTH_ENABLED]                                             =   sizeof(gp.lockOutAuthEnabled);

382     s_reservedSize[NV_ORDERLY]                     =     sizeof(gp.orderlyState);

383     s_reservedSize[NV_AUDIT_COMMANDS]                                   =     sizeof(gp.auditComands);

384     s_reservedSize[NV_AUDIT_HASH_ALG]                                   =     sizeof(gp.auditHashAlg);

385     s_reservedSize[NV_AUDIT_COUNTER]                                 =     sizeof(gp.auditCounter);

386     s_reservedSize[NV_ALGORITHM_SET]                                 =     sizeof(gp.algorithmSet);

387     s_reservedSize[NV_FIRMWARE_V1]                             =     sizeof(gp.firmwareV1);

388     s_reservedSize[NV_FIRMWARE_V2]                             =     sizeof(gp.firmwareV2);

389     s_reservedSize[NV_ORDERLY_DATA]                               =     sizeof(go);

390     s_reservedSize[NV_STATE_CLEAR]                             =     sizeof(gc);

391     s_reservedSize[NV_STATE_RESET]                             =     sizeof(gr);

392

393     //    Initialize         reserved      data       address.                      In     this  implementation,  reserved  data

394     //    is   stored    at  the        start   of       NV       memory

395     reservedAddr         =   0;

396     for(i      =  0;  i  <   NV_RESERVE_LAST;                     i++)

397     {

398           s_reservedAddr[i]             =  reservedAddr;

399           reservedAddr           +=     s_reservedSize[i];

400     }

401

402     //    Initialize         auxiliary     variable                  space             for  index/evict  implementation.

403     //    Auxiliary      variables         are     stored               after           reserved  data   area

404     //    RAM     index  copy    starts        at     the         beginning

405     s_ramIndexSizeAddr               =  reservedAddr;

     Page 128                                                         TCG Published                                             Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                                         Level 00 Revision 01.16
     Part  4: Supporting Routines                                                              Trusted Platform Module  Library

406        s_ramIndexAddr        =     s_ramIndexSizeAddr           +  sizeof(UINT32);

407

408        //  Maximum  counter        value

409        s_maxCountAddr        =     s_ramIndexAddr       +   RAM_INDEX_SPACE;

410

411        //  dynamic  memory         start

412        s_evictNvStart        =     s_maxCountAddr       +   sizeof(UINT64);

413

414        //  dynamic  memory         ends    at  the  end     of     NV  memory

415        s_evictNvEnd      =   NV_MEMORY_SIZE;

416

417        return;

418  }

     8.4.6.2       NvInit()

     This function initializes the NV system at pre-install time.

     This function should only be called in a manufacturing environment or in a simulation.

     The layout of NV memory space is an implementation choice.

419  void

420  NvInit(

421        void

422        )

423  {

424        UINT32        nullPointer           =   0;

425        UINT64        zeroCounter           =   0;

426

427        //  Initialize       static     variables

428        NvInitStatic();

429

430        //  Initialize       RAM    index   space    as     unused

431        _plat__NvMemoryWrite(s_ramIndexSizeAddr,                        sizeof(UINT32),     &nullPointer);

432

433        //  Initialize       max    counter     value    to  0

434        _plat__NvMemoryWrite(s_maxCountAddr,                        sizeof(UINT64),      &zeroCounter);

435

436        //  Initialize       the    next    offset   of     the     first     entry  in  evict/index  list  to  0

437        _plat__NvMemoryWrite(s_evictNvStart,                        sizeof(TPM_HANDLE),     &nullPointer);

438

439        return;

440

441  }

     8.4.6.3       NvReadReserved()

     This function is used to move reserved data from NV memory to RAM.

442  void

443  NvReadReserved(

444        NV_RESERVE                  type,                //  IN:        type  of  reserved  data

445        void                     *buffer                 //  OUT:       buffer    receives  the   data.

446        )

447  {

448        //  Input  type      should     be  valid

449        pAssert(type      >=     0  &&  type    <   NV_RESERVE_LAST);

450

451        _plat__NvMemoryRead(s_reservedAddr[type],                          s_reservedSize[type],      buffer);

452        return;

453  }

     Family "2.0"                                           TCG Published                                             Page 129

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                       Part 4: Supporting Routines

     8.4.6.4        NvWriteReserved()

     This function is used to post a reserved data for writing to NV memory. Before the TPM completes   the

     operation, the value will be written.

454  void

455  NvWriteReserved(

456        NV_RESERVE               type,              //  IN:   type  of  reserved  data

457        void                  *buffer               //  IN:   data  buffer

458        )

459  {

460        //  Input  type   should     be  valid

461        pAssert(type      >=  0  &&  type    <  NV_RESERVE_LAST);

462

463        _plat__NvMemoryWrite(s_reservedAddr[type],                  s_reservedSize[type],  buffer);

464

465        //  Set   the  flag   that   a   NV  write  happens

466        g_updateNV     =  TRUE;

467        return;

468  }

     8.4.6.5        NvReadPersistent()

     This function reads persistent data to the RAM copy of the gp structure.

469  void

470  NvReadPersistent(

471        void

472        )

473  {

474        //  Hierarchy     persistent     data

475        NvReadReserved(NV_DISABLE_CLEAR,            &gp.disableClear);

476        NvReadReserved(NV_OWNER_ALG,            &gp.ownerAlg);

477        NvReadReserved(NV_ENDORSEMENT_ALG,              &gp.endorsementAlg);

478        NvReadReserved(NV_LOCKOUT_ALG,              &gp.lockoutAlg);

479        NvReadReserved(NV_OWNER_POLICY,             &gp.ownerPolicy);

480        NvReadReserved(NV_ENDORSEMENT_POLICY,                &gp.endorsementPolicy);

481        NvReadReserved(NV_LOCKOUT_POLICY,               &gp.lockoutPolicy);

482        NvReadReserved(NV_OWNER_AUTH,           &gp.ownerAuth);

483        NvReadReserved(NV_ENDORSEMENT_AUTH,               &gp.endorsementAuth);

484        NvReadReserved(NV_LOCKOUT_AUTH,             &gp.lockoutAuth);

485        NvReadReserved(NV_EP_SEED,              &gp.EPSeed);

486        NvReadReserved(NV_SP_SEED,              &gp.SPSeed);

487        NvReadReserved(NV_PP_SEED,              &gp.PPSeed);

488        NvReadReserved(NV_PH_PROOF,             &gp.phProof);

489        NvReadReserved(NV_SH_PROOF,             &gp.shProof);

490        NvReadReserved(NV_EH_PROOF,             &gp.ehProof);

491

492        //  Time   persistent    data

493        NvReadReserved(NV_TOTAL_RESET_COUNT,              &gp.totalResetCount);

494        NvReadReserved(NV_RESET_COUNT,              &gp.resetCount);

495

496        //  PCR   persistent     data

497        NvReadReserved(NV_PCR_POLICIES,             &gp.pcrPolicies);

498        NvReadReserved(NV_PCR_ALLOCATED,            &gp.pcrAllocated);

499

500        //  Physical      Presence   persistent     data

501        NvReadReserved(NV_PP_LIST,              &gp.ppList);

502

503        //  Dictionary    attack     values     persistent    data

504        NvReadReserved(NV_FAILED_TRIES,             &gp.failedTries);

505        NvReadReserved(NV_MAX_TRIES,            &gp.maxTries);

506        NvReadReserved(NV_RECOVERY_TIME,            &gp.recoveryTime);

     Page 130                                          TCG Published                          Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                  Level 00 Revision 01.16
     Part  4: Supporting Routines                                                     Trusted Platform      Module  Library

507        NvReadReserved(NV_LOCKOUT_RECOVERY,            &gp.lockoutRecovery);

508        NvReadReserved(NV_LOCKOUT_AUTH_ENABLED,                &gp.lockOutAuthEnabled);

509

510        //  Orderly   State   persistent  data

511        NvReadReserved(NV_ORDERLY,        &gp.orderlyState);

512

513        //  Command   audit   values  persistent     data

514        NvReadReserved(NV_AUDIT_COMMANDS,            &gp.auditComands);

515        NvReadReserved(NV_AUDIT_HASH_ALG,            &gp.auditHashAlg);

516        NvReadReserved(NV_AUDIT_COUNTER,          &gp.auditCounter);

517

518        //  Algorithm  selection      persistent     data

519        NvReadReserved(NV_ALGORITHM_SET,          &gp.algorithmSet);

520

521        //  Firmware   version  persistent  data

522        NvReadReserved(NV_FIRMWARE_V1,      &gp.firmwareV1);

523        NvReadReserved(NV_FIRMWARE_V2,      &gp.firmwareV2);

524

525        return;

526  }

     8.4.6.6       NvIsPlatformPersistentHandle()

     This function indicates if a handle references a persistent object in the range belonging to the platform.

     Return Value                    Meaning

     TRUE                            handle references a platform persistent object

     FALSE                           handle  does    not    reference  platform   persistent  object   and  may

                                     reference an owner persistent object either

527  BOOL

528  NvIsPlatformPersistentHandle(

529        TPM_HANDLE            handle             //  IN:   handle

530        )

531  {

532        return   (handle  >=    PLATFORM_PERSISTENT        &&  handle  <=  PERSISTENT_LAST);

533  }

     8.4.6.7       NvIsOwnerPersistentHandle()

     This function indicates if a handle references a persistent object in the range belonging to the owner.

     Return Value                    Meaning

     TRUE                            handle is owner persistent handle

     FALSE                           handle is not owner persistent handle       and  may  not  be  a  persistent

                                     handle at all

534  BOOL

535  NvIsOwnerPersistentHandle(

536        TPM_HANDLE            handle             //  IN:   handle

537        )

538  {

539        return   (handle  >=    PERSISTENT_FIRST     &&    handle   <  PLATFORM_PERSISTENT);

540  }

     8.4.6.8       NvNextIndex()

     This function returns the offset in NV of the next NV Index entry.   A value of 0 indicates the end of the list.

     Family "2.0"                                   TCG Published                                                  Page 131

     Level 00 Revision 01.16             Copyright © TCG 2006-2014                                     October 30, 2014
     Trusted Platform Module Library                                                    Part 4: Supporting Routines

541  static    UINT32

542  NvNextIndex(

543         NV_ITER                *iter

544         )

545  {

546         UINT32          addr;

547         TPM_HANDLE      handle;

548

549         while((addr     =  NvNext(iter))   !=  0)

550         {

551            //    Read   handle

552            _plat__NvMemoryRead(addr,           sizeof(TPM_HANDLE),       &handle);

553            if(HandleGetType(handle)        ==  TPM_HT_NV_INDEX)

554                  return        addr;

555         }

556

557         pAssert(addr       ==  0);

558         return   addr;

559  }

     8.4.6.9        NvNextEvict()

     This function returns the offset in NV of the next evict object entry.  A value of  0  indicates  the   end  of  the

     list.

560  static    UINT32

561  NvNextEvict(

562         NV_ITER                *iter

563         )

564  {

565         UINT32          addr;

566         TPM_HANDLE      handle;

567

568         while((addr     =  NvNext(iter))   !=  0)

569         {

570            //    Read   handle

571            _plat__NvMemoryRead(addr,           sizeof(TPM_HANDLE),       &handle);

572            if(HandleGetType(handle)        ==  TPM_HT_PERSISTENT)

573                  return        addr;

574         }

575

576         pAssert(addr       ==  0);

577         return   addr;

578  }

     8.4.6.10       NvFindHandle()

     this function returns the offset in NV memory of the entity associated with the input handle.           A value  of

     zero indicates that handle does not exist reference an existing persistent object or defined NV Index.

579  static    UINT32

580  NvFindHandle(

581         TPM_HANDLE             handle

582         )

583  {

584         UINT32                 addr;

585         NV_ITER                iter   =  NV_ITER_INIT;

586

587         while((addr     =  NvNext(&iter))  !=  0)

588         {

589            TPM_HANDLE                    entityHandle;

590            //    Read   handle

     Page 132                                      TCG Published                                       Family "2.0"

     October 30, 2014                         Copyright © TCG 2006-2014                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                    Trusted Platform Module Library

591              _plat__NvMemoryRead(addr,                sizeof(TPM_HANDLE),              &entityHandle);

592              if(entityHandle            ==  handle)

593                    return       addr;

594        }

595

596        pAssert(addr         ==  0);

597        return    addr;

598  }

     8.4.6.11        NvPowerOn()

     This function is called at _TPM_Init() to initialize the NV environment.

     Return Value                               Meaning

     TRUE                                       all NV was initialized

     FALSE                                      the   NV     containing        saved     state      had   an  error    and

                                                TPM2_Startup(CLEAR) is required

599  BOOL

600  NvPowerOn(

601        void

602        )

603  {

604        int                  nvError     =   0;

605        //   If   power     was  lost,       need  to  re-establish         the    RAM  data     that  is  loaded   from

606        //   NV   and   initialize       the      static  variables

607        if(_plat__WasPowerLost(TRUE))

608        {

609              if((nvError        =   _plat__NVEnable(0))             <  0)

610                    FAIL(FATAL_ERROR_NV_UNRECOVERABLE);

611

612              NvInitStatic();

613        }

614

615        return    nvError        ==  0;

616  }

     8.4.6.12        NvStateSave()

     This function is used to cause the memory containing the RAM backed NV Indices to be written                           to  NV.

617  void

618  NvStateSave(

619        void

620        )

621  {

622        //   Write     RAM   backed      NV  Index     info  to  NV

623        //   No   need   to  save     s_ramIndexSize         because        we  save    it   to  NV   whenever  it  is

624        //   updated.

625        _plat__NvMemoryWrite(s_ramIndexAddr,                     RAM_INDEX_SPACE,            s_ramIndex);

626

627        //   Set  the    flag    so   that    an   NV  write     happens        before  the      command   completes.

628        g_updateNV       =   TRUE;

629

630        return;

631  }

     Family "2.0"                                            TCG Published                                                  Page 133

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

     8.4.6.13      NvEntityStartup()

     This function is called at TPM_Startup(). If the startup completes a TPM Resume                              cycle,   no  action  is

     taken. If the startup is a TPM Reset or a TPM Restart, then this function will:

     a)  clear read/write lock;

     b)  reset NV Index data that has TPMA_NV_CLEAR_STCLEAR SET; and

     c)  set the lower bits in orderly counters to 1 for a non-orderly startup

     It is a prerequisite that NV be available for writing before this function is called.

632  void

633  NvEntityStartup(

634        STARTUP_TYPE               type                   //   IN:      start       up   type

635        )

636  {

637        NV_ITER                           iter   =  NV_ITER_INIT;

638        UINT32                            currentAddr;                     //   offset      points  to   the   current  entity

639

640        //  Restore     RAM     index      data

641        _plat__NvMemoryRead(s_ramIndexSizeAddr,                            sizeof(UINT32),          &s_ramIndexSize);

642        _plat__NvMemoryRead(s_ramIndexAddr,                        RAM_INDEX_SPACE,              s_ramIndex);

643

644        //  If  recovering         from    state      save,    do   nothing

645        if(type     ==  SU_RESUME)

646            return;

647

648        //  Iterate     all     the    NV  Index      to  clear     the     locks

649        while((currentAddr             =   NvNextIndex(&iter))              !=   0)

650        {

651            NV_INDEX               nvIndex;

652            UINT32                 indexAddr;                              //   NV   address     points    to  index  info

653            TPMA_NV                attributes;

654

655            indexAddr        =     currentAddr        +   sizeof(TPM_HANDLE);

656

657            //   Read   NV      Index      info     structure

658            _plat__NvMemoryRead(indexAddr,                     sizeof(NV_INDEX),                 &nvIndex);

659            attributes          =  nvIndex.publicArea.attributes;

660

661            //   Clear     read/write           lock

662            if(attributes.TPMA_NV_READLOCKED                        ==     SET)

663                    attributes.TPMA_NV_READLOCKED                   =      CLEAR;

664

665            if(         attributes.TPMA_NV_WRITELOCKED                          ==   SET

666                    &&  (          attributes.TPMA_NV_WRITTEN                   ==   CLEAR

667                        ||         attributes.TPMA_NV_WRITEDEFINE                       ==  CLEAR

668                        )

669                 )

670                    attributes.TPMA_NV_WRITELOCKED                      =   CLEAR;

671

672            //   Reset     NV      data    for   TPMA_NV_CLEAR_STCLEAR

673            if(attributes.TPMA_NV_CLEAR_STCLEAR                            ==   SET)

674            {

675                    attributes.TPMA_NV_WRITTEN                 =    CLEAR;

676                    attributes.TPMA_NV_WRITELOCKED                      =   CLEAR;

677            }

678

679            //   Reset     NV      data    for   orderly       values      that     are     not  counters

680            //   NOTE:     The     function         has   already   exited          on   a  TPM  Resume,   so  the    only

681            //   things      being        processed       are  TPM  Restart          and    TPM  Reset

682            if(         type       ==     SU_RESET

683                    &&  attributes.TPMA_NV_ORDERLY                      ==     SET

684                    &&  attributes.TPMA_NV_COUNTER                      ==     CLEAR

     Page 134                                                TCG Published                                                 Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                           Trusted Platform Module Library

685                  )

686                     attributes.TPMA_NV_WRITTEN                       =   CLEAR;

687

688              //     Write       NV  Index        info  back      if  it  has  changed

689              if(*((UINT32               *)&attributes)           !=  *((UINT32      *)&nvIndex.publicArea.attributes))

690              {

691                     nvIndex.publicArea.attributes                        =   attributes;

692                     _plat__NvMemoryWrite(indexAddr,                          sizeof(NV_INDEX),             &nvIndex);

693

694                     //      Set     the   flag    that      a   NV   write   happens

695                     g_updateNV            =   TRUE;

696              }

697              //     Set     the     lower     bits     in   an   orderly     counter       to   1  for  a     non-orderly    startup

698              if(         g_prevOrderlyState                 ==   SHUTDOWN_NONE

699                     &&   attributes.TPMA_NV_WRITTEN                      ==  SET)

700              {

701                     if(          attributes.TPMA_NV_ORDERLY                   ==   SET

702                             &&   attributes.TPMA_NV_COUNTER                   ==   SET)

703                     {

704                             TPMI_RH_NV_INDEX                     nvHandle;

705                             UINT64                               counter;

706

707                             //      Read     NV   handle

708                             _plat__NvMemoryRead(currentAddr,                        sizeof(TPM_HANDLE),             &nvHandle);

709

710                             //      Read     the  counter        value   saved     to   NV     upon  the      last  roll    over.

711                             //      Do   not     use   RAM     backed    storage    for     this     once.

712                             nvIndex.publicArea.attributes.TPMA_NV_ORDERLY                                  =  CLEAR;

713                             NvGetIntIndexData(nvHandle,                      &nvIndex,         &counter);

714                             nvIndex.publicArea.attributes.TPMA_NV_ORDERLY                                  =  SET;

715

716                             //      Set   the     lower     bits     of  counter    to     1's

717                             counter          |=   MAX_ORDERLY_COUNT;

718

719                             //      Write     back     to   RAM

720                             NvWriteIndexData(nvHandle,                       &nvIndex,      0,     sizeof(counter),         &counter);

721

722                             //      No   write    to   NV      because   an   orderly       shutdown       will     update  the

723                             //      counters.

724

725                     }

726              }

727        }

728

729        return;

730

731  }

     8.4.7       NV Access Functions

     8.4.7.1         Introduction

     This   set  of  functions          provide      accessing      NV   Index   and    persistent     objects    based   using  a     handle  for

     reference to the entity.

     8.4.7.2         NvIsUndefinedIndex()

     This     function      is  used         to   verify   that      an    NV    Index     is   not    defined.   This    is    only   used    by

     TPM2_NV_DefineSpace().

     Family "2.0"                                                    TCG Published                                                     Page 135

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

     Return Value                              Meaning

     TRUE                                      the handle points to an existing NV Index

     FALSE                                     the handle points to a non-existent Index

732  BOOL

733  NvIsUndefinedIndex(

734        TPMI_RH_NV_INDEX                handle               //  IN:  handle

735        )

736  {

737        UINT32                    entityAddr;                //  offset      points    to  the  entity

738

739        pAssert(HandleGetType(handle)                ==      TPM_HT_NV_INDEX);

740

741        //  Find  the     address       of  index

742        entityAddr     =  NvFindHandle(handle);

743

744        //  If  handle    is      not   found,     return    TPM_RC_SUCCESS

745        if(entityAddr         ==  0)

746            return     TPM_RC_SUCCESS;

747

748        //  NV  Index     is  defined

749        return    TPM_RC_NV_DEFINED;

750  }

     8.4.7.3       NvIndexIsAccessible()

     This function validates         that  a   handle  references   a  defined  NV  Index     and  that  the  Index  is  current ly

     accessible.

     Error Returns                             Meaning

     TPM_RC_HANDLE                             the handle points to an undefined NV Index If shEnable is CLEAR,

                                               this would include an index created using ownerAuth. If phEnableNV

                                               is CLEAR, this would include and index created using platform auth

     TPM_RC_NV_READLOCKED                      Index is present but locked for reading and command does not write

                                               to the index

     TPM_RC_NV_WRITELOCKED                     Index is present but locked for writing and command writes to the

                                               index

751  TPM_RC

752  NvIndexIsAccessible(

753        TPMI_RH_NV_INDEX                handle,              //  IN:  handle

754        TPM_CC                          commandCode          //  IN:  the    command

755        )

756  {

757        UINT32                          entityAddr;          //  offset      points    to  the  entity

758        NV_INDEX                        nvIndex;             //

759

760        pAssert(HandleGetType(handle)                ==      TPM_HT_NV_INDEX);

761

762        //  Find  the     address       of  index

763        entityAddr     =  NvFindHandle(handle);

764

765        //  If  handle    is      not   found,     return    TPM_RC_HANDLE

766        if(entityAddr         ==  0)

767            return     TPM_RC_HANDLE;

768

769        //  Read  NV   Index      info      structure

770        _plat__NvMemoryRead(entityAddr                    +  sizeof(TPM_HANDLE),       sizeof(NV_INDEX),

771                                            &nvIndex);

     Page 136                                                   TCG Published                                      Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                    Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                    Trusted Platform Module Library

772

773     if(gc.shEnable           ==      FALSE    ||  gc.phEnableNV           ==  FALSE)

774     {

775           //    if  shEnable          is     CLEAR,   an     ownerCreate      NV  Index      should  not  be

776           //    indicated        as      present

777           if(nvIndex.publicArea.attributes.TPMA_NV_PLATFORMCREATE                                    ==   CLEAR)

778           {

779                 if(gc.shEnable                ==  FALSE)

780                          return       TPM_RC_HANDLE;

781           }

782           //    if  phEnableNV            is  CLEAR,      a  platform       created    Index    should    not

783           //    be  visible

784           else      if(gc.phEnableNV              ==  FALSE)

785                 return       TPM_RC_HANDLE;

786     }

787

788     //    If  the   Index        is   write       locked     and  this    is  an  NV   Write    operation...

789     if(         nvIndex.publicArea.attributes.TPMA_NV_WRITELOCKED

790           &&    IsWriteOperation(commandCode))

791     {

792           //    then     return       a   locked      indication        unless    the  command  is   TPM2_NV_WriteLock

793           if(commandCode              !=     TPM_CC_NV_WriteLock)

794                 return       TPM_RC_NV_LOCKED;

795           return      TPM_RC_SUCCESS;

796     }

797     //    If  the   Index        is   read    locked      and     this  is    an  NV   Read  operation...

798     if(         nvIndex.publicArea.attributes.TPMA_NV_READLOCKED

799           &&    IsReadOperation(commandCode))

800     {

801           //    then     return       a   locked      indication        unless    the  command  is   TPM2_NV_ReadLock

802           if(commandCode              !=     TPM_CC_NV_ReadLock)

803                 return       TPM_RC_NV_LOCKED;

804           return      TPM_RC_SUCCESS;

805     }

806

807     //    NV  Index      is  accessible

808     return      TPM_RC_SUCCESS;

809  }

     8.4.7.4      NvIsUndefinedEvictHandle()

     This function indicates if a handle does not reference an existing persistent object.                    This function requires

     that the handle be in the proper range for persistent objects.

     Return Value                                Meaning

     TRUE                                        handle does not reference an existing persistent object

     FALSE                                       handle does reference an existing persistent object

810  static   BOOL

811  NvIsUndefinedEvictHandle(

812     TPM_HANDLE                   handle                      //   IN:   handle

813     )

814  {

815     UINT32                       entityAddr;                 //   offset    points     to  the  entity

816     pAssert(HandleGetType(handle)                     ==     TPM_HT_PERSISTENT);

817

818     //    Find  the      address         of   evict   object

819     entityAddr        =  NvFindHandle(handle);

820

821     //    If  handle     is      not     found,   return         TRUE

822     if(entityAddr            ==  0)

823           return      TRUE;

     Family "2.0"                                                TCG Published                                        Page 137

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

824        else

825              return    FALSE;

826  }

     8.4.7.5         NvGetEvictObject()

     This function is used to dereference an evict object handle and get a pointer to the object.

     Error Returns                           Meaning

     TPM_RC_HANDLE                           the handle does not point to an existing persistent object

827  TPM_RC

828  NvGetEvictObject(

829        TPM_HANDLE                handle,                 //  IN:     handle

830        OBJECT                  *object                   //  OUT:    object      data

831        )

832  {

833        UINT32                  entityAddr;                       //  offset     points  to   the  entity

834        TPM_RC                  result    =   TPM_RC_SUCCESS;

835

836        pAssert(HandleGetType(handle)                 ==    TPM_HT_PERSISTENT);

837

838        //  Find  the      address    of  evict  object

839        entityAddr      =  NvFindHandle(handle);

840

841        //  If    handle   is   not   found,     return       an  error

842        if(entityAddr      ==     0)

843              result    =  TPM_RC_HANDLE;

844        else

845              //  Read     evict  object

846              _plat__NvMemoryRead(entityAddr                  +   sizeof(TPM_HANDLE),

847                                             sizeof(OBJECT),

848                                             object);

849

850        //  whether     there     is  an  error  or       not,    make     sure   that   the  evict

851        //  status    of   the    object     is  set    so    that    the   slot  will   get  freed   on   exit

852        object->attributes.evict              =  SET;

853

854        return    result;

855  }

     8.4.7.6         NvGetIndexInfo()

     This function is used to retrieve the contents of an NV Index.

     An implementation is allowed to save the NV Index in a vendor-defined format. If the format is different

     from the default used by the reference code, then this function would be changed to reformat the data into

     the default format.

     A prerequisite to calling this function is that the handle must be known to reference a defined NV Index.

856  void

857  NvGetIndexInfo(

858        TPMI_RH_NV_INDEX              handle,                     //  IN:   handle

859        NV_INDEX                      *nvIndex                    //  OUT:  NV    index  structure

860        )

861  {

862        UINT32                        entityAddr;                 //  offset     points  to   the  entity

863

864        pAssert(HandleGetType(handle)                 ==    TPM_HT_NV_INDEX);

865

866        //  Find  the      address    of  NV     index

     Page 138                                                TCG Published                                          Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                        Trusted Platform    Module  Library

867        entityAddr         =   NvFindHandle(handle);

868        pAssert(entityAddr                 !=     0);

869

870        //  This    implementation                   uses  the     default  format        so   just

871        //  read    the       data     in

872        _plat__NvMemoryRead(entityAddr                          +  sizeof(TPM_HANDLE),             sizeof(NV_INDEX),

873                                              nvIndex);

874

875        return;

876  }

     8.4.7.7          NvInitialCounter()

     This function returns the value to be used when a counter index is initialized. It will scan the NV counters

     and find the highest value in any active counter. It will use that value as the starting point. If there are no

     active counters, it will use the value of the previous largest counter.

877  UINT64

878  NvInitialCounter(

879        void

880        )

881  {

882        UINT64                      maxCount;

883        NV_ITER                     iter       =     NV_ITER_INIT;

884        UINT32                      currentAddr;

885

886        //  Read    the       maxCount         value

887        maxCount        =  NvReadMaxCount();

888

889        //  Iterate        all     existing          counters

890        while((currentAddr                 =   NvNextIndex(&iter))              !=  0)

891        {

892               TPMI_RH_NV_INDEX                      nvHandle;

893               NV_INDEX                              nvIndex;

894

895               //   Read      NV   handle

896               _plat__NvMemoryRead(currentAddr,                         sizeof(TPM_HANDLE),           &nvHandle);

897

898               //   Get    NV     Index

899               NvGetIndexInfo(nvHandle,                     &nvIndex);

900               if(         nvIndex.publicArea.attributes.TPMA_NV_COUNTER                              ==     SET

901                    &&     nvIndex.publicArea.attributes.TPMA_NV_WRITTEN                              ==     SET)

902               {

903                    UINT64                    countValue;

904                    //     Read     counter          value

905                    NvGetIntIndexData(nvHandle,                         &nvIndex,        &countValue);

906                    if(countValue                 >  maxCount)

907                              maxCount         =     countValue;

908               }

909        }

910        //  Initialize            the   new       counter   value       to  be  maxCount       +   1

911        //  A     counter      is   only       initialized         the  first       time  it   is     written.    The

912        //  way     to     write    a   counter        is   with   TPM2_NV_INCREMENT().               Since  the

913        //  "initial"          value       of     a  defined       counter  is      the   largest     count  value     that

914        //  may     have      existed         in     this  index   previously,           then  the    first  use   would

915        //  add     one    to     that     value.

916        return      maxCount;

917  }

     8.4.7.8          NvGetIndexData()

     This function is used to access the data in an NV Index. The data is returned as a byte sequence. Since

     counter values are kept in native format, they are converted to canonical form before being returned.

     Family "2.0"                                                     TCG Published                                             Page 139

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

     This function requires that the NV Index be defined, and that the required data is within the                          data  range.  It

     also requires that TPMA_NV_WRITTEN of the Index is SET.

918  void

919  NvGetIndexData(

920        TPMI_RH_NV_INDEX                  handle,               //  IN:    handle

921        NV_INDEX                         *nvIndex,              //  IN:    RAM     image    of   index      header

922        UINT32                            offset,               //  IN:    offset       of  NV   data

923        UINT16                            size,                 //  IN:    size    of   NV  data

924        void                             *data                  //  OUT:   data    buffer

925        )

926  {

927

928        pAssert(nvIndex->publicArea.attributes.TPMA_NV_WRITTEN                                  ==   SET);

929

930        if(       nvIndex->publicArea.attributes.TPMA_NV_BITS                           ==  SET

931             ||   nvIndex->publicArea.attributes.TPMA_NV_COUNTER                            ==   SET)

932        {

933              //  Read     bit   or   counter       data  in    canonical    form

934              UINT64             dataInInt;

935              NvGetIntIndexData(handle,                nvIndex,     &dataInInt);

936              UINT64_TO_BYTE_ARRAY(dataInInt,                   (BYTE     *)data);

937        }

938        else

939        {

940              if(nvIndex->publicArea.attributes.TPMA_NV_ORDERLY                             ==      SET)

941              {

942                    UINT32               ramAddr;

943

944                    //  Get     data     from   RAM  buffer

945                    ramAddr      =   NvGetRAMIndexOffset(handle);

946                    MemoryCopy(data,            s_ramIndex      +   ramAddr     +  offset,       size,      size);

947              }

948              else

949              {

950                    UINT32               entityAddr;

951                    entityAddr        =   NvFindHandle(handle);

952                    //  Get     data     from   NV

953                    //  Skip     NV   Index     info,     read  data   buffer

954                    entityAddr        +=   sizeof(TPM_HANDLE)          +   sizeof(NV_INDEX)              +  offset;

955                    //  Read     the     data

956                    _plat__NvMemoryRead(entityAddr,                   size,     data);

957              }

958        }

959        return;

960  }

     8.4.7.9         NvGetIntIndexData()

     Get data in integer format of a bit or counter NV Index.

     This function requires that the NV Index is defined and that the NV Index previously has been                           written.

961  void

962  NvGetIntIndexData(

963        TPMI_RH_NV_INDEX                  handle,               //  IN:    handle

964        NV_INDEX                         *nvIndex,              //  IN:    RAM     image    of   NV  Index       header

965        UINT64                           *data                  //  IN:    UINT64       pointer      for    counter   or  bit

966        )

967  {

968        //   Validate      that     index  has      been  written     and  is      the  right       type

969        pAssert(        nvIndex->publicArea.attributes.TPMA_NV_WRITTEN                               ==     SET

970                    &&  (       nvIndex->publicArea.attributes.TPMA_NV_BITS                          ==     SET

971                           ||   nvIndex->publicArea.attributes.TPMA_NV_COUNTER                              ==   SET

     Page 140                                                TCG Published                                                   Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
      Part  4: Supporting Routines                                                                   Trusted Platform Module Library

972                           )

973                   );

974

975         //  bit   and     counter     value     is   store     in  native     format       for  TPM     CPU.  So  we   directly

976         //  copy  the        contents      of   NV  to   output    data     buffer

977         if(nvIndex->publicArea.attributes.TPMA_NV_ORDERLY                             ==   SET)

978         {

979               UINT32                 ramAddr;

980

981               //  Get     data       from  RAM  buffer

982               ramAddr        =   NvGetRAMIndexOffset(handle);

983               MemoryCopy(data,             s_ramIndex     +    ramAddr,       sizeof(*data),         sizeof(*data));

984         }

985         else

986         {

987               UINT32                 entityAddr;

988               entityAddr         =   NvFindHandle(handle);

989

990               //  Get     data       from  NV

991               //  Skip       NV  Index     info,    read  data     buffer

992               _plat__NvMemoryRead(

993                   entityAddr          +    sizeof(TPM_HANDLE)          +    sizeof(NV_INDEX),

994                   sizeof(UINT64),               data);

995         }

996

997         return;

998   }

      8.4.7.10        NvWriteIndexInfo()

      This function is called to queue the write of NV Index data to persistent memory.

      This function requires that NV Index is defined.

      Error Returns                             Meaning

      TPM_RC_NV_RATE                            NV is rate limiting so retry

      TPM_RC_NV_UNAVAILABLE                     NV is not available

999   TPM_RC

1000  NvWriteIndexInfo(

1001        TPMI_RH_NV_INDEX                   handle,                 //  IN:    handle

1002        NV_INDEX                           *nvIndex                //  IN:    NV  Index    info     to   be   written

1003        )

1004  {

1005        UINT32               entryAddr;

1006        TPM_RC               result;

1007

1008        //  Get   the     starting         offset   for   the  index      in  the     RAM  image     of  NV

1009        entryAddr      =     NvFindHandle(handle);

1010        pAssert(entryAddr            !=    0);

1011

1012        //  Step  over          the  link   value

1013        entryAddr      =     entryAddr      +   sizeof(TPM_HANDLE);

1014

1015        //  If    the  index         data  is   actually     changed,       then   a  write     to   NV  is   required

1016        if(_plat__NvIsDifferent(entryAddr,                     sizeof(NV_INDEX),nvIndex))

1017        {

1018              //  Make       sure    that   NV  is   available

1019              result      =     NvIsAvailable();

1020              if(result          !=  TPM_RC_SUCCESS)

1021                  return         result;

1022              _plat__NvMemoryWrite(entryAddr,                      sizeof(NV_INDEX),            nvIndex);

1023              g_updateNV         =   TRUE;

      Family "2.0"                                            TCG Published                                                 Page 141

      Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                     October 30, 2014
      Trusted Platform Module Library                                                                                     Part 4: Supporting Routines

1024     }

1025     return       TPM_RC_SUCCESS;

1026  }

      8.4.7.11      NvWriteIndexData()

      This function is used to write NV index data.

      This function requires that the NV Index is defined, and                         the   data       is  within  the   defined  data  range  for  the

      index.

      Error Returns                              Meaning

      TPM_RC_NV_RATE                             NV is rate limiting so retry

      TPM_RC_NV_UNAVAILABLE                      NV is not available

1027  TPM_RC

1028  NvWriteIndexData(

1029     TPMI_RH_NV_INDEX                        handle,                  //     IN:   handle

1030     NV_INDEX                               *nvIndex,                 //     IN:   RAM       copy       of  NV    Index

1031     UINT32                                  offset,                  //     IN:   offset           of  NV  data

1032     UINT32                                  size,                    //     IN:   size         of  NV      data

1033     void                                   *data                     //     OUT:     data      buffer

1034     )

1035  {

1036     TPM_RC                                  result;

1037     //     Validate         that     write   falls      within       range       of     the    index

1038     pAssert(nvIndex->publicArea.dataSize                                >=  offset          +  size);

1039

1040     //     Update     TPMA_NV_WRITTEN              bit     if   necessary

1041     if(nvIndex->publicArea.attributes.TPMA_NV_WRITTEN                                              ==  CLEAR)

1042     {

1043            nvIndex->publicArea.attributes.TPMA_NV_WRITTEN                                          =   SET;

1044            result        =     NvWriteIndexInfo(handle,                  nvIndex);

1045            if(result           !=    TPM_RC_SUCCESS)

1046                   return         result;

1047     }

1048

1049     //     Check     to     see    if  process        for   an  orderly          index         is  required.

1050     if(nvIndex->publicArea.attributes.TPMA_NV_ORDERLY                                              ==  SET)

1051     {

1052            UINT32                  ramAddr;

1053

1054            //    Write         data    to   RAM   buffer

1055            ramAddr          =  NvGetRAMIndexOffset(handle);

1056            MemoryCopy(s_ramIndex                   +   ramAddr       +   offset,        data,          size,

1057                                  sizeof(s_ramIndex)             -    ramAddr         -  offset);

1058

1059            //    NV   update         does   not    happen       for     orderly         index.         Have

1060            //    to   clear        orderlyState         to     reflect      that        we     have    changed       the

1061            //    NV   and      an    orderly      shutdown      is      required.           Only       going     to  do   this  if  we

1062            //    are     not     processing        a   counter       that   has         just       rolled      over

1063            if(g_updateNV               ==   FALSE)

1064                   g_clearOrderly             =    TRUE;

1065     }

1066     //     Need   to     process       this      part   if     the   Index       isn't         orderly     or    if  it   is

1067     //     an  orderly         counter      that      just     rolled       over.

1068     if(g_updateNV              ||    nvIndex->publicArea.attributes.TPMA_NV_ORDERLY                                       ==  CLEAR)

1069     {

1070            //    Processing            for  an    index     with     TPMA_NV_ORDERLY                   CLEAR

1071            UINT32                  entryAddr       =   NvFindHandle(handle);

1072

1073            pAssert(entryAddr                !=    0);

      Page 142                                                      TCG Published                                                        Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                                         Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                  Trusted Platform Module Library

1074

1075            //    Offset      into     the    index   to  the  first     byte  of  the    data     to   be  written

1076            entryAddr         +=  sizeof(TPM_HANDLE)           +   sizeof(NV_INDEX)         +  offset;

1077

1078            //    If     the  data     is     actually    changed,  then   a   write    to     NV  is   required

1079            if(_plat__NvIsDifferent(entryAddr,                      size,  data))

1080            {

1081                     //  Make     sure     that   NV  is  available

1082                     result    =  NvIsAvailable();

1083                     if(result      !=     TPM_RC_SUCCESS)

1084                            return     result;

1085                     _plat__NvMemoryWrite(entryAddr,                size,      data);

1086                     g_updateNV        =   TRUE;

1087            }

1088     }

1089     return       TPM_RC_SUCCESS;

1090  }

      8.4.7.12       NvGetName()

      This function is used to compute the Name of an NV Index.

      The name buffer receives the bytes of the Name and the                       return  value   is  the  number      of  octets  in  the

      Name.

      This function requires that the NV Index is defined.

1091  UINT16

1092  NvGetName(

1093     TPMI_RH_NV_INDEX                      handle,             //   IN:   handle   of   the    index

1094     NAME                                 *name                //   OUT:   name    of  the     index

1095     )

1096  {

1097     UINT16                                dataSize,      digestSize;

1098     NV_INDEX                              nvIndex;

1099     BYTE                                  marshalBuffer[sizeof(TPMS_NV_PUBLIC)];

1100     BYTE                                 *buffer;

1101     HASH_STATE                            hashState;

1102

1103     //     Get   NV     public   info

1104     NvGetIndexInfo(handle,                   &nvIndex);

1105

1106     //     Marshal      public     area

1107     buffer       =   marshalBuffer;

1108     dataSize         =  TPMS_NV_PUBLIC_Marshal(&nvIndex.publicArea,                        &buffer,        NULL);

1109

1110     //     hash     public    area

1111     digestSize          =    CryptStartHash(nvIndex.publicArea.nameAlg,                       &hashState);

1112     CryptUpdateDigest(&hashState,                      dataSize,   marshalBuffer);

1113

1114     //     Complete        digest     leaving    room    for  the  nameAlg

1115     CryptCompleteHash(&hashState,                      digestSize,      &((BYTE   *)name)[2]);

1116

1117     //     Include      the   nameAlg

1118     UINT16_TO_BYTE_ARRAY(nvIndex.publicArea.nameAlg,                              (BYTE    *)name);

1119     return       digestSize        +     2;

1120  }

      8.4.7.13       NvDefineIndex()

      This function is used to assign NV memory to an NV Index.

      Family "2.0"                                            TCG Published                                                 Page 143

      Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                 October 30, 2014
      Trusted Platform Module Library                                                                                Part 4: Supporting Routines

      Error Returns                               Meaning

      TPM_RC_NV_SPACE                             insufficient NV space

1121  TPM_RC

1122  NvDefineIndex(

1123     TPMS_NV_PUBLIC               *publicArea,                  //   IN:  A  template        for     an  area        to  create.

1124     TPM2B_AUTH                   *authValue                    //   IN:  The   initial         authorization            value

1125     )

1126  {

1127     //     The   buffer      to  be      written      to   NV      memory

1128     BYTE                         nvBuffer[sizeof(TPM_HANDLE)                      +   sizeof(NV_INDEX)];

1129

1130     NV_INDEX                     *nvIndex;                           //  a  pointer        to  the      NV_INDEX        data   in

1131                                                                      //     nvBuffer

1132     UINT16                       entrySize;                          //  size     of  entry

1133

1134     entrySize         =  sizeof(TPM_HANDLE)                +    sizeof(NV_INDEX)            +  publicArea->dataSize;

1135

1136     //     Check     if  we  have        enough       space     to   create    the    NV    Index

1137     //     In   this     implementation,              the  only      resource        limitation         is  the     available      NV

1138     //     space.        Other   implementation                may   have   other     limitation            on  counter       or   on

1139     //     NV   slot

1140     if(!NvTestSpace(entrySize,                        TRUE))       return   TPM_RC_NV_SPACE;

1141

1142     //     if   the   index      to  be      defined       is   RAM     backed,      check     RAM  space       availability

1143     //     as   well

1144     if(publicArea->attributes.TPMA_NV_ORDERLY                                 ==     SET

1145                   &&     !NvTestRAMSpace(publicArea->dataSize))

1146            return        TPM_RC_NV_SPACE;

1147

1148     //     Copy   input      value       to  nvBuffer

1149            //    Copy    handle

1150     *   (TPM_HANDLE          *)  nvBuffer          =  publicArea->nvIndex;

1151

1152            //    Copy    NV_INDEX

1153     nvIndex       =   (NV_INDEX          *)  (nvBuffer          +   sizeof(TPM_HANDLE));

1154     nvIndex->publicArea                  =   *publicArea;

1155     nvIndex->authValue               =      *authValue;

1156

1157     //     Add   index   to      NV  memory

1158     NvAdd(entrySize,             sizeof(TPM_HANDLE)                  +   sizeof(NV_INDEX),              nvBuffer);

1159

1160     //     If   the   data   of      NV     Index     is   RAM     backed,    add     the   data    area        in  RAM  as    well

1161     if(publicArea->attributes.TPMA_NV_ORDERLY                                 ==     SET)

1162            NvAddRAM(publicArea->nvIndex,                           publicArea->dataSize);

1163

1164     return       TPM_RC_SUCCESS;

1165  }

      8.4.7.14       NvAddEvictObject()

      This function is used to assign NV memory to a persistent object.

      Error Returns                               Meaning

      TPM_RC_NV_HANDLE                            the requested handle is already in use

      TPM_RC_NV_SPACE                             insufficient NV space

1166  TPM_RC

1167  NvAddEvictObject(

1168     TPMI_DH_OBJECT               evictHandle,                  //   IN:  new   evict       handle

      Page 144                                                      TCG Published                                                       Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
      Part  4: Supporting Routines                                                                                   Trusted Platform Module       Library

1169        OBJECT                          *object                          //     IN:  object      to     be  added

1170        )

1171  {

1172        //  The   buffer          to    be     written            to  NV     memory

1173        BYTE                            nvBuffer[sizeof(TPM_HANDLE)                          +   sizeof(OBJECT)];

1174

1175        OBJECT                          *nvObject;                              //   a   pointer        to  the  OBJECT      data  in

1176                                                                                //   nvBuffer

1177        UINT16                          entrySize;                              //   size    of  entry

1178

1179        //  evict   handle              type       should         match      the     object     hierarchy

1180        pAssert(           (         NvIsPlatformPersistentHandle(evictHandle)

1181                              &&     object->attributes.ppsHierarchy                             ==     SET)

1182                   ||      (         NvIsOwnerPersistentHandle(evictHandle)

1183                              &&     (         object->attributes.spsHierarchy                              ==  SET

1184                                        ||     object->attributes.epsHierarchy                              ==  SET)));

1185

1186        //  An    evict       needs         4  bytes        of    handle        +    sizeof     OBJECT

1187        entrySize       =     sizeof(TPM_HANDLE)                      +     sizeof(OBJECT);

1188

1189        //  Check   if        we     have      enough          space        to  add     the  evict      object

1190        //  An    evict       object           needs    8      bytes        in  index    table       +  sizeof       OBJECT

1191        //  In    this     implementation,                     the    only      resource        limitation       is  the     available     NV

1192        //  space.         Other        implementation                   may    have     other   limitation          on  evict     object

1193        //  handle      space

1194        if(!NvTestSpace(entrySize,                             FALSE))          return   TPM_RC_NV_SPACE;

1195

1196        //  Allocate          a   new       evict      handle

1197        if(!NvIsUndefinedEvictHandle(evictHandle))

1198              return       TPM_RC_NV_DEFINED;

1199

1200        //  Copy   evict          object           to  nvBuffer

1201              //  Copy        handle

1202        *   (TPM_HANDLE           *)    nvBuffer            =     evictHandle;

1203

1204              //  Copy        OBJECT

1205        nvObject    =      (OBJECT             *)  (nvBuffer             +   sizeof(TPM_HANDLE));

1206        *nvObject       =     *object;

1207

1208        //  Set   evict          attribute             and     handle

1209        nvObject->attributes.evict                             =  SET;

1210        nvObject->evictHandle                      =   evictHandle;

1211

1212        //  Add   evict          to     NV     memory

1213        NvAdd(entrySize,                entrySize,                nvBuffer);

1214

1215        return    TPM_RC_SUCCESS;

1216

1217  }

      8.4.7.15        NvDeleteEntity()

      This function will delete a NV Index or an evict object.

      This function requires that the index/evict object has been defined.

1218  void

1219  NvDeleteEntity(

1220        TPM_HANDLE                      handle                           //     IN:  handle      of     entity   to  be   deleted

1221        )

1222  {

1223        UINT32                entityAddr;                         //  pointer        to  entity

1224

1225        entityAddr         =     NvFindHandle(handle);

1226        pAssert(entityAddr                     !=  0);

      Family "2.0"                                                           TCG Published                                                     Page 145

      Level 00 Revision 01.16                                   Copyright © TCG 2006-2014                                              October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines

1227

1228        if(HandleGetType(handle)                  ==  TPM_HT_NV_INDEX)

1229        {

1230            NV_INDEX            nvIndex;

1231

1232            //   Read  the      NV  Index         info

1233            _plat__NvMemoryRead(entityAddr                       +   sizeof(TPM_HANDLE),            sizeof(NV_INDEX),

1234                                              &nvIndex);

1235

1236            //   If  the    entity      to    be      deleted    is     a  counter   with  the      maximum  counter

1237            //   value,     record      it    in      NV  memory

1238            if(nvIndex.publicArea.attributes.TPMA_NV_COUNTER                               ==    SET

1239                       &&   nvIndex.publicArea.attributes.TPMA_NV_WRITTEN                                ==  SET)

1240            {

1241                 UINT64                 countValue;

1242                 UINT64                 maxCount;

1243                 NvGetIntIndexData(handle,                     &nvIndex,        &countValue);

1244                 maxCount       =   NvReadMaxCount();

1245                 if(countValue             >  maxCount)

1246                       NvWriteMaxCount(countValue);

1247            }

1248            //   If  the    NV  Index         is  RAM     back,     delete      the  RAM  data   as   well

1249            if(nvIndex.publicArea.attributes.TPMA_NV_ORDERLY                               ==    SET)

1250                 NvDeleteRAM(handle);

1251        }

1252        NvDelete(entityAddr);

1253

1254        return;

1255

1256  }

      8.4.7.16      NvFlushHierarchy()

      This function will delete persistent objects belonging to the indicated If the storage hierarchy is selected,

      the function will also delete any NV Index define using ownerAuth.

1257  void

1258  NvFlushHierarchy(

1259        TPMI_RH_HIERARCHY               hierarchy                   //     IN:  hierarchy  to    be   flushed.

1260        )

1261  {

1262        NV_ITER                 iter    =     NV_ITER_INIT;

1263        UINT32                  currentAddr;

1264

1265        while((currentAddr          =   NvNext(&iter))              !=     0)

1266        {

1267            TPM_HANDLE                  entityHandle;

1268

1269            //   Read  handle       information.

1270            _plat__NvMemoryRead(currentAddr,                         sizeof(TPM_HANDLE),            &entityHandle);

1271

1272            if(HandleGetType(entityHandle)                       ==     TPM_HT_NV_INDEX)

1273            {

1274                 //    Handle       NV  Index

1275                 NV_INDEX               nvIndex;

1276

1277                 //    If   flush       endorsement       or     platform       hierarchy,      no   NV  Index  would  be

1278                 //    flushed

1279                 if(hierarchy           ==    TPM_RH_ENDORSEMENT                ||   hierarchy   ==   TPM_RH_PLATFORM)

1280                       continue;

1281                 _plat__NvMemoryRead(currentAddr                           +    sizeof(TPM_HANDLE),

1282                                                      sizeof(NV_INDEX),              &nvIndex);

1283

1284                 //    For  storage           hierarchy,       flush       OwnerCreated    index

      Page 146                                                TCG Published                                                Family "2.0"

      October 30, 2014                                Copyright © TCG 2006-2014                              Level 00 Revision 01.16
      Part  4: Supporting Routines                                                                  Trusted Platform Module        Library

1285                    if(      nvIndex.publicArea.attributes.TPMA_NV_PLATFORMCREATE                                  ==  CLEAR)

1286                    {

1287                            //     Delete         the   NV  Index

1288                            NvDelete(currentAddr);

1289

1290                            //     Re-iterate           from    beginning    after   a  delete

1291                            iter       =  NV_ITER_INIT;

1292

1293                            //     If     the     NV   Index    is  RAM  back,   delete  the    RAM  data      as  well

1294                            if(nvIndex.publicArea.attributes.TPMA_NV_ORDERLY                              ==   SET)

1295                                   NvDeleteRAM(entityHandle);

1296                    }

1297              }

1298              else     if(HandleGetType(entityHandle)                      ==    TPM_HT_PERSISTENT)

1299              {

1300                    OBJECT                            object;

1301

1302                    //   Get       evict       object

1303                    NvGetEvictObject(entityHandle,                       &object);

1304

1305                    //   If     the       evict       object    belongs  to    the   hierarchy  to   be   flushed

1306                    if(         (         hierarchy         ==  TPM_RH_PLATFORM

1307                                   &&     object.attributes.ppsHierarchy                 ==  SET)

1308                         ||     (         hierarchy         ==  TPM_RH_OWNER

1309                                   &&     object.attributes.spsHierarchy                 ==  SET)

1310                         ||     (         hierarchy         ==  TPM_RH_ENDORSEMENT

1311                                   &&     object.attributes.epsHierarchy                 ==  SET)

1312                         )

1313                    {

1314                            //     Delete         the   evict   object

1315                            NvDelete(currentAddr);

1316

1317                            //     Re-iterate           from    beginning    after   a  delete

1318                            iter       =  NV_ITER_INIT;

1319                    }

1320              }

1321              else

1322              {

1323                    pAssert(FALSE);

1324              }

1325        }

1326

1327        return;

1328  }

      8.4.7.17        NvSetGlobalLock()

      This  function    is  used       to  SET        the   TPMA_NV_WRITELOCKED              attribute   for  all  NV  Indices  that  have

      TPMA_NV_GLOBALLOCK SET. This function is use by TPM2_NV_GlobalWriteLock().

1329  void

1330  NvSetGlobalLock(

1331        void

1332        )

1333  {

1334        NV_ITER                    iter        =  NV_ITER_INIT;

1335        UINT32                     currentAddr;

1336

1337        //  Check      all   Indices

1338        while((currentAddr                =    NvNextIndex(&iter))           !=  0)

1339        {

1340              NV_INDEX             nvIndex;

1341

1342              //  Read      the    index          data

      Family "2.0"                                                  TCG Published                                               Page 147

      Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                  October 30, 2014
      Trusted Platform Module Library                                                                                  Part 4:  Supporting  Routines

1343            _plat__NvMemoryRead(currentAddr                                 +   sizeof(TPM_HANDLE),

1344                                                     sizeof(NV_INDEX),                 &nvIndex);

1345

1346            //      See       if     it   should     be      locked

1347            if(nvIndex.publicArea.attributes.TPMA_NV_GLOBALLOCK                                             ==     SET)

1348            {

1349

1350                       //     if     so,     lock    it

1351                       nvIndex.publicArea.attributes.TPMA_NV_WRITELOCKED                                        =  SET;

1352

1353                       _plat__NvMemoryWrite(currentAddr                             +  sizeof(TPM_HANDLE),

1354                                                               sizeof(NV_INDEX),              &nvIndex);

1355                       //     Set       the  flag    that      a  NV    write       happens

1356                       g_updateNV            =   TRUE;

1357            }

1358     }

1359

1360     return;

1361

1362  }

      8.4.7.18       InsertSort()

      Sort a handle into handle list in ascending order.                            The total handle number in the list         should  not  exceed

      MAX_CAP_HANDLES

1363  static    void

1364  InsertSort(

1365     TPML_HANDLE                         *handleList,              //      IN/OUT:     sorted       handle  list

1366     UINT32                               count,                   //      IN:   maximum      count     in  the    handle   list

1367     TPM_HANDLE                           entityHandle             //      IN:   handle       to  be    inserted

1368     )

1369  {

1370     UINT32                              i,  j;

1371     UINT32                              originalCount;

1372

1373     //     For     a     corner         case    that     the     maximum       count     is  0,    do  nothing

1374     if(count             ==     0)     return;

1375

1376     //     For     empty         list,      add     the     handle     at     the  beginning         and   return

1377     if(handleList->count                        ==  0)

1378     {

1379            handleList->handle[0]                         =  entityHandle;

1380            handleList->count++;

1381            return;

1382     }

1383

1384     //     Check         if     the     maximum     of      the  list      has     been   reached

1385     originalCount                   =   handleList->count;

1386     if(originalCount                     <  count)

1387            handleList->count++;

1388

1389     //     Insert         the       handle      to  the     list

1390     for(i       =     0;     i   <     originalCount;            i++)

1391     {

1392            if(handleList->handle[i]                           >  entityHandle)

1393            {

1394                       for(j         =   handleList->count              -   1;   j  >  i;     j--)

1395                       {

1396                                 handleList->handle[j]                  =   handleList->handle[j-1];

1397                       }

1398                       break;

1399            }

1400     }

      Page 148                                                         TCG Published                                                  Family "2.0"

      October 30, 2014                                        Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                       Trusted Platform Module Library

1401

1402       //   If     a     slot     was    found,           insert     the       handle     in     this     position

1403       if(i     <     originalCount                ||     handleList->count               >   originalCount)

1404             handleList->handle[i]                         =    entityHandle;

1405

1406       return;

1407  }

      8.4.7.19         NvCapGetPersistent()

      This function is used to get a list of handles of the persistent objects, starting at handle.

      Handle   must       be     in   valid  persistent        object       handle       range,      but  does   not    have  to  reference   an  existing

      persistent object.

      Return Value                                        Meaning

      YES                                                 if there are more handles available

      NO                                                  all the available handles has been returned

1408  TPMI_YES_NO

1409  NvCapGetPersistent(

1410       TPMI_DH_OBJECT                    handle,                        //     IN:   start       handle

1411       UINT32                            count,                         //     IN:   maximum         number     of  returned    handle

1412       TPML_HANDLE                       *handleList                    //     OUT:     list     of   handle

1413       )

1414  {

1415       TPMI_YES_NO                                 more    =    NO;

1416       NV_ITER                                     iter    =    NV_ITER_INIT;

1417       UINT32                                      currentAddr;

1418

1419       pAssert(HandleGetType(handle)                                ==   TPM_HT_PERSISTENT);

1420

1421       //   Initialize               output        handle       list

1422       handleList->count                 =      0;

1423

1424       //   The       maximum        count         of     handles       we     may   return       is   MAX_CAP_HANDLES

1425       if(count           >  MAX_CAP_HANDLES)                   count       =     MAX_CAP_HANDLES;

1426

1427       while((currentAddr                    =     NvNextEvict(&iter))                  !=    0)

1428       {

1429             TPM_HANDLE                         entityHandle;

1430

1431             //       Read     handle        information.

1432             _plat__NvMemoryRead(currentAddr,                                     sizeof(TPM_HANDLE),               &entityHandle);

1433

1434             //       Ignore         persistent            handles       that       have     values       less  than   the    input  handle

1435             if(entityHandle                    <     handle)

1436                         continue;

1437

1438             //       if     the     handles          in   the   list       have     reached         the  requested       count,  and   there

1439             //       are    still       handles           need     to   be       inserted,       indicate      that   there    are  more.

1440             if(handleList->count                          ==   count)

1441                         more     =  YES;

1442

1443             //       A   handle         with      a   value     larger           than  start        handle     is  a  candidate

1444             //       for    return.         Insert        sort      it     to    the   return        list.     Insert    sort    algorithm

1445             //       is     chosen      here         for  simplicity             based      on   the     assumption      that  the  total

1446             //       number         of  NV     Indices         is   small.          For     an   implementation          that  may  allow

1447             //       large       number        of     NV  Indices,            a  more    efficient       sorting      algorithm     may  be

1448             //       used     here.

1449             InsertSort(handleList,                            count,       entityHandle);

1450

      Family "2.0"                                                          TCG Published                                                     Page 149

      Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                              October 30, 2014
      Trusted Platform Module Library                                                                              Part 4: Supporting Routines

1451       }

1452       return    more;

1453  }

      8.4.7.20       NvCapGetIndex()

      This function returns a list of handles of NV Indices, starting from handle. Handle must be in the range                          of

      NV Indices, but does not have to reference an existing NV Index.

      Return Value                                   Meaning

      YES                                            if there are more handles to report

      NO                                             all the available handles has been reported

1454  TPMI_YES_NO

1455  NvCapGetIndex(

1456       TPMI_DH_OBJECT               handle,                       //     IN:   start       handle

1457       UINT32                       count,                        //     IN:   maximum         number   of  returned  handle

1458       TPML_HANDLE                  *handleList                   //     OUT:     list     of   handle

1459       )

1460  {

1461       TPMI_YES_NO                            more    =   NO;

1462       NV_ITER                                iter    =   NV_ITER_INIT;

1463       UINT32                                 currentAddr;

1464

1465       pAssert(HandleGetType(handle)                          ==   TPM_HT_NV_INDEX);

1466

1467       //   Initialize          output        handle      list

1468       handleList->count            =      0;

1469

1470       //   The  maximum        count         of  handles         we     may   return       is   MAX_CAP_HANDLES

1471       if(count      >  MAX_CAP_HANDLES)                  count       =     MAX_CAP_HANDLES;

1472

1473       while((currentAddr               =     NvNextIndex(&iter))                  !=   0)

1474       {

1475            TPM_HANDLE                     entityHandle;

1476

1477            //   Read     handle        information.

1478            _plat__NvMemoryRead(currentAddr,                                 sizeof(TPM_HANDLE),            &entityHandle);

1479

1480            //   Ignore         index      handles        that     have       values       less  than   the    'handle'

1481            if(entityHandle                <     handle)

1482                    continue;

1483

1484            //   if     the     count      of     handles      in     the     list     has     reached  the    requested   count,

1485            //   and    there       are       still       handles        to   report,       set  more.

1486            if(handleList->count                      ==  count)

1487                    more     =  YES;

1488

1489            //   A   handle         with      a   value   larger            than   start       handle   is  a  candidate

1490            //   for    return.         Insert        sort     it     to     the   return       list.   Insert  sort     algorithm

1491            //   is     chosen      here         for  simplicity             based     on   the  assumption     that  the  total

1492            //   number         of  NV     Indices        is   small.          For     an   implementation      that  may  allow

1493            //   large       number        of     NV  Indices,           a   more   efficient      sorting     algorithm   may  be

1494            //   used     here.

1495            InsertSort(handleList,                        count,      entityHandle);

1496       }

1497       return    more;

1498  }

      Page 150                                                        TCG Published                                               Family "2.0"

      October 30, 2014                                    Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
      Part 4: Supporting Routines                                                              Trusted Platform Module Library

      8.4.7.21       NvCapGetIndexNumber()

      This function returns the count of NV Indexes currently      defined.

1499  UINT32

1500  NvCapGetIndexNumber(

1501     void

1502     )

1503  {

1504     UINT32                   num   =     0;

1505     NV_ITER                  iter     =  NV_ITER_INIT;

1506

1507     while(NvNextIndex(&iter)                 !=  0)   num++;

1508

1509     return      num;

1510  }

      8.4.7.22       NvCapGetPersistentNumber()

      Function returns the count of persistent objects currently           in  NV  memory.

1511  UINT32

1512  NvCapGetPersistentNumber(

1513     void

1514     )

1515  {

1516     UINT32                   num   =     0;

1517     NV_ITER                  iter     =  NV_ITER_INIT;

1518

1519     while(NvNextEvict(&iter)                 !=  0)   num++;

1520

1521     return      num;

1522  }

      8.4.7.23       NvCapGetPersistentAvail()

      This function returns an estimate of the number of additional persistent objects that             could  be  loaded  into

      NV memory.

1523  UINT32

1524  NvCapGetPersistentAvail(

1525     void

1526     )

1527  {

1528     UINT32                   availSpace;

1529     UINT32                   objectSpace;

1530

1531     //     Compute    the   available        space    in  NV  storage

1532     availSpace        =     NvGetFreeByte();

1533

1534     //     Get  the   space  needed          to  add  a   persistent      object  to  NV  storage

1535     objectSpace          =  NvGetEvictObjectSize();

1536

1537     return      availSpace    /    objectSpace;

1538  }

      8.4.7.24       NvCapGetCounterNumber()

      Get the number of defined NV Indexes that have NV TPMA_NV_COUNTER attribute SET.

      Family "2.0"                                            TCG Published                                        Page 151

      Level 00 Revision 01.16                         Copyright © TCG 2006-2014                         October 30, 2014
      Trusted Platform Module Library                                                                                                Part 4: Supporting  Routines

1539  UINT32

1540  NvCapGetCounterNumber(

1541     void

1542     )

1543  {

1544     NV_ITER                         iter           =   NV_ITER_INIT;

1545     UINT32                          currentAddr;

1546     UINT32                          num         =     0;

1547

1548     while((currentAddr                       =     NvNextIndex(&iter))                          !=  0)

1549     {

1550            NV_INDEX                 nvIndex;

1551

1552            //   Get    NV     Index             info

1553            _plat__NvMemoryRead(currentAddr                                             +   sizeof(TPM_HANDLE),

1554                                                           sizeof(NV_INDEX),                     &nvIndex);

1555            if(nvIndex.publicArea.attributes.TPMA_NV_COUNTER                                                           ==  SET)  num++;

1556     }

1557

1558     return      num;

1559  }

      8.4.7.25       NvCapGetCounterAvail()

      This function returns an estimate of the number of additional counter type NV Indices that can be defined.

1560  UINT32

1561  NvCapGetCounterAvail(

1562     void

1563     )

1564  {

1565     UINT32                          availNVSpace;

1566     UINT32                          availRAMSpace;

1567     UINT32                          counterNVSpace;

1568     UINT32                          counterRAMSpace;

1569     UINT32                          persistentNum                       =     NvCapGetPersistentNumber();

1570

1571     //     Get  the    available                   space         in     NV       storage

1572     availNVSpace           =     NvGetFreeByte();

1573

1574     if     (persistentNum                 <     MIN_EVICT_OBJECTS)

1575     {

1576            //   Some   space              have         to     be     reserved              for  evict       object.       Adjust  availNVSpace.

1577            UINT32                   reserved               =     (MIN_EVICT_OBJECTS                     -   persistentNum)

1578                                                               *     NvGetEvictObjectSize();

1579            if   (reserved              >     availNVSpace)

1580                  availNVSpace                      =   0;

1581            else

1582                  availNVSpace                      -=     reserved;

1583     }

1584

1585     //     Get  the    space           needed             to     add       a     counter        index      to     NV  storage

1586     counterNVSpace               =     NvGetCounterSize();

1587

1588     //     Compute     the       available                 space           in       RAM

1589     availRAMSpace             =     RAM_INDEX_SPACE                           -     s_ramIndexSize;

1590

1591     //     Compute     the       space             needed           to     add      a     counter    index        to  RAM      storage

1592     //     It   takes  an        size           field,           a   handle            and  sizeof(UINT64)                for  counter  data

1593     counterRAMSpace                 =     sizeof(UINT32)                         +  sizeof(TPM_HANDLE)                +   sizeof(UINT64);

1594

1595     //     Return    the      min         of       counter           number            in   NV  and     in     RAM

1596     if(availNVSpace                 /     counterNVSpace                         >  availRAMSpace              /  counterRAMSpace)

1597            return      availRAMSpace                       /     counterRAMSpace;

      Page 152                                                                     TCG Published                                                   Family "2.0"

      October 30, 2014                                             Copyright © TCG 2006-2014                                         Level 00 Revision 01.16
      Part 4: Supporting Routines                                                               Trusted Platform Module Library

1598        else

1599              return       availNVSpace             /  counterNVSpace;

1600  }

      8.5       Object.c

      8.5.1       Introduction

      This file contains the functions that manage the object store of the TPM.

      8.5.2       Includes and Data Definitions

1     #define     OBJECT_C

2     #include     "InternalRoutines.h"

3     #include     <Platform.h>

      8.5.3       Functions

      8.5.3.1         ObjectStartup()

      This function is called at TPM2_Startup() to initialize the               object  subsystem.

4     void

5     ObjectStartup(

6           void

7           )

8     {

9           UINT32                i;

10

11          //  object       slots        initialization

12          for(i     =  0;    i  <    MAX_LOADED_OBJECTS;              i++)

13          {

14                //Set      the      slot  to      not    occupied

15                s_objects[i].occupied                    =   FALSE;

16          }

17          return;

18    }

      8.5.3.2         ObjectCleanupEvict()

      In this implementation, a persistent object is moved from NV into an object slot for processing. It is

      flushed after command execution. This function is called from ExecuteCommand().

19    void

20    ObjectCleanupEvict(

21          void

22          )

23    {

24          UINT32                i;

25

26          //  This     has      to   be   iterated           because  a  command  may  have   two   handles

27          //  and      they     may     both   be     persistent.

28          //  This     could        be   made     to     be  more  efficient  so  that  a    search  is   not   needed.

29          for(i     =  0;    i  <    MAX_LOADED_OBJECTS;              i++)

30          {

31                //     If  an   object        is   a     temporary    evict  object,   flush  it    from  slot

32                if(s_objects[i].object.entity.attributes.evict                          ==    SET)

33                       s_objects[i].occupied                 =     FALSE;

34          }

      Family "2.0"                                                   TCG Published                                         Page 153

      Level 00 Revision 01.16                              Copyright © TCG 2006-2014                              October 30, 2014
    Trusted Platform Module Library                                                                       Part 4: Supporting Routines

35

36        return;

37  }

    8.5.3.3            ObjectIsPresent()

    This function checks to see if a transient handle references a loaded object.                         This routine should         not be

    called    if  the   handle   is    not    a  transient  handle.         The  function   validates     that  the  handle       is  in   the

    implementation-dependent allowed in range for loaded transient objects.

    Return Value                                 Meaning

    TRUE                                         if the handle references a loaded object

    FALSE                                        if the handle is not an object handle, or      it  does  not   reference  to  a

                                                 loaded object

38  BOOL

39  ObjectIsPresent(

40        TPMI_DH_OBJECT               handle                  //   IN:     handle  to  be  checked

41        )

42  {

43        UINT32                      slotIndex;                       //   index   of  object      slot

44

45        pAssert(HandleGetType(handle)                    ==   TPM_HT_TRANSIENT);

46

47        //      The   index  in     the     loaded  object       array    is   found  by  subtracting         the  first

48        //      object    handle     number    from  the      input       handle  number.     If  the      indicated

49        //      slot  is     occupied,      then    indicate      that    there   is  already     is    a  loaded

50        //      object       associated     with    the   handle.

51        slotIndex         =  handle      -  TRANSIENT_FIRST;

52        if(slotIndex         >=     MAX_LOADED_OBJECTS)

53                return       FALSE;

54

55        return        s_objects[slotIndex].occupied;

56  }

    8.5.3.4            ObjectIsSequence()

    This function is used to check if the object is a sequence object. This function should                          not   be  called  if  the

    handle does not reference a loaded object.

    Return Value                                 Meaning

    TRUE                                         object is an HMAC, hash, or event sequence object

    FALSE                                        object is not an HMAC, hash, or event sequence object

57  BOOL

58  ObjectIsSequence(

59        OBJECT                      *object                  //   IN:     handle  to  be  checked

60        )

61  {

62        pAssert       (object       !=   NULL);

63        if(          object->attributes.hmacSeq               ==     SET

64                ||   object->attributes.hashSeq               ==     SET

65                ||   object->attributes.eventSeq                 ==  SET)

66                return       TRUE;

67        else

68                return       FALSE;

69  }

    Page 154                                                    TCG Published                                              Family "2.0"

    October 30, 2014                                  Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part 4: Supporting Routines                                                         Trusted Platform Module Library

     8.5.3.5      ObjectGet()

     This function is used to find the object structure associated with a handle.

     This function requires that handle references a loaded object.

70   OBJECT*

71   ObjectGet(

72      TPMI_DH_OBJECT           handle                  //  IN:   handle   of  the  object

73      )

74   {

75      pAssert(         handle   >=     TRANSIENT_FIRST

76                  &&   handle   -   TRANSIENT_FIRST        <    MAX_LOADED_OBJECTS);

77      pAssert(s_objects[handle             -  TRANSIENT_FIRST].occupied            ==  TRUE);

78

79      //    In  this   implementation,        the  handle       is  determined     by  the  slot  occupied  by  the

80      //    object.

81      return      &s_objects[handle        -  TRANSIENT_FIRST].object.entity;

82   }

     8.5.3.6      ObjectGetName()

     This function is used to access the Name of the object. In this implementation, the Name is computed

     when the object is loaded and is saved in the internal representation of the object. This function copies

     the Name data from the object into the buffer at name and returns the number of octets copied.

     This function requires that handle references a loaded object.

83   UINT16

84   ObjectGetName(

85      TPMI_DH_OBJECT           handle,                 //  IN:   handle   of  the  object

86      NAME                   *name                     //  OUT:     name  of  the  object

87      )

88   {

89      OBJECT           *object      =  ObjectGet(handle);

90      if(object->publicArea.nameAlg                ==  TPM_ALG_NULL)

91            return     0;

92

93      //    Copy  the  Name    data    to  the     output

94      MemoryCopy(name,         object->name.t.name,             object->name.t.size,        sizeof(NAME));

95      return      object->name.t.size;

96   }

     8.5.3.7      ObjectGetNameAlg()

     This function is used to get the Name algorithm of a object.

     This function requires that handle references a loaded object.

97   TPMI_ALG_HASH

98   ObjectGetNameAlg(

99      TPMI_DH_OBJECT           handle                  //  IN:   handle   of  the  object

100     )

101  {

102     OBJECT                        *object     =  ObjectGet(handle);

103

104     return      object->publicArea.nameAlg;

105  }

     Family "2.0"                                        TCG Published                                        Page 155

     Level 00 Revision 01.16                    Copyright © TCG 2006-2014                           October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

     8.5.3.8         ObjectGetQualifiedName()

     This function returns the Qualified Name of the object. In this implementation, the Qualified Name is

     computed    when    the  object     is  loaded  and     is  saved  in  the  internal  representation  of  the  object.  The

     alternative would be to retain the Name of the parent and compute the QN when needed. This would take

     the same amount of space so it is not recommended that the alternate be used.

     This function requires that handle references a loaded object.

106  void

107  ObjectGetQualifiedName(

108        TPMI_DH_OBJECT       handle,                      //  IN:   handle    of  the   object

109        TPM2B_NAME           *qualifiedName               //  OUT:   qualified    name  of  the  object

110        )

111  {

112        OBJECT          *object       =   ObjectGet(handle);

113        if(object->publicArea.nameAlg                 ==  TPM_ALG_NULL)

114              qualifiedName->t.size       =       0;

115        else

116              //  Copy  the  name

117              *qualifiedName       =     object->qualifiedName;

118

119        return;

120  }

     8.5.3.9         ObjectDataGetHierarchy()

     This function returns the handle for the hierarchy of an object.

121  TPMI_RH_HIERARCHY

122  ObjectDataGetHierarchy(

123        OBJECT               *object                      //  IN   :object

124        )

125  {

126        if(object->attributes.spsHierarchy)

127        {

128              return    TPM_RH_OWNER;

129        }

130        else  if(object->attributes.epsHierarchy)

131        {

132              return    TPM_RH_ENDORSEMENT;

133        }

134        else  if(object->attributes.ppsHierarchy)

135        {

136              return    TPM_RH_PLATFORM;

137        }

138        else

139        {

140              return    TPM_RH_NULL;

141        }

142

143  }

     8.5.3.10        ObjectGetHierarchy()

     This function returns the handle of the hierarchy to which a handle belongs. This function is similar to

     ObjectDataGetHierarchy() but this routine takes a handle but ObjectDataGetHierarchy() takes an pointer

     to an object.

     This function requires that handle references a loaded object.

144  TPMI_RH_HIERARCHY

     Page 156                                                TCG Published                                     Family "2.0"

     October 30, 2014                        Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

145  ObjectGetHierarchy(

146     TPMI_DH_OBJECT                      handle              //  IN    :object  handle

147     )

148  {

149     OBJECT                         *object      =   ObjectGet(handle);

150

151     return         ObjectDataGetHierarchy(object);

152  }

     8.5.3.11      ObjectAllocateSlot()

     This function is used to allocate a slot in internal object array.

     Return Value                                Meaning

     TRUE                                        allocate success

     FALSE                                       do not have free slot

153  static    BOOL

154  ObjectAllocateSlot(

155     TPMI_DH_OBJECT                 *handle,                 //  OUT:  handle   of  allocated       object

156     OBJECT                         **object                 //  OUT:  points   to  the    allocated   object

157     )

158  {

159     UINT32                   i;

160

161     //     find    an     unoccupied         handle     slot

162     for(i      =   0;     i     <  MAX_LOADED_OBJECTS;          i++)

163     {

164            if(!s_objects[i].occupied)                                 //  If   found   a  free  slot

165            {

166                    //     Mark     the  slot        as  occupied

167                    s_objects[i].occupied                =   TRUE;

168                    break;

169            }

170     }

171     //     If  we     reach        the  end     of  object    slot    without  finding    a  free  one,    return

172     //     error.

173     if(i       ==  MAX_LOADED_OBJECTS)                  return  FALSE;

174

175     *handle        =   i     +     TRANSIENT_FIRST;

176     *object        =   &s_objects[i].object.entity;

177

178     //     Initialize              the  object      attributes

179     MemorySet(&((*object)->attributes),                           0,  sizeof(OBJECT_ATTRIBUTES));

180

181     return         TRUE;

182  }

     8.5.3.12      ObjectLoad()

     This function loads an object into an internal object structure. If an error is returned, the internal state is

     unchanged.

     Family "2.0"                                               TCG Published                                          Page 157

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                              October 30, 2014
     Trusted Platform Module Library                                                                              Part 4: Supporting Routines

     Error Returns                             Meaning

     TPM_RC_BINDING                            if the public and sensitive parts of the object are not matched

     TPM_RC_KEY                                if the parameters in the public area of the object are not consistent

     TPM_RC_OBJECT_MEMORY                      if there is no free slot for an object

     TPM_RC_TYPE                               the public and private parts are not the same type

183  TPM_RC

184  ObjectLoad(

185     TPMI_RH_HIERARCHY                  hierarchy,                     //   IN:   hierarchy           to  which      the   object  belongs

186     TPMT_PUBLIC                        *publicArea,                   //   IN:   public       area

187     TPMT_SENSITIVE                     *sensitive,                    //   IN:   sensitive           area     (may    be  null)

188     TPM2B_NAME                         *name,                         //   IN:   object's         name     (may     be    null)

189     TPM_HANDLE                         parentHandle,                  //   IN:   handle       of     parent

190     BOOL                               skipChecks,                    //   IN:   flag     to   indicate       if      it  is  OK  to  skip

191                                                                       //         consistency             checks.

192     TPMI_DH_OBJECT                     *handle                        //   OUT:     object     handle

193     )

194  {

195     OBJECT                             *object           =     NULL;

196     OBJECT                             *parent           =     NULL;

197     TPM_RC                                 result        =     TPM_RC_SUCCESS;

198     TPM2B_NAME                             parentQN;                        //   Parent       qualified       name

199

200     //   Try  to    allocate        a  slot         for     new     object

201     if(!ObjectAllocateSlot(handle,                             &object))

202           return    TPM_RC_OBJECT_MEMORY;

203

204     //   Initialize     public

205     object->publicArea              =  *publicArea;

206     if(sensitive        !=     NULL)

207           object->sensitive                =     *sensitive;

208

209     //   Are  the   consistency               checks        needed

210     if(!skipChecks)

211     {

212           //  Check     if     key     size         matches

213           if(!CryptObjectIsPublicConsistent(&object->publicArea))

214           {

215                 result      =  TPM_RC_KEY;

216                 goto    ErrorExit;

217           }

218           if(sensitive         !=      NULL)

219           {

220                 //  Check      if      public       type       matches      sensitive         type

221                 result      =  CryptObjectPublicPrivateMatch(object);

222                 if(result          !=  TPM_RC_SUCCESS)

223                         goto   ErrorExit;

224           }

225     }

226     object->attributes.publicOnly                           =  (sensitive        ==  NULL);

227

228     //   If   'name'    is     NULL,       then     there        is   nothing       left  to      do     for  this

229     //   object     as  it     has     no     qualified          name     and   it   is   not     a   member      of    any

230     //   hierarchy      and    it      is     temporary

231     if(name     ==  NULL       ||   name->t.size               ==    0)

232     {

233           object->qualifiedName.t.size                           =   0;

234           object->name.t.size                    =  0;

235           object->attributes.temporary                           =   SET;

236           return    TPM_RC_SUCCESS;

237     }

238     //   If   parent    handle         is     a     permanent        handle,     it  is   a    primary        or    temporary

     Page 158                                                      TCG Published                                                      Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
     Part 4: Supporting Routines                                                              Trusted Platform Module  Library

239     //  object

240     if(HandleGetType(parentHandle)                   ==     TPM_HT_PERMANENT)

241     {

242           //   initialize     QN

243           parentQN.t.size         =  4;

244

245           //   for  a  primary       key,     parent     qualified     name  is   the  handle  of  hierarchy

246           UINT32_TO_BYTE_ARRAY(parentHandle,                       parentQN.t.name);

247     }

248     else

249     {

250           //   Get  hierarchy        and   qualified        name   of  parent

251           ObjectGetQualifiedName(parentHandle,                         &parentQN);

252

253           //   Check   for    stClear      object

254           parent    =  ObjectGet(parentHandle);

255           if(       publicArea->objectAttributes.stClear                     ==  SET

256                ||   parent->attributes.stClear                 ==  SET)

257                 object->attributes.stClear                  =  SET;

258

259     }

260     object->name       =   *name;

261

262     //  Compute     object    qualified       name

263     ObjectComputeQualifiedName(&parentQN,                      publicArea->nameAlg,

264                                               name,      &object->qualifiedName);

265

266     //  Any    object     in  TPM_RH_NULL         hierarchy        is  temporary

267     if(hierarchy       ==     TPM_RH_NULL)

268     {

269           object->attributes.temporary                   =  SET;

270     }

271     else  if(parentQN.t.size              ==  sizeof(TPM_HANDLE))

272     {

273           //   Otherwise,     if     the   size   of     parent's      qualified    name  is  the  size  of  a

274           //   handle,     this   object      is  a     primary    object

275           object->attributes.primary                 =   SET;

276     }

277     switch(hierarchy)

278     {

279           case     TPM_RH_PLATFORM:

280                 object->attributes.ppsHierarchy                    =   SET;

281                 break;

282           case     TPM_RH_OWNER:

283                 object->attributes.spsHierarchy                    =   SET;

284                 break;

285           case     TPM_RH_ENDORSEMENT:

286                 object->attributes.epsHierarchy                    =   SET;

287                 break;

288           case     TPM_RH_NULL:

289                 break;

290           default:

291                 pAssert(FALSE);

292                 break;

293     }

294     return     TPM_RC_SUCCESS;

295

296  ErrorExit:

297     ObjectFlush(*handle);

298     return     result;

299  }

     Family "2.0"                                           TCG Published                                           Page 159

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                            October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting Routines

     8.5.3.13       AllocateSequenceSlot()

     This function allocates a sequence slot and initializes the parts that are used by the normal objects                              so

     that a sequence object is not inadvertently used for an operation that is not appropriate for a sequence.

300  static    BOOL

301  AllocateSequenceSlot(

302     TPM_HANDLE                  *newHandle,                //    OUT:      receives       the  allocated        handle

303     HASH_OBJECT                 **object,                  //    OUT:      receives       pointer      to   allocated   object

304     TPM2B_AUTH                  *auth                      //    IN:      the   authValue      for     the  slot

305     )

306  {

307     OBJECT                              *objectHash;                       //   the     hash   as  an  object

308

309     if(!ObjectAllocateSlot(newHandle,                            &objectHash))

310               return   FALSE;

311

312     *object       =   (HASH_OBJECT             *)objectHash;

313

314     //     Validate       that     the     proper      location       of   the     hash   state    data     relative    to  the

315     //     object     state     data.

316     pAssert(&((*object)->auth)                     ==  &objectHash->publicArea.authPolicy);

317

318     //     Set   the   common      values      that    a   sequence        object        shares    with     an  ordinary    object

319     //     The   type     is  TPM_ALG_NULL

320     (*object)->type             =  TPM_ALG_NULL;

321

322     //     This   has     no  name      algorithm      and       the   name     is   the  Empty     Buffer

323     (*object)->nameAlg              =      TPM_ALG_NULL;

324

325     //     Clear     the  attributes

326     MemorySet(&((*object)->objectAttributes),                                  0,   sizeof(TPMA_OBJECT));

327

328     //     A   sequence       object       is  considered        to    be  in      the   NULL  hierarchy        so  it  should

329     //     be   marked    as    temporary          so  that      it   can't     be   persisted

330     (*object)->attributes.temporary                        =     SET;

331

332     //     A   sequence       object       is  DA  exempt.

333     (*object)->objectAttributes.noDA                          =  SET;

334

335     if(auth       !=   NULL)

336     {

337               MemoryRemoveTrailingZeros(auth);

338               (*object)->auth           =  *auth;

339     }

340     else

341               (*object)->auth.t.size               =   0;

342     return       TRUE;

343  }

     8.5.3.14       Object C reat eHM AC Seq uen ce()

     This function creates an internal HMAC sequence object.

     Error Returns                             Meaning

     TPM_RC_OBJECT_MEMORY                      if there is no free slot for an object

344  TPM_RC

345  ObjectCreateHMACSequence(

346     TPMI_ALG_HASH                  hashAlg,                //    IN:      hash     algorithm

347     TPM_HANDLE                     handle,                 //    IN:      the   handle    associated        with    sequence

348                                                            //             object

     Page 160                                                  TCG Published                                                    Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part  4: Supporting Routines                                                        Trusted Platform Module  Library

349        TPM2B_AUTH         *auth,                   //  IN:   authValue

350        TPMI_DH_OBJECT     *newHandle               //  OUT:    HMAC  sequence   object  handle

351        )

352  {

353        HASH_OBJECT                *hmacObject;

354        OBJECT                     *keyObject;

355

356        //  Try  to  allocate   a    slot   for  new    object

357        if(!AllocateSequenceSlot(newHandle,             &hmacObject,          auth))

358            return      TPM_RC_OBJECT_MEMORY;

359

360        //  Set  HMAC   sequence     bit

361        hmacObject->attributes.hmacSeq           =    SET;

362

363        //  Get  pointer   to   the   HMAC  key  object

364        keyObject    =  ObjectGet(handle);

365

366        CryptStartHMACSequence2B(hashAlg,               &keyObject->sensitive.sensitive.bits.b,

367                                           &hmacObject->state.hmacState);

368

369        return   TPM_RC_SUCCESS;

370  }

     8.5.3.15       ObjectCreateHashSequence()

     This function creates a hash sequence object.

     Error Returns                       Meaning

     TPM_RC_OBJECT_MEMORY                if there is no free slot for an object

371  TPM_RC

372  ObjectCreateHashSequence(

373        TPMI_ALG_HASH           hashAlg,            //  IN:   hash    algorithm

374        TPM2B_AUTH         *auth,                   //  IN:   authValue

375        TPMI_DH_OBJECT     *newHandle               //  OUT:    sequence      object  handle

376        )

377  {

378        HASH_OBJECT                *hashObject;

379

380        //  Try  to  allocate   a    slot   for  new    object

381        if(!AllocateSequenceSlot(newHandle,             &hashObject,          auth))

382            return      TPM_RC_OBJECT_MEMORY;

383

384        //  Set  hash   sequence     bit

385        hashObject->attributes.hashSeq           =    SET;

386

387        //  Start    hash  for  hash  sequence

388        CryptStartHashSequence(hashAlg,             &hashObject->state.hashState[0]);

389

390        return   TPM_RC_SUCCESS;

391  }

     8.5.3.16       ObjectCreateEventSequence()

     This function creates an event sequence object.

     Error Returns                       Meaning

     TPM_RC_OBJECT_MEMORY                if there is no free slot for an object

392  TPM_RC

     Family "2.0"                                      TCG Published                                Page 161

     Level 00 Revision 01.16                   Copyright © TCG 2006-2014                            October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

393  ObjectCreateEventSequence(

394        TPM2B_AUTH                  *auth,                        //  IN:   authValue

395        TPMI_DH_OBJECT              *newHandle                    //  OUT:    sequence   object       handle

396        )

397  {

398        HASH_OBJECT                           *hashObject;

399        UINT32                                count;

400        TPM_ALG_ID                            hash;

401

402        //   Try  to   allocate            a  slot    for     new     object

403        if(!AllocateSequenceSlot(newHandle,                               &hashObject,   auth))

404              return      TPM_RC_OBJECT_MEMORY;

405

406        //   Set  the     event         sequence      attribute

407        hashObject->attributes.eventSeq                           =   SET;

408

409        //   Initialize          hash      states     for     each    implemented      PCR   algorithms

410        for(count      =     0;     (hash     =  CryptGetHashAlgByIndex(count))                   !=  TPM_ALG_NULL;     count++)

411        {

412              //  If   this         is  a     _TPM_Init       or     _TPM_HashStart,     the   sequence       object    will

413              //  not     leave         the   TPM   so    it  doesn't       need  the   sequence      handling

414              if(auth        ==     NULL)

415                    CryptStartHash(hash,                   &hashObject->state.hashState[count]);

416              else

417                    CryptStartHashSequence(hash,                          &hashObject->state.hashState[count]);

418        }

419        return    TPM_RC_SUCCESS;

420  }

     8.5.3.17        ObjectTerminateEvent()

     This function is called to close out the event sequence and clean up the hash context states.

421  void

422  ObjectTerminateEvent(

423        void

424        )

425  {

426        HASH_OBJECT                           *hashObject;

427        int                                   count;

428        BYTE                                  buffer[MAX_DIGEST_SIZE];

429        hashObject        =  (HASH_OBJECT             *)ObjectGet(g_DRTMHandle);

430

431        //   Don't    assume        that      this    is   a  proper        sequence   object

432        if(hashObject->attributes.eventSeq)

433        {

434              //  If   it    is,        close    any    open      hash    contexts.    This   is  done  in    case

435              //  the     crypto        implementation               has  some  context     values    that    need  to  be

436              //  cleaned           up  (hygiene).

437              //

438              for(count          =  0;     CryptGetHashAlgByIndex(count)                 !=   TPM_ALG_NULL;         count++)

439              {

440                    CryptCompleteHash(&hashObject->state.hashState[count],                                    0,    buffer);

441              }

442              //  Flush      sequence            object

443              ObjectFlush(g_DRTMHandle);

444        }

445

446        g_DRTMHandle         =      TPM_RH_UNASSIGNED;

447  }

     Page 162                                                        TCG Published                                             Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

     8.5.3.18       ObjectContextLoad()

     This function loads an object from a saved object context.

     Error Returns                         Meaning

     TPM_RC_OBJECT_MEMORY                  if there is no free slot for an object

448  TPM_RC

449  ObjectContextLoad(

450        OBJECT             *object,                   //      IN:   object    structure     from  saved  context

451        TPMI_DH_OBJECT     *handle                    //      OUT:    object    handle

452        )

453  {

454        OBJECT            *newObject;

455

456        //  Try   to  allocate       a  slot    for   new     object

457        if(!ObjectAllocateSlot(handle,                &newObject))

458            return     TPM_RC_OBJECT_MEMORY;

459

460        //  Copy  input    object       data    to    internal     structure

461        *newObject     =   *object;

462

463        return    TPM_RC_SUCCESS;

464  }

     8.5.3.19       ObjectFlush()

     This function frees an object slot.

     This function requires that the object is loaded.

465  void

466  ObjectFlush(

467        TPMI_DH_OBJECT           handle               //      IN:   handle    to  be  freed

468        )

469  {

470        UINT32            index   =     handle     -  TRANSIENT_FIRST;

471        pAssert(ObjectIsPresent(handle));

472

473        //  Mark  the     handle     slot  as      unoccupied

474        s_objects[index].occupied               =     FALSE;

475

476        //  With  no   attributes

477        MemorySet((BYTE*)&(s_objects[index].object.entity.attributes),

478                       0,  sizeof(OBJECT_ATTRIBUTES));

479        return;

480  }

     8.5.3.20       ObjectFlushHierarchy()

     This function is called to flush all the loaded             transient objects associated with a        hierarchy when the

     hierarchy is disabled.

481  void

482  ObjectFlushHierarchy(

483        TPMI_RH_HIERARCHY               hierarchy             //    IN:  hierarchy      to  be  flush

484        )

485  {

486        UINT16             i;

487

488        //  iterate    object     slots

     Family "2.0"                                        TCG Published                                               Page 163

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                    Part 4: Supporting Routines

489     for(i       =  0;  i   <  MAX_LOADED_OBJECTS;          i++)

490     {

491            if(s_objects[i].occupied)                               //     If     found   an  occupied      slot

492            {

493                    switch(hierarchy)

494                    {

495                           case    TPM_RH_PLATFORM:

496                                   if(s_objects[i].object.entity.attributes.ppsHierarchy                               ==  SET)

497                                       s_objects[i].occupied               =   FALSE;

498                                   break;

499                           case    TPM_RH_OWNER:

500                                   if(s_objects[i].object.entity.attributes.spsHierarchy                               ==  SET)

501                                       s_objects[i].occupied               =   FALSE;

502                                   break;

503                           case    TPM_RH_ENDORSEMENT:

504                                   if(s_objects[i].object.entity.attributes.epsHierarchy                               ==  SET)

505                                       s_objects[i].occupied               =   FALSE;

506                                   break;

507                           default:

508                                   pAssert(FALSE);

509                                   break;

510                    }

511            }

512     }

513

514     return;

515

516  }

     8.5.3.21       ObjectLoadEvict()

     This function loads a persistent object into a transient object slot.

     This function requires that handle is associated with a persistent object.

     Error Returns                             Meaning

     TPM_RC_HANDLE                             the persistent  object  does      not  exist  or  the  associated  hierarchy   is

                                               disabled.

     TPM_RC_OBJECT_MEMORY                      no object slot

517  TPM_RC

518  ObjectLoadEvict(

519     TPM_HANDLE                    *handle,            //   IN:OUT:           evict     object     handle.     If  success,      it

520                                                       //   will       be     replace     by  the    loaded    object      handle

521     TPM_CC                        commandCode         //   IN:     the       command     being    processed

522     )

523  {

524     TPM_RC                        result;

525     TPM_HANDLE                    evictHandle     =   *handle;         //     Save     the   evict  handle

526     OBJECT                        *object;

527

528     //     If   this   is     an  index    that   references       a   persistent           object  created       by

529     //     the     platform,      then    return     TPM_RH_HANDLE           if   the    phEnable   is  FALSE

530     if(*handle         >=     PLATFORM_PERSISTENT)

531     {

532            //      belongs    to  platform

533            if(g_phEnable          ==    CLEAR)

534                    return     TPM_RC_HANDLE;

535     }

536     //     belongs     to     owner

537     else       if(gc.shEnable         ==   CLEAR)

538            return      TPM_RC_HANDLE;

539

     Page 164                                                  TCG Published                                                  Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                              Trusted Platform Module  Library

540        //   Try    to   allocate        a   slot     for    an    object

541        if(!ObjectAllocateSlot(handle,                         &object))

542                return       TPM_RC_OBJECT_MEMORY;

543

544        //   Copy       persistent       object       to     transient        object  slot.          A  TPM_RC_HANDLE

545        //   may    be   returned        at     this     point.      This     will    mark  the      slot   as    containing

546        //   a   transient         object       so   that    it    will     be  flushed     at   the        end  of  the

547        //   command

548        result      =    NvGetEvictObject(evictHandle,                        object);

549

550        //   Bail       out   if   this     failed

551        if(result        !=    TPM_RC_SUCCESS)

552                return       result;

553

554        //   check       the   object       to   see     if  it    is  in     the   endorsement         hierarchy

555        //   if     it   is   and   this     is     not   a  TPM2_EvictControl()            command,             indicate

556        //   that       the   hierarchy         is   disabled.

557        //   If     the  associated          hierarchy         is    disabled,        make  it   look       like     the

558        //   handle      is    not  defined

559        if(         ObjectDataGetHierarchy(object)                          ==  TPM_RH_ENDORSEMENT

560                &&  gc.ehEnable          ==     CLEAR

561                &&  commandCode          !=     TPM_CC_EvictControl

562             )

563                return       TPM_RC_HANDLE;

564

565        return      result;

566  }

     8.5.3.22          ObjectComputeName()

     This function computes the Name of an object from its public area.

567  void

568  ObjectComputeName(

569        TPMT_PUBLIC                 *publicArea,                 //    IN:    public  area       of     an  object

570        TPM2B_NAME                  *name                        //    OUT:     name  of    the  object

571        )

572  {

573        TPM2B_PUBLIC                         marshalBuffer;

574        BYTE                                *buffer;                            //  auxiliary        marshal      buffer   pointer

575        HASH_STATE                           hashState;                         //  hash    state

576

577        //   if     the  nameAlg       is    NULL     then     there      is    no  name.

578        if(publicArea->nameAlg                   ==   TPM_ALG_NULL)

579        {

580                name->t.size        =    0;

581                return;

582        }

583        //   Start       hash     stack

584        name->t.size           =   CryptStartHash(publicArea->nameAlg,                           &hashState);

585

586        //   Marshal         the   public       area     into    its   canonical      form

587        buffer      =    marshalBuffer.b.buffer;

588

589        marshalBuffer.t.size                 =   TPMT_PUBLIC_Marshal(publicArea,                        &buffer,     NULL);

590

591        //   Adding      public     area

592        CryptUpdateDigest2B(&hashState,                          &marshalBuffer.b);

593

594        //   Complete         hash  leaving          room    for     the    name    algorithm

595        CryptCompleteHash(&hashState,                        name->t.size,            &name->t.name[2]);

596

597        //   set    the      nameAlg

598        UINT16_TO_BYTE_ARRAY(publicArea->nameAlg,                                   name->t.name);

     Family "2.0"                                                   TCG Published                                                Page 165

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

599        name->t.size        +=    2;

600        return;

601  }

     8.5.3.23          ObjectComputeQualifiedName()

     This function computes the qualified name of an object.

602  void

603  ObjectComputeQualifiedName(

604        TPM2B_NAME                *parentQN,             //  IN:   parent's       qualified    name

605        TPM_ALG_ID                nameAlg,               //  IN:   name   hash

606        TPM2B_NAME                *name,                 //  IN:   name   of  the   object

607        TPM2B_NAME                *qualifiedName         //  OUT:  qualified        name  of   the   object

608        )

609  {

610        HASH_STATE                hashState;         //  hash     state

611

612        //            QN_A  =   hash_A    (QN  of    parent    ||  NAME_A)

613

614        //     Start  hash

615        qualifiedName->t.size             =   CryptStartHash(nameAlg,             &hashState);

616

617        //     Add  parent's      qualified    name

618        CryptUpdateDigest2B(&hashState,                  &parentQN->b);

619

620        //     Add  self    name

621        CryptUpdateDigest2B(&hashState,                  &name->b);

622

623        //     Complete     hash  leaving      room  for     the   name   algorithm

624        CryptCompleteHash(&hashState,                qualifiedName->t.size,

625                                      &qualifiedName->t.name[2]);

626        UINT16_TO_BYTE_ARRAY(nameAlg,                qualifiedName->t.name);

627        qualifiedName->t.size             +=   2;

628        return;

629  }

     8.5.3.24          ObjectDataIsStorage()

     This function determines if a public area has the attributes associated with a storage key. A storage key               is

     an asymmetric object that has its restricted and decrypt attributes SET, and sign CLEAR.

     Return Value                            Meaning

     TRUE                                    if the object is a storage key

     FALSE                                   if the object is not a storage key

630  BOOL

631  ObjectDataIsStorage(

632        TPMT_PUBLIC               *publicArea            //  IN:   public     area  of    the  object

633        )

634  {

635        if(         CryptIsAsymAlgorithm(publicArea->type)                                //   must    be  asymmetric,

636               &&   publicArea->objectAttributes.restricted                   ==   SET    //   restricted,

637               &&   publicArea->objectAttributes.decrypt                  ==  SET         //   decryption      key

638               &&   publicArea->objectAttributes.sign              ==     CLEAR           //   can   not   be  sign  key

639            )

640               return     TRUE;

641        else

642               return     FALSE;

643  }

     Page 166                                               TCG Published                                         Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                             Trusted Platform Module Library

     8.5.3.25       ObjectIsStorage()

     This function determines if an object has the attributes associated with a storage key.                              A  storage  key  is  an

     asymmetric object that has its restricted and decrypt attributes SET, and sign CLEAR.

     Return Value                               Meaning

     TRUE                                       if the object is a storage key

     FALSE                                      if the object is not a storage key

644  BOOL

645  ObjectIsStorage(

646        TPMI_DH_OBJECT               handle                      //     IN:    object     handle

647        )

648  {

649        OBJECT                       *object     =      ObjectGet(handle);

650        return      ObjectDataIsStorage(&object->publicArea);

651  }

     8.5.3.26       ObjectCapGetLoaded()

     This function returns a a list of handles of loaded object, starting from handle. Handle must be in the

     range of valid transient object handles, but does not have to be the handle of a loaded transient object.

     Return Value                               Meaning

     YES                                        if there are more handles available

     NO                                         all the available handles has been returned

652  TPMI_YES_NO

653  ObjectCapGetLoaded(

654        TPMI_DH_OBJECT               handle,                     //     IN:    start   handle

655        UINT32                       count,                      //     IN:    count   of     returned    handles

656        TPML_HANDLE                 *handleList                  //     OUT:   list    of     handle

657        )

658  {

659        TPMI_YES_NO                      more        =  NO;

660        UINT32                           i;

661

662        pAssert(HandleGetType(handle)                        ==  TPM_HT_TRANSIENT);

663

664        //  Initialize           output  handle         list

665        handleList->count            =   0;

666

667        //  The     maximum      count   of      handles         we     may    return     is  MAX_CAP_HANDLES

668        if(count       >  MAX_CAP_HANDLES)              count        =  MAX_CAP_HANDLES;

669

670        //  Iterate       object     slots       to     get   loaded         object    handles

671        for(i    =  handle       -   TRANSIENT_FIRST;                i  <    MAX_LOADED_OBJECTS;              i++)

672        {

673            if(s_objects[i].occupied                      ==     TRUE)

674            {

675                    //    A  valid      transient         object        can    not    be   the     copy   of  a  persistent    object

676                    pAssert(s_objects[i].object.entity.attributes.evict                                          ==  CLEAR);

677

678                    if(handleList->count                  <   count)

679                    {

680                             //  If  we  have        not     filled        up  the    return       list,  add    this  object

681                             //  handle      to  it

682                             handleList->handle[handleList->count]                              =  i  +   TRANSIENT_FIRST;

683                             handleList->count++;

     Family "2.0"                                                   TCG Published                                                 Page 167

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

684                     }

685                     else

686                     {

687                              //   If     the   return      list  is    full   but     we     still  have   loaded     object

688                              //   available,          report     this    and  stop    iterating

689                              more     =  YES;

690                              break;

691                     }

692             }

693       }

694

695       return        more;

696  }

     8.5.3.27        ObjectCapGetTransientAvail()

     This function returns an estimate of the number of additional transient                            objects    that  could  be    loaded  into

     the TPM.

697  UINT32

698  ObjectCapGetTransientAvail(

699       void

700       )

701  {

702       UINT32                 i;

703       UINT32                 num   =     0;

704

705       //   Iterate        object         slot  to     get  the   number       of      unoccupied    slots

706       for(i      =  0;    i  <    MAX_LOADED_OBJECTS;            i++)

707       {

708             if(s_objects[i].occupied                       ==  FALSE)    num++;

709       }

710

711       return        num;

712  }

     8.6       PCR.c

     8.6.1      Introduction

     This function contains the functions needed for PCR access and manipulation.

     This implementation uses a static allocation for the PCR. The amount of memory is allocated based on

     the number of PCR in the implementation and the number of implemented hash algorithms. This is not

     the expected implementation. PCR SPACE DEFINITIONS.

     In   the  definitions       below,      the   g_hashPcrMap          is  a    bit     array  that   indicates  which  of    the   PCR     are

     implemented. The g_hashPcr array is an array of digests. In this implementation, the space is allocated

     whether the PCR is implemented or not.

     8.6.2      Includes, Defines, and Data Definitions

1    #define    PCR_C

2    #include        "InternalRoutines.h"

3    #include        <Platform.h>

     The    initial  value  of   PCR         attributes.   The     value     of  these    fields  should  be   consistent       with  PC  Client

     specification In this implementation, we assume the total number of implemented PCR is 24.

4    static    const       PCR_Attributes          s_initAttributes[]                  =

     Page 168                                                      TCG Published                                                Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                  Trusted Platform Module Library

5   {

6         //   PCR  0  -   15,    static    RTM

7         {1,  0,   0x1F},      {1,     0,  0x1F},      {1,  0,   0x1F},   {1,    0,   0x1F},

8         {1,  0,   0x1F},      {1,     0,  0x1F},      {1,  0,   0x1F},   {1,    0,   0x1F},

9         {1,  0,   0x1F},      {1,     0,  0x1F},      {1,  0,   0x1F},   {1,    0,   0x1F},

10        {1,  0,   0x1F},      {1,     0,  0x1F},      {1,  0,   0x1F},   {1,    0,   0x1F},

11

12        {0,  0x0F,      0x1F},                //     PCR   16,  Debug

13        {0,  0x10,      0x1C},                //     PCR   17,  Locality     4

14        {0,  0x10,      0x1C},                //     PCR   18,  Locality     3

15        {0,  0x10,      0x0C},                //     PCR   19,  Locality     2

16        {0,  0x14,      0x0E},                //     PCR   20,  Locality     1

17        {0,  0x14,      0x04},                //     PCR   21,  Dynamic     OS

18        {0,  0x14,      0x04},                //     PCR   22,  Dynamic     OS

19        {0,  0x0F,      0x1F},                //     PCR   23,  App   specific

20        {0,  0x0F,      0x1F}                 //     PCR   24,  testing     policy

21  };

    8.6.3      Functions

    8.6.3.1         PCRBelongsAuthGroup()

    This function indicates if a PCR belongs to a group that requires an authValue in order to modify                              the

    PCR.     If it does, groupIndex is set to value of the group index.                 This feature of PCR is decided by          the

    platform specification.

    Return Value                            Meaning

    TRUE:                                   PCR belongs an auth group

    FALSE:                                  PCR does not belong an auth group

22  BOOL

23  PCRBelongsAuthGroup(

24        TPMI_DH_PCR                  handle,               //   IN:   handle    of   PCR

25        UINT32                    *groupIndex              //   OUT:   group    index     if  PCR     belongs    a

26                                                           //          group    that     allows       authValue.        If  PCR

27                                                           //          does     not  belong     to    an   auth  group,

28                                                           //          the   value    in     this     parameter     is

29                                                           //          invalid

30  )

31  {

32  #if   NUM_AUTHVALUE_PCR_GROUP               >   0

33        //   Platform       specification         determines    to     which    auth     group     a  PCR  belongs      (if

34        //   any).   In     this     implementation,       we   assume      there    is   only

35        //   one  auth      group     which   contains     PCR[20-22].          If   the     platform      specification

36        //   requires       differently,         the  implementation         should      be   changed      accordingly

37        if(handle       >=  20    &&  handle      <=  22)

38        {

39             *groupIndex          =   0;

40             return      TRUE;

41        }

42

43  #endif

44        return    FALSE;

45  }

    8.6.3.2         PCRBelongsPolicyGroup()

    This function indicates if a PCR belongs to a group that requires a policy authorization in order to modify

    the PCR.   If it does, groupIndex is set to value of the group index.                  This feature of PCR is decided by the

    platform specification.

    Family "2.0"                                             TCG Published                                                     Page 169

    Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                      October 30, 2014
    Trusted Platform Module Library                                                                   Part 4: Supporting Routines

    Return Value                           Meaning

    TRUE:                                  PCR belongs a policy group

    FALSE:                                 PCR does not belong a policy group

46  BOOL

47  PCRBelongsPolicyGroup(

48        TPMI_DH_PCR              handle,                 //   IN:   handle     of  PCR

49        UINT32                *groupIndex                //   OUT:     group   index    if     PCR  belongs      a  group     that

50                                                         //         allows     policy.         If   PCR  does    not    belong  to

51                                                         //         a  policy      group,      the  value    in     this

52                                                         //         parameter      is   invalid

53        )

54  {

55  #if   NUM_POLICY_PCR_GROUP          >  0

56        //  Platform     specification          decides      if  a  PCR  belongs       to   a  policy    group      and

57        //  belongs   to  which       group.        In  this     implementation,        we     assume    there      is  only

58        //  one  policy   group       which     contains      PCR20-22.        If  the     platform      specification

59        //  requires     differently,        the    implementation       should        be   changed      accordingly

60        if(handle    >=   20  &&  handle        <=  22)

61        {

62            *groupIndex       =   0;

63            return    TRUE;

64        }

65  #endif

66        return   FALSE;

67  }

    8.6.3.3        PCRBelongsTCBGroup()

    This function indicates if a PCR belongs to the TCB group.

    Return Value                           Meaning

    TRUE:                                  PCR belongs to TCB group

    FALSE:                                 PCR does not belong to TCB group

68  static    BOOL

69  PCRBelongsTCBGroup(

70        TPMI_DH_PCR              handle                  //   IN:   handle     of  PCR

71        )

72  {

73  #if   ENABLE_PCR_NO_INCREMENT             ==  YES

74        //  Platform     specification          decides      if  a  PCR  belongs       to   a  TCB  group.          In  this

75        //  implementation,       we     assume     PCR[20-22]         belong  to  TCB      group.       If  the    platform

76        //  specification        requires       differently,        the  implementation             should   be

77        //  changed   accordingly

78        if(handle    >=   20  &&  handle        <=  22)

79            return    TRUE;

80

81  #endif

82        return   FALSE;

83  }

    8.6.3.4        PCRPolicyIsAvailable()

    This function indicates if a policy is available for a PCR.

    Page 170                                               TCG Published                                                    Family "2.0"

    October 30, 2014                              Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

     Return Value                        Meaning

     TRUE                                the PCR should be authorized by policy

     FALSE                               the PCR does not allow policy

84   BOOL

85   PCRPolicyIsAvailable(

86         TPMI_DH_PCR         handle             //  IN:   PCR  handle

87         )

88   {

89         UINT32              groupIndex;

90

91         return   PCRBelongsPolicyGroup(handle,     &groupIndex);

92   }

     8.6.3.5       PCRGetAuthValue()

     This function is used to access the authValue of a PCR.     If PCR     does not  belong  to  an  authValue  group,

     an Empty Auth will be returned.

93   void

94   PCRGetAuthValue(

95         TPMI_DH_PCR         handle,            //  IN:   PCR  handle

96         TPM2B_AUTH          *auth              //  OUT:  authValue       of   PCR

97         )

98   {

99         UINT32           groupIndex;

100

101        if(PCRBelongsAuthGroup(handle,         &groupIndex))

102        {

103              *auth   =  gc.pcrAuthValues.auth[groupIndex];

104        }

105        else

106        {

107              auth->t.size  =  0;

108        }

109

110        return;

111  }

     8.6.3.6       PCRGetAuthPolicy()

     This function is used to access the authorization policy of a PCR. It sets policy to the authorization policy

     and returns the hash algorithm for policy If the PCR does not allow a policy, TPM_ALG_NULL is returned.

112  TPMI_ALG_HASH

113  PCRGetAuthPolicy(

114        TPMI_DH_PCR         handle,            //  IN:   PCR  handle

115        TPM2B_DIGEST        *policy            //  OUT:  policy      of  PCR

116        )

117  {

118        UINT32              groupIndex;

119

120        if(PCRBelongsPolicyGroup(handle,       &groupIndex))

121        {

122              *policy    =  gp.pcrPolicies.policy[groupIndex];

123              return     gp.pcrPolicies.hashAlg[groupIndex];

124        }

125        else

126        {

127              policy->t.size   =   0;

     Family "2.0"                                 TCG Published                                       Page 171

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                               October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

128              return      TPM_ALG_NULL;

129        }

130  }

     8.6.3.7       PCRSimStart()

     This function is used to initialize the policies when a TPM is manufactured. This function would                  only  be

     called in a manufacturing environment or in a TPM simulator.

131  void

132  PCRSimStart(

133        void

134        )

135  {

136        UINT32     i;

137        for(i   =  0;     i     <  NUM_POLICY_PCR_GROUP;              i++)

138        {

139              gp.pcrPolicies.hashAlg[i]                   =  TPM_ALG_NULL;

140              gp.pcrPolicies.policy[i].t.size                      =  0;

141        }

142

143        for(i   =  0;     i     <  NUM_AUTHVALUE_PCR_GROUP;               i++)

144        {

145              gc.pcrAuthValues.auth[i].t.size                      =  0;

146        }

147

148        //  We  need      to       give     an  initial   configuration         on  allocated      PCR  before

149        //  receiving           any      TPM2_PCR_Allocate       command    to      change   this    configuration

150        //  When   the       simulation         environment      starts,    we      allocate    all  the  PCRs

151        for(gp.pcrAllocated.count                  =  0;     gp.pcrAllocated.count           <  HASH_COUNT;

152                   gp.pcrAllocated.count++)

153        {

154              gp.pcrAllocated.pcrSelections[gp.pcrAllocated.count].hash

155                   =   CryptGetHashAlgByIndex(gp.pcrAllocated.count);

156

157              gp.pcrAllocated.pcrSelections[gp.pcrAllocated.count].sizeofSelect

158                   =   PCR_SELECT_MAX;

159              for(i    =     0;    i     <  PCR_SELECT_MAX;      i++)

160                   gp.pcrAllocated.pcrSelections[gp.pcrAllocated.count].pcrSelect[i]

161                             =     0xFF;

162        }

163

164        //  Store     the       initial         configuration    to   NV

165        NvWriteReserved(NV_PCR_POLICIES,                     &gp.pcrPolicies);

166        NvWriteReserved(NV_PCR_ALLOCATED,                        &gp.pcrAllocated);

167

168        return;

169  }

     8.6.3.8       GetSavedPcrPointer()

     This function returns the address of an array of state saved PCR based on the hash algorithm.

     Return Value                                  Meaning

     NULL                                          no such algorithm

     not NULL                                      pointer to the 0th byte of the 0th PCR

170  static    BYTE   *

171  GetSavedPcrPointer                  (

172        TPM_ALG_ID                       alg,                //  IN:   algorithm        for  bank

173        UINT32                           pcrIndex            //  IN:   PCR  index       in   PCR_SAVE

     Page 172                                                   TCG Published                                          Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                         Trusted Platform Module Library

174        )

175  {

176        switch(alg)

177        {

178  #ifdef   TPM_ALG_SHA1

179        case     TPM_ALG_SHA1:

180              return      gc.pcrSave.sha1[pcrIndex];

181              break;

182  #endif

183  #ifdef   TPM_ALG_SHA256

184        case     TPM_ALG_SHA256:

185              return      gc.pcrSave.sha256[pcrIndex];

186              break;

187  #endif

188  #ifdef   TPM_ALG_SHA384

189        case     TPM_ALG_SHA384:

190              return      gc.pcrSave.sha384[pcrIndex];

191              break;

192  #endif

193

194  #ifdef   TPM_ALG_SHA512

195        case     TPM_ALG_SHA512:

196              return      gc.pcrSave.sha512[pcrIndex];

197              break;

198  #endif

199  #ifdef   TPM_ALG_SM3_256

200        case     TPM_ALG_SM3_256:

201              return      gc.pcrSave.sm3_256[pcrIndex];

202              break;

203  #endif

204        default:

205              FAIL(FATAL_ERROR_INTERNAL);

206        }

207        //return       NULL;  //     Can't  be  reached

208  }

     8.6.3.9        PcrIsAllocated()

     This function indicates if a PCR number for the particular hash algorithm is allocated.

     Return Value                          Meaning

     FALSE                                 PCR is not allocated

     TRUE                                  PCR is allocated

209  BOOL

210  PcrIsAllocated          (

211        UINT32                    pcr,                //  IN:   The  number  of  the  PCR

212        TPMI_ALG_HASH             hashAlg             //  IN:   The  PCR   algorithm

213        )

214  {

215        UINT32                          i;

216        BOOL                            allocated  =  FALSE;

217

218        if(pcr   <     IMPLEMENTATION_PCR)

219        {

220

221              for(i    =  0;  i   <  gp.pcrAllocated.count;          i++)

222              {

223                    if(gp.pcrAllocated.pcrSelections[i].hash                 ==  hashAlg)

224                    {

225                          if(((gp.pcrAllocated.pcrSelections[i].pcrSelect[pcr/8])

226                                     &  (1  <<  (pcr  %   8)))  !=   0)

     Family "2.0"                                        TCG Published                        Page 173

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                  October 30, 2014
     Trusted Platform Module Library                                                         Part 4: Supporting Routines

227                              allocated  =    TRUE;

228                        else

229                              allocated  =    FALSE;

230                        break;

231                  }

232            }

233     }

234     return      allocated;

235  }

     8.6.3.10     GetPcrPointer()

     This function returns the address of an array of PCR based on the hash algorithm.

     Return Value                         Meaning

     NULL                                 no such algorithm

     not NULL                             pointer to the 0th byte of the 0th PCR

236  static    BYTE  *

237  GetPcrPointer      (

238     TPM_ALG_ID               alg,              //     IN:  algorithm          for  bank

239     UINT32                   pcrNumber         //     IN:  PCR  number

240     )

241  {

242     static      BYTE         *pcr  =  NULL;

243

244     if(!PcrIsAllocated(pcrNumber,              alg))

245            return     NULL;

246

247     switch(alg)

248     {

249  #ifdef    TPM_ALG_SHA1

250     case      TPM_ALG_SHA1:

251            pcr   =  s_pcrs[pcrNumber].sha1Pcr;

252            break;

253  #endif

254  #ifdef    TPM_ALG_SHA256

255     case      TPM_ALG_SHA256:

256            pcr   =  s_pcrs[pcrNumber].sha256Pcr;

257            break;

258  #endif

259  #ifdef    TPM_ALG_SHA384

260     case      TPM_ALG_SHA384:

261            pcr   =  s_pcrs[pcrNumber].sha384Pcr;

262            break;

263  #endif

264  #ifdef    TPM_ALG_SHA512

265     case      TPM_ALG_SHA512:

266            pcr   =  s_pcrs[pcrNumber].sha512Pcr;

267            break;

268  #endif

269  #ifdef    TPM_ALG_SM3_256

270     case      TPM_ALG_SM3_256:

271            pcr   =  s_pcrs[pcrNumber].sm3_256Pcr;

272            break;

273  #endif

274     default:

275            pAssert(FALSE);

276            break;

277     }

278

279     return      pcr;

     Page 174                                      TCG Published                             Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                             Trusted Platform  Module  Library

280  }

     8.6.3.11      IsPcrSelected()

     This function indicates if an indicated PCR number is selected by the bit map in selection.

     Return Value                                  Meaning

     FALSE                                         PCR is not selected

     TRUE                                          PCR is selected

281  static    BOOL

282  IsPcrSelected           (

283     UINT32                                     pcr,                       //  IN:   The     number  of    the  PCR

284     TPMS_PCR_SELECTION                         *selection                 //  IN:   The     selection     structure

285     )

286  {

287     BOOL                                       selected     =   FALSE;

288     if(        pcr       <     IMPLEMENTATION_PCR

289            &&  ((selection->pcrSelect[pcr/8])                             &   (1    <<  (pcr  %    8)))   !=   0)

290            selected               =     TRUE;

291

292     return        selected;

293  }

     8.6.3.12      FilterPcr()

     This function modifies a PCR selection array based on the implemented PCR.

294  static    void

295  FilterPcr(

296     TPMS_PCR_SELECTION                         *selection                 //  IN:   input     PCR   selection

297     )

298  {

299     UINT32                  i;

300     TPMS_PCR_SELECTION                             *allocated         =   NULL;

301

302     //     If  size         of       select    is  less     than      PCR_SELECT_MAX,         zero  the       unspecified  PCR

303     for(i      =     selection->sizeofSelect;                      i  <   PCR_SELECT_MAX;           i++)

304            selection->pcrSelect[i]                       =  0;

305

306     //     Find      the       internal        configuration          for     the   bank

307     for(i      =     0;     i     <     gp.pcrAllocated.count;                i++)

308     {

309            if(gp.pcrAllocated.pcrSelections[i].hash                                     ==  selection->hash)

310            {

311                      allocated            =    &gp.pcrAllocated.pcrSelections[i];

312                      break;

313            }

314     }

315

316     for    (i     =  0;        i     <  selection->sizeofSelect;                  i++)

317     {

318            if(allocated                   ==   NULL)

319            {

320                      //     If       the  required    bank      does      not     exist,    clear   input      selection

321                      selection->pcrSelect[i]                    =     0;

322            }

323            else

324                      selection->pcrSelect[i]                    &=    allocated->pcrSelect[i];

325     }

326

     Family "2.0"                                                   TCG Published                                                   Page 175

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                                              Part 4: Supporting Routines

327        return;

328  }

     8.6.3.13        PcrDrtm()

     This function does the DRTM and H-CRTM processing it is called from _TPM_Hash_End().

329  void

330  PcrDrtm(

331        const     TPMI_DH_PCR                       pcrHandle,                  //   IN:   the   index     of  the    PCR   to     be

332                                                                                //         modified

333        const     TPMI_ALG_HASH                     hash,                       //   IN:   the   bank    identifier

334        const     TPM2B_DIGEST                  *digest                         //   IN:   the   digest    to    modify     the    PCR

335        )

336  {

337        BYTE               *pcrData         =  GetPcrPointer(hash,                   pcrHandle);

338

339        if(pcrData      !=   NULL)

340        {

341              //  Rest     the   PCR      to   zeros

342              MemorySet(pcrData,               0,   digest->t.size);

343

344              //  if   the   TPM       has     not  started,           then     set  the    PCR   to     0...04   and    then      extend

345              if(!TPMIsStarted())

346              {

347                  pcrData[digest->t.size                       -   1]   =   4;

348              }

349              //  Now,     extend         the  value

350              PCRExtend(pcrHandle,                  hash,      digest->t.size,             (BYTE   *)digest->t.buffer);

351        }

352  }

     8.6.3.14        PCRStartup()

     This function initializes the PCR subsystem at TPM2_Startup().

353  void

354  PCRStartup(

355        STARTUP_TYPE                type,                         //   IN:     startup     type

356        BYTE                        locality                      //   IN:     startup     locality

357        )

358  {

359        UINT32                            pcr,      j;

360        UINT32                            saveIndex         =     0;

361

362        g_pcrReConfig        =   FALSE;

363

364        if(type   !=    SU_RESUME)

365        {

366              //  PCR   generation             counter      is     cleared      at   TPM_RESET        and  TPM_RESTART

367              gr.pcrCounter            =  0;

368        }

369

370        //  Initialize/Restore                 PCR  values

371        for(pcr   =    0;   pcr     <     IMPLEMENTATION_PCR;                  pcr++)

372        {

373              //  On   resume,         need    to   know       if     this     PCR   had   its   state     saved    or   not

374              UINT32             stateSaved             =

375                  (type      ==     SU_RESUME           &&  s_initAttributes[pcr].stateSave                       ==    SET)    ?  1   :  0;

376

377              //  If   this     is     the     H-CRTM       PCR    and     we   are  not    doing     a  resume     and     we

378              //  had   an   H-CRTM         event,         then    we   don't       change  this      PCR

379              if(pcr    ==   HCRTM_PCR          &&      type      !=   SU_RESUME       &&   g_DrtmPreStartup            ==  TRUE)

     Page 176                                                        TCG Published                                                    Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                       Trusted Platform Module  Library

380                   continue;

381

382            //   Iterate      each      hash      algorithm         bank

383            for(j      =  0;  j      <  gp.pcrAllocated.count;                 j++)

384            {

385                   TPMI_ALG_HASH                  hash       =  gp.pcrAllocated.pcrSelections[j].hash;

386                   BYTE                          *pcrData       =   GetPcrPointer(hash,             pcr);

387                   UINT16                         pcrSize       =   CryptGetHashDigestSize(hash);

388

389                   if(pcrData           !=   NULL)

390                   {

391                          //  if        state    was     saved

392                          if(stateSaved             ==    1)

393                          {

394                                  //    Restore       saved     PCR     value

395                                  BYTE           *pcrSavedData;

396                                  pcrSavedData            =     GetSavedPcrPointer(

397                                                                    gp.pcrAllocated.pcrSelections[j].hash,

398                                                                    saveIndex);

399                                  MemoryCopy(pcrData,                pcrSavedData,         pcrSize,     pcrSize);

400                          }

401                          else

402                                  //    PCR    was    not       restored  by      state    save

403                          {

404                                  //    If   the    reset       locality      of     the   PCR  is  4,  then

405                                  //    the    reset      value     is   all   one's,      otherwise    it    is

406                                  //    all    zero.

407                                  if((s_initAttributes[pcr].resetLocality                           &   0x10)     !=  0)

408                                        MemorySet(pcrData,                0xFF,      pcrSize);

409                                  else

410                                  {

411                                        MemorySet(pcrData,                0,   pcrSize);

412                                        if(pcr        ==     HCRTM_PCR)

413                                                 pcrData[pcrSize-1]               =  locality;

414                                  }

415                          }

416                   }

417            }

418            saveIndex         +=     stateSaved;

419        }

420

421        //  Reset     authValues

422        if(type    !=     SU_RESUME)

423        {

424            for(j      =  0;  j      <  NUM_AUTHVALUE_PCR_GROUP;                     j++)

425            {

426                   gc.pcrAuthValues.auth[j].t.size                        =    0;

427            }

428        }

429

430  }

     8.6.3.15      PCRStateSave()

     This function is used to save the PCR               values that will be restored on           TPM  Resume.

431  void

432  PCRStateSave(

433        TPM_SU                       type                       //  IN:   startup         type

434        )

435  {

436        UINT32                       pcr,    j;

437        UINT32                       saveIndex        =   0;

438

     Family "2.0"                                                  TCG Published                                             Page 177

     Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

439        //  if    state   save       CLEAR,     nothing     to  be   done.    Return     here

440        if(type   ==     TPM_SU_CLEAR)             return;

441

442        //  Copy  PCR     values        to  the    structure     that  should    be   saved    to  NV

443        for(pcr   =   0;     pcr     <  IMPLEMENTATION_PCR;           pcr++)

444        {

445              UINT32      stateSaved         =     (s_initAttributes[pcr].stateSave            ==  SET)  ?    1  :  0;

446

447              //  Iterate     each      hash       algorithm    bank

448              for(j   =   0;  j      <  gp.pcrAllocated.count;             j++)

449              {

450                  BYTE            *pcrData;

451                  UINT32          pcrSize;

452

453                  pcrData         =     GetPcrPointer(gp.pcrAllocated.pcrSelections[j].hash,                        pcr);

454

455                  if(pcrData            !=  NULL)

456                  {

457                          pcrSize

458                                  =     CryptGetHashDigestSize(gp.pcrAllocated.pcrSelections[j].hash);

459

460                          if(stateSaved            ==  1)

461                          {

462                                  //    Restore    saved    PCR     value

463                                  BYTE          *pcrSavedData;

464                                  pcrSavedData

465                                        =   GetSavedPcrPointer(gp.pcrAllocated.pcrSelections[j].hash,

466                                                                       saveIndex);

467                                  MemoryCopy(pcrSavedData,             pcrData,      pcrSize,      pcrSize);

468                          }

469                  }

470              }

471              saveIndex       +=     stateSaved;

472        }

473

474        return;

475  }

     8.6.3.16        PCRIsStateSaved()

     This function indicates if the selected PCR is a PCR that is state saved on TPM2_Shutdown(STATE).                        The

     return value is based on PCR attributes.

     Return Value                              Meaning

     TRUE                                      PCR is state saved

     FALSE                                     PCR is not state saved

476  BOOL

477  PCRIsStateSaved(

478        TPMI_DH_PCR                  handle                 //  IN:   PCR   handle   to  be    extended

479        )

480  {

481        UINT32                          pcr     =  handle   -   PCR_FIRST;

482

483        if(s_initAttributes[pcr].stateSave                      ==   SET)

484              return     TRUE;

485        else

486              return     FALSE;

487  }

     Page 178                                                  TCG Published                                           Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

     8.6.3.17       PCRIsResetAllowed()

     This function indicates if a PCR may be reset by the current command locality. The                        return  value  is  based

     on PCR attributes, and not the PCR allocation.

     Return Value                            Meaning

     TRUE                                    TPM2_PCR_Reset() is allowed

     FALSE                                   TPM2_PCR_Reset() is not allowed

488  BOOL

489  PCRIsResetAllowed(

490        TPMI_DH_PCR              handle                  //      IN:  PCR  handle   to   be   extended

491        )

492  {

493        UINT8                       commandLocality;

494        UINT8                       localityBits              =  1;

495        UINT32                      pcr       =  handle       -  PCR_FIRST;

496

497        //  Check   for  the     locality

498        commandLocality       =     _plat__LocalityGet();

499

500  #ifdef    DRTM_PCR

501        //  For  a  TPM  that       does  DRTM,         Reset    is   not  allowed  at   locality       4

502        if(commandLocality          ==    4)

503              return  FALSE;

504  #endif

505

506        localityBits     =   localityBits            <<  commandLocality;

507        if((localityBits         &  s_initAttributes[pcr].resetLocality)                      ==  0)

508              return  FALSE;

509        else

510              return  TRUE;

511

512  }

     8.6.3.18       PCRChanged()

     This function checks a PCR handle to see if the attributes for the PCR are set so that any change                            to  the

     PCR causes an increment of the pcrCounter. If it does, then the function increments the counter.

513  void

514  PCRChanged(

515        TPM_HANDLE               pcrHandle               //      IN:  the  handle   of   the   PCR    that      changed.

516        )

517  {

518        //  For  the  reference         implementation,              the   only  change  that     does     not  cause

519        //  increment    is   a     change       to  a   PCR     in  the   TCB   group.

520        if(!PCRBelongsTCBGroup(pcrHandle))

521              gr.pcrCounter++;

522  }

     8.6.3.19       PCRIsExtendAllowed()

     This function indicates a PCR may be extended at the current command locality. The return value is

     based on PCR attributes, and not the PCR allocation.

     Family "2.0"                                           TCG Published                                                    Page 179

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting  Routines

     Return Value                                   Meaning

     TRUE                                           extend is allowed

     FALSE                                          extend is not allowed

523  BOOL

524  PCRIsExtendAllowed(

525        TPMI_DH_PCR                     handle                 //     IN:  PCR    handle  to  be      extended

526        )

527  {

528        UINT8                               commandLocality;

529        UINT8                               localityBits       =      1;

530        UINT32                              pcr  =     handle  -      PCR_FIRST;

531

532        //  Check     for     the       locality

533        commandLocality              =     _plat__LocalityGet();

534        localityBits          =  localityBits          <<  commandLocality;

535        if((localityBits                &   s_initAttributes[pcr].extendLocality)                      ==   0)

536              return   FALSE;

537        else

538              return   TRUE;

539

540  }

     8.6.3.20        PCRExtend()

     This function is used to extend a PCR in a specific bank.

541  void

542  PCRExtend(

543        TPMI_DH_PCR                     handle,                //     IN:  PCR    handle  to  be      extended

544        TPMI_ALG_HASH                   hash,                  //     IN:  hash   algorithm       of   PCR

545        UINT32                          size,                  //     IN:  size   of  data    to  be   extended

546        BYTE                         *data                     //     IN:  data   to  be  extended

547        )

548  {

549        UINT32                              pcr     =  handle      -  PCR_FIRST;

550        BYTE                                *pcrData;

551        HASH_STATE                          hashState;

552        UINT16                              pcrSize;

553

554        pcrData    =  GetPcrPointer(hash,                  pcr);

555

556        //  Extend    PCR        if     it  is   allocated

557        if(pcrData     !=        NULL)

558        {

559              pcrSize      =     CryptGetHashDigestSize(hash);

560              CryptStartHash(hash,                  &hashState);

561              CryptUpdateDigest(&hashState,                        pcrSize,       pcrData);

562              CryptUpdateDigest(&hashState,                        size,   data);

563              CryptCompleteHash(&hashState,                        pcrSize,       pcrData);

564

565              //  If  PCR        does       not  belong    to  TCB        group,  increment       PCR  counter

566              if(!PCRBelongsTCBGroup(handle))

567                   gr.pcrCounter++;

568        }

569

570        return;

571  }

     Page 180                                                     TCG Published                                     Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                            Trusted Platform Module Library

     8.6.3.21        PCRComputeCurrentDigest()

     This function computes the digest of the selected PCR.

     As a side-effect, selection is modified so that only the implemented PCR will have their bits still set.

572  void

573  PCRComputeCurrentDigest(

574        TPMI_ALG_HASH                            hashAlg,                //  IN:   hash     algorithm          to   compute  digest

575        TPML_PCR_SELECTION                    *selection,                //  IN/OUT:        PCR   selection         (filtered     on

576                                                                         //        output)

577        TPM2B_DIGEST                          *digest                    //  OUT:      digest

578        )

579  {

580        HASH_STATE                                      hashState;

581        TPMS_PCR_SELECTION                              *select;

582        BYTE                                            *pcrData;        //  will      point     to   a  digest

583        UINT32                                          pcrSize;

584        UINT32                                          pcr;

585        UINT32                                          i;

586

587        //  Initialize              the   hash

588        digest->t.size               =   CryptStartHash(hashAlg,                  &hashState);

589        pAssert(digest->t.size                       >  0   &&    digest->t.size        <   UINT16_MAX);

590

591        //  Iterate        through           the     list     of  PCR   selection       structures

592        for(i     =  0;    i     <   selection->count;                 i++)

593        {

594              //     Point       to     the   current         selection

595              select       =     &selection->pcrSelections[i];                     //      Point     to  the   current  selection

596              FilterPcr(select);                              //  Clear      out  the   bits     for     unimplemented       PCR

597

598              //     Need     the       size     of     each    digest

599              pcrSize         =     CryptGetHashDigestSize(selection->pcrSelections[i].hash);

600

601              //     Iterate         through         the    selection

602              for(pcr         =     0;   pcr     <   IMPLEMENTATION_PCR;           pcr++)

603              {

604                     if(IsPcrSelected(pcr,                        select))                  //   Is   this     PCR  selected

605                     {

606                              //     Get     pointer        to    the  digest     data     for   the     bank

607                              pcrData         =     GetPcrPointer(selection->pcrSelections[i].hash,                            pcr);

608                              pAssert(pcrData                 !=  NULL);

609                              CryptUpdateDigest(&hashState,                       pcrSize,        pcrData);         //  add  to   digest

610                     }

611              }

612        }

613        //  Complete          hash       stack

614        CryptCompleteHash2B(&hashState,                           &digest->b);

615

616        return;

617  }

     8.6.3.22        PCRRead()

     This function is used to read a list of selected PCR.                      If the requested PCR number exceeds the maximum

     number that can be output, the selection is adjusted to reflect the actual output PCR.

618  void

619  PCRRead(

620        TPML_PCR_SELECTION                    *selection,                //  IN/OUT:        PCR   selection         (filtered     on

621                                                                         //        output)

622        TPML_DIGEST                           *digest,                   //  OUT:      digest

623        UINT32                                *pcrCounter                //  OUT:      the  current      value      of  PCR  generation

     Family "2.0"                                                    TCG Published                                                       Page 181

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

624                                                                              //        number

625     )

626  {

627     TPMS_PCR_SELECTION                               *select;

628     BYTE                                             *pcrData;                     //  will    point       to  a  digest

629     UINT32                                            pcr;

630     UINT32                                            i;

631

632     digest->count              =  0;

633

634     //  Iterate      through            the       list     of       PCR  selection         structures

635     for(i     =  0;  i      <     selection->count;                     i++)

636     {

637           //     Point      to    the    current           selection

638           select     =      &selection->pcrSelections[i];                              //  Point       to   the   current    selection

639           FilterPcr(select);                               //       Clear     out  the     bits    for     unimplemented          PCR

640

641           //     Iterate          through         the     selection

642           for    (pcr       =     0;   pcr     <     IMPLEMENTATION_PCR;                 pcr++)

643           {

644                  if(IsPcrSelected(pcr,                           select))                      //  Is   this      PCR  selected

645                  {

646                          //       Check     if       number         of   digest    exceed      upper       bound

647                          if(digest->count                     >     7)

648                          {

649                                   //    Clear         rest       of     the   current      select      bitmap

650                                   while(              pcr     <     IMPLEMENTATION_PCR

651                                                       //   do       not  round     up!

652                                                &&     (pcr       /   8)  <    select->sizeofSelect)

653                                   {

654                                          //       do   not       round       up!

655                                          select->pcrSelect[pcr/8]                          &=  (BYTE)       ~(1   <<   (pcr  %    8));

656                                          pcr++;

657                                   }

658                                   //    Exit         inner       loop

659                                   break;;

660                          }

661                          //       Need   the         size     of     each     digest

662                          digest->digests[digest->count].t.size                                     =

663                                   CryptGetHashDigestSize(selection->pcrSelections[i].hash);

664

665                          //       Get   pointer           to     the     digest    data    for     the     bank

666                          pcrData         =     GetPcrPointer(selection->pcrSelections[i].hash,                                    pcr);

667                          pAssert(pcrData                   !=       NULL);

668                          //       Add   to     the     data         to   digest

669                          MemoryCopy(digest->digests[digest->count].t.buffer,

670                                                   pcrData,

671                                                   digest->digests[digest->count].t.size,

672                                                   digest->digests[digest->count].t.size);

673                          digest->count++;

674                  }

675           }

676           //     If  we     exit       inner         loop     because         we   have    exceed      the     output      upper  bound

677           if(digest->count                  >     7   &&   pcr       <   IMPLEMENTATION_PCR)

678           {

679                  //  Clear            rest     of     the     selection

680                  while(i          <    selection->count)

681                  {

682                          MemorySet(selection->pcrSelections[i].pcrSelect,                                              0,

683                                                selection->pcrSelections[i].sizeofSelect);

684                          i++;

685                  }

686                  //  exit         outer        loop

687                  break;

688           }

689     }

     Page 182                                                            TCG Published                                                     Family "2.0"

     October 30, 2014                                      Copyright © TCG 2006-2014                                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                        Trusted Platform Module Library

690

691        *pcrCounter       =    gr.pcrCounter;

692

693        return;

694  }

     8.6.3.23        PcrWrite()

     This function is used by _TPM_Hash_End() to set a PCR to the computed hash of the H-CRTM                                  event.

695  void

696  PcrWrite(

697        TPMI_DH_PCR                 handle,                 //       IN:   PCR   handle     to  be   extended

698        TPMI_ALG_HASH               hash,                   //       IN:   hash   algorithm      of   PCR

699        TPM2B_DIGEST               *digest                  //       IN:   the   new   value

700        )

701  {

702        UINT32                           pcr   =   handle         -  PCR_FIRST;

703        BYTE                             *pcrData;

704

705        //  Copy  value        to   the  PCR   if  it   is        allocated

706        pcrData   =    GetPcrPointer(hash,              pcr);

707        if(pcrData        !=   NULL)

708        {

709              MemoryCopy(pcrData,             digest->t.buffer,                 digest->t.size,         digest->t.size);       ;

710        }

711

712        return;

713  }

     8.6.3.24        PCRAllocate()

     This function is used to change the PCR allocation.

     Error Returns                             Meaning

     TPM_RC_SUCCESS                            allocate success

     TPM_RC_NO_RESULTS                         allocate failed

     TPM_RC_PCR                                improper allocation

714  TPM_RC

715  PCRAllocate(

716        TPML_PCR_SELECTION               *allocate,                  //    IN:   required       allocation

717        UINT32                           *maxPCR,                    //    OUT:   Maximum       number  of   PCR

718        UINT32                           *sizeNeeded,                //    OUT:   required      space

719        UINT32                           *sizeAvailable              //    OUT:   available      space

720        )

721  {

722        UINT32                                i,   j,   k;

723        TPML_PCR_SELECTION                    newAllocate;

724        //  Initialize         the  flags     to   indicate          if    HCRTM  PCR    and    DRTM    PCR  are  allocated.

725        BOOL                                  pcrHcrtm         =     FALSE;

726        BOOL                                  pcrDrtm       =     FALSE;

727

728        //  Create     the     expected      new   PCR  allocation              based  on   the     existing    allocation

729        //  and   the     new  input:

730        //    1.  if   a  PCR      bank  does     not   appear       in    the    new  allocation,         the  existing

731        //        allocation        of   this     PCR   bank         will  be    preserved.

732        //    2.  if   a  PCR      bank  appears       multiple           times   in   the  new     allocation,   only    the

733        //        last    one      will  be   in   effect.

734        newAllocate       =    gp.pcrAllocated;

     Family "2.0"                                              TCG Published                                                   Page 183

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                                       Part 4: Supporting Routines

735       for(i    =  0;      i     <     allocate->count;                  i++)

736       {

737           for(j        =     0;       j  <   newAllocate.count;                  j++)

738           {

739                   //      If       hash      matches,           the     new     allocation        covers    the     old     allocation

740                   //      for         this      particular             bank.

741                   //      The         assumption            is     the  initial      PCR      allocation        (from       manufacture)

742                   //      has         all    the     supported          hash     algorithms          with   an    assigned        bank

743                   //      (possibly              empty).            So  there       must   be     a  match     for     any  new   bank

744                   //      allocation                from     the       input.

745                   if(newAllocate.pcrSelections[j].hash                                        ==

746                              allocate->pcrSelections[i].hash)

747                   {

748                              newAllocate.pcrSelections[j]                            =    allocate->pcrSelections[i];

749                              break;

750                   }

751           }

752           //      The     j     loop         must    exit       with    a    match.

753           pAssert(j                <     newAllocate.count);

754       }

755

756       //  Max     PCR     in       a     bank    is     MIN(implemented              PCR,     PCR    with   attributes        defined)

757       *maxPCR     =    sizeof(s_initAttributes)                              /  sizeof(PCR_Attributes);

758       if(*maxPCR          >     IMPLEMENTATION_PCR)

759           *maxPCR            =     IMPLEMENTATION_PCR;

760

761       //  Compute         required              size     for       allocation

762       *sizeNeeded            =     0;

763       for(i    =  0;      i     <     newAllocate.count;                   i++)

764       {

765           UINT32                         digestSize

766                   =    CryptGetHashDigestSize(newAllocate.pcrSelections[i].hash);

767  #if  defined(DRTM_PCR)

768           //      Make       sure        that       we   end       up   with    at   least     one   DRTM      PCR

769  #    define      PCR_DRTM               (PCR_FIRST             +   DRTM_PCR)             //   for   cosmetics

770           pcrDrtm            =           pcrDrtm         ||     TEST_BIT(PCR_DRTM,                newAllocate.pcrSelections[i]);

771  #else    //      if   DRTM           PCR    is     not     required,           indicate      that   the    allocation        is      OK

772           pcrDrtm            =     TRUE;

773  #endif

774

775  #if  defined(HCRTM_PCR)

776           //      and     one         HCRTM      PCR     (since         this    is   usually         PCR   0...)

777  #    define      PCR_HCRTM              (PCR_FIRST             +   HCRTM_PCR)

778           pcrHcrtm              =            pcrDrtm        ||     TEST_BIT(PCR_HCRTM,               newAllocate.pcrSelections[i]);

779  #else

780           pcrHcrtm              =     TRUE;

781  #endif

782           for(j        =     0;       j  <   newAllocate.pcrSelections[i].sizeofSelect;                                     j++)

783           {

784                   BYTE                          mask     =   1;

785                   for(k            =     0;  k   <   8;     k++)

786                   {

787                              if((newAllocate.pcrSelections[i].pcrSelect[j]                                          &  mask)      !=  0)

788                                          *sizeNeeded            +=     digestSize;

789                              mask        =   mask       <<   1;

790                   }

791           }

792       }

793

794       if(!pcrDrtm            ||       !pcrHcrtm)

795           return          TPM_RC_PCR;

796

797       //  In   this       particular                implementation,              we  always          have  enough      space      to

798       //  allocate           PCR.            Different          implementation            may     return    a   sizeAvailable             less

799       //  than    the        sizeNeed.

800       *sizeAvailable                  =  sizeof(s_pcrs);

     Page 184                                                               TCG Published                                                     Family "2.0"

     October 30, 2014                                           Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                              Trusted Platform Module Library

801

802        //   Save    the       required          allocation            to  NV.  Note   that       after    NV  is  written,  the

803        //   PCR     allocation           in     NV   is      no   longer     consistent     with     the  RAM     data

804        //   gp.pcrAllocated.                    The      NV     version   reflect     the   allocate      after       next

805        //   TPM_RESET,              while       the  RAM        version   reflects    the    current      allocation

806        NvWriteReserved(NV_PCR_ALLOCATED,                                  &newAllocate);

807

808        return       TPM_RC_SUCCESS;

809

810  }

     8.6.3.25        PCRSetValue()

     This function is used to set the designated PCR in all banks to an initial value. The initial value                               is  signed

     and will be sign extended into the entire PCR.

811  void

812  PCRSetValue(

813        TPM_HANDLE                        handle,                      //  IN:  the   handle      of  the  PCR     to  set

814        INT8                              initialValue                 //  IN:  the   value   to      set

815        )

816  {

817        int                               i;

818        UINT32                            pcr    =    handle       -   PCR_FIRST;

819        TPMI_ALG_HASH                     hash;

820        UINT16                            digestSize;

821        BYTE                         *pcrData;

822

823        //   Iterate        supported            PCR      bank     algorithms     to   reset

824        for(i     =  0;     i     <  HASH_COUNT;              i++)

825        {

826              hash       =  CryptGetHashAlgByIndex(i);

827              //     Prevent         runaway

828              if(hash          ==    TPM_ALG_NULL)

829                     break;

830

831              //     Get    a     pointer        to   the        data

832              pcrData          =     GetPcrPointer(gp.pcrAllocated.pcrSelections[i].hash,                                    pcr);

833

834              //     If     the      PCR  is     allocated

835              if(pcrData             !=   NULL)

836              {

837                     //     And      the      size    of      the     digest

838                     digestSize               =  CryptGetHashDigestSize(hash);

839

840                     //     Set      the      LSO     to  the      input   value

841                     pcrData[digestSize                       -   1]   =   initialValue;

842

843                     //     Sign     extend

844                     if(initialValue                  >=      0)

845                               MemorySet(pcrData,                     0,   digestSize  -     1);

846                     else

847                               MemorySet(pcrData,                     -1,  digestSize     -  1);

848              }

849        }

850  }

     8.6.3.26        PCRResetDynamics

     This function is used to reset a dynamic PCR to 0.                            This function is used in DRTM sequence.

851  void

852  PCRResetDynamics(

     Family "2.0"                                                         TCG Published                                                Page 185

     Level 00 Revision 01.16                                 Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                         Part 4: Supporting Routines

853        void

854        )

855  {

856        UINT32                             pcr,        i;

857

858        //  Initialize        PCR       values

859        for(pcr   =   0;  pcr        <     IMPLEMENTATION_PCR;              pcr++)

860        {

861              //  Iterate      each        hash        algorithm      bank

862              for(i   =   0;   i     <     gp.pcrAllocated.count;                i++)

863              {

864                  BYTE            *pcrData;

865                  UINT32          pcrSize;

866

867                  pcrData         =     GetPcrPointer(gp.pcrAllocated.pcrSelections[i].hash,                               pcr);

868

869                  if(pcrData               !=   NULL)

870                  {

871                          pcrSize          =

872                                  CryptGetHashDigestSize(gp.pcrAllocated.pcrSelections[i].hash);

873

874                          //   Reset           PCR

875                          //   Any         PCR  can        be  reset  by    locality     4  should  be    reset     to  0

876                          if((s_initAttributes[pcr].resetLocality                               &  0x10)  !=    0)

877                                  MemorySet(pcrData,                  0,  pcrSize);

878                  }

879              }

880        }

881        return;

882  }

     8.6.3.27        PCRCapGetAllocation()

     This function is used to get the current allocation of PCR banks.

     Return Value                                  Meaning

     YES:                                          if the return count is 0

     NO:                                           if the return count is not 0

883  TPMI_YES_NO

884  PCRCapGetAllocation(

885        UINT32                                 count,                 //    IN:   count     of  return

886        TPML_PCR_SELECTION                 *pcrSelection              //    OUT:  PCR    allocation       list

887        )

888  {

889        if(count     ==   0)

890        {

891              pcrSelection->count                   =  0;

892              return     YES;

893        }

894        else

895        {

896              *pcrSelection             =  gp.pcrAllocated;

897              return     NO;

898        }

899  }

     8.6.3.28        PCRSetSelectBit()

     This function sets a bit in a bitmap array.

     Page 186                                                     TCG Published                                               Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                     Trusted Platform Module Library

900  static    void

901  PCRSetSelectBit(

902     UINT32                      pcr,                      //   IN:   PCR  number

903     BYTE                        *bitmap                   //   OUT:  bit     map  to   be        set

904     )

905  {

906     bitmap[pcr      /      8]   |=  (1     <<  (pcr    %  8));

907     return;

908  }

     8.6.3.29     PCRGetProperty()

     This function returns the selected PCR property.

     Return Value                              Meaning

     TRUE                                      the property type is implemented

     FALSE                                     the property type is not implemented

909  static    BOOL

910  PCRGetProperty(

911     TPM_PT_PCR                                 property,

912     TPMS_TAGGED_PCR_SELECT                     *select

913     )

914  {

915     UINT32                          pcr;

916     UINT32                          groupIndex;

917

918     select->tag         =  property;

919     //     Always   set    the      bitmap     to  be     the  size  of   all     PCR

920     select->sizeofSelect                =  (IMPLEMENTATION_PCR            +  7)   /    8;

921

922     //     Initialize      bitmap

923     MemorySet(select->pcrSelect,                     0,   select->sizeofSelect);

924

925     //     Collecting      properties

926     for(pcr      =  0;     pcr  <   IMPLEMENTATION_PCR;              pcr++)

927     {

928            switch(property)

929            {

930                  case      TPM_PT_PCR_SAVE:

931                         if(s_initAttributes[pcr].stateSave                        ==   SET)

932                                 PCRSetSelectBit(pcr,            select->pcrSelect);

933                         break;

934                  case      TPM_PT_PCR_EXTEND_L0:

935                         if((s_initAttributes[pcr].extendLocality                              &  0x01)  !=  0)

936                                 PCRSetSelectBit(pcr,            select->pcrSelect);

937                         break;

938                  case      TPM_PT_PCR_RESET_L0:

939                         if((s_initAttributes[pcr].resetLocality                            &     0x01)  !=  0)

940                                 PCRSetSelectBit(pcr,            select->pcrSelect);

941                         break;

942                  case      TPM_PT_PCR_EXTEND_L1:

943                         if((s_initAttributes[pcr].extendLocality                              &  0x02)  !=  0)

944                                 PCRSetSelectBit(pcr,            select->pcrSelect);

945                         break;

946                  case      TPM_PT_PCR_RESET_L1:

947                         if((s_initAttributes[pcr].resetLocality                            &     0x02)  !=  0)

948                                 PCRSetSelectBit(pcr,            select->pcrSelect);

949                         break;

950                  case      TPM_PT_PCR_EXTEND_L2:

951                         if((s_initAttributes[pcr].extendLocality                              &  0x04)  !=  0)

952                                 PCRSetSelectBit(pcr,            select->pcrSelect);

     Family "2.0"                                             TCG Published                                         Page 187

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                        October 30, 2014
      Trusted Platform Module Library                                                            Part 4: Supporting  Routines

953                       break;

954                case   TPM_PT_PCR_RESET_L2:

955                       if((s_initAttributes[pcr].resetLocality                   &     0x04)  !=   0)

956                           PCRSetSelectBit(pcr,         select->pcrSelect);

957                       break;

958                case   TPM_PT_PCR_EXTEND_L3:

959                       if((s_initAttributes[pcr].extendLocality                     &  0x08)  !=   0)

960                           PCRSetSelectBit(pcr,         select->pcrSelect);

961                       break;

962                case   TPM_PT_PCR_RESET_L3:

963                       if((s_initAttributes[pcr].resetLocality                   &     0x08)  !=   0)

964                           PCRSetSelectBit(pcr,         select->pcrSelect);

965                       break;

966                case   TPM_PT_PCR_EXTEND_L4:

967                       if((s_initAttributes[pcr].extendLocality                     &  0x10)  !=   0)

968                           PCRSetSelectBit(pcr,         select->pcrSelect);

969                       break;

970                case   TPM_PT_PCR_RESET_L4:

971                       if((s_initAttributes[pcr].resetLocality                   &     0x10)  !=   0)

972                           PCRSetSelectBit(pcr,         select->pcrSelect);

973                       break;

974                case   TPM_PT_PCR_DRTM_RESET:

975                       //  DRTM  reset     PCRs    are  the     PCR   reset  by  locality     4

976                       if((s_initAttributes[pcr].resetLocality                   &     0x10)  !=   0)

977                           PCRSetSelectBit(pcr,         select->pcrSelect);

978                       break;

979   #if  NUM_POLICY_PCR_GROUP     >  0

980                case   TPM_PT_PCR_POLICY:

981                       if(PCRBelongsPolicyGroup(pcr                +  PCR_FIRST,       &groupIndex))

982                           PCRSetSelectBit(pcr,         select->pcrSelect);

983                       break;

984   #endif

985   #if  NUM_AUTHVALUE_PCR_GROUP        >   0

986                case   TPM_PT_PCR_AUTH:

987                       if(PCRBelongsAuthGroup(pcr               +  PCR_FIRST,    &groupIndex))

988                           PCRSetSelectBit(pcr,         select->pcrSelect);

989                       break;

990   #endif

991   #if  ENABLE_PCR_NO_INCREMENT        ==     YES

992                case   TPM_PT_PCR_NO_INCREMENT:

993                       if(PCRBelongsTCBGroup(pcr             +     PCR_FIRST))

994                           PCRSetSelectBit(pcr,         select->pcrSelect);

995                       break;

996   #endif

997                default:

998                       //  If   property      is   not  supported,    stop   scanning         PCR  attributes

999                       //  and   return.

1000                      return    FALSE;

1001                      break;

1002            }

1003       }

1004       return  TRUE;

1005  }

      8.6.3.30     PCRCapGetProperties()

      This function returns a list of PCR properties starting at property.

      Page 188                                        TCG Published                                       Family "2.0"

      October 30, 2014                        Copyright © TCG 2006-2014                          Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                             Trusted Platform Module Library

      Return Value                                 Meaning

      YES:                                         if no more property is available

      NO:                                          if there are more properties not reported

1006  TPMI_YES_NO

1007  PCRCapGetProperties(

1008        TPM_PT_PCR                                        property,                   //  IN:      the   starting    PCR  property

1009        UINT32                                            count,                      //  IN:      count  of  returned    propertie

1010        TPML_TAGGED_PCR_PROPERTY                        *select                       //  OUT:     PCR    select

1011        )

1012  {

1013        TPMI_YES_NO                more     =   NO;

1014        UINT32                     i;

1015

1016        //  Initialize         output       property      list

1017        select->count          =   0;

1018

1019        //  The     maximum       count     of  properties           we     may   return       is  MAX_PCR_PROPERTIES

1020        if(count    >   MAX_PCR_PROPERTIES)                  count       =  MAX_PCR_PROPERTIES;

1021

1022        //  TPM_PT_PCR_FIRST              is    defined      as   0   in    spec.         It   ensures    that     property

1023        //  value   would         never     be  less      than    TPM_PT_PCR_FIRST

1024        pAssert(TPM_PT_PCR_FIRST                    ==  0);

1025

1026        //  Iterate     PCR       properties.           TPM_PT_PCR_LAST           is      the  index      of  the  last   property

1027        //  implemented           on   the     TPM.

1028        for(i    =  property;          i  <=    TPM_PT_PCR_LAST;            i++)

1029        {

1030            if(select->count                <   count)

1031            {

1032                    //  If     we     have     not   filled      up   the   return        list,    add    more     properties  to   it

1033                    if(PCRGetProperty(i,                  &select->pcrProperty[select->count]))

1034                           //     only    increment       if     the     property         is   implemented

1035                    select->count++;

1036            }

1037            else

1038            {

1039                    //  If     the     return       list  is     full       but   we  still        have   properties

1040                    //  available,             report     this    and       stop  iterating.

1041                    more    =     YES;

1042                    break;

1043            }

1044        }

1045        return      more;

1046  }

      8.6.3.31       PCRCapGetHandles()

      This function is used to get a list of handles of PCR, started from handle.                             If handle  exceeds the maximum

      PCR handle range, an empty list will be returned and the return value will                              be NO.

      Return Value                                 Meaning

      YES                                          if there are more handles available

      NO                                           all the available handles has been returned

1047  TPMI_YES_NO

1048  PCRCapGetHandles(

1049        TPMI_DH_PCR                   handle,                 //     IN:    start     handle

1050        UINT32                        count,                  //     IN:    count     of      returned    handle

1051        TPML_HANDLE                *handleList                //     OUT:   list      of      handle

      Family "2.0"                                                TCG Published                                                    Page 189

      Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                            October 30, 2014
      Trusted Platform Module Library                                                                         Part 4: Supporting  Routines

1052        )

1053  {

1054        TPMI_YES_NO                more    =   NO;

1055        UINT32                     i;

1056

1057        pAssert(HandleGetType(handle)                     ==    TPM_HT_PCR);

1058

1059        //  Initialize         output      handle      list

1060        handleList->count              =   0;

1061

1062        //  The     maximum    count       of      handles     we     may  return    is     MAX_CAP_HANDLES

1063        if(count    >   MAX_CAP_HANDLES)               count       =  MAX_CAP_HANDLES;

1064

1065        //  Iterate     PCR    handle          range

1066        for(i    =  handle     &    HR_HANDLE_MASK;             i     <=   PCR_LAST;     i++)

1067        {

1068              if(handleList->count                  <  count)

1069              {

1070                    //  If     we   have       not     filled   up    the  return       list,  add   this  PCR

1071                    //  handle         to  it

1072                    handleList->handle[handleList->count]                            =   i  +  PCR_FIRST;

1073                    handleList->count++;

1074              }

1075              else

1076              {

1077                    //  If     the     return       list  is    full       but   we  still     have  PCR  handle

1078                    //  available,             report     this     and     stop  iterating

1079                    more    =  YES;

1080                    break;

1081              }

1082        }

1083        return      more;

1084  }

      8.7       PP.c

      8.7.1       Introduction

      This file contains the functions that support the physical presence operations of the TPM.

      8.7.2       Includes

1     #include       "InternalRoutines.h"

      8.7.3       Functions

      8.7.3.1        PhysicalPresencePreInstall_Init()

      This function is used to initialize the array of commands that require confirmation with physical                           presence.

      The array is an array of bits that has a correspondence with the command code.

      This command should only ever be executable in a manufacturing setting or in a simulation.

2     void

3     PhysicalPresencePreInstall_Init(

4           void

5           )

6     {

7           //  Clear   all     the     PP     commands

8           MemorySet(&gp.ppList,                  0,

      Page 190                                                     TCG Published                                      Family "2.0"

      October 30, 2014                                     Copyright © TCG 2006-2014                           Level 00 Revision 01.16
    Part  4: Supporting Routines                                                                   Trusted Platform Module Library

9                       ((TPM_CC_PP_LAST            -   TPM_CC_PP_FIRST      +   1)     +  7)   /   8);

10

11        //  TPM_CC_PP_Commands             always     requires     PP

12        if(CommandIsImplemented(TPM_CC_PP_Commands))

13            PhysicalPresenceCommandSet(TPM_CC_PP_Commands);

14

15        //  Write     PP  list    to   NV

16        NvWriteReserved(NV_PP_LIST,                  &gp.ppList);

17

18        return;

19  }

    8.7.3.2        PhysicalPresenceCommandSet()

    This function is used to indicate a command that requires PP confirmation.

20  void

21  PhysicalPresenceCommandSet(

22        TPM_CC                    commandCode         //      IN:  command     code

23        )

24  {

25        UINT32            bitPos;

26

27        //  Assume    command     is   implemented.           It   should  be      checked       before  this

28        //  function      is  called

29        pAssert(CommandIsImplemented(commandCode));

30

31        //  If   the  command     is   not    a   PP  command,     ignore      it

32        if(commandCode        <   TPM_CC_PP_FIRST     ||      commandCode          >  TPM_CC_PP_LAST)

33            return;

34

35        bitPos   =    commandCode      -   TPM_CC_PP_FIRST;

36

37        //  Set  bit

38        gp.ppList[bitPos/8]            |=  1  <<     (bitPos  %    8);

39

40        return;

41  }

    8.7.3.3        PhysicalPresenceCommandClear()

    This function is used to indicate a command that no longer requires PP confirmation.

42  void

43  PhysicalPresenceCommandClear(

44        TPM_CC                    commandCode         //      IN:  command     code

45        )

46  {

47        UINT32            bitPos;

48

49        //  Assume    command     is   implemented.           It   should  be      checked       before  this

50        //  function      is  called

51        pAssert(CommandIsImplemented(commandCode));

52

53        //  If   the  command     is   not    a   PP  command,     ignore      it

54        if(commandCode        <   TPM_CC_PP_FIRST     ||      commandCode          >  TPM_CC_PP_LAST)

55            return;

56

57        //  if   the  input      code  is     TPM_CC_PP_Commands,          it  can       not  be  cleared

58        if(commandCode        ==  TPM_CC_PP_Commands)

59            return;

60

61        bitPos   =    commandCode      -   TPM_CC_PP_FIRST;

    Family "2.0"                                        TCG Published                                            Page 191

    Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                     October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

62

63         //  Set   bit

64         gp.ppList[bitPos/8]                 |=  (1   <<   (bitPos        %   8));

65         //  Flip     it  to  off

66         gp.ppList[bitPos/8]                 ^=  (1   <<   (bitPos        %   8));

67

68         return;

69   }

     8.7.3.4        PhysicalPresenceIsRequired()

     This function indicates if PP confirmation is required for a command.

     Return Value                                  Meaning

     TRUE                                          if physical presence is required

     FALSE                                         if physical presence is not required

70   BOOL

71   PhysicalPresenceIsRequired(

72         TPM_CC                     commandCode                 //     IN:    command     code

73         )

74   {

75         UINT32             bitPos;

76

77         //  if   the     input     commandCode           is  not      a  PP  command,          return  FALSE

78         if(commandCode          <  TPM_CC_PP_FIRST                ||     commandCode        >  TPM_CC_PP_LAST)

79             return       FALSE;

80

81         bitPos    =   commandCode           -   TPM_CC_PP_FIRST;

82

83         //  Check     the    bit   map.         If   the     bit   is    SET,  PP    authorization          is   required

84         return    ((gp.ppList[bitPos/8]                   &  (1    <<    (bitPos     %   8)))  !=      0);

85

86   }

     8.7.3.5        PhysicalPresenceCapGetCCList()

     This  function   returns   a     list     of  commands       that      require   PP   confirmation.       The  list  starts  from  the  first

     implemented command that has a command code that the same or greater than commandCode.

     Return Value                                  Meaning

     YES                                           if there are more command codes available

     NO                                            all the available command codes have been returned

87   TPMI_YES_NO

88   PhysicalPresenceCapGetCCList(

89         TPM_CC                     commandCode,                //     IN:    start   command   code

90         UINT32                     count,                      //     IN:    count   of     returned   TPM_CC

91         TPML_CC                    *commandList                //     OUT:   list    of     TPM_CC

92         )

93   {

94         TPMI_YES_NO                more     =   NO;

95         UINT32                     i;

96

97         //  Initialize       output         handle       list

98         commandList->count               =  0;

99

100        //  The   maximum       count       of  command        we     may    return     is     MAX_CAP_CC

101        if(count      >  MAX_CAP_CC)            count     =  MAX_CAP_CC;

     Page 192                                                     TCG Published                                                   Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                                  Level  00  Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

102

103        //  Collect    PP     commands

104        for(i   =  commandCode;           i  <=  TPM_CC_PP_LAST;           i++)

105        {

106            if(PhysicalPresenceIsRequired(i))

107            {

108                   if(commandList->count                 <  count)

109                   {

110                          //  If     we   have   not     filled    up  the  return   list,  add          this  command

111                          //  code       to  it

112                          commandList->commandCodes[commandList->count]                           =  i;

113                          commandList->count++;

114                   }

115                   else

116                   {

117                          //  If     the     return   list  is     full    but   we  still  have     PP  command

118                          //  available,         report     this    and    stop  iterating

119                          more    =  YES;

120                          break;

121                   }

122            }

123        }

124        return     more;

125  }

     8.8       Session.c

     8.8.1     Introduction

     The code in this file is used to manage the session context counter. The scheme implemented here is a

     "truncated counter". This scheme allows the TPM to not need TPM_SU_CLEAR for a very long period of

     time and still not have the context count for a session repeated.

     The counter (contextCounter)in this implementation is a UINT64 but can be smaller.                           The "tracking array"

     (contextArray) only has 16-bits per context.              The tracking array is the data that needs to be saved and

     restored across TPM_SU_STATE so that sessions are not lost when the system enters the sleep state.

     Also, when the TPM is active, the tracking array is kept in RAM making it important that the number of

     bytes for each entry be kept as small as possible.

     The TPM prevents collisions of these truncated values by not allowing a contextID to be assigned if it

     would be the same as an existing value.                   Since the array holds 16 bits, after a context has been saved,

     an   additional  2^16-1     contexts       may     be     saved  before   the  count     would     again  match.     The   normal

     expectation is that the context will be flushed before its count value is needed again but it is always

     possible to have long-lived sessions.

     The contextID is assigned when the context is saved (TPM2_ContextSave()). At that time, the TPM will

     compare   the    low-order    16   bits    of  contextCounter        to  the   existing  values    in  contextArray   and  if  one

     matches, the TPM will return TPM_RC_CONTEXT_GAP (by construction, the entry that contains the

     matching value is the oldest context).

     The expected remediation by the TRM is to load the oldest saved session context (the one found by the

     TPM), and save it.      Since loading the oldest session also eliminates its              contextID value from contextArray,

     there TPM will always be able to load and save the oldest existing context.

     In the worst case, software may have to load and save several contexts in order to save an additional

     one.   This should happen very infrequently.

     When the TPM searches contextArray and finds that none of the contextIDs match the low-order 16-bits

     of contextCount, the TPM can copy the low bits to the contextArray associated with the session, and

     increment contextCount.

     Family "2.0"                                              TCG Published                                               Page 193

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                     October 30, 2014
    Trusted Platform Module Library                                                              Part 4: Supporting Routines

    There is one entry in contextArray for each of the active sessions allowed by the TPM implementation.

    This array contains either a context count, an index, or a value indicating the slot is available (0).

    The index into the contextArray is the handle for the session with the region selector byte of the session

    set to zero.      If an entry in contextArray contains 0, then the corresponding handle may be assigned to a

    session.     If the entry contains a value that is less than or equal to the number of loaded sessions for the

    TPM, then the array entry is the slot in which the context is loaded.

    EXAMPLE:           If the TPM allows 8 loaded sessions, then the slot numbers would be 1-8 and a contextArrary value in that

                       range would represent the loaded session.

    NOTE:              When the TPM firmware determines that the array entry is for a loaded session, it will subtract 1 to create the

                       zero-based slot number.

    There is one significant corner case in this scheme.               When the contextCount is equal to a value in the

    contextArray, the oldest session needs to be recycled or flushed. In order to recycle the session, it must

    be loaded. To be loaded, there must be an available slot.                     Rather than require that a spare slot be

    available    all  the  time,  the  TPM   will  check  to  see  if  the  contextCount     is  equal    to  some  value  in           the

    contextArray when a session is created.             This prevents the last session slot from being used when it is

    likely that a session will need to be recycled.

    If a TPM with both 1.2 and 2.0 functionality uses this scheme for both 1.2 and 2.0 sessions, and the list of

    active contexts is read with TPM_GetCapabiltiy(), the TPM will create 32-bit representations of the list that

    contains 16-bit values (the TPM2_GetCapability() returns a list of handles for active sessions rather than

    a  list  of  contextID).      The  full  contextID  has   high-order    bits  that  are  either  the  same  as  the    current

    contextCount or one less.          It is one less if the 16-bits of the contextArray has a value that is larger than

    the low-order 16 bits of contextCount.

    8.8.2        Includes, Defines, and Local Variables

1   #define      SESSION_C

2   #include      "InternalRoutines.h"

3   #include      "Platform.h"

4   #include      "SessionProcess_fp.h"

    8.8.3        File Scope Function -- ContextIdSetOldest()

    This function is called when the oldest contextID is being loaded or deleted. Once a saved context

    becomes the oldest, it stays the oldest until it is deleted.

    Finding the oldest is a bit tricky.      It is not just the numeric comparison of values but is dependent on the

    value of contextCounter.

    Assume we have a small contextArray with 8, 4-bit values with values 1 and 2 used to indicate the loaded

    context slot number.          Also assume that the array contains hex values of (0 0 1 0 3 0 9 F) and that the

    contextCounter is an 8-bit counter with a value of 0x37. Since the low nibble is 7, that means that values

    above 7 are older than values below it and, in this example, 9 is the oldest value.

    Note if we subtract the counter value, from each slot that contains a saved contextID we get (- - - - B - 2 -

    8) and the oldest entry is now easy to find.

5   static       void

6   ContextIdSetOldest(

7      void

8      )

9   {

10     CONTEXT_SLOT               lowBits;

11     CONTEXT_SLOT               entry;

12     CONTEXT_SLOT               smallest      =  ((CONTEXT_SLOT)        ~0);

13     UINT32          i;

    Page 194                                              TCG Published                                             Family "2.0"

    October 30, 2014                               Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                                            Trusted Platform Module Library

14

15        //  Set     oldestSaveContext                    to      a  value            indicating           none   assigned

16        s_oldestSavedSession                      =    MAX_ACTIVE_SESSIONS                       +    1;

17

18        lowBits     =   (CONTEXT_SLOT)gr.contextCounter;

19        for(i    =  0;     i   <     MAX_ACTIVE_SESSIONS;                            i++)

20        {

21            entry       =     gr.contextArray[i];

22

23            //      only      look         at     entries        that       are       saved      contexts

24            if(entry           >     MAX_LOADED_SESSIONS)

25            {

26                    //     Use       a     less      than    or     equal            in   case       the   oldest

27                    //     is     brand           new    (=  lowBits-1)                  and     equal     to   our     initial

28                    //     value           for    smallest.

29                    if(((CONTEXT_SLOT)                       (entry            -     lowBits))         <=   smallest)

30                    {

31                              smallest            =    (entry       -      lowBits);

32                              s_oldestSavedSession                          =     i;

33                    }

34            }

35        }

36        //  When    we     finish,             either        the    s_oldestSavedSession                        still     has  its   initial

37        //  value,      or     it       has       the    index      of      the       oldest         saved     context.

38  }

    8.8.4     Startup Function -- SessionStartup()

    This function initializes the session subsystem on TPM2_Startup().

39  void

40  SessionStartup(

41        STARTUP_TYPE                       type

42        )

43  {

44        UINT32                                    i;

45

46        //  Initialize            session            slots.         At      startup,             all   the     in-memory       session  slots

47        //  are     cleared          and       marked        as     not     occupied

48        for(i    =  0;     i   <     MAX_LOADED_SESSIONS;                            i++)

49            s_sessions[i].occupied                           =      FALSE;               //   session       slot     is   not  occupied

50

51        //  The     free      session             slots      the    number            of     maximum       allowed       loaded    sessions

52        s_freeSessionSlots                     =  MAX_LOADED_SESSIONS;

53

54        //  Initialize            context            ID  data.             On     a   ST_SAVE         or   hibernate       sequence,    it   will

55        //  scan    the       saved        array         of  session              context        counts,        and     clear  any   entry   that

56        //  references            a     session          that       was     in       memory      during        the   state     save  since   that

57        //  memory      was       not      preserved             over       the       ST_SAVE.

58        if(type     ==     SU_RESUME              ||     type       ==     SU_RESTART)

59        {

60            //      On  ST_SAVE            we     preserve          the        contexts          that      were     saved   but    not  the  ones

61            //      in  memory

62            for     (i     =   0;       i  <      MAX_ACTIVE_SESSIONS;                        i++)

63            {

64                    //     If     the      array         value      is      unused           or  references          a   loaded    session   then

65                    //     that         loaded         session          context           is     lost     and   the     array  entry    is

66                    //     reclaimed.

67                    if     (gr.contextArray[i]                          <=     MAX_LOADED_SESSIONS)

68                              gr.contextArray[i]                        =   0;

69            }

70            //      Find      the       oldest         session          in     context           ID   data     and   set   it  in

71            //      s_oldestSavedSession

72            ContextIdSetOldest();

    Family "2.0"                                                             TCG Published                                                       Page 195

    Level 00 Revision 01.16                                    Copyright © TCG 2006-2014                                                  October 30, 2014
     Trusted Platform Module Library                                                                 Part 4: Supporting Routines

73         }

74         else

75         {

76                //   For    STARTUP_CLEAR,           clear   out    the  contextArray

77                for     (i  =   0;   i  <  MAX_ACTIVE_SESSIONS;          i++)

78                        gr.contextArray[i]           =  0;

79

80                //   reset      the     context   counter

81                gr.contextCounter              =  MAX_LOADED_SESSIONS        +     1;

82

83                //   Initialize         oldest    saved     session

84                s_oldestSavedSession              =  MAX_ACTIVE_SESSIONS           +   1;

85         }

86         return;

87   }

     8.8.5        Access Functions

     8.8.5.1          SessionIsLoaded()

     This function test a session handle references a loaded session.                    The handle must have previously     been

     checked to make sure that it is a valid handle for an authorization session.

     NOTE:                 A PWAP authorization does not have a session.

     Return Value                                Meaning

     TRUE                                        if session is loaded

     FALSE                                       if it is not loaded

88   BOOL

89   SessionIsLoaded(

90         TPM_HANDLE                     handle               //     IN:  session   handle

91         )

92   {

93         pAssert(           HandleGetType(handle)            ==     TPM_HT_POLICY_SESSION

94                        ||  HandleGetType(handle)            ==     TPM_HT_HMAC_SESSION);

95

96         handle      =   handle      &  HR_HANDLE_MASK;

97

98         //     if  out     of  range      of  possible     active       session,  or  not  assigned  to  a  loaded

99         //     session     return      false

100        if(        handle      >=   MAX_ACTIVE_SESSIONS

101               ||  gr.contextArray[handle]              ==  0

102               ||  gr.contextArray[handle]              >   MAX_LOADED_SESSIONS

103            )

104               return      FALSE;

105

106        return      TRUE;

107  }

     8.8.5.2          SessionIsSaved()

     This function test a session handle references a saved session.                     The handle  must  have  previously  been

     checked to make sure that it is a valid handle for an authorization                 session.

     NOTE:                 An password authorization does not have a session.

     This function requires that the handle be a valid session handle.

     Page 196                                                  TCG Published                                     Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                     Level 00 Revision 01.16
     Part 4: Supporting Routines                                                           Trusted Platform Module Library

     Return Value                              Meaning

     TRUE                                      if session is saved

     FALSE                                     if it is not saved

108  BOOL

109  SessionIsSaved(

110        TPM_HANDLE                      handle             //   IN:  session   handle

111        )

112  {

113        pAssert(          HandleGetType(handle)            ==    TPM_HT_POLICY_SESSION

114                      ||  HandleGetType(handle)            ==    TPM_HT_HMAC_SESSION);

115

116        handle     =     handle      &  HR_HANDLE_MASK;

117        //     if  out    of  range     of  possible   active        session,  or  not  assigned,  or

118        //     assigned       to  a     loaded  session,   return    false

119        if(        handle     >=     MAX_ACTIVE_SESSIONS

120               ||  gr.contextArray[handle]             ==  0

121               ||  gr.contextArray[handle]             <=  MAX_LOADED_SESSIONS

122            )

123               return     FALSE;

124

125        return     TRUE;

126  }

     8.8.5.3          SessionPCRValueIsCurrent()

     This function is used to check if PCR values have been updated since                  the  last  time  they  were  checked  in

     a policy session.

     This function requires the session is loaded.

     Return Value                              Meaning

     TRUE                                      if PCR value is current

     FALSE                                     if PCR value is not current

127  BOOL

128  SessionPCRValueIsCurrent(

129        TPMI_SH_POLICY                  handle             //   IN:  session   handle

130        )

131  {

132        SESSION                         *session;

133

134        pAssert(SessionIsLoaded(handle));

135

136        session       =   SessionGet(handle);

137        if(        session->pcrCounter          !=  0

138               &&  session->pcrCounter          !=  gr.pcrCounter

139            )

140               return     FALSE;

141        else

142               return     TRUE;

143  }

     8.8.5.4          SessionGet()

     This function returns a pointer to the session object associated with a session handle.

     The function requires that the session is loaded.

     Family "2.0"                                             TCG Published                                             Page 197

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting       Routines

144  SESSION   *

145  SessionGet(

146     TPM_HANDLE                     handle                       //     IN:     session       handle

147     )

148  {

149     CONTEXT_SLOT              sessionIndex;

150

151     pAssert(           HandleGetType(handle)                    ==     TPM_HT_POLICY_SESSION

152                  ||    HandleGetType(handle)                    ==     TPM_HT_HMAC_SESSION

153                );

154

155     pAssert((handle           &    HR_HANDLE_MASK)                  <  MAX_ACTIVE_SESSIONS);

156

157     //    get  the     contents         of   the     session           array.          Because      session     is   loaded,       we

158     //    should     always        get  a    valid       sessionIndex

159     sessionIndex           =  gr.contextArray[handle                        &  HR_HANDLE_MASK]            -   1;

160

161     pAssert(sessionIndex                <    MAX_LOADED_SESSIONS);

162

163     return     &s_sessions[sessionIndex].session;

164  }

     8.8.6    Utility Functions

     8.8.6.1       ContextIdSessionCreate()

     This function is called when a session is created.                         It will check to see if the current gap would                prevent a

     context from being saved.         If so it will return TPM_RC_CONTEXT_GAP.                                   Otherwise, it will try     to find an

     open slot in contextArray, set contextArray to the slot.

     This routine requires that the caller has determined the session array index for the session.

     return type                                TPM_RC

     TPM_RC_SUCCESS                             context ID was assigned

     TPM_RC_CONTEXT_GAP                         can't assign a new contextID until the oldest saved session context is

                                                recycled

     TPM_RC_SESSION_HANDLE                      there    is  no     slot   available       in  the  context  array  for  tracking  of  this

                                                session context

165  static   TPM_RC

166  ContextIdSessionCreate                 (

167     TPM_HANDLE                *handle,                          //     OUT:    receives          the    assigned     handle.       This    will

168                                                                 //             be   an     index    that  must      be  adjusted       by  the

169                                                                 //             caller       according     to    the     type   of  the

170                                                                 //             session       created

171     UINT32                         sessionIndex                 //     IN:     The     session      context     array     entry    that    will

172                                                                 //             be   occupied        by   the  created     session

173     )

174  {

175

176     pAssert(sessionIndex                <    MAX_LOADED_SESSIONS);

177

178     //    check    to  see    if       creating         the     context        is      safe

179     //    Is   this    going       to   be   an   assignment           for         the     last     session   context

180     //    array    entry?          If   so,     then     there         will    be      no   room    to   recycle     the

181     //    oldest     context       if   needed.             If  the    gap         is   not     at  maximum,      then

182     //    it   will    be     possible       to   save       a  context            if   it   becomes      necessary.

183     if(        s_oldestSavedSession                  <   MAX_ACTIVE_SESSIONS

184           &&   s_freeSessionSlots                ==     1)

185     {

186           //   See     if     the  gap      is   at     maximum

     Page 198                                                       TCG Published                                                          Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                        Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                  Trusted Platform Module  Library

187            if(       (CONTEXT_SLOT)gr.contextCounter

188                  ==  gr.contextArray[s_oldestSavedSession])

189

190                  //   Note:  if   this      is   being         used  on   a  TPM.combined,       this  return

191                  //          code    should         be     transformed       to    an  appropriate     1.2  error

192                  //          code    for       this     case.

193                  return     TPM_RC_CONTEXT_GAP;

194        }

195

196        //  Find  an   unoccupied     entry       in     the    contextArray

197        for(*handle    =  0;  *handle        <   MAX_ACTIVE_SESSIONS;               (*handle)++)

198        {

199            if(gr.contextArray[*handle]                     ==  0)

200            {

201                  //   indicate    that      the     session        associated      with  this    handle

202                  //   references     a   loaded         session

203                  gr.contextArray[*handle]                  =   (CONTEXT_SLOT)(sessionIndex+1);

204                  return     TPM_RC_SUCCESS;

205            }

206        }

207        return    TPM_RC_SESSION_HANDLES;

208  }

     8.8.6.2       SessionCreate()

     This function does the detailed work for starting an authorization session. This is done in a support

     routine rather than in the action code because the session management may differ in implementations.

     This implementation uses a fixed memory allocation to hold sessions and a fixed allocation to hold the

     contextID for the saved contexts.

     Error Returns                       Meaning

     TPM_RC_CONTEXT_GAP                  need to recycle sessions

     TPM_RC_SESSION_HANDLE               active session space is full

     TPM_RC_SESSION_MEMORY               loaded session space is full

209  TPM_RC

210  SessionCreate(

211        TPM_SE                sessionType,                  //  IN:   the     session   type

212        TPMI_ALG_HASH         authHash,                     //  IN:   the     hash  algorithm

213        TPM2B_NONCE           *nonceCaller,                 //  IN:   initial       nonceCaller

214        TPMT_SYM_DEF          *symmetric,                   //  IN:   the     symmetric   algorithm

215        TPMI_DH_ENTITY        bind,                         //  IN:   the     bind  object

216        TPM2B_DATA            *seed,                        //  IN:   seed    data

217        TPM_HANDLE            *sessionHandle                //  OUT:  the     session     handle

218        )

219  {

220        TPM_RC                      result        =     TPM_RC_SUCCESS;

221        CONTEXT_SLOT                slotIndex;

222        SESSION                    *session          =   NULL;

223

224        pAssert(       sessionType       ==     TPM_SE_HMAC

225                  ||   sessionType       ==     TPM_SE_POLICY

226                  ||   sessionType       ==     TPM_SE_TRIAL);

227

228        //  If  there  are    no   open   spots         in  the     session   array,      then  no  point    in  searching

229        if(s_freeSessionSlots         ==     0)

230            return     TPM_RC_SESSION_MEMORY;

231

232        //  Find  a   space   for  loading        a     session

233        for(slotIndex     =   0;   slotIndex         <   MAX_LOADED_SESSIONS;             slotIndex++)

234        {

     Family "2.0"                                              TCG Published                                           Page 199

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                                Part 4: Supporting Routines

235               //  Is      this    available?
           
236               if(s_sessions[slotIndex].occupied                                   ==   FALSE)
           
237               {
           
238                       session        =   &s_sessions[slotIndex].session;
           
239                       break;
           
240               }
           
241        }
           
242        //  if     no  spot        found,        then       this   is       an  internal           error
           
243        pAssert        (slotIndex            <   MAX_LOADED_SESSIONS);
           
244        
           
245        //  Call       context        ID     function         to   get      a   handle.            TPM_RC_SESSION_HANDLE          may  be
           
246        //  returned           from      ContextIdHandelAssign()
           
247        result     =   ContextIdSessionCreate(sessionHandle,                                       slotIndex);
           
248        if(result          !=  TPM_RC_SUCCESS)
           
249               return      result;
           
250        
           
251        //***      Only    return         from       this     point         on  is     TPM_RC_SUCCESS
           
252        
           
253        //  Can    now     indicate             that     the   session          array         entry   is  occupied.
           
254        s_freeSessionSlots--;
           
255        s_sessions[slotIndex].occupied                             =     TRUE;
           
256        
           
257        //  Initialize             the    session           data
           
258        MemorySet(session,                   0,     sizeof(SESSION));
           
259        
           
260        //  Initialize             internal          session       data
           
261        session->authHashAlg                     =   authHash;
           
262        //  Initialize             session          type
           
263        if(sessionType             ==     TPM_SE_HMAC)
           
264        {
           
265               *sessionHandle                +=     HMAC_SESSION_FIRST;
           
266        
           
267        }
           
268        else
           
269        {
           
270               *sessionHandle                +=     POLICY_SESSION_FIRST;
           
271        
           
272               //  For     TPM_SE_POLICY                 or   TPM_SE_TRIAL
           
273               session->attributes.isPolicy                              =  SET;
           
274               if(sessionType                ==     TPM_SE_TRIAL)
           
275                       session->attributes.isTrialPolicy                                   =   SET;
           
276        
           
277               //  Initialize             policy         session         data
           
278               SessionInitPolicyData(session);
           
279        }
           
280        //  Create         initial        session           nonce
           
281        session->nonceTPM.t.size                         =   nonceCaller->t.size;
           
282        CryptGenerateRandom(session->nonceTPM.t.size,                                              session->nonceTPM.t.buffer);
           
283        
           
284        //  Set    up      session        parameter           encryption            algorithm
           
285        session->symmetric                   =   *symmetric;
           
286        
           
287        //  If     there       is  a     bind       object     or     a     session        secret,     then   need     to   compute
           
288        //  a     sessionKey.
           
289        if(bind        !=  TPM_RH_NULL               ||     seed->t.size            !=     0)
           
290        {
           
291               //  sessionKey             =     KDFa(hash,         (authValue              ||  seed),     "ATH",      nonceTPM,
           
292               //                                             nonceCaller,              bits)
           
293               //  The     HMAC       key       for   generating            the     sessionSecret         can     be   the  concatenation
           
294               //  of      an  authorization                 value       and    a   seed       value
           
295               TPM2B_TYPE(KEY,                  (sizeof(TPMT_HA)                +   sizeof(seed->t.buffer)));
           
296               TPM2B_KEY                                 key;
           
297        
           
298               UINT16                                    hashSize;                     //     The  size   of  the     hash  used  by   the
           
299                                                                                       //     session     crated   by  this  command
           
300               TPM2B_AUTH             entityAuth;                                      //     The  authValue      of   the  entity

     Page 200                                                      TCG Published                                                    Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                                Trusted Platform Module Library

301                                                                                    //   associated          with  HMAC     session

302

303                //  Get    hash     size,    which    is       also         the     length       of  sessionKey

304                hashSize     =   CryptGetHashDigestSize(session->authHashAlg);

305

306                //  Get    authValue         of   associated             entity

307                entityAuth.t.size            =    EntityGetAuthValue(bind,                           &entityAuth.t.buffer);

308

309                //  Concatenate            authValue  and            seed

310                pAssert(entityAuth.t.size                   +     seed->t.size               <=  sizeof(key.t.buffer));

311                MemoryCopy2B(&key.b,                 &entityAuth.b,                 sizeof(key.t.buffer));

312                MemoryConcat2B(&key.b,               &seed->b,              sizeof(key.t.buffer));

313

314                session->sessionKey.t.size                     =     hashSize;

315

316                //  Compute      the       session   key

317                KDFa(session->authHashAlg,                     &key.b,           "ATH",      &session->nonceTPM.b,

318                         &nonceCaller->b,            hashSize            *  8,      session->sessionKey.t.buffer,                  NULL);

319        }

320

321        //  Copy    the    name        of  the    entity       that         the     HMAC     session      is  bound     to

322        //  Policy       session       is    not     bound     to     an    entity

323        if(bind     !=     TPM_RH_NULL           &&  sessionType                ==   TPM_SE_HMAC)

324        {

325                session->attributes.isBound                       =   SET;

326                SessionComputeBoundEntity(bind,                             &session->u1.boundEntity);

327        }

328        //  If      there  is    a     bind  object   and            it     is   subject         to  DA,     then  use   of  this    session

329        //  is      subject     to     DA  regardless          of     how       it   is   used.

330        session->attributes.isDaBound                       =            (bind       !=   TPM_RH_NULL)

331                                                                  &&     (IsDAExempted(bind)                  ==   FALSE);

332

333        //  If      the  session       is    bound,   then           check       to     see  if      it  is   bound  to     lockoutAuth

334        session->attributes.isLockoutBound                               =          (session->attributes.isDaBound                   ==  SET)

335                                                                            &&      (bind    ==      TPM_RH_LOCKOUT);

336        return      TPM_RC_SUCCESS;

337

338  }

     8.8.6.3           SessionContextSave()

     This function is called when a session context is to be saved.                                     The contextID of the saved session is

     returned.     If no contextID can be assigned, then the routine returns TPM_RC_CONTEXT_GAP. If the

     function completes normally, the session slot will be freed.

     This function requires that handle references a loaded session. Otherwise, it should not be called at the

     first place.

     Error Returns                                      Meaning

     TPM_RC_CONTEXT_GAP                                 a contextID could not be assigned.

     TPM_RC_TOO_MANY_CONTEXTS                           the counter maxed out

339  TPM_RC

340  SessionContextSave                (

341        TPM_HANDLE                           handle,                        //   IN:     session         handle

342        CONTEXT_COUNTER                    *contextID                       //   OUT:     assigned        contextID

343        )

344  {

345        UINT32                                        contextIndex;

346        CONTEXT_SLOT                                  slotIndex;

347

348        pAssert(SessionIsLoaded(handle));

     Family "2.0"                                                    TCG Published                                                          Page 201

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                               October 30, 2014
     Trusted Platform Module Library                                                                                   Part 4: Supporting Routines

349

350     //     check     to    see        if  the      gap   is  already        maxed        out

351     //     Need     to     have       a   saved     session

352     if(         s_oldestSavedSession                     <   MAX_ACTIVE_SESSIONS

353                 //   if    the        oldest       saved     session        has     the  same        value  as   the   low   bits

354                 //   of    the        contextCounter,              then     the     GAP  is      maxed    out.

355            &&   gr.contextArray[s_oldestSavedSession]                                    ==   (CONTEXT_SLOT)gr.contextCounter)

356            return          TPM_RC_CONTEXT_GAP;

357

358     //     if   the     caller           wants     the   context       counter,          set     it

359     if(contextID               !=     NULL)

360            *contextID              =     gr.contextCounter;

361

362     pAssert((handle                   &   HR_HANDLE_MASK)           <    MAX_ACTIVE_SESSIONS);

363

364     contextIndex               =   handle       &   HR_HANDLE_MASK;

365

366     //     Extract         the     session         slot     number     referenced            by   the     contextArray

367     //     because         we     are     going     to   overwrite          this     with     the    low    order

368     //     contextID           value.

369     slotIndex           =  gr.contextArray[contextIndex]                             -   1;

370

371     //     Set   the       contextID          for   the      contextArray

372     gr.contextArray[contextIndex]                            =     (CONTEXT_SLOT)gr.contextCounter;

373

374     //     Increment           the       counter

375     gr.contextCounter++;

376

377     //     In   the     unlikely          event     that     the    64-bit          context       counter   rolls      over...

378     if(gr.contextCounter                      ==    0)

379     {

380            //    back      it      up

381            gr.contextCounter--;

382            //    return           an     error

383            return          TPM_RC_TOO_MANY_CONTEXTS;

384     }

385     //     if   the     low-order           bits    wrapped,        need        to   advance         the  value    to  skip  over

386     //     the   values           used    to    indicate        that     a  session          is   loaded

387     if(((CONTEXT_SLOT)gr.contextCounter)                                    ==   0)

388            gr.contextCounter                    +=  MAX_LOADED_SESSIONS                  +    1;

389

390     //     If   no   other         sessions         are     saved,     this      is     now   the    oldest.

391     if(s_oldestSavedSession                         >=   MAX_ACTIVE_SESSIONS)

392            s_oldestSavedSession                     =    contextIndex;

393

394     //     Mark     the    session          slot    as      unoccupied

395     s_sessions[slotIndex].occupied                              =  FALSE;

396

397     //     and   indicate             that    there      is  an    additional            open     slot

398     s_freeSessionSlots++;

399

400     return       TPM_RC_SUCCESS;

401  }

     8.8.6.4        SessionContextLoad()

     This function is used to load a session from saved context.                                     The session handle must be for a saved

     context.

     If the gap is at a maximum, then the only session that can be loaded is the oldest session, otherwise

     TPM_RC_CONTEXT_GAP is returned.

     This function requires that handle references a valid saved session.

     Page 202                                                          TCG Published                                                   Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                Trusted Platform Module Library

     Error Returns                                  Meaning

     TPM_RC_SESSION_MEMORY                          no free session slots

     TPM_RC_CONTEXT_GAP                             the gap count is maximum and this is not the oldest saved context

402  TPM_RC

403  SessionContextLoad(

404     SESSION                        *session,                           //  IN:      session      structure      from  saved  context

405     TPM_HANDLE                     *handle                             //  IN/OUT:          session     handle

406     )

407  {

408     UINT32                                  contextIndex;

409     CONTEXT_SLOT                            slotIndex;

410

411     pAssert(            HandleGetType(*handle)                             ==  TPM_HT_POLICY_SESSION

412                     ||  HandleGetType(*handle)                             ==  TPM_HT_HMAC_SESSION);

413

414     //     Don't       bother      looking          if  no       openings

415     if(s_freeSessionSlots                       ==  0)

416            return       TPM_RC_SESSION_MEMORY;

417

418     //     Find     a   free       session       slot      to       load       the  session

419     for(slotIndex               =  0;    slotIndex            <     MAX_LOADED_SESSIONS;                 slotIndex++)

420            if(s_sessions[slotIndex].occupied                                    ==      FALSE)   break;

421

422     //     if   no     spot     found,       then       this        is     an  internal          error

423     pAssert         (slotIndex           <   MAX_LOADED_SESSIONS);

424

425     contextIndex             =     *handle       &  HR_HANDLE_MASK;                         //   extract   the   index

426

427     //     If   there   is         only     one     slot      left,        and      the     gap  is  at    maximum,   the  only  session

428     //     context      that       we    can     safely          load      is   the      oldest      one.

429     if(         s_oldestSavedSession                    <     MAX_ACTIVE_SESSIONS

430            &&   s_freeSessionSlots                  ==     1

431            &&   (CONTEXT_SLOT)gr.contextCounter                                 ==      gr.contextArray[s_oldestSavedSession]

432            &&   contextIndex             !=     s_oldestSavedSession

433         )

434            return       TPM_RC_CONTEXT_GAP;

435

436     pAssert(contextIndex                     <   MAX_ACTIVE_SESSIONS);

437

438     //     set   the    contextArray                value        to     point       to   the     session   slot  where

439     //     the   context           is   loaded

440     gr.contextArray[contextIndex]                                =     slotIndex         +  1;

441

442     //     if   this    was        the   oldest         context,           find     the     new  oldest

443     if(contextIndex                ==    s_oldestSavedSession)

444            ContextIdSetOldest();

445

446     //     Copy     session        data      to     session            slot

447     s_sessions[slotIndex].session                                =     *session;

448

449     //     Set   session           slot     as   occupied

450     s_sessions[slotIndex].occupied                                  =   TRUE;

451

452     //     Reduce       the     number       of     open      spots

453     s_freeSessionSlots--;

454

455     return       TPM_RC_SUCCESS;

456  }

     Family "2.0"                                                          TCG Published                                             Page 203

     Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

     8.8.6.5         SessionFlush()

     This function is used to flush a session referenced by its handle.                          If the session associated with    handle    is

     loaded, the session array entry is marked as available.

     This function requires that handle be a valid active session.

457  void

458  SessionFlush(

459        TPM_HANDLE                     handle                     //   IN:     loaded   or   saved  session      handle

460        )

461  {

462        CONTEXT_SLOT                         slotIndex;

463        UINT32                               contextIndex;                 //  Index    into  contextArray

464

465        pAssert(           (       HandleGetType(handle)                   ==  TPM_HT_POLICY_SESSION

466                              ||   HandleGetType(handle)                   ==  TPM_HT_HMAC_SESSION

467                           )

468                   &&      (SessionIsLoaded(handle)                        ||  SessionIsSaved(handle))

469                  );

470

471        //  Flush     context          ID   of     this    session

472        //  Convert        handle       to   an       index    into    the     contextArray

473        contextIndex           =   handle       &     HR_HANDLE_MASK;

474

475        pAssert(contextIndex                 <     sizeof(gr.contextArray)/sizeof(gr.contextArray[0]));

476

477        //  Get   the      current         contents        of     the  array

478        slotIndex       =     gr.contextArray[contextIndex];

479

480        //  Mark   context            array     entry      as     available

481        gr.contextArray[contextIndex]                          =  0;

482

483        //  Is    this     a   saved       session        being   flushed

484        if(slotIndex           >   MAX_LOADED_SESSIONS)

485        {

486              //  Flushing            the   oldest        session?

487              if(contextIndex               ==     s_oldestSavedSession)

488                   //      If     so,   find       a  new    value     for     oldest.

489                   ContextIdSetOldest();

490        }

491        else

492        {

493              //  Adjust          slot     index      to   point       to  session     array  index

494              slotIndex           -=   1;

495

496              //  Free        session       array     index

497              s_sessions[slotIndex].occupied                           =   FALSE;

498              s_freeSessionSlots++;

499        }

500

501        return;

502  }

     8.8.6.6         SessionComputeBoundEntity()

     This function computes the binding value for a session.                           The binding value for a reserved handle is the

     handle itself.   For        all  the  other      entities,      the  authValue    at  the   time  of  binding  is  included  to  prevent

     squatting. For those values, the Name and the authValue are concatenated into the bind buffer.                                   If they

     will not both fit, the will be overlapped by XORing() bytes.                      If XOR is required, the bind value will be     full.

503  void

504  SessionComputeBoundEntity(

     Page 204                                                        TCG Published                                          Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                                       Trusted Platform Module       Library

505        TPMI_DH_ENTITY                      entityHandle,                //   IN:      handle       of  entity

506        TPM2B_NAME                          *bind                        //   OUT:        binding       value

507        )

508  {

509        TPM2B_AUTH                                  auth;

510        INT16                                       overlap;

511

512        //  Get      name

513        bind->t.size                 =   EntityGetName(entityHandle,                           &bind->t.name);

514

515  //        //  The        bound         value         of     a   reserved    handle      is   the      handle       itself

516  //        if(bind->t.size                     ==     sizeof(TPM_HANDLE))                return;

517

518        //  For      all       the       other         entities,         concatenate           the  auth        value  to    the  name.

519        //  Get      a     local         copy       of     the     auth  value        because       some    overlapping

520        //  may      be    necessary.

521        auth.t.size               =     EntityGetAuthValue(entityHandle,                            &auth.t.buffer);

522        pAssert(auth.t.size                         <=     sizeof(TPMU_HA));

523

524        //  Figure         out          if  there          will    be    any  overlap

525        overlap         =  bind->t.size                    +     auth.t.size       -   sizeof(bind->t.name);

526

527        //  There          is     overlap           if     the     combined   sizes       are       greater      than  will       fit

528        if(overlap             >     0)

529        {

530                //   The       overlap          area          is   at   the   end     of  the  Name

531                BYTE              *result           =   &bind->t.name[bind->t.size                      -   overlap];

532                int               i;

533

534                //   XOR       the       auth       value         into   the  Name        for  the      overlap      area

535                for(i      =      0;     i  <   overlap;           i++)

536                        result[i]               ^=     auth.t.buffer[i];

537        }

538        else

539        {

540                //   There           is     no  overlap

541                overlap           =     0;

542        }

543        //copy       the       remainder               of     the  authData        to     the  end      of  the  name

544        MemoryCopy(&bind->t.name[bind->t.size],                                           &auth.t.buffer[overlap],

545                               auth.t.size                 -     overlap,     sizeof(bind->t.name)               -     bind->t.size);

546

547        //  Increase              the       size       of     the  bind      data     by  the  size         of  the    auth  -    the  overlap

548        bind->t.size                 +=     auth.t.size-overlap;

549

550        return;

551  }

     8.8.6.7           SessionInitPolicyData()

     This function initializes the portions of the session policy data that are not set by the allocation                                                 of  a

     session.

552  void

553  SessionInitPolicyData(

554        SESSION                             *session                     //   IN:      session      handle

555        )

556  {

557        //  Initialize                  start       time

558        session->startTime                      =      go.clock;

559

560        //  Initialize                  policyDigest.                  policyDigest       is   initialized             with  a    string    of  0  of

561        //  session            algorithm               digest      size.      Since       the  policy       already    contains        all  zeros

562        //  it      is     only         necessary             to   set   the  size

     Family "2.0"                                                           TCG Published                                                          Page 205

     Level 00 Revision 01.16                                         Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

563        session->u2.policyDigest.t.size                   =   CryptGetHashDigestSize(session->authHashAlg);

564        return;

565  }

     8.8.6.8        SessionResetPolicyData()

     This function is used to reset the policy data without changing the nonce or the start time of the session.

566  void

567  SessionResetPolicyData(

568        SESSION            *session                       //  IN:     the  session   to  reset

569        )

570  {

571        session->commandCode          =  0;           //      No  command

572

573        //  No   locality  selected

574        MemorySet(&session->commandLocality,                      0,  sizeof(session->commandLocality));

575

576        //  The  cpHash    size   to     zero

577        session->u1.cpHash.b.size              =  0;

578

579        //  No   timeout

580        session->timeOut      =   0;

581

582        //  Reset  the    pcrCounter

583        session->pcrCounter        =     0;

584

585        //  Reset  the    policy   hash

586        MemorySet(&session->u2.policyDigest.t.buffer,                        0,

587                      session->u2.policyDigest.t.size);

588

589        //  Reset  the    session     attributes

590        MemorySet(&session->attributes,                   0,  sizeof(SESSION_ATTRIBUTES));

591

592        //  set  the  policy     attribute

593        session->attributes.isPolicy              =   SET;

594  }

     8.8.6.9        SessionCapGetLoaded()

     This function returns a list of handles of loaded session, started from input handle

     Handle must be in valid loaded session handle range, but does not have to point to a loaded session.

     Return Value                           Meaning

     YES                                    if there are more handles available

     NO                                     all the available handles has been returned

595  TPMI_YES_NO

596  SessionCapGetLoaded(

597        TPMI_SH_POLICY        handle,                     //  IN:     start  handle

598        UINT32                count,                      //  IN:     count  of  returned  handle

599        TPML_HANDLE        *handleList                    //  OUT:    list   of  handle

600        )

601  {

602        TPMI_YES_NO        more       =  NO;

603        UINT32             i;

604

605        pAssert(HandleGetType(handle)                 ==     TPM_HT_LOADED_SESSION);

606

607        //  Initialize     output     handle      list

     Page 206                                                TCG Published                            Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                               Trusted Platform    Module Library

608        handleList->count             =   0;

609

610        //  The     maximum    count         of     handles          we     may    return    is    MAX_CAP_HANDLES

611        if(count        >  MAX_CAP_HANDLES)                   count      =     MAX_CAP_HANDLES;

612

613        //  Iterate        session       context          ID     slots         to  get     loaded     session    handles

614        for(i    =  handle     &    HR_HANDLE_MASK;                   i     <  MAX_ACTIVE_SESSIONS;              i++)

615        {

616            //      If     session    is     active

617            if(gr.contextArray[i]                         !=  0)

618            {

619                    //     If  session          is     loaded

620                    if     (gr.contextArray[i]                    <=     MAX_LOADED_SESSIONS)

621                    {

622                           if(handleList->count                       <     count)

623                           {

624                                  SESSION                            *session;

625

626                                  //     If     we     have      not     filled        up    the  return     list,  add   this

627                                  //     session          handle         to    it

628                                  //     assume           that    this         is  going     to   be  an  HMAC   session

629                                  handle         =     i  +   HMAC_SESSION_FIRST;

630                                  session           =     SessionGet(handle);

631                                  if(session->attributes.isPolicy)

632                                          handle          =   i   +   POLICY_SESSION_FIRST;

633                                  handleList->handle[handleList->count]                                   =  handle;

634                                  handleList->count++;

635                           }

636                           else

637                           {

638                                  //     If     the       return      list         is  full  but      we  still  have    loaded  object

639                                  //     available,              report        this     and  stop     iterating

640                                  more       =   YES;

641                                  break;

642                           }

643                    }

644            }

645        }

646

647        return      more;

648

649  }

     8.8.6.10       SessionCapGetSaved()

     This function returns a list of handles for saved session, starting at handle.

     Handle must be in a valid handle range, but does not have to point to a saved session

     Return Value                                  Meaning

     YES                                           if there are more handles available

     NO                                            all the available handles has been returned

650  TPMI_YES_NO

651  SessionCapGetSaved(

652        TPMI_SH_HMAC                handle,                          //     IN:    start     handle

653        UINT32                      count,                           //     IN:    count     of   returned     handle

654        TPML_HANDLE               *handleList                        //     OUT:       list  of   handle

655        )

656  {

657        TPMI_YES_NO               more       =   NO;

658        UINT32                    i;

659

     Family "2.0"                                                       TCG Published                                               Page 207

     Level 00 Revision 01.16                                 Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                               Part 4: Supporting Routines

660     pAssert(HandleGetType(handle)                          ==    TPM_HT_ACTIVE_SESSION);

661

662     //     Initialize         output        handle       list

663     handleList->count                =   0;

664

665     //     The     maximum    count         of     handles       we     may    return    is    MAX_CAP_HANDLES

666     if(count           >  MAX_CAP_HANDLES)               count       =     MAX_CAP_HANDLES;

667

668     //     Iterate        session       context       ID   slots           to  get     loaded  session     handles

669     for(i       =  handle     &    HR_HANDLE_MASK;               i      <  MAX_ACTIVE_SESSIONS;            i++)

670     {

671            //      If     session    is     active

672            if(gr.contextArray[i]                    !=    0)

673            {

674                    //     If  session          is   saved

675                    if     (gr.contextArray[i]                 >  MAX_LOADED_SESSIONS)

676                    {

677                           if(handleList->count                   <      count)

678                           {

679                                  //     If     we   have   not       filled        up  the   return     list,  add  this

680                                  //     session       handle         to    it

681                                  handleList->handle[handleList->count]                               =  i  +   HMAC_SESSION_FIRST;

682                                  handleList->count++;

683                           }

684                           else

685                           {

686                                  //     If     the  return       list          is  full  but   we  still      have  loaded  object

687                                  //     available,         report          this     and  stop  iterating

688                                  more       =   YES;

689                                  break;

690                           }

691                    }

692            }

693     }

694

695     return         more;

696

697  }

     8.8.6.11       SessionCapGetLoadedNumber()

     This function return the number of authorization sessions currently loaded into TPM RAM.

698  UINT32

699  SessionCapGetLoadedNumber(

700     void

701     )

702  {

703     return         MAX_LOADED_SESSIONS                -   s_freeSessionSlots;

704  }

     8.8.6.12       SessionCapGetLoadedAvail()

     This function returns the number of additional authorization sessions,                              of any type, that could be loaded

     into TPM RAM.

     NOTE:                 In other implementations, this number may just be an estimate. The            only requirement for the estimate is, if it is

                           one or more, then at least one session must be loadable.

705  UINT32

706  SessionCapGetLoadedAvail(

707     void

708     )

     Page 208                                                        TCG Published                                              Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                           Trusted Platform Module Library

709  {

710        return     s_freeSessionSlots;

711  }

     8.8.6.13      SessionCapGetActiveNumber()

     This function returns the number of active authorization sessions currently being tracked             by  the  TPM.

712  UINT32

713  SessionCapGetActiveNumber(

714        void

715        )

716  {

717        UINT32                   i;

718        UINT32                   num        =  0;

719

720        //     Iterate   the     context    array  to  find     the  number  of  non-zero  slots

721        for(i   =   0;   i  <    MAX_ACTIVE_SESSIONS;        i++)

722        {

723               if(gr.contextArray[i]           !=  0)  num++;

724        }

725

726        return     num;

727  }

     8.8.6.14      SessionCapGetActiveAvail()

     This function returns the number of additional authorization sessions, of any type, that could be created.

     This not the number of slots for sessions, but the number of additional sessions that the TPM is capable

     of tracking.

728  UINT32

729  SessionCapGetActiveAvail(

730        void

731        )

732  {

733        UINT32                   i;

734        UINT32                   num        =  0;

735

736        //     Iterate   the     context    array  to  find     the  number  of  zero   slots

737        for(i   =   0;   i  <    MAX_ACTIVE_SESSIONS;        i++)

738        {

739               if(gr.contextArray[i]           ==  0)  num++;

740        }

741

742        return     num;

743  }

     8.9       Time.c

     8.9.1        Introduction

     This   file  contains     the  functions  relating   to  the  TPM's  time  functions  including  the  interface  to  the

     implementation-specific time functions.

     8.9.2        Includes

1    #include      "InternalRoutines.h"

2    #include      "Platform.h"

     Family "2.0"                                         TCG Published                                             Page 209

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                           October 30, 2014
    Trusted Platform Module Library                                                              Part 4: Supporting Routines

    8.9.3       Functions

    8.9.3.1         TimePowerOn()

    This function initialize time info at _TPM_Init().

3   void

4   TimePowerOn(

5         void

6         )

7   {

8         TPM_SU                    orderlyShutDown;

9

10        //  Read     orderly      data    info  from     NV   memory

11        NvReadReserved(NV_ORDERLY_DATA,                   &go);

12

13        //  Read     orderly      shut    down  state     flag

14        NvReadReserved(NV_ORDERLY,                  &orderlyShutDown);

15

16        //  If    the    previous     cycle     is  orderly     shut  down,   the  value  of   the  safe  bit

17        //  the   same     as  previously       saved.        Otherwise,  it  is   not  safe.

18        if(orderlyShutDown            ==  SHUTDOWN_NONE)

19              go.clockSafe=          NO;

20        else

21              go.clockSafe        =   YES;

22

23        //  Set   the      initial    state     of  the   DRBG

24        CryptDrbgGetPutState(PUT_STATE);

25

26        //  Clear      time    since    TPM  power    on

27        g_time    =    0;

28

29        return;

30  }

    8.9.3.2         TimeStartup()

    This function updates the resetCount and restartCount components                  of  TPMS_CLOCK_INFO structure at

    TPM2_Startup().

31  void

32  TimeStartup(

33        STARTUP_TYPE              type                    //  IN:  start  up  type

34        )

35  {

36        if(type      ==    SU_RESUME)

37        {

38              //  Resume       sequence

39              gr.restartCount++;

40        }

41        else

42        {

43              if(type      ==  SU_RESTART)

44              {

45                     //    Hibernate      sequence

46                     gr.clearCount++;

47                     gr.restartCount++;

48              }

49              else

50              {

51                     //    Reset  sequence

52                     //    Increase     resetCount

53                     gp.resetCount++;

    Page 210                                                TCG Published                                        Family "2.0"

    October 30, 2014                              Copyright © TCG 2006-2014                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                              Trusted Platform Module Library

54

55                    //     Write     resetCount           to   NV

56                    NvWriteReserved(NV_RESET_COUNT,                             &gp.resetCount);

57                    gp.totalResetCount++;

58

59                    //     We   do   not    expect        the     total     reset    counter       overflow       during      the   life

60                    //     time     of  TPM.         if   it   ever     happens,         TPM  will      be  put   to   failure      mode

61                    //     and   there      is    no     way   to  recover          it.

62                    //     The   reason       that       there     is   no   recovery         is   that     we  don't     increment

63                    //     the   NV     totalResetCount            when      incrementing          would        make  it  0.    When    the

64                    //     TPM   starts       up     again,       the   old     value    of   totalResetCount             will  be    read

65                    //     and   we     will    get      right     back     to  here     with      the   increment        failing.

66                    if(gp.totalResetCount                     ==   0)

67                           FAIL(FATAL_ERROR_INTERNAL);

68

69                    //     Write     total      reset     counter        to     NV

70                    NvWriteReserved(NV_TOTAL_RESET_COUNT,                                &gp.totalResetCount);

71

72                    //     Reset     restartCount

73                    gr.restartCount               =   0;

74               }

75         }

76

77         return;

78   }

     8.9.3.3        TimeUpdateToCurrent()

     This function updates the Time and Clock in the global TPMS_TIME_INFO structure.

     In this implementation, Time and Clock are updated at the beginning of each command and the values

     are unchanged for the duration of the command.

     Because Clock updates may require a write to NV memory, Time and Clock are not allowed to advance if

     NV  is   not   available.    When      clock      is  not   advancing,       any      function  that     uses  Clock   will  fail  and    return

     TPM_RC_NV_UNAVAILABLE or TPM_RC_NV_RATE.

     This implementations does not do rate limiting. If the implementation does do rate limiting, then the Clock

     update should not be inhibited even when doing rather limiting.

79   void

80   TimeUpdateToCurrent(

81         void

82         )

83   {

84         UINT64                     oldClock;

85         UINT64                     elapsed;

86   #define     CLOCK_UPDATE_MASK                ((1ULL        <<   NV_CLOCK_UPDATE_INTERVAL)-                    1)

87

88         //  Can't     update       time    during        the     dark   interval        or   when      rate    limiting.

89         if(NvIsAvailable()             !=    TPM_RC_SUCCESS)

90               return;

91

92         //  Save   the    old      clock     value

93         oldClock      =   go.clock;

94

95         //  Update       the   time    info      to     current

96         elapsed    =     _plat__ClockTimeElapsed();

97         go.clock      +=  elapsed;

98         g_time    +=     elapsed;

99

100        //  Check     to  see      if  the     update        has  caused       a   need      for  an    nvClock      update

101        //  CLOCK_UPDATE_MASK              is    measured         by   second,      while        the   value    in   go.clock      is

102        //  recorded      by    millisecond.             Align        the   clock       value     to   second    before      the   bit

     Family "2.0"                                                   TCG Published                                                         Page 211

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                          Part 4: Supporting  Routines

103        //   operations

104        if(  ((go.clock/1000)         |    CLOCK_UPDATE_MASK)

105                   >    ((oldClock/1000)        |  CLOCK_UPDATE_MASK))

106        {

107             //    Going   to    update    the  time    state  so  the  safe   flag

108             //    should    be  set

109             go.clockSafe        =   YES;

110

111             //    Get  the    DRBG   state     before  updating      orderly  data

112             CryptDrbgGetPutState(GET_STATE);

113

114             NvWriteReserved(NV_ORDERLY_DATA,                  &go);

115        }

116

117        //   Call  self    healing    logic     for   dictionary      attack   parameters

118        DASelfHeal();

119

120        return;

121  }

     8.9.3.4        TimeSetAdjustRate()

     This function is used to perform rate adjustment on Time and Clock.

122  void

123  TimeSetAdjustRate(

124        TPM_CLOCK_ADJUST              adjust            //     IN:    adjust   constant

125        )

126  {

127        switch(adjust)

128        {

129             case     TPM_CLOCK_COARSE_SLOWER:

130                   _plat__ClockAdjustRate(CLOCK_ADJUST_COARSE);

131                   break;

132             case     TPM_CLOCK_COARSE_FASTER:

133                   _plat__ClockAdjustRate(-CLOCK_ADJUST_COARSE);

134                   break;

135             case     TPM_CLOCK_MEDIUM_SLOWER:

136                   _plat__ClockAdjustRate(CLOCK_ADJUST_MEDIUM);

137                   break;

138             case     TPM_CLOCK_MEDIUM_FASTER:

139                   _plat__ClockAdjustRate(-CLOCK_ADJUST_MEDIUM);

140                   break;

141             case     TPM_CLOCK_FINE_SLOWER:

142                   _plat__ClockAdjustRate(CLOCK_ADJUST_FINE);

143                   break;

144             case     TPM_CLOCK_FINE_FASTER:

145                   _plat__ClockAdjustRate(-CLOCK_ADJUST_FINE);

146                   break;

147             case     TPM_CLOCK_NO_CHANGE:

148                   break;

149             default:

150                   pAssert(FALSE);

151                   break;

152        }

153

154        return;

155  }

     8.9.3.5        TimeGetRange()

     This function is used to access TPMS_TIME_INFO. The TPMS_TIME_INFO structure is treaded as an

     array of bytes, and a byte offset and length determine what bytes are returned.

     Page 212                                              TCG Published                      Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                            Trusted Platform Module   Library

     Error Returns                            Meaning

     TPM_RC_RANGE                             invalid data range

156  TPM_RC

157  TimeGetRange(

158        UINT16                   offset,                  //  IN:   offset    in  TPMS_TIME_INFO

159        UINT16                   size,                    //  IN:   size  of  data

160        TIME_INFO                *dataBuffer              //  OUT:    result  buffer

161        )

162  {

163        TPMS_TIME_INFO                  timeInfo;

164        UINT16                          infoSize;

165        BYTE                            infoData[sizeof(TPMS_TIME_INFO)];

166        BYTE                            *buffer;

167

168        //  Fill     TPMS_TIME_INFO           structure

169        timeInfo.time      =     g_time;

170        TimeFillInfo(&timeInfo.clockInfo);

171

172        //  Marshal        TPMS_TIME_INFO        to  canonical      form

173        buffer    =  infoData;

174        infoSize     =     TPMS_TIME_INFO_Marshal(&timeInfo,                &buffer,     NULL);

175

176        //  Check    if    the   input     range     is  valid

177        if(offset       +  size  >  infoSize)        return     TPM_RC_RANGE;

178

179        //  Copy     info  data     to     output    buffer

180        MemoryCopy(dataBuffer,                infoData    +   offset,  size,      sizeof(TIME_INFO));

181

182        return    TPM_RC_SUCCESS;

183  }

     8.9.3.6        TimeFillInfo

     This function gathers information to fill in a TPMS_CLOCK_INFO structure.

184  void

185  TimeFillInfo(

186        TPMS_CLOCK_INFO                 *clockInfo

187        )

188  {

189        clockInfo->clock         =  go.clock;

190        clockInfo->resetCount              =  gp.resetCount;

191        clockInfo->restartCount               =  gr.restartCount;

192

193        //  If   NV  is    not   available,        clock     stopped   advancing    and  the  value  reported  is

194        //  not   "safe".

195        if(NvIsAvailable()          ==     TPM_RC_SUCCESS)

196              clockInfo->safe           =  go.clockSafe;

197        else

198              clockInfo->safe           =  NO;

199

200        return;

201  }

     Family "2.0"                                            TCG Published                                        Page 213

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                             October 30, 2014
    Trusted Platform Module Library                                             Part 4: Supporting Routines

    9     Support

    9.1     AlgorithmCap.c

    9.1.1        Description

    This   file  contains  the  algorithm  property  definitions  for     the  algorithms  and    the  code  for  the

    TPM2_GetCapability() to return the algorithm properties.

    9.1.2        Includes and Defines

1   #include     "InternalRoutines.h"

2   typedef      struct

3   {

4         TPM_ALG_ID            algID;

5         TPMA_ALGORITHM        attributes;

6   }  ALGORITHM;

7   static   const  ALGORITHM        s_algorithms[]      =

8   {

9   #ifdef   TPM_ALG_RSA

10        {TPM_ALG_RSA,                {1,  0,  0,   1,  0,   0,  0,  0,  0}},

11  #endif

12  #ifdef   TPM_ALG_DES

13        {TPM_ALG_DES,                {0,  1,  0,   0,  0,   0,  0,  0,  0}},

14  #endif

15  #ifdef   TPM_ALG_3DES

16        {TPM_ALG__3DES,              {0,  1,  0,   0,  0,   0,  0,  0,  0}},

17  #endif

18  #ifdef   TPM_ALG_SHA1

19        {TPM_ALG_SHA1,               {0,  0,  1,   0,  0,   0,  0,  0,  0}},

20  #endif

21  #ifdef   TPM_ALG_HMAC

22        {TPM_ALG_HMAC,               {0,  0,  1,   0,  0,   1,  0,  0,  0}},

23  #endif

24  #ifdef   TPM_ALG_AES

25        {TPM_ALG_AES,                {0,  1,  0,   0,  0,   0,  0,  0,  0}},

26  #endif

27  #ifdef   TPM_ALG_MGF1

28        {TPM_ALG_MGF1,               {0,  0,  1,   0,  0,   0,  0,  1,  0}},

29  #endif

30

31        {TPM_ALG_KEYEDHASH,          {0,  0,  1,   1,  0,   1,  1,  0,  0}},

32

33  #ifdef   TPM_ALG_XOR

34        {TPM_ALG_XOR,                {0,  1,  1,   0,  0,   0,  0,  0,  0}},

35  #endif

36

37  #ifdef   TPM_ALG_SHA256

38        {TPM_ALG_SHA256,             {0,  0,  1,   0,  0,   0,  0,  0,  0}},

39  #endif

40  #ifdef   TPM_ALG_SHA384

41        {TPM_ALG_SHA384,             {0,  0,  1,   0,  0,   0,  0,  0,  0}},

42  #endif

43  #ifdef   TPM_ALG_SHA512

44        {TPM_ALG_SHA512,             {0,  0,  1,   0,  0,   0,  0,  0,  0}},

45  #endif

46  #ifdef   TPM_ALG_WHIRLPOOL512

47        {TPM_ALG_WHIRLPOOL512,       {0,  0,  1,   0,  0,   0,  0,  0,  0}},

48  #endif

49  #ifdef   TPM_ALG_SM3_256

50        {TPM_ALG_SM3_256,            {0,  0,  1,   0,  0,   0,  0,  0,  0}},

51  #endif

    Page 214                                    TCG Published                                          Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014                       Level  00 Revision 01.16
     Part 4: Supporting Routines                                            Trusted Platform Module  Library

52   #ifdef  TPM_ALG_SM4

53       {TPM_ALG_SM4,            {0,     1,  0,  0,  0,  0,  0,  0,  0}},

54   #endif

55   #ifdef  TPM_ALG_RSASSA

56       {TPM_ALG_RSASSA,            {1,  0,  0,  0,  0,  1,  0,  0,  0}},

57   #endif

58   #ifdef  TPM_ALG_RSAES

59       {TPM_ALG_RSAES,             {1,  0,  0,  0,  0,  0,  1,  0,  0}},

60   #endif

61   #ifdef  TPM_ALG_RSAPSS

62       {TPM_ALG_RSAPSS,            {1,  0,  0,  0,  0,  1,  0,  0,  0}},

63   #endif

64   #ifdef  TPM_ALG_OAEP

65       {TPM_ALG_OAEP,              {1,  0,  0,  0,  0,  0,  1,  0,  0}},

66   #endif

67   #ifdef  TPM_ALG_ECDSA

68       {TPM_ALG_ECDSA,             {1,  0,  0,  0,  0,  1,  0,  1,  0}},

69   #endif

70   #ifdef  TPM_ALG_ECDH

71       {TPM_ALG_ECDH,              {1,  0,  0,  0,  0,  0,  0,  1,  0}},

72   #endif

73   #ifdef  TPM_ALG_ECDAA

74       {TPM_ALG_ECDAA,             {1,  0,  0,  0,  0,  1,  0,  0,  0}},

75   #endif

76   #ifdef  TPM_ALG_ECSCHNORR

77       {TPM_ALG_ECSCHNORR,         {1,  0,  0,  0,  0,  1,  0,  0,  0}},

78   #endif

79   #ifdef  TPM_ALG_KDF1_SP800_56a

80       {TPM_ALG_KDF1_SP800_56a,{0,      0,  1,  0,  0,  0,  0,  1,  0}},

81   #endif

82   #ifdef  TPM_ALG_KDF2

83       {TPM_ALG_KDF2,              {0,  0,  1,  0,  0,  0,  0,  1,  0}},

84   #endif

85   #ifdef  TPM_ALG_KDF1_SP800_108

86       {TPM_ALG_KDF1_SP800_108,{0,      0,  1,  0,  0,  0,  0,  1,  0}},

87   #endif

88   #ifdef  TPM_ALG_ECC

89       {TPM_ALG_ECC,               {1,  0,  0,  1,  0,  0,  0,  0,  0}},

90   #endif

91

92       {TPM_ALG_SYMCIPHER,         {0,  0,  0,  1,  0,  0,  0,  0,  0}},

93

94   #ifdef  TPM_ALG_CTR

95       {TPM_ALG_CTR,               {0,  1,  0,  0,  0,  0,  1,  0,  0}},

96   #endif

97   #ifdef  TPM_ALG_OFB

98       {TPM_ALG_OFB,               {0,  1,  0,  0,  0,  0,  1,  0,  0}},

99   #endif

100  #ifdef  TPM_ALG_CBC

101      {TPM_ALG_CBC,               {0,  1,  0,  0,  0,  0,  1,  0,  0}},

102  #endif

103  #ifdef  TPM_ALG_CFB

104      {TPM_ALG_CFB,               {0,  1,  0,  0,  0,  0,  1,  0,  0}},

105  #endif

106  #ifdef  TPM_ALG_ECB

107      {TPM_ALG_ECB,               {0,  1,  0,  0,  0,  0,  1,  0,  0}},

108  #endif

109  };

     9.1.3   AlgorithmCapGetImplemented()

     This function is used by TPM2_GetCapability() to return a list of the implemented algorithms.

     Family "2.0"                                 TCG Published                                     Page 215

     Level 00 Revision 01.16           Copyright © TCG 2006-2014            October 30, 2014
     Trusted Platform Module Library                                                                                    Part 4: Supporting Routines

     Return Value                                      Meaning

     YES                                               more algorithms to report

     NO                                                no more algorithms to report

110  TPMI_YES_NO

111  AlgorithmCapGetImplemented(

112        TPM_ALG_ID                                               algID,           //    IN:      the  starting       algorithm    ID

113        UINT32                                                   count,           //    IN:      count   of   returned       algorithms

114        TPML_ALG_PROPERTY                                     *algList            //    OUT:     algorithm        list

115  )

116  {

117        TPMI_YES_NO                       more   =     NO;

118        UINT32                            i;

119        UINT32                            algNum;

120

121        //   initialize               output     algorithm             list

122        algList->count                =    0;

123

124        //   The     maximum          count      of    algorithms            we   may   return   is      MAX_CAP_ALGS.

125        if(count         >     MAX_CAP_ALGS)

126             count          =     MAX_CAP_ALGS;

127

128        //   Compute           how    many      algorithms             are   defined    in   s_algorithms            array.

129        algNum       =   sizeof(s_algorithms)                       /   sizeof(s_algorithms[0]);

130

131        //   Scan       the       implemented          algorithm            list  to    see  if  there        is  a  match   to   'algID'.

132        for(i     =     0;     i   <  algNum;          i++)

133        {

134             //      If     algID         is   less    than      the    starting        algorithm        ID,  skip      it

135             if(s_algorithms[i].algID                            <     algID)

136                        continue;

137             if(algList->count                      <  count)

138             {

139                        //     If     we   have     not     filled      up   the  return         list,   add      more     algorithms

140                        //     to     it

141                        algList->algProperties[algList->count].alg                                    =  s_algorithms[i].algID;

142                        algList->algProperties[algList->count].algProperties                                            =

143                                  s_algorithms[i].attributes;

144                        algList->count++;

145             }

146             else

147             {

148                        //     If     the     return       list     is  full      but   we   still    have    algorithms

149                        //     available,           report       this       and   stop  scanning.

150                        more       =  YES;

151                        break;

152             }

153

154        }

155

156        return       more;

157

158  }

159  LIB_EXPORT

160  void

161  AlgorithmGetImplementedVector(

162        ALGORITHM_VECTOR                        *implemented                 //   OUT:      the  implemented         bits    are  SET

163        )

164  {

165        int                                                index;

166

167        //   Nothing           implemented             until     we     say  it   is

168        MemorySet(implemented,                         0,   sizeof(ALGORITHM_VECTOR));

     Page 216                                                              TCG Published                                                  Family "2.0"

     October 30, 2014                                          Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

169

170        for(index    =    (sizeof(s_algorithms)            /  sizeof(s_algorithms[0]))           -    1;

171              index  >=   0;

172              index--)

173                   SET_BIT(s_algorithms[index].algID,                    *implemented);

174        return;

175  }

     9.2      Bits.c

     9.2.1       Introduction

     This file contains bit manipulation routines.       They operate on bit arrays.

     The 0th bit in the array is the right-most bit in the 0th octet in the array.

     NOTE:              If pAssert() is defined, the functions will assert if the indicated bit number is outside of the range of bArray. How

                        the assert is handled is implementation dependent.

     9.2.2       Includes

1    #include    "InternalRoutines.h"

     9.2.3       Functions

     9.2.3.1     BitIsSet()

     This function is used to check the setting of a bit in an array of bits.

     Return Value                        Meaning

     TRUE                                bit is set

     FALSE                               bit is not set

2    BOOL

3    BitIsSet(

4          unsigned     int      bitNum,                 //   IN:   number      of  the   bit  in   'bArray'

5          BYTE                  *bArray,                //   IN:   array      containing      the  bit

6          unsigned     int      arraySize               //   IN:   size    in  bytes     of   'bArray'

7          )

8    {

9          pAssert(arraySize      >  (bitNum     >>  3));

10         return((bArray[bitNum         >>  3]  &   (1   <<     (bitNum    &   7)))  !=  0);

11   }

     9.2.3.2     BitSet()

     This function will set the indicated bit in bArray.

12   void

13   BitSet(

14         unsigned     int      bitNum,                 //   IN:   number      of  the   bit  in   'bArray'

15         BYTE                  *bArray,                //   IN:   array      containing      the  bit

16         unsigned     int      arraySize               //   IN:   size    in  bytes     of   'bArray'

17         )

18   {

19         pAssert(arraySize      >  bitNum/8);

20         bArray[bitNum     >>  3]  |=  (1  <<      (bitNum     &  7));

     Family "2.0"                                        TCG Published                                        Page 217

     Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                       October 30, 2014
    Trusted Platform Module Library                                                                   Part 4: Supporting Routines

21  }

    9.2.3.3     BitClear()

    This function will clear the indicated bit in bArray.

22  void

23  BitClear(

24        unsigned  int       bitNum,                    //     IN:     number     of  the  bit  in   'bArray'.

25        BYTE                *bArray,                   //     IN:     array   containing       the  bit

26        unsigned  int       arraySize                  //     IN:     size   in   bytes   of   'bArray'

27        )

28  {

29        pAssert(arraySize       >  bitNum/8);

30        bArray[bitNum   >>  3]     &=  ~(1     <<  (bitNum         &  7));

31  }

    9.3      CommandAttributeData.c

    This is the command code attribute array for GetCapability(). Both this array and s_commandAttributes

    provides command code attributes, but tuned for different purpose

1   static   const  TPMA_CC          s_ccAttr        []  =   {

2               {0x011f,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_UndefineSpaceSpecial

3               {0x0120,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_EvictControl

4               {0x0121,  0,  1,     1,  0,  1,  0,      0,  0},        //      TPM_CC_HierarchyControl

5               {0x0122,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_UndefineSpace

6               {0x0123,  0,  0,     0,  0,  0,  0,      0,  0},        //      No     command

7               {0x0124,  0,  1,     1,  0,  1,  0,      0,  0},        //      TPM_CC_ChangeEPS

8               {0x0125,  0,  1,     1,  0,  1,  0,      0,  0},        //      TPM_CC_ChangePPS

9               {0x0126,  0,  1,     1,  0,  1,  0,      0,  0},        //      TPM_CC_Clear

10              {0x0127,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_ClearControl

11              {0x0128,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_ClockSet

12              {0x0129,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_HierarchyChangeAuth

13              {0x012a,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_NV_DefineSpace

14              {0x012b,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_PCR_Allocate

15              {0x012c,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_PCR_SetAuthPolicy

16              {0x012d,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_PP_Commands

17              {0x012e,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_SetPrimaryPolicy

18              {0x012f,  0,  0,     0,  0,  2,  0,      0,  0},        //      TPM_CC_FieldUpgradeStart

19              {0x0130,  0,  0,     0,  0,  1,  0,      0,  0},        //      TPM_CC_ClockRateAdjust

20              {0x0131,  0,  0,     0,  0,  1,  1,      0,  0},        //      TPM_CC_CreatePrimary

21              {0x0132,  0,  0,     0,  0,  1,  0,      0,  0},        //      TPM_CC_NV_GlobalWriteLock

22              {0x0133,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_GetCommandAuditDigest

23              {0x0134,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_Increment

24              {0x0135,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_SetBits

25              {0x0136,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_Extend

26              {0x0137,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_Write

27              {0x0138,  0,  1,     0,  0,  2,  0,      0,  0},        //      TPM_CC_NV_WriteLock

28              {0x0139,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_DictionaryAttackLockReset

29              {0x013a,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_DictionaryAttackParameters

30              {0x013b,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_NV_ChangeAuth

31              {0x013c,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_PCR_Event

32              {0x013d,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_PCR_Reset

33              {0x013e,  0,  0,     0,  1,  1,  0,      0,  0},        //      TPM_CC_SequenceComplete

34              {0x013f,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_SetAlgorithmSet

35              {0x0140,  0,  1,     0,  0,  1,  0,      0,  0},        //      TPM_CC_SetCommandCodeAuditStatus

36              {0x0141,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_FieldUpgradeData

37              {0x0142,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_IncrementalSelfTest

38              {0x0143,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_SelfTest

39              {0x0144,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_Startup

40              {0x0145,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_Shutdown

41              {0x0146,  0,  1,     0,  0,  0,  0,      0,  0},        //      TPM_CC_StirRandom

    Page 218                                             TCG Published                                           Family "2.0"

    October 30, 2014                          Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                            Trusted Platform Module Library

42   {0x0147,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_ActivateCredential

43   {0x0148,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_Certify

44   {0x0149,      0,  0,         0,  0,  3,  0,  0,  0},  //  TPM_CC_PolicyNV

45   {0x014a,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_CertifyCreation

46   {0x014b,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_Duplicate

47   {0x014c,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_GetTime

48   {0x014d,      0,  0,         0,  0,  3,  0,  0,  0},  //  TPM_CC_GetSessionAuditDigest

49   {0x014e,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_NV_Read

50   {0x014f,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_NV_ReadLock

51   {0x0150,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_ObjectChangeAuth

52   {0x0151,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_PolicySecret

53   {0x0152,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_Rewrap

54   {0x0153,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_Create

55   {0x0154,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_ECDH_ZGen

56   {0x0155,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_HMAC

57   {0x0156,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_Import

58   {0x0157,      0,  0,         0,  0,  1,  1,  0,  0},  //  TPM_CC_Load

59   {0x0158,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_Quote

60   {0x0159,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_RSA_Decrypt

61   {0x015a,      0,  0,         0,  0,  0,  0,  0,  0},  //  No  command

62   {0x015b,      0,  0,         0,  0,  1,  1,  0,  0},  //  TPM_CC_HMAC_Start

63   {0x015c,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_SequenceUpdate

64   {0x015d,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_Sign

65   {0x015e,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_Unseal

66   {0x015f,      0,  0,         0,  0,  0,  0,  0,  0},  //  No  command

67   {0x0160,      0,  0,         0,  0,  2,  0,  0,  0},  //  TPM_CC_PolicySigned

68   {0x0161,      0,  0,         0,  0,  0,  1,  0,  0},  //  TPM_CC_ContextLoad

69   {0x0162,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_ContextSave

70   {0x0163,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_ECDH_KeyGen

71   {0x0164,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_EncryptDecrypt

72   {0x0165,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_FlushContext

73   {0x0166,      0,  0,         0,  0,  0,  0,  0,  0},  //  No  command

74   {0x0167,      0,  0,         0,  0,  0,  1,  0,  0},  //  TPM_CC_LoadExternal

75   {0x0168,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_MakeCredential

76   {0x0169,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_NV_ReadPublic

77   {0x016a,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyAuthorize

78   {0x016b,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyAuthValue

79   {0x016c,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyCommandCode

80   {0x016d,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyCounterTimer

81   {0x016e,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyCpHash

82   {0x016f,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyLocality

83   {0x0170,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyNameHash

84   {0x0171,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyOR

85   {0x0172,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyTicket

86   {0x0173,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_ReadPublic

87   {0x0174,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_RSA_Encrypt

88   {0x0175,      0,  0,         0,  0,  0,  0,  0,  0},  //  No  command

89   {0x0176,      0,  0,         0,  0,  2,  1,  0,  0},  //  TPM_CC_StartAuthSession

90   {0x0177,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_VerifySignature

91   {0x0178,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_ECC_Parameters

92   {0x0179,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_FirmwareRead

93   {0x017a,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_GetCapability

94   {0x017b,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_GetRandom

95   {0x017c,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_GetTestResult

96   {0x017d,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_Hash

97   {0x017e,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_PCR_Read

98   {0x017f,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyPCR

99   {0x0180,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyRestart

100  {0x0181,      0,  0,         0,  0,  0,  0,  0,  0},  //  TPM_CC_ReadClock

101  {0x0182,      0,  1,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PCR_Extend

102  {0x0183,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PCR_SetAuthValue

103  {0x0184,      0,  0,         0,  0,  3,  0,  0,  0},  //  TPM_CC_NV_Certify

104  {0x0185,      0,  1,         0,  1,  2,  0,  0,  0},  //  TPM_CC_EventSequenceComplete

105  {0x0186,      0,  0,         0,  0,  0,  1,  0,  0},  //  TPM_CC_HashSequenceStart

106  {0x0187,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyPhysicalPresence

107  {0x0188,      0,  0,         0,  0,  1,  0,  0,  0},  //  TPM_CC_PolicyDuplicationSelect

     Family "2.0"                                 TCG Published                                Page 219

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                     October 30, 2014
     Trusted Platform Module Library                                                  Part 4: Supporting Routines

108           {0x0189,     0,  0,  0,  0,  1,  0,   0,  0},       //  TPM_CC_PolicyGetDigest

109           {0x018a,     0,  0,  0,  0,  0,  0,   0,  0},       //  TPM_CC_TestParms

110           {0x018b,     0,  0,  0,  0,  1,  0,   0,  0},       //  TPM_CC_Commit

111           {0x018c,     0,  0,  0,  0,  1,  0,   0,  0},       //  TPM_CC_PolicyPassword

112           {0x018d,     0,  0,  0,  0,  1,  0,   0,  0},       //  TPM_CC_ZGen_2Phase

113           {0x018e,     0,  0,  0,  0,  0,  0,   0,  0},       //  TPM_CC_EC_Ephemeral

114           {0x018f,     0,  0,  0,  0,  1,  0,   0,  0}        //  TPM_CC_PolicyNvWritten

115  };

116  typedef     UINT16                    _ATTR_;

117  #define     NOT_IMPLEMENTED           (_ATTR_)(0)

118  #define     ENCRYPT_2             (_ATTR_)(1       <<   0)

119  #define     ENCRYPT_4             (_ATTR_)(1       <<   1)

120  #define     DECRYPT_2             (_ATTR_)(1       <<   2)

121  #define     DECRYPT_4             (_ATTR_)(1       <<   3)

122  #define     HANDLE_1_USER         (_ATTR_)(1       <<   4)

123  #define     HANDLE_1_ADMIN        (_ATTR_)(1       <<   5)

124  #define     HANDLE_1_DUP          (_ATTR_)(1       <<   6)

125  #define     HANDLE_2_USER         (_ATTR_)(1       <<   7)

126  #define     PP_COMMAND            (_ATTR_)(1       <<   8)

127  #define     IS_IMPLEMENTED        (_ATTR_)(1       <<   9)

128  #define     NO_SESSIONS           (_ATTR_)(1       <<   10)

129  #define     NV_COMMAND            (_ATTR_)(1       <<   11)

130  #define     PP_REQUIRED           (_ATTR_)(1       <<   12)

131  #define     R_HANDLE              (_ATTR_)(1       <<   13)

     This is the command code attribute structure.

132  typedef  UINT16      COMMAND_ATTRIBUTES;

133  static   const  COMMAND_ATTRIBUTES             s_commandAttributes  []  =  {

134      (_ATTR_)(CC_NV_UndefineSpaceSpecial                 *  (IS_IMPLEMENTED+HANDLE_1_ADMIN+HANDLE_2_USER+PP_COMMAND)),                               //  0x011f

135      (_ATTR_)(CC_EvictControl                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0120

136      (_ATTR_)(CC_HierarchyControl                        *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0121

137      (_ATTR_)(CC_NV_UndefineSpace                        *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0122

138      (_ATTR_)                                                 (NOT_IMPLEMENTED),  //  0x0123  -   Not  assigned

139      (_ATTR_)(CC_ChangeEPS                               *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0124

140      (_ATTR_)(CC_ChangePPS                               *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0125

141      (_ATTR_)(CC_Clear                                   *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0126

142      (_ATTR_)(CC_ClearControl                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0127

143      (_ATTR_)(CC_ClockSet                                *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0128

144      (_ATTR_)(CC_HierarchyChangeAuth                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x0129

145      (_ATTR_)(CC_NV_DefineSpace                          *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012a

146      (_ATTR_)(CC_PCR_Allocate                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x012b

147      (_ATTR_)(CC_PCR_SetAuthPolicy                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012c

148      (_ATTR_)(CC_PP_Commands                             *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_REQUIRED)),                                             //  0x012d

149      (_ATTR_)(CC_SetPrimaryPolicy                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012e

150      (_ATTR_)(CC_FieldUpgradeStart                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+PP_COMMAND)),                                   //  0x012f

151      (_ATTR_)(CC_ClockRateAdjust                         *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0130

     Page 220                                       TCG Published                                 Family "2.0"

     October 30, 2014                      Copyright © TCG 2006-2014                    Level 00 Revision 01.16
     Part 4: Supporting Routines                                 Trusted Platform Module Library

152      (_ATTR_)(CC_CreatePrimary                *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND+ENCRYPT_2+R_HANDLE)),      //  0x0131

153      (_ATTR_)(CC_NV_GlobalWriteLock           *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0132

154      (_ATTR_)(CC_GetCommandAuditDigest        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x0133

155      (_ATTR_)(CC_NV_Increment                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0134

156      (_ATTR_)(CC_NV_SetBits                   *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0135

157      (_ATTR_)(CC_NV_Extend                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0136

158      (_ATTR_)(CC_NV_Write                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0137

159      (_ATTR_)(CC_NV_WriteLock                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0138

160      (_ATTR_)(CC_DictionaryAttackLockReset    *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0139

161      (_ATTR_)(CC_DictionaryAttackParameters   *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013a

162      (_ATTR_)(CC_NV_ChangeAuth                *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN)),                                   //  0x013b

163      (_ATTR_)(CC_PCR_Event                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x013c

164      (_ATTR_)(CC_PCR_Reset                    *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013d

165      (_ATTR_)(CC_SequenceComplete             *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x013e

166      (_ATTR_)(CC_SetAlgorithmSet              *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013f

167      (_ATTR_)(CC_SetCommandCodeAuditStatus    *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0140

168      (_ATTR_)(CC_FieldUpgradeData             *  (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0141

169      (_ATTR_)(CC_IncrementalSelfTest          *  (IS_IMPLEMENTED)),  //  0x0142

170      (_ATTR_)(CC_SelfTest                     *  (IS_IMPLEMENTED)),  //  0x0143

171      (_ATTR_)(CC_Startup                      *  (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0144

172      (_ATTR_)(CC_Shutdown                     *  (IS_IMPLEMENTED)),  //  0x0145

173      (_ATTR_)(CC_StirRandom                   *  (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0146

174      (_ATTR_)(CC_ActivateCredential           *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0147

175      (_ATTR_)(CC_Certify                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0148

176      (_ATTR_)(CC_PolicyNV                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0149

177      (_ATTR_)(CC_CertifyCreation              *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x014a

178      (_ATTR_)(CC_Duplicate                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_DUP+ENCRYPT_2)),                           //  0x014b

179      (_ATTR_)(CC_GetTime                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014c

180      (_ATTR_)(CC_GetSessionAuditDigest        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014d

181      (_ATTR_)(CC_NV_Read                      *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                    //  0x014e

182      (_ATTR_)(CC_NV_ReadLock                  *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x014f

183      (_ATTR_)(CC_ObjectChangeAuth             *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+ENCRYPT_2)),                         //  0x0150

184      (_ATTR_)(CC_PolicySecret                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x0151

     Family "2.0"                           TCG Published                              Page 221

     Level 00 Revision 01.16          Copyright © TCG 2006-2014                October 30, 2014
     Trusted Platform Module Library                                      Part 4: Supporting Routines

185      (_ATTR_)(CC_Rewrap                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0152

186      (_ATTR_)(CC_Create                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0153

187      (_ATTR_)(CC_ECDH_ZGen                   *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0154

188      (_ATTR_)(CC_HMAC                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0155

189      (_ATTR_)(CC_Import                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0156

190      (_ATTR_)(CC_Load                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2+R_HANDLE)),                  //  0x0157

191      (_ATTR_)(CC_Quote                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0158

192      (_ATTR_)(CC_RSA_Decrypt                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0159

193      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x015a  -  Not  assigned

194      (_ATTR_)(CC_HMAC_Start                  *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+R_HANDLE)),                            //  0x015b

195      (_ATTR_)(CC_SequenceUpdate              *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015c

196      (_ATTR_)(CC_Sign                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015d

197      (_ATTR_)(CC_Unseal                      *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x015e

198      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x015f  -  Not  assigned

199      (_ATTR_)(CC_PolicySigned                *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0160

200      (_ATTR_)(CC_ContextLoad                 *    (IS_IMPLEMENTED+NO_SESSIONS+R_HANDLE)),  //  0x0161

201      (_ATTR_)(CC_ContextSave                 *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0162

202      (_ATTR_)(CC_ECDH_KeyGen                 *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0163

203      (_ATTR_)(CC_EncryptDecrypt              *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x0164

204      (_ATTR_)(CC_FlushContext                *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0165

205      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x0166  -  Not  assigned

206      (_ATTR_)(CC_LoadExternal                *  (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0167

207      (_ATTR_)(CC_MakeCredential              *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0168

208      (_ATTR_)(CC_NV_ReadPublic               *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0169

209      (_ATTR_)(CC_PolicyAuthorize             *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016a

210      (_ATTR_)(CC_PolicyAuthValue             *    (IS_IMPLEMENTED)),  //  0x016b

211      (_ATTR_)(CC_PolicyCommandCode           *    (IS_IMPLEMENTED)),  //  0x016c

212      (_ATTR_)(CC_PolicyCounterTimer          *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016d

213      (_ATTR_)(CC_PolicyCpHash                *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016e

214      (_ATTR_)(CC_PolicyLocality              *    (IS_IMPLEMENTED)),  //  0x016f

215      (_ATTR_)(CC_PolicyNameHash              *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0170

216      (_ATTR_)(CC_PolicyOR                    *    (IS_IMPLEMENTED)),  //  0x0171

217      (_ATTR_)(CC_PolicyTicket                *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0172

     Page 222                            TCG Published                                  Family "2.0"

     October 30, 2014                 Copyright © TCG 2006-2014           Level 00 Revision 01.16
     Part 4: Supporting Routines                                 Trusted Platform Module Library

218      (_ATTR_)(CC_ReadPublic                  *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0173

219      (_ATTR_)(CC_RSA_Encrypt                 *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0174

220      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x0175  -  Not  assigned

221      (_ATTR_)(CC_StartAuthSession            *  (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0176

222      (_ATTR_)(CC_VerifySignature             *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0177

223      (_ATTR_)(CC_ECC_Parameters              *    (IS_IMPLEMENTED)),  //  0x0178

224      (_ATTR_)(CC_FirmwareRead                *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0179

225      (_ATTR_)(CC_GetCapability               *    (IS_IMPLEMENTED)),  //  0x017a

226      (_ATTR_)(CC_GetRandom                   *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x017b

227      (_ATTR_)(CC_GetTestResult               *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x017c

228      (_ATTR_)(CC_Hash                        *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x017d

229      (_ATTR_)(CC_PCR_Read                    *    (IS_IMPLEMENTED)),  //  0x017e

230      (_ATTR_)(CC_PolicyPCR                   *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x017f

231      (_ATTR_)(CC_PolicyRestart               *    (IS_IMPLEMENTED)),  //  0x0180

232      (_ATTR_)(CC_ReadClock                   *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0181

233      (_ATTR_)(CC_PCR_Extend                  *    (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0182

234      (_ATTR_)(CC_PCR_SetAuthValue            *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x0183

235      (_ATTR_)(CC_NV_Certify                  *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),             //  0x0184

236      (_ATTR_)(CC_EventSequenceComplete       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER)),                       //  0x0185

237      (_ATTR_)(CC_HashSequenceStart           *    (IS_IMPLEMENTED+DECRYPT_2+R_HANDLE)),  //  0x0186

238      (_ATTR_)(CC_PolicyPhysicalPresence      *    (IS_IMPLEMENTED)),  //  0x0187

239      (_ATTR_)(CC_PolicyDuplicationSelect     *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0188

240      (_ATTR_)(CC_PolicyGetDigest             *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0189

241      (_ATTR_)(CC_TestParms                   *    (IS_IMPLEMENTED)),  //  0x018a

242      (_ATTR_)(CC_Commit                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018b

243      (_ATTR_)(CC_PolicyPassword              *    (IS_IMPLEMENTED)),  //  0x018c

244      (_ATTR_)(CC_ZGen_2Phase                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018d

245      (_ATTR_)(CC_EC_Ephemeral                *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x018e

246      (_ATTR_)(CC_PolicyNvWritten             *    (IS_IMPLEMENTED))  //  0x018f

247  };

     Family "2.0"                           TCG Published                               Page 223

     Level 00 Revision 01.16          Copyright © TCG 2006-2014           October 30, 2014
    Trusted Platform Module Library                                                                     Part 4: Supporting Routines

    9.4      CommandCodeAttributes.c

    9.4.1     Introduction

    This file contains the functions for testing various command properties.

    9.4.2     Includes and Defines

1   #include      "Tpm.h"

2   #include      "InternalRoutines.h"

3   typedef   UINT16                ATTRIBUTE_TYPE;

    The following file is produced from the command tables in part 3 of the specification. It defines the

    attributes for each of the commands.

    NOTE:         This file is currently produced by an automated process. Files produced from Part 2 or Part 3 tables through

                  automated     processes  are  not  included  in  the  specification  so  that  their  is  no  ambiguity  about  the  table

                  containing the information being the normative definition.

4   #include      "CommandAttributeData.c"

    9.4.3     Command Attribute Functions

    9.4.3.1      CommandAuthRole()

    This function returns  the  authorization role required of a handle.

    Return Value                        Meaning

    AUTH_NONE                           no authorization is required

    AUTH_USER                           user role authorization is required

    AUTH_ADMIN                          admin role authorization is required

    AUTH_DUP                            duplication role authorization is required

5   AUTH_ROLE

6   CommandAuthRole(

7        TPM_CC            commandCode,                 //  IN:    command    code

8        UINT32            handleIndex                  //  IN:    handle     index       (zero  based)

9        )

10  {

11       if(handleIndex     >   1)

12            return  AUTH_NONE;

13       if(handleIndex     ==  0)  {

14            ATTRIBUTE_TYPE        properties       =  s_commandAttributes[commandCode                         -  TPM_CC_FIRST];

15            if(properties     &   HANDLE_1_USER)          return      AUTH_USER;

16            if(properties     &   HANDLE_1_ADMIN)            return   AUTH_ADMIN;

17            if(properties     &   HANDLE_1_DUP)           return  AUTH_DUP;

18            return  AUTH_NONE;

19       }

20       if(s_commandAttributes[commandCode                 -  TPM_CC_FIRST]           &   HANDLE_2_USER)          return AUTH_USER;

21       return   AUTH_NONE;

22  }

    9.4.3.2      CommandIsImplemented()

    This function indicates if a command is implemented.

    Page 224                                            TCG Published                                                      Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                              Trusted Platform Module Library

    Return Value                            Meaning

    TRUE                                    if the command is implemented

    FALSE                                   if the command is not implemented

23  BOOL

24  CommandIsImplemented(

25        TPM_CC                    commandCode           //  IN:     command     code

26        )

27  {

28        if(commandCode         <  TPM_CC_FIRST      ||      commandCode      >  TPM_CC_LAST)

29              return   FALSE;

30        if((s_commandAttributes[commandCode                     -   TPM_CC_FIRST]     &  IS_IMPLEMENTED))

31              return   TRUE;

32        else

33              return   FALSE;

34  }

    9.4.3.3       CommandGetAttribute()

    return a TPMA_CC structure for the given command code

35  TPMA_CC

36  CommandGetAttribute(

37        TPM_CC                    commandCode           //  IN:     command     code

38        )

39  {

40        UINT32            size    =  sizeof(s_ccAttr)           /   sizeof(s_ccAttr[0]);

41        UINT32            i;

42        for(i   =  0;  i   <   size;  i++)       {

43              if(s_ccAttr[i].commandIndex               ==  (UINT16)         commandCode)

44                   return      s_ccAttr[i];

45        }

46

47        //  This   function       should     be     called  in     the  way  that  the   command  code

48        //  attribute      is     available.

49        FAIL(FATAL_ERROR_INTERNAL);

50  }

    9.4.3.4       EncryptSize()

    This function returns the size of the decrypt size field. This function returns 0           if encryption is not allowed

    Return Value                            Meaning

    0                                       encryption not allowed

    2                                       size field is two bytes

    4                                       size field is four bytes

51  int

52  EncryptSize(

53        TPM_CC                    commandCode           //  IN:     commandCode

54        )

55  {

56        COMMAND_ATTRIBUTES            ca  =  s_commandAttributes[commandCode               -  TPM_CC_FIRST];

57        if(ca   &  ENCRYPT_2)

58              return   2;

59        if(ca   &  ENCRYPT_4)

60              return   4;

61        return     0;

    Family "2.0"                                          TCG Published                                         Page 225

    Level 00 Revision 01.16                        Copyright © TCG 2006-2014                              October 30, 2014
    Trusted Platform Module Library                                                         Part 4: Supporting Routines

62  }

    9.4.3.5       DecryptSize()

    This function returns the size of the decrypt size field. This function returns      0  if decryption is not  allowed

    Return Value                     Meaning

    0                                encryption not allowed

    2                                size field is two bytes

    4                                size field is four bytes

63  int

64  DecryptSize(

65        TPM_CC                 commandCode  //  IN:          commandCode

66        )

67  {

68        COMMAND_ATTRIBUTES     ca  =  s_commandAttributes[commandCode                  -  TPM_CC_FIRST];

69

70        if(ca   &  DECRYPT_2)

71              return   2;

72        if(ca   &  DECRYPT_4)

73              return   4;

74        return     0;

75  }

    9.4.3.6       IsSessionAllowed()

    This function indicates if the command is allowed to have sessions.

    This function must not be called if the command is not known to be implemented.

    Return Value                     Meaning

    TRUE                             session is allowed with this command

    FALSE                            session is not allowed with this command

76  BOOL

77  IsSessionAllowed(

78        TPM_CC                 commandCode  //  IN:          the  command  to      be  checked

79        )

80  {

81        if(s_commandAttributes[commandCode      -  TPM_CC_FIRST]           &   NO_SESSIONS)

82              return   FALSE;

83        else

84              return   TRUE;

85  }

    9.4.3.7       IsHandleInResponse()

86  BOOL

87  IsHandleInResponse(

88        TPM_CC                 commandCode

89        )

90  {

91        if(s_commandAttributes[commandCode      -  TPM_CC_FIRST]           &   R_HANDLE)

92              return   TRUE;

93        else

94              return   FALSE;

    Page 226                                  TCG Published                                           Family "2.0"

    October 30, 2014                    Copyright © TCG 2006-2014                           Level 00  Revision 01.16
     Part 4: Supporting Routines                                                              Trusted Platform Module Library

95   }

     9.4.3.8       IsWriteOperation()

     Checks to see if an operation will write to NV memory

96   BOOL

97   IsWriteOperation(

98         TPM_CC                   command                  //   IN:  Command    to   check

99         )

100  {

101        switch    (command)

102        {

103            case      TPM_CC_NV_Write:

104            case      TPM_CC_NV_Increment:

105            case      TPM_CC_NV_SetBits:

106            case      TPM_CC_NV_Extend:

107            //    Nv  write   lock     counts  as      a  write     operation      for  authorization      purposes.

108            //    We  check   to    see    if  the  NV    is    write  locked      before  we  do  the  authorization

109            //    If  it  is  locked,      we  fail       the   command  early.

110            case      TPM_CC_NV_WriteLock:

111                  return      TRUE;

112            default:

113                  break;

114        }

115        return    FALSE;

116  }

     9.4.3.9       IsReadOperation()

     Checks to see if an operation will write to NV memory

117  BOOL

118  IsReadOperation(

119        TPM_CC                   command                  //   IN:  Command    to   check

120        )

121  {

122        switch    (command)

123        {

124            case      TPM_CC_NV_Read:

125            case      TPM_CC_PolicyNV:

126            case      TPM_CC_NV_Certify:

127            //    Nv  read    lock     counts  as   a     read  operation      for  authorization       purposes.

128            //    We  check   to    see    if  the  NV    is    read   locked  before      we  do  the  authorization

129            //    If  it  is  locked,      we  fail       the   command  early.

130            case      TPM_CC_NV_ReadLock:

131                  return      TRUE;

132            default:

133                  break;

134        }

135        return    FALSE;

136  }

     9.4.3.10      CommandCapGetCCList()

     This  function  returns     a  list  of  implemented         commands    and     command     attributes  starting  from  the

     command in commandCode.

     Family "2.0"                                            TCG Published                                              Page 227

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                   October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

     Return Value                                 Meaning

     YES                                          more command attributes are available

     NO                                           no more command attributes are available

137  TPMI_YES_NO

138  CommandCapGetCCList(

139       TPM_CC                       commandCode,                 //  IN:    start    command     code

140       UINT32                       count,                       //  IN:    maximum       count  for   number  of    entries  in

141                                                                 //         'commandList'

142       TPML_CCA                  *commandList                    //  OUT:   list     of   TPMA_CC

143       )

144  {

145       TPMI_YES_NO                  more       =  NO;

146       UINT32                       i;

147

148       //  initialize         output        handle       list      count

149       commandList->count               =   0;

150

151       //  The     maximum    count         of    commands         that    may  be   return      is  MAX_CAP_CC.

152       if(count       >  MAX_CAP_CC)              count    =     MAX_CAP_CC;

153

154       //  If   the      command       code       is  smaller        than   TPM_CC_FIRST,        start  from   TPM_CC_FIRST

155       if(commandCode         <     TPM_CC_FIRST)                commandCode      =  TPM_CC_FIRST;

156

157       //  Collect       command        attributes

158       for(i    =  commandCode;             i     <=  TPM_CC_LAST;          i++)

159       {

160            if(CommandIsImplemented(i))

161            {

162                   if(commandList->count                      <  count)

163                   {

164                          //  If       the     list    is     not    full,  add      the  attributes    for    this  command.

165                          commandList->commandAttributes[commandList->count]

166                                 =     CommandGetAttribute(i);

167                          commandList->count++;

168                   }

169                   else

170                   {

171                          //  If       the     list    is     full   but    there    are  more       commands  to  report,

172                          //  indicate            this     and     return.

173                          more      =   YES;

174                          break;

175                   }

176            }

177       }

178       return      more;

179  }

     9.5      DRTM.c

     9.5.1     Description

     This file contains functions that simulate the DRTM events. Its primary purpose is to isolate the name

     space of the simulator from the name space of the TPM. This is only an issue with the parameters to

     _TPM_Hash_Data().

     9.5.2     Includes

1    #include         "InternalRoutines.h"

     Page 228                                                       TCG Published                                       Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part 4: Supporting Routines                                      Trusted Platform Module Library

    9.5.3      Functions

    9.5.3.1    Signal_Hash_Start()

    This function interfaces between the  platform  code  and  _TPM_Hash_Start().

2   LIB_EXPORT    void

3   Signal_Hash_Start(

4        void

5        )

6   {

7        _TPM_Hash_Start();

8        return;

9   }

    9.5.3.2    Signal_Hash_Data()

    This function interfaces between the platform   code  and  _TPM_Hash_Data().

10  LIB_EXPORT    void

11  Signal_Hash_Data(

12       unsigned      int   size,

13       unsigned      char  *buffer

14       )

15  {

16       _TPM_Hash_Data(size,    buffer);

17       return;

18  }

    9.5.3.3    Signal_Hash_End()

    This function interfaces between the  platform  code  and  _TPM_Hash_End().

19  LIB_EXPORT    void

20  Signal_Hash_End(

21       void

22       )

23  {

24       _TPM_Hash_End();

25       return;

26  }

    9.6      Entity.c

    9.6.1      Description

    The functions in this file are used for accessing properties for handles of various types. Functions in other

    files require handles of a specific type but the functions in this file allow use of any handle type.

    9.6.2      Includes

1   #include   "InternalRoutines.h"

    Family "2.0"                                   TCG Published                                           Page 229

    Level 00 Revision 01.16               Copyright © TCG 2006-2014                October 30, 2014
    Trusted Platform Module Library                                                           Part 4: Supporting Routines

    9.6.3    Functions

    9.6.3.1      EntityGetLoadStatus()

    This function will indicate if the entity associated with a handle is present in TPM memory. If the handle is

    a persistent object handle, and the object exists, the persistent object is moved from NV memory into a

    RAM object slot and the persistent handle is replaced with the transient object handle for the slot.

    Error Returns                      Meaning

    TPM_RC_HANDLE                      handle type does not match

    TPM_RC_REFERENCE_H0                entity is not present

    TPM_RC_HIERARCHY                   entity belongs to a disabled hierarchy

    TPM_RC_OBJECT_MEMORY               handle is an evict object but there is no space to load it to RAM

2   TPM_RC

3   EntityGetLoadStatus(

4      TPM_HANDLE            *handle,                  //  IN/OUT:        handle  of   the   entity

5      TPM_CC                commandCode               //  IN:    the     commmandCode

6      )

7   {

8      TPM_RC                result     =  TPM_RC_SUCCESS;

9

10     switch(HandleGetType(*handle))

11     {

12           //  For   handles    associated        with   hierarchies,       the     entity  is  present

13           //  only  if  the    associated        enable    is  SET.

14           case     TPM_HT_PERMANENT:

15                 switch(*handle)

16                 {

17                     case  TPM_RH_OWNER:

18                           if(!gc.shEnable)

19                                 result    =    TPM_RC_HIERARCHY;

20                           break;

21

22  #ifdef   VENDOR_PERMANENT

23                     case  VENDOR_PERMANENT:

24  #endif

25                     case  TPM_RH_ENDORSEMENT:

26                           if(!gc.ehEnable)

27                                 result    =    TPM_RC_HIERARCHY;

28                           break;

29                     case  TPM_RH_PLATFORM:

30                           if(!g_phEnable)

31                                 result    =    TPM_RC_HIERARCHY;

32                           break;

33                           //   null     handle,     PW  session        handle  and  lockout

34                           //   handle     are    always    available

35                     case  TPM_RH_NULL:

36                     case  TPM_RS_PW:

37                     case  TPM_RH_LOCKOUT:

38                           break;

39                     default:

40                           //   handling      of  the    manufacture_specific             handles

41                           if(           ((TPM_RH)*handle           >=  TPM_RH_AUTH_00)

42                                 &&      ((TPM_RH)*handle           <=  TPM_RH_AUTH_FF))

43                                 //   use  the    value     that     would  have     been   returned    from

44                                 //   unmarshaling        if    it   did  the   handle     filtering

45                                         result   =  TPM_RC_VALUE;

46                           else

47                                 pAssert(FALSE);

48                           break;

    Page 230                                           TCG Published                                            Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                       Trusted Platform Module    Library

49                  }

50                  break;

51            case     TPM_HT_TRANSIENT:

52                  //  For    a     transient           object,      check      if   the   handle     is  associated

53                  //  with      a  loaded         object.

54                  if(!ObjectIsPresent(*handle))

55                         result      =     TPM_RC_REFERENCE_H0;

56                  break;

57            case     TPM_HT_PERSISTENT:

58                  //  Persistent           object

59                  //  Copy      the     persistent          object       to    RAM   and   replace       the  handle  with  the

60                  //  handle       of      the    assigned      slot.          A    TPM_RC_OBJECT_MEMORY,

61                  //  TPM_RC_HIERARCHY                 or   TPM_RC_REFERENCE_H0                error     may  be  returned  by

62                  //  ObjectLoadEvict()

63                  result     =     ObjectLoadEvict(handle,                     commandCode);

64                  break;

65            case     TPM_HT_HMAC_SESSION:

66                  //  For    an    HMAC        session,        see   if     the     session    is    loaded

67                  //  and    if    the     session         in   the     session      slot    is    actually

68                  //  an     HMAC    session.

69                  if(SessionIsLoaded(*handle))

70                  {

71                         SESSION                               *session;

72                         session        =  SessionGet(*handle);

73                         //  Check         if     the  session       is     a  HMAC     session

74                         if(session->attributes.isPolicy                            ==   SET)

75                                result         =  TPM_RC_HANDLE;

76                  }

77                  else

78                         result      =     TPM_RC_REFERENCE_H0;

79                  break;

80            case     TPM_HT_POLICY_SESSION:

81                  //  For    a     policy         session,      see     if     the  session      is  loaded

82                  //  and    if    the     session         in   the     session      slot    is    actually

83                  //  a   policy        session.

84                  if(SessionIsLoaded(*handle))

85                  {

86                         SESSION                               *session;

87                         session        =  SessionGet(*handle);

88                         //  Check         if     the  session       is     a  policy     session

89                         if(session->attributes.isPolicy                            ==   CLEAR)

90                                result         =  TPM_RC_HANDLE;

91                  }

92                  else

93                         result      =     TPM_RC_REFERENCE_H0;

94                  break;

95            case     TPM_HT_NV_INDEX:

96                  //  For    an    NV      Index,      use     the   platform-specific               routine

97                  //  to     search        the    IN   Index    space.

98                  result     =     NvIndexIsAccessible(*handle,                         commandCode);

99                  break;

100           case     TPM_HT_PCR:

101                 //  Any    PCR     handle       that      is  unmarshaled             successfully     referenced

102                 //  a   PCR      that    is     defined.

103                 break;

104           default:

105                 //  Any    other         handle      type     is   a   defect      in   the    unmarshaling     code.

106                 pAssert(FALSE);

107                 break;

108        }

109        return  result;

110  }

     Family "2.0"                                                TCG Published                                                Page 231

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting Routines

     9.6.3.2   EntityGetAuthValue()

     This function is used to access the authValue associated with a handle. This function assumes that the

     handle references an entity that is accessible and the handle is not for a persistent objects. That is

     EntityGetLoadStatus() should have been called. Also, the accessibility of the authValue should have been

     verified by IsAuthValueAvailable().

     This function copies the authorization value of the entity to auth.

     Return value is the number of octets copied to auth.

111  UINT16

112  EntityGetAuthValue(

113     TPMI_DH_ENTITY           handle,                   //   IN:   handle    of  entity

114     AUTH_VALUE               *auth                     //   OUT:  authValue     of     the  entity

115     )

116  {

117     TPM2B_AUTH               authValue         =  {0};

118

119     switch(HandleGetType(handle))

120     {

121           case     TPM_HT_PERMANENT:

122                 switch(handle)

123                 {

124                        case  TPM_RH_OWNER:

125                              //  ownerAuth        for   TPM_RH_OWNER

126                              authValue     =      gp.ownerAuth;

127                              break;

128                        case  TPM_RH_ENDORSEMENT:

129                              //  endorsementAuth            for   TPM_RH_ENDORSEMENT

130                              authValue     =      gp.endorsementAuth;

131                              break;

132                        case  TPM_RH_PLATFORM:

133                              //  platformAuth          for    TPM_RH_PLATFORM

134                              authValue     =      gc.platformAuth;

135                              break;

136                        case  TPM_RH_LOCKOUT:

137                              //  lockoutAuth           for  TPM_RH_LOCKOUT

138                              authValue     =      gp.lockoutAuth;

139                              break;

140                        case  TPM_RH_NULL:

141                              //  nullAuth         for  TPM_RH_NULL.       Return    0  directly     here

142                              return   0;

143                              break;

144  #ifdef   VENDOR_PERMANENT

145                        case  VENDOR_PERMANENT:

146                              //  vendor    auth        value

147                              authValue     =      g_platformUniqueDetails;

148  #endif

149                        default:

150                              //  If  any   other       permanent      handle    is  present    it   is

151                              //  a   code  defect.

152                              pAssert(FALSE);

153                              break;

154                 }

155                 break;

156           case     TPM_HT_TRANSIENT:

157                 //  authValue        for   an     object

158                 //  A  persistent         object       would  have    been  copied     into   RAM

159                 //  and    would     have  an     transient       object    handle     here.

160                 {

161                        OBJECT                     *object;

162                        object    =   ObjectGet(handle);

163                        //  special    handling         if   this  is  a   sequence     object

164                        if(ObjectIsSequence(object))

     Page 232                                              TCG Published                                      Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part  4: Supporting Routines                                                           Trusted Platform Module     Library

165                       {

166                             authValue   =    ((HASH_OBJECT       *)object)->auth;

167                       }

168                       else

169                       {

170                             //  Auth    value    is  available   only       when   the   private  portion       of

171                             //  the     object   is  loaded.     The    check     should     be   made  before

172                             //  this    function     is  called

173                             pAssert(object->attributes.publicOnly                  ==    CLEAR);

174                             authValue   =    object->sensitive.authValue;

175                       }

176                  }

177                  break;

178            case     TPM_HT_NV_INDEX:

179                  //   authValue   for   an   NV  index

180                  {

181                       NV_INDEX               nvIndex;

182                       NvGetIndexInfo(handle,             &nvIndex);

183                       authValue      =  nvIndex.authValue;

184                  }

185                  break;

186            case     TPM_HT_PCR:

187                  //   authValue   for   PCR

188                  PCRGetAuthValue(handle,             &authValue);

189                  break;

190            default:

191                  //   If  any   other   handle   type    is    present  here,      then   there   is    a  defect

192                  //   in  the   unmarshaling     code.

193                  pAssert(FALSE);

194                  break;

195        }

196

197        //  Copy  the  authValue

198        pAssert(authValue.t.size         <=   sizeof(authValue.t.buffer));

199        MemoryCopy(auth,        authValue.t.buffer,        authValue.t.size,         sizeof(TPMU_HA));

200

201        return    authValue.t.size;

202  }

     9.6.3.3       EntityGetAuthPolicy()

     This function is used to access the authPolicy associated with a handle. This function assumes that the

     handle references an entity that is accessible and the handle is not for a persistent objects. That is

     EntityGetLoadStatus()    should  have  been     called.  Also,  the    accessibility    of  the  authPolicy  should  have

     been verified by IsAuthPolicyAvailable().

     This function copies the authorization policy of the entity to authPolicy.

     The return value is the hash algorithm for the policy.

203  TPMI_ALG_HASH

204  EntityGetAuthPolicy(

205        TPMI_DH_ENTITY          handle,               //  IN:   handle   of  entity

206        TPM2B_DIGEST         *authPolicy              //  OUT:  authPolicy      of  the    entity

207        )

208  {

209        TPMI_ALG_HASH             hashAlg     =   TPM_ALG_NULL;

210

211        switch(HandleGetType(handle))

212        {

213            case     TPM_HT_PERMANENT:

214                  switch(handle)

215                  {

216                       case     TPM_RH_OWNER:

     Family "2.0"                                        TCG Published                                              Page 233

     Level 00 Revision 01.16                Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                  Part 4:  Supporting  Routines

217                             //  ownerPolicy            for   TPM_RH_OWNER

218                             *authPolicy           =   gp.ownerPolicy;

219                             hashAlg     =   gp.ownerAlg;

220                             break;

221                       case     TPM_RH_ENDORSEMENT:

222                             //  endorsementPolicy                for  TPM_RH_ENDORSEMENT

223                             *authPolicy           =   gp.endorsementPolicy;

224                             hashAlg     =   gp.endorsementAlg;

225                             break;

226                       case     TPM_RH_PLATFORM:

227                             //  platformPolicy              for   TPM_RH_PLATFORM

228                             *authPolicy           =   gc.platformPolicy;

229                             hashAlg     =   gc.platformAlg;

230                             break;

231                       case     TPM_RH_LOCKOUT:

232                             //  lockoutPolicy          for       TPM_RH_LOCKOUT

233                             *authPolicy           =   gp.lockoutPolicy;

234                             hashAlg     =   gp.lockoutAlg;

235                             break;

236                       default:

237                             //  If    any   other      permanent      handle        is  present   it  is

238                             //  a     code  defect.

239                             pAssert(FALSE);

240                             break;

241                 }

242                 break;

243           case     TPM_HT_TRANSIENT:

244                 //    authPolicy      for   an       object

245                 {

246                       OBJECT    *object        =     ObjectGet(handle);

247                       *authPolicy       =   object->publicArea.authPolicy;

248                       hashAlg      =  object->publicArea.nameAlg;

249                 }

250                 break;

251           case     TPM_HT_NV_INDEX:

252                 //    authPolicy      for   a     NV   index

253                 {

254                       NV_INDEX                    nvIndex;

255                       NvGetIndexInfo(handle,                 &nvIndex);

256                       *authPolicy       =   nvIndex.publicArea.authPolicy;

257                       hashAlg      =  nvIndex.publicArea.nameAlg;

258                 }

259                 break;

260           case     TPM_HT_PCR:

261                 //    authPolicy      for   a     PCR

262                 hashAlg     =   PCRGetAuthPolicy(handle,              authPolicy);

263                 break;

264           default:

265                 //    If  any   other   handle         type   is   present      it  is  a   code  defect.

266                 pAssert(FALSE);

267                 break;

268     }

269     return  hashAlg;

270  }

     9.6.3.4    EntityGetName()

     This function returns the Name associated with a handle. It will set name                  to  the Name and return the size

     of the Name string.

271  UINT16

272  EntityGetName(

273     TPMI_DH_ENTITY             handle,                 //    IN:   handle   of      entity

274     NAME                    *name                      //    OUT:     name  of  entity

     Page 234                                              TCG Published                                       Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part  4: Supporting Routines                                                           Trusted    Platform  Module  Library

275        )

276  {

277        UINT16             nameSize;

278

279        switch(HandleGetType(handle))

280        {

281           case     TPM_HT_TRANSIENT:

282                 //  Name  for    an    object

283                 nameSize      =  ObjectGetName(handle,              name);

284                 break;

285           case     TPM_HT_NV_INDEX:

286                 //  Name  for    a     NV  index

287                 nameSize      =  NvGetName(handle,            name);

288                 break;

289           default:

290                 //  For   all    other     types,    the  handle      is   the   Name

291                 nameSize      =  TPM_HANDLE_Marshal(&handle,                (BYTE  **)&name,       NULL);

292                 break;

293        }

294        return  nameSize;

295  }

     9.6.3.5       EntityGetHierarchy()

     This function returns the hierarchy handle associated with an entity.

     a)    A handle that is a hierarchy handle is associated with itself.

     b)    An NV index belongs to TPM_RH_PLATFORM if TPMA_NV_PLATFORMCREATE, is SET,

           otherwise it belongs to TPM_RH_OWNER

     c)    An object handle belongs to its hierarchy. All other handles belong to the platform hierarchy. or an NV

           Index.

296  TPMI_RH_HIERARCHY

297  EntityGetHierarchy(

298        TPMI_DH_ENTITY         handle                 //   IN    :handle    of   entity

299        )

300  {

301        TPMI_RH_HIERARCHY                   hierarcy    =  TPM_RH_NULL;

302

303        switch(HandleGetType(handle))

304        {

305           case     TPM_HT_PERMANENT:

306                 //  hierarchy       for    a   permanent      handle

307                 switch(handle)

308                 {

309                     case      TPM_RH_PLATFORM:

310                     case      TPM_RH_ENDORSEMENT:

311                     case      TPM_RH_NULL:

312                           hierarcy         =   handle;

313                           break;

314                     //    all    other     permanent      handles     are   associated       with  the  owner

315                     //    hierarchy.          (should     only  be  TPM_RH_OWNER        and  TPM_RH_LOCKOUT)

316                     default:

317                           hierarcy         =   TPM_RH_OWNER;

318                           break;

319                 }

320                 break;

321           case     TPM_HT_NV_INDEX:

322                 //  hierarchy       for    NV  index

323                 {

324                     NV_INDEX                   nvIndex;

325                     NvGetIndexInfo(handle,                &nvIndex);

326                     //    If     only  the     platform   can   delete      the  index,      then  it   is

     Family "2.0"                                        TCG Published                                             Page 235

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                 October 30, 2014
     Trusted Platform Module Library                                                           Part 4: Supporting Routines

327                        //  considered           to  be     in  the  platform   hierarchy,  otherwise     it

328                        //  is     in  the  owner        hierarchy.

329                        if(nvIndex.publicArea.attributes.TPMA_NV_PLATFORMCREATE                        ==     SET)

330                              hierarcy      =    TPM_RH_PLATFORM;

331                        else

332                              hierarcy      =    TPM_RH_OWNER;

333                    }

334                    break;

335            case       TPM_HT_TRANSIENT:

336                    //  hierarchy      for  an       object

337                    {

338                        OBJECT                       *object;

339                        object     =   ObjectGet(handle);

340                        if(object->attributes.ppsHierarchy)

341                        {

342                              hierarcy      =    TPM_RH_PLATFORM;

343                        }

344                        else    if(object->attributes.epsHierarchy)

345                        {

346                              hierarcy      =    TPM_RH_ENDORSEMENT;

347                        }

348                        else    if(object->attributes.spsHierarchy)

349                        {

350                              hierarcy      =    TPM_RH_OWNER;

351                        }

352

353                    }

354                    break;

355            case       TPM_HT_PCR:

356                    hierarcy    =  TPM_RH_OWNER;

357                    break;

358            default:

359                    pAssert(0);

360                    break;

361        }

362        //  this    is  unreachable         but  it  provides        a  return  value  for  the  default

363        //  case    which   makes      the  complier        happy

364        return     hierarcy;

365  }

     9.7       Global.c

     9.7.1     Description

     This file will instance the TPM variables that are not stack allocated. The descriptions for these variables

     is in Global.h.

     9.7.2     Includes and Defines

1    #define   GLOBAL_C

2    #include  "InternalRoutines.h"

     9.7.3     Global Data Values

     These values are visible across multiple modules.

3    BOOL                          g_phEnable;

4    const     UINT16              g_rcIndex[15]            =  {TPM_RC_1,     TPM_RC_2,   TPM_RC_3,  TPM_RC_4,

5                                                                  TPM_RC_5,  TPM_RC_6,   TPM_RC_7,  TPM_RC_8,

6                                                                  TPM_RC_9,  TPM_RC_A,   TPM_RC_B,  TPM_RC_C,

7                                                                  TPM_RC_D,  TPM_RC_E,   TPM_RC_F

     Page 236                                                  TCG Published                                     Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                       Level 00 Revision 01.16
    Part 4: Supporting Routines                                             Trusted  Platform Module Library

8                                                 };

9   TPM_HANDLE               g_exclusiveAuditSession;

10  UINT64                   g_time;

11  BOOL                     g_pcrReConfig;

12  TPMI_DH_OBJECT           g_DRTMHandle;

13  BOOL                     g_DrtmPreStartup;

14  BOOL                     g_StartupLocality3;

15  BOOL                     g_clearOrderly;

16  TPM_SU                   g_prevOrderlyState;

17  BOOL                     g_updateNV;

18  BOOL                     g_nvOk;

19  TPM2B_AUTH               g_platformUniqueDetails;

20  STATE_CLEAR_DATA         gc;

21  STATE_RESET_DATA         gr;

22  PERSISTENT_DATA          gp;

23  ORDERLY_DATA             go;

    9.7.4    Private Values

    9.7.4.1      SessionProcess.c

24  #ifndef  __IGNORE_STATE__             //  DO  NOT  DEFINE  THIS  VALUE

    These values do not need to be retained between commands.

25  TPM_HANDLE               s_sessionHandles[MAX_SESSION_NUM];

26  TPMA_SESSION             s_attributes[MAX_SESSION_NUM];

27  TPM_HANDLE               s_associatedHandles[MAX_SESSION_NUM];

28  TPM2B_NONCE              s_nonceCaller[MAX_SESSION_NUM];

29  TPM2B_AUTH               s_inputAuthValues[MAX_SESSION_NUM];

30  UINT32                   s_encryptSessionIndex;

31  UINT32                   s_decryptSessionIndex;

32  UINT32                   s_auditSessionIndex;

33  TPM2B_DIGEST             s_cpHashForAudit;

34  UINT32                   s_sessionNum;

35  #endif   //   __IGNORE_STATE__

36  BOOL                     s_DAPendingOnNV;

37  #ifdef   TPM_CC_GetCommandAuditDigest

38  TPM2B_DIGEST             s_cpHashForCommandAudit;

39  #endif

    9.7.4.2      DA.c

40  UINT64                   s_selfHealTimer;

41  UINT64                   s_lockoutTimer;

    9.7.4.3      NV.c

42  UINT32                   s_reservedAddr[NV_RESERVE_LAST];

43  UINT32                   s_reservedSize[NV_RESERVE_LAST];

44  UINT32                   s_ramIndexSize;

45  BYTE                     s_ramIndex[RAM_INDEX_SPACE];

46  UINT32                   s_ramIndexSizeAddr;

47  UINT32                   s_ramIndexAddr;

48  UINT32                   s_maxCountAddr;

49  UINT32                   s_evictNvStart;

50  UINT32                   s_evictNvEnd;

51  TPM_RC                   s_NvStatus;

    Family "2.0"                               TCG Published                         Page 237

    Level 00 Revision 01.16           Copyright © TCG 2006-2014                      October 30, 2014
    Trusted Platform Module Library                                               Part 4: Supporting Routines

    9.7.4.4   Object.c

52  OBJECT_SLOT           s_objects[MAX_LOADED_OBJECTS];

    9.7.4.5   PCR.c

53  PCR                   s_pcrs[IMPLEMENTATION_PCR];

    9.7.4.6   Session.c

54  SESSION_SLOT          s_sessions[MAX_LOADED_SESSIONS];

55  UINT32                s_oldestSavedSession;

56  int                   s_freeSessionSlots;

    9.7.4.7   Manufacture.c

57  BOOL                  g_manufactured      =  FALSE;

    9.7.4.8   Power.c

58  BOOL                  s_initialized    =     FALSE;

    9.7.4.9   MemoryLib.c

    The s_actionOutputBuffer should not be modifiable by the host system until the TPM has     returned a

    response code. The s_actionOutputBuffer should not be accessible until response parameter  encryption,

    if any, is complete. This memory is not used between commands

59  #ifndef   __IGNORE_STATE__         //  DO    NOT  DEFINE  THIS        VALUE

60  UINT32    s_actionInputBuffer[1024];                 //   action      input   buffer

61  UINT32    s_actionOutputBuffer[1024];                //   action      output  buffer

62  BYTE      s_responseBuffer[MAX_RESPONSE_SIZE];//          response    buffer

63  #endif

    9.7.4.10  SelfTest.c

    Define these values here if the AlgorithmTests() project is not used

64  #ifndef   SELF_TEST

65  ALGORITHM_VECTOR      g_implementedAlgorithms;

66  ALGORITHM_VECTOR      g_toTest;

67  #endif

    9.7.4.11  TpmFail.c

68  jmp_buf               g_jumpBuffer;

69  BOOL                  g_forceFailureMode;

70  BOOL                  g_inFailureMode;

71  UINT32                s_failFunction;

72  UINT32                s_failLine;

73  UINT32                s_failCode;

    Page 238                                  TCG Published                                    Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                             Trusted Platform Module Library

    9.8      Handle.c

    9.8.1     Description

    This file contains the functions that return the type of a handle.

    9.8.2     Includes

1   #include     "Tpm.h"

2   #include     "InternalRoutines.h"

    9.8.3     Functions

    9.8.3.1       HandleGetType()

    This function returns the type of a handle which is the MSO of the handle.

3   TPM_HT

4   HandleGetType(

5        TPM_HANDLE                    handle              //  IN:   a  handle  to  be   checked

6        )

7   {

8        //  return    the        upper  bytes      of  input  data

9        return    (TPM_HT)         ((handle     &   HR_RANGE_MASK)         >>  HR_SHIFT);

10  }

    9.8.3.2       NextPermanentHandle()

    This function returns the permanent handle that is equal to the input value or is the next higher value. If

    there is no handle with the input value and there is no next higher value, it returns 0:

    Return Value                              Meaning

11  TPM_HANDLE

12  NextPermanentHandle(

13       TPM_HANDLE                    inHandle            //  IN:   the    handle  to  check

14       )

15  {

16       //  If   inHandle         is  below    the     start  of  the  range   of  permanent  handles

17       //  set   it  to      the     start   and   scan  from    there

18       if(inHandle        <     TPM_RH_FIRST)

19            inHandle         =   TPM_RH_FIRST;

20       //  scan     from     input     value   untill    we  find     an  implemented     permanent  handle

21       //  or   go   out     of   range

22       for(;    inHandle         <=  TPM_RH_LAST;        inHandle++)

23       {

24            switch   (inHandle)

25            {

26                    case     TPM_RH_OWNER:

27                    case     TPM_RH_NULL:

28                    case     TPM_RS_PW:

29                    case     TPM_RH_LOCKOUT:

30                    case     TPM_RH_ENDORSEMENT:

31                    case     TPM_RH_PLATFORM:

32                    case     TPM_RH_PLATFORM_NV:

33       #ifdef       VENDOR_PERMANENT

34                    case     VENDOR_PERMANENT:

35       #endif

36                          return       inHandle;

    Family "2.0"                                           TCG Published                                       Page 239

    Level 00 Revision 01.16                         Copyright © TCG 2006-2014                           October 30, 2014
    Trusted Platform Module Library                                                                      Part 4: Supporting Routines

37                              break;

38                   default:

39                              break;

40           }

41       }

42       //  Out     of     range      on     the   top

43       return      0;

44  }

    9.8.3.3       PermanentCapGetHandles()

    This function returns a list of the permanent handles of PCR, started from handle. If handle is                         larger  than

    the largest permanent handle, an empty list will be returned with more set to NO.

    Return Value                                   Meaning

    YES                                            if there are more handles available

    NO                                             all the available handles has been returned

45  TPMI_YES_NO

46  PermanentCapGetHandles(

47       TPM_HANDLE                       handle,                  //     IN:   start    handle

48       UINT32                           count,                   //     IN:   count    of  returned    handle

49       TPML_HANDLE                   *handleList                 //     OUT:  list     of  handle

50       )

51  {

52       TPMI_YES_NO                   more     =   NO;

53       UINT32                        i;

54

55       pAssert(HandleGetType(handle)                        ==    TPM_HT_PERMANENT);

56

57       //  Initialize            output       handle     list

58       handleList->count                 =   0;

59

60       //  The     maximum        count       of  handles        we     may   return   is  MAX_CAP_HANDLES

61       if(count        >  MAX_CAP_HANDLES)               count       =  MAX_CAP_HANDLES;

62

63       //  Iterate        permanent           handle     range

64       for(i    =  NextPermanentHandle(handle);

65                   i      !=  0;     i   =   NextPermanentHandle(i+1))

66       {

67           if(handleList->count                       <  count)

68           {

69                   //     If     we     have     not     filled   up    the   return       list,  add  this  permanent

70                   //     handle         to   it

71                   handleList->handle[handleList->count]                               =   i;

72                   handleList->count++;

73           }

74           else

75           {

76                   //     If     the     return       list  is    full       but   we  still   have    permanent  handle

77                   //     available,             report     this     and     stop  iterating

78                   more       =   YES;

79                   break;

80           }

81       }

82       return      more;

83  }

    Page 240                                                       TCG Published                                            Family "2.0"

    October 30, 2014                                       Copyright © TCG 2006-2014                           Level 00 Revision 01.16
    Part 4: Supporting Routines                                                        Trusted Platform Module Library

    9.9      Locality.c

    9.9.1       Includes

1   #include     "InternalRoutines.h"

    9.9.2       LocalityGetAttributes()

    This function will convert a locality expressed as an integer into TPMA_LOCALITY form.

    The function returns the locality attribute.

2   TPMA_LOCALITY

3   LocalityGetAttributes(

4         UINT8                locality            //    IN:  locality          value

5         )

6   {

7         TPMA_LOCALITY                    locality_attributes;

8         BYTE                          *localityAsByte       =     (BYTE       *)&locality_attributes;

9

10        MemorySet(&locality_attributes,          0,    sizeof(TPMA_LOCALITY));

11        switch(locality)

12        {

13              case  0:

14                    locality_attributes.TPM_LOC_ZERO           =     SET;

15                    break;

16              case  1:

17                    locality_attributes.TPM_LOC_ONE         =     SET;

18                    break;

19              case  2:

20                    locality_attributes.TPM_LOC_TWO         =     SET;

21                    break;

22              case  3:

23                    locality_attributes.TPM_LOC_THREE             =     SET;

24                    break;

25              case  4:

26                    locality_attributes.TPM_LOC_FOUR           =     SET;

27                    break;

28              default:

29                    pAssert(locality     <  256  &&  locality        >  31);

30                    *localityAsByte   =     locality;

31                    break;

32        }

33        return  locality_attributes;

34  }

    9.10     Manufacture.c

    9.10.1      Description

    This file contains the function that performs the manufacturing of the TPM in a simulated environment.

    These functions should not be used outside of a manufacturing or simulation environment.

    9.10.2      Includes and Data Definitions

1   #define     MANUFACTURE_C

2   #include     "InternalRoutines.h"

3   #include     "Global.h"

    Family "2.0"                                   TCG Published                                         Page 241

    Level 00 Revision 01.16                   Copyright © TCG 2006-2014                       October 30, 2014
    Trusted Platform Module Library                                                                  Part 4: Supporting Routines

    9.10.3    Functions

    9.10.3.1      TPM_Manufacture()

    This function initializes the TPM values in preparation for the TPM's first use. This function will fail if

    previously called. The TPM can be re-manufactured by calling TPM_Teardown() first and then calling this

    function again.

    Return Value                            Meaning

    0                                       success

    1                                       manufacturing process previously performed

4   LIB_EXPORT       int

5   TPM_Manufacture(

6      BOOL                           firstTime             //     IN:  indicates      if  this  is  the  first  call   from

7                                                           //          main()

8      )

9   {

10     TPM_SU                      orderlyShutdown;

11     UINT64                      totalResetCount          =   0;

12

13     //     If  TPM  has    been        manufactured,        return   indication.

14     if(!firstTime          &&      g_manufactured)

15            return      1;

16

17     //     initialize      crypto        units

18     //CryptInitUnits();

19

20     //

21     s_selfHealTimer             =  0;

22     s_lockoutTimer         =       0;

23     s_DAPendingOnNV             =  FALSE;

24

25     //     initialize      NV

26     NvInit();

27

28  #ifdef    _DRBG_STATE_SAVE

29     //     Initialize      the     drbg.   This    needs        to   come   before  the  install

30     //     of  the  hierarchies

31     if(!_cpri__Startup())                                        //  Have   to  start    the  crypto   units  first

32            FAIL(FATAL_ERROR_INTERNAL);

33     _cpri__DrbgGetPutState(PUT_STATE,                        0,     NULL);

34  #endif

35

36     //     default     configuration       for     PCR

37     PCRSimStart();

38

39     //     initialize      pre-installed         hierarchy           data

40     //     This   should   happen        after   NV  is      initialized        because  hierarchy     data   is

41     //     stored   in     NV.

42     HierarchyPreInstall_Init();

43

44     //     initialize      dictionary      attack        parameters

45     DAPreInstall_Init();

46

47     //     initialize      PP      list

48     PhysicalPresencePreInstall_Init();

49

50     //     initialize      command       audit   list

51     CommandAuditPreInstall_Init();

52

53     //     first    start  up      is    required    to     be   Startup(CLEAR)

    Page 242                                                TCG Published                                            Family "2.0"

    October 30, 2014                               Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                        Trusted Platform Module Library

54      orderlyShutdown                  =   TPM_SU_CLEAR;

55      NvWriteReserved(NV_ORDERLY,                          &orderlyShutdown);

56

57      //     initialize          the       firmware        version

58      gp.firmwareV1              =     FIRMWARE_V1;

59   #ifdef    FIRMWARE_V2

60      gp.firmwareV2              =     FIRMWARE_V2;

61   #else

62      gp.firmwareV2              =     0;

63   #endif

64      NvWriteReserved(NV_FIRMWARE_V1,                         &gp.firmwareV1);

65      NvWriteReserved(NV_FIRMWARE_V2,                         &gp.firmwareV2);

66

67      //     initialize          the       total       reset  counter    to  0

68      NvWriteReserved(NV_TOTAL_RESET_COUNT,                              &totalResetCount);

69

70      //     initialize          the       clock       stuff

71      go.clock         =  0;

72      go.clockSafe            =     YES;

73

74   #ifdef    _DRBG_STATE_SAVE

75      //     initialize          the       current      DRBG  state      in  NV

76

77      _cpri__DrbgGetPutState(GET_STATE,                             sizeof(go.drbgState),             (BYTE  *)&go.drbgState);

78   #endif

79

80      NvWriteReserved(NV_ORDERLY_DATA,                          &go);

81

82      //     Commit       NV  writes.              Manufacture      process      is  an  artificial   process       existing

83      //     only  in     simulator            environment      and      it  is  not     defined  in  the    specification

84      //     that  what       should           be  the     expected  behavior        if  the  NV  write      fails  at  this

85      //     point.       Therefore,               it  is  assumed   the     NV  write   here     is  always  success   and

86      //     no  return       code         of  this     function     is  checked.

87      NvCommit();

88

89      g_manufactured                =     TRUE;

90

91      return       0;

92   }

     9.10.3.2      TPM_TearDown()

     This function prepares the TPM for re-manufacture. It should not be implemented in anything other than a

     simulated TPM.

     In this implementation, all that is needs is to stop the cryptographic units and set a flag to indicate that the

     TPM can be re-manufactured. This should be all that is necessary to start the manufacturing process

     again.

     Return Value                                    Meaning

     0                                               success

     1                                               TPM not previously manufactured

93   LIB_EXPORT      int

94   TPM_TearDown(

95      void

96      )

97   {

98      //     stop  crypt         units

99      CryptStopUnits();

100

101     g_manufactured                =     FALSE;

     Family "2.0"                                               TCG Published                                                   Page 243

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                   October 30, 2014
     Trusted Platform Module Library                                                     Part 4: Supporting Routines

102        return  0;

103  }

     9.11      Marshal.c

     9.11.1    Introduction

     This file contains the marshaling and unmarshaling code.

     The marshaling and unmarshaling code and function prototypes are not listed, as the code is repetitive,

     long, and not very useful to read. Examples of a few unmarshaling routines are provided. Most of the

     others are similar.

     Depending on the table header flags, a type will have an unmarshaling routine and a marshaling routine

     The table header flags that control the generation of the unmarshaling and marshaling code are delimited

     by angle brackets ("<>") in the table header. If no brackets are present, then both unmarshaling and

     marshaling code is generated (i.e., generation of both marshaling and unmarshaling code is the default).

     9.11.2    Unmarshal and Marshal a Value

     In TPM 2.0 Part 2, a TPMI_DI_OBJECT is defined by this table:

                          Table xxx -- Definition    of  (TPM_HANDLE) TPMI_DH_OBJECT Type

     Values                                                  Comments

     {TRANSIENT_FIRST:TRANSIENT_LAST}                        allowed range for transient objects

     {PERSISTENT_FIRST:PERSISTENT_LAST}                      allowed range for persistent objects

     +TPM_RH_NULL                                            the null handle

     #TPM_RC_VALUE

     This generates the following unmarshaling code:

1    TPM_RC

2    TPMI_DH_OBJECT_Unmarshal(TPMI_DH_OBJECT             *target,       BYTE  **buffer,  INT32     *size,

3                                     bool        flag)

4    {

5          TPM_RC         result;

6          result  =   TPM_HANDLE_Unmarshal((TPM_HANDLE            *)target,  buffer,    size);

7          if(result      !=     TPM_RC_SUCCESS)

8              return     result;

9          if  (*target       ==  TPM_RH_NULL)    {

10             if(flag)

11                    return      TPM_RC_SUCCESS;

12             else

13                    return      TPM_RC_VALUE;

14         }

15         if((*target        <   TRANSIENT_FIRST)   ||  (*target  >  TRANSIENT_LAST))

16             if((*target        <  PERSISTENT_FIRST)   ||  (*target   >  PERSISTENT_LAST))

17                    return      TPM_RC_VALUE;

18         return  TPM_RC_SUCCESS;

19   }

     Page 244                                            TCG Published                             Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                       Trusted Platform Module Library

    and the following marshaling code:

    NOTE             The marshaling code does not do parameter checking, as the TPM is the source of the marshaling data.

1   UINT16

2   TPMI_DH_OBJECT_Marshal(TPMI_DH_OBJECT          *source,  BYTE   **buffer,                               INT32  *size)

3   {

4         return  UINT32_Marshal((UINT32  *)source,     buffer,     size);

5   }

    9.11.3     Unmarshal and Marshal a Union

    In TPM 2.0 Part 2, a TPMU_PUBLIC_PARMS union is defined by:

                     Table xxx -- Definition of TPMU_PUBLIC_PARMS Union <IN/OUT, S>

    Parameter        Type                               Selector                                            Description

    keyedHash        TPMS_KEYEDHASH_PARMS               TPM_ALG_KEYEDHASH                                   sign | encrypt  | neither

    symDetail        TPMT_SYM_DEF_OBJECT                TPM_ALG_SYMCIPHER                                   a symmetric block cipher

    rsaDetail        TPMS_RSA_PARMS                     TPM_ALG_RSA                                         decrypt + sign

    eccDetail        TPMS_ECC_PARMS                     TPM_ALG_ECC                                         decrypt + sign

    asymDetail       TPMS_ASYM_PARMS                                                                        common     scheme   structure

                                                                                                            for RSA and ECC keys

    NOTE The Description column indicates which of TPMA_OBJECT.decrypt or TPMA_OBJECT.sign may be set.

       "+" indicates that both may be set but one shall be set. "|" indicates the optional settings.

    From this table, the following unmarshaling code is generated.

1   TPM_RC

2   TPMU_PUBLIC_PARMS_Unmarshal(TPMU_PUBLIC_PARMS            *target,                                 BYTE  **buffer,  INT32  *size,

3                                       UINT32  selector)

4   {

5         switch(selector)   {

6   #ifdef     TPM_ALG_KEYEDHASH

7              case  TPM_ALG_KEYEDHASH:

8                    return  TPMS_KEYEDHASH_PARMS_Unmarshal(

9                                  (TPMS_KEYEDHASH_PARMS     *)&(target->keyedHash),                                   buffer,  size);

10  #endif

11  #ifdef     TPM_ALG_SYMCIPHER

12             case  TPM_ALG_SYMCIPHER:

13                   return  TPMT_SYM_DEF_OBJECT_Unmarshal(

14                           (TPMT_SYM_DEF_OBJECT  *)&(target->symDetail),                                  buffer,    size,    FALSE);

15  #endif

16  #ifdef     TPM_ALG_RSA

17             case  TPM_ALG_RSA:

18                   return  TPMS_RSA_PARMS_Unmarshal(

19                                        (TPMS_RSA_PARMS    *)&(target->rsaDetail),                                   buffer,  size);

20  #endif

21  #ifdef     TPM_ALG_ECC

22             case  TPM_ALG_ECC:

23                   return  TPMS_ECC_PARMS_Unmarshal(

24                                        (TPMS_ECC_PARMS    *)&(target->eccDetail),                                   buffer,  size);

25  #endif

26        }

27        return  TPM_RC_SELECTOR;

28  }

    Family "2.0"                                TCG Published                                                                  Page 245

    Level 00 Revision 01.16              Copyright © TCG 2006-2014                                                     October 30, 2014
    Trusted Platform Module Library                                                          Part 4: Supporting Routines

    NOTE              The #ifdef/#endif directives are added whenever a value is dependent on an algorithm ID so that

                      removing the algorithm definition will remove the related code.

    The marshaling code for the union is:

1   UINT16

2   TPMU_PUBLIC_PARMS_Marshal(TPMU_PUBLIC_PARMS             *source,                   BYTE  **buffer,  INT32    *size,

3                                    UINT32  selector)

4   {

5         switch(selector)    {

6   #ifdef   TPM_ALG_KEYEDHASH

7            case     TPM_ALG_KEYEDHASH:

8                  return     TPMS_KEYEDHASH_PARMS_Marshal(

9                                    (TPMS_KEYEDHASH_PARMS   *)&(source->keyedHash),                    buffer,  size);

10  #endif

11  #ifdef   TPM_ALG_SYMCIPHER

12           case     TPM_ALG_SYMCIPHER:

13                 return     TPMT_SYM_DEF_OBJECT_Marshal(

14                                   (TPMT_SYM_DEF_OBJECT    *)&(source->symDetail),                    buffer,  size);

15  #endif

16  #ifdef   TPM_ALG_RSA

17           case     TPM_ALG_RSA:

18                 return     TPMS_RSA_PARMS_Marshal(

19                                   (TPMS_RSA_PARMS        *)&(source->rsaDetail),                     buffer,  size);

20  #endif

21  #ifdef   TPM_ALG_ECC

22           case     TPM_ALG_ECC:

23                 return     TPMS_ECC_PARMS_Marshal(

24                                         (TPMS_ECC_PARMS  *)&(source->eccDetail),                     buffer,  size);

25  #endif

26        }

27        assert(1);

28        return  0;

29  }

    For the marshaling and unmarshaling code, a value in the structure containing the union provides the

    value used for selector.  The example in the next section illustrates this.

    Page 246                                 TCG Published                                                       Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part 4: Supporting Routines                                                      Trusted Platform Module Library

    9.11.4      Unmarshal and Marshal a Structure

    In TPM 2.0 Part 2, the TPMT_PUBLiC structure is defined by:

                                 Table xxx -- Definition of TPMT_PUBLIC Structure

    Parameter           Type                 Description

    type                TPMI_ALG_PUBLIC      "algorithm" associated with this object

    nameAlg             +TPMI_ALG_HASH       algorithm used for computing the Name of the object

                                             NOTE     The "+" indicates that the instance of a TPMT_PUBLIC may have

                                                      a "+" to indicate that the nameAlg may be TPM_ALG_NULL.

    objectAttributes    TPMA_OBJECT          attributes that, along with type, determine the manipulations of this

                                             object

    authPolicy          TPM2B_DIGEST         optional policy for using this key

                                             The policy is computed using the nameAlg of the object.

                                             NOTE     shall be the Empty Buffer if no authorization policy is present

    [type]parameters    TPMU_PUBLIC_PARMS    the algorithm or structure details

    [type]unique        TPMU_PUBLIC_ID       the unique identifier of the structure

                                             For an asymmetric key, this would be the public key.

    This structure is tagged (the first value indicates the structure type), and that tag is used to determine how

    the parameters and unique fields are unmarshaled and marshaled. The use of the type for specifying the

    union selector is emphasized below.

    The unmarshaling code for the structure in the table above is:

1   TPM_RC

2   TPMT_PUBLIC_Unmarshal(TPMT_PUBLIC        *target,     BYTE      **buffer,    INT32  *size,     bool   flag)

3   {

4         TPM_RC        result;

5         result  =   TPMI_ALG_PUBLIC_Unmarshal((TPMI_ALG_PUBLIC           *)&(target->type),

6                                                    buffer,  size);

7         if(result     !=  TPM_RC_SUCCESS)

8               return  result;

9         result  =   TPMI_ALG_HASH_Unmarshal((TPMI_ALG_HASH         *)&(target->nameAlg),

10                                           buffer,      size,      flag);

11        if(result     !=  TPM_RC_SUCCESS)

12              return  result;

13        result  =   TPMA_OBJECT_Unmarshal((TPMA_OBJECT            *)&(target->objectAttributes),

14                                           buffer,   size);

15        if(result     !=  TPM_RC_SUCCESS)

16              return  result;

17        result  =   TPM2B_DIGEST_Unmarshal((TPM2B_DIGEST          *)&(target->authPolicy),

18                                           buffer,   size);

19        if(result     !=  TPM_RC_SUCCESS)

20              return  result;

21

22        result  =   TPMU_PUBLIC_PARMS_Unmarshal((TPMU_PUBLIC_PARMS                 *)&(target->parameters),

23                                                   buffer,        size,                             );

24        if(result     !=  TPM_RC_SUCCESS)

25              return  result;

26

27        result  =   TPMU_PUBLIC_ID_Unmarshal((TPMU_PUBLIC_ID             *)&(target->unique),

28                                           buffer,          size,                                )

29        if(result     !=  TPM_RC_SUCCESS)

30              return  result;

31

32        return  TPM_RC_SUCCESS;

33  }

    Family "2.0"                             TCG Published                                                Page 247

    Level 00 Revision 01.16              Copyright © TCG 2006-2014                              October 30, 2014
    Trusted Platform Module Library                                          Part 4: Supporting Routines

    The marshaling code for the TPMT_PUBLIC structure is:

1   UINT16

2   TPMT_PUBLIC_Marshal(TPMT_PUBLIC     *source,   BYTE    **buffer,  INT32  *size)

3   {

4      UINT16     result  =  0;

5      result  =  (UINT16)(result    +  TPMI_ALG_PUBLIC_Marshal(

6                                       (TPMI_ALG_PUBLIC        *)&(source->type),   buffer,  size));

7      result  =  (UINT16)(result    +  TPMI_ALG_HASH_Marshal(

8                                       (TPMI_ALG_HASH     *)&(source->nameAlg),     buffer,  size))

9   ;

10     result  =  (UINT16)(result    +  TPMA_OBJECT_Marshal(

11                                   (TPMA_OBJECT  *)&(source->objectAttributes),    buffer,  size));

12

13     result  =  (UINT16)(result    +  TPM2B_DIGEST_Marshal(

14                                      (TPM2B_DIGEST      *)&(source->authPolicy),  buffer,  size));

15

16     result  =  (UINT16)(result    +  TPMU_PUBLIC_PARMS_Marshal(

17                                   (TPMU_PUBLIC_PARMS    *)&(source->parameters),  buffer,  size,

18                                                                                            ));

19

20     result  =  (UINT16)(result    +  TPMU_PUBLIC_ID_Marshal(

21                                      (TPMU_PUBLIC_ID       *)&(source->unique),   buffer,  size,

22                                                                                            ));

23

24     return  result;

25  }

    Page 248                            TCG Published                                Family "2.0"

    October 30, 2014                    Copyright © TCG 2006-2014            Level 00 Revision 01.16
    Part 4: Supporting Routines                                                        Trusted Platform Module Library

    9.11.5      Unmarshal and Marshal an Array

    In TPM 2.0 Part 2, the TPML_DIGEST is defined by:

                                     Table xxx -- Definition of TPML_DIGEST Structure

    Parameter                                   Type                Description

    count {2:}                                  UINT32              number of digests in the list, minimum is two

    digests[count]{:8}                          TPM2B_DIGEST        a list of digests

                                                                    For  TPM2_PolicyOR(),     all   digests      will  have  been

                                                                    computed using the digest of the policy session. For

                                                                    TPM2_PCR_Read(), each digest will be the size of the

                                                                    digest for the bank containing the PCR.

    #TPM_RC_SIZE                                                    response code      when  count  is  not  at  least  two  or   is

                                                                    greater than 8

    The digests parameter is an array of up to count structures (TPM2B_DIGESTS). The auto-generated code

    to Unmarshal this structure is:

1   TPM_RC

2   TPML_DIGEST_Unmarshal(TPML_DIGEST                  *target,  BYTE    **buffer,     INT32      *size)

3   {

4      TPM_RC             result;

5      result      =    UINT32_Unmarshal((UINT32           *)&(target->count),         buffer,    size);

6      if(result          !=  TPM_RC_SUCCESS)

7               return    result;

8

9      if(      (target->count       <   2))       //  This  check  is   triggered     by    the  {2:}    notation

10                                                 //  on  `count'

11              return    TPM_RC_SIZE;

12

13     if((target->count)            >   8)        //  This  check  is   triggered     by    the  {:8}    notation

14                                                 //  on  `digests'.

15              return    TPM_RC_SIZE;

16

17     result      =    TPM2B_DIGEST_Array_Unmarshal((TPM2B_DIGEST                  *)(target->digests),

18                                                           buffer,     size,                                         );

19     if(result          !=  TPM_RC_SUCCESS)

20              return    result;

21

22     return      TPM_RC_SUCCESS;

23  }

    The routine unmarshals a count value and passes that value to a routine that unmarshals an                             array  of

    TPM2B_DIGEST values. The unmarshaling code for the array is:

1   TPM_RC

2   TPM2B_DIGEST_Array_Unmarshal(TPM2B_DIGEST                    *target,  BYTE        **buffer,    INT32    *size,

3                                               INT32  count)

4   {

5      TPM_RC             result;

6      INT32    i;

7      for(i    =     0;  i   <  count;   i++)  {

8               result    =   TPM2B_DIGEST_Unmarshal(&target[i],           buffer,     size);

9               if(result        !=  TPM_RC_SUCCESS)

10                    return     result;

11     }

12     return      TPM_RC_SUCCESS;

13  }

14

    Family "2.0"                                       TCG Published                                                   Page 249

    Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                 October 30, 2014
    Trusted Platform Module Library                                                              Part 4: Supporting Routines

    Marshaling  of    the     TPML_DIGEST         uses   a  similar  scheme  with  a  structure  specifying  the  number  of

    elements in an array and a subsequent call to a routine to marshal an array of that type.

1   UINT16

2   TPML_DIGEST_Marshal(TPML_DIGEST                  *source,        BYTE  **buffer,  INT32  *size)

3   {

4      UINT16             result     =  0;

5      result      =  (UINT16)(result       +     UINT32_Marshal((UINT32           *)&(source->count),       buffer,

6                                                                                                                 size));

7      result      =  (UINT16)(result       +     TPM2B_DIGEST_Array_Marshal(

8                                                           (TPM2B_DIGEST    *)(source->digests),    buffer,      size,

9                                                           (INT32)(source->count)));

10

11     return      result;

12  }

    The marshaling code for the array is:

1   TPM_RC

2   TPM2B_DIGEST_Array_Unmarshal(TPM2B_DIGEST                        *target,  BYTE   **buffer,  INT32       *size,

3                                                 INT32     count)

4   {

5      TPM_RC             result;

6      INT32    i;

7      for(i    =     0;   i  <  count;     i++)  {

8           result         =  TPM2B_DIGEST_Unmarshal(&target[i],               buffer,  size);

9           if(result            !=  TPM_RC_SUCCESS)

10                    return     result;

11     }

12     return      TPM_RC_SUCCESS;

13  }

    Page 250                                                TCG Published                                    Family "2.0"

    October 30, 2014                              Copyright © TCG 2006-2014                      Level 00 Revision 01.16
    Part 4: Supporting Routines                                                          Trusted Platform Module Library

    9.11.6      TPM2B Handling

    A TPM2B structure is handled as a special case. The unmarshaling code is similar to what is shown in

    10.11.5 but the unmarshaling/marshaling is to a union element.                  Each TPM2B is a union of two sized

    buffers, one of which is type specific (the `t' element) and the other is a generic value (the `b' element).

    This allows each of the TPM2B structures to have some inheritance property with all other TPM2B. The

    purpose is to allow functions that have parameters that can be any TPM2B structure while allowing other

    functions to be specific about the type of the TPM2B that is used. When the generic structure is allowed,

    the input parameter would use the `b' element and when the type-specific structure is required, the `t'

    element is used.

                                  Table xxx -- Definition of TPM2B_EVENT Structure

    Parameter                                       Type                        Description

    size                                            UINT16                      Size of the operand

    buffer [size] {:1024}                           BYTE                        The operand

1   TPM_RC

2   TPM2B_EVENT_Unmarshal(TPM2B_EVENT                     *target,   BYTE   **buffer,   INT32        *size)

3   {

4         TPM_RC        result;

5         result  =    UINT16_Unmarshal((UINT16               *)&(target->t.size),      buffer,      size);

6         if(result     !=    TPM_RC_SUCCESS)

7               return     result;

8

9         //  if  size     equal  to    0,     the  rest  of  the   structure   is  a   zero  buffer.        Stop

    processing

10        if(target->t.size         ==     0)

11              return     TPM_RC_SUCCESS;

12

13        if((target->t.size)           >   1024)         //  This  check   is  triggered     by  the  {:1024}     notation

14                                                        //  on  `buffer'

15              return     TPM_RC_SIZE;

16

17        result  =    BYTE_Array_Unmarshal((BYTE                 *)(target->t.buffer),       buffer,  size,

18                                                  (INT32)(target->t.size));

19        if(result     !=    TPM_RC_SUCCESS)

20              return     result;

21

22        return  TPM_RC_SUCCESS;

23  }

    Which use these structure definitions:

1   typedef     struct     {

2         UINT16              size;

3         BYTE                buffer[1];

4   }  TPM2B;

5

6   typedef     struct     {

7         UINT16              size;

8         BYTE                buffer[1024];

9   }  EVENT_2B;

10

11  typedef     union   {

12        EVENT_2B            t;        //     The  type-specific    union      member

13        TPM2B               b;        //     The  generic   union  member

14  }  TPM2B_EVENT;

    Family "2.0"                                          TCG Published                                            Page 251

    Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                October 30, 2014
    Trusted Platform Module Library                                                                   Part 4: Supporting Routines

    9.12      MemoryLib.c

    9.12.1      Description

    This file contains a set of miscellaneous memory manipulation routines. Many of the functions have the

    same semantics as functions defined in string.h. Those functions are not used in the TPM in order to

    avoid namespace contamination.

    9.12.2      Includes and Data Definitions

1   #define     MEMORY_LIB_C

2   #include       "InternalRoutines.h"

    These buffers are set aside to hold command and response values. In this implementation, it is not

    guaranteed that the code will stop accessing the s_actionInputBuffer before starting to put values in the

    s_actionOutputBuffer             so  different   buffers      are   required.      However,       the  s_actionInputBuffer               and

    s_responseBuffer are not needed at the same time and they could be the same buffer.

    9.12.3      Functions on BYTE Arrays

    9.12.3.1       MemoryMove()

    This   function    moves      data   from   one  place    in  memory      to  another.   No   safety   checks             of  any  type  are

    performed. If source and data buffer overlap, then the move is done as if an intermediate buffer were

    used.

    NOTE:                 This function is used by MemoryCopy(), MemoryCopy2B(), and MemoryConcat2b() and requires                that  the  caller

                          know the maximum size of the destination buffer so that there is no possibility of buffer overrun.

3   LIB_EXPORT         void

4   MemoryMove(

5         void                       *destination,           //   OUT:   move     destination

6         const    void              *source,                //   IN:   move   source

7         UINT32                         size,               //   IN:   number     of  octets     to  moved

8         UINT32                         dSize               //   IN:   size   of   the    receive    buffer

9         )

10  {

11        const    BYTE    *p     =  (BYTE      *)source;

12        BYTE     *q  =   (BYTE     *)destination;

13

14        if(destination             ==  NULL   ||   source   ==  NULL)

15              return;

16

17        pAssert(size         <=    dSize);

18        //  if   the     destination          buffer  has   a   lower   address      than      the

19        //  source,      then      moving     bytes   in   ascending       order     is  safe.

20        dSize    -=     size;

21

22        if  (p>q     ||  (p+size       <=     q))

23        {

24              while(size--)

25                     *q++    =     *p++;

26        }

27        //  If   the     destination          buffer  has   a   higher     address       than  the

28        //  source,      then      move    bytes   from    the  end    to   the   beginning.

29        else     if  (p  <   q)

30        {

31              p  +=     size;

32              q  +=     size;

    Page 252                                                 TCG Published                                                        Family "2.0"

    October 30, 2014                                 Copyright © TCG 2006-2014                             Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                Trusted Platform Module Library

33               while   (size--)

34                  *--q       =   *--p;

35        }

36

37        //  If   the   source      and    destination     address      are     the   same,  nothing     to  move.

38        return;

39  }

    9.12.3.2       MemoryCopy()

    This  function  moves         data  from    one  place  in  memory       to  another.  No  safety  checks  of any type are

    performed. If the destination and source overlap, then the results are unpredictable. void                 MemoryCopy(

    void                                      *destination, // OUT: copy destination

    void                                      *source, // IN: copy source

    UINT32                                    size, // IN: number of octets being copied

    UINT32                                    dSize // IN: size of the receive buffer

    MemoryMove(destination, source, size, dSize);

40  //%#define      MemoryCopy(destination,               source,      size,     destSize)             \

41  //%       MemoryMove((destination),               (source),        (size),    (destSize))

    9.12.3.3       MemoryEqual()

    This function indicates if two buffers have the same values in the indicated number of bytes.

    Return Value                              Meaning

    TRUE                                      all octets are the same

    FALSE                                     all octets are not the same

42  LIB_EXPORT      BOOL

43  MemoryEqual(

44        const    void              *buffer1,              //  IN:    compare    buffer1

45        const    void              *buffer2,              //  IN:    compare    buffer2

46        UINT32                     size                   //  IN:    size   of  bytes    being  compared

47        )

48  {

49        BOOL                 equal    =   TRUE;

50        const    BYTE        *b1,  *b2;

51

52        b1  =   (BYTE     *)buffer1;

53        b2  =   (BYTE     *)buffer2;

54

55        //  Compare       all    bytes    so  that  there     is   no  leakage       of  information

56        //  due   to   timing      differences.

57        for(;    size     >  0;    size--)

58               equal   =     (*b1++   ==  *b2++)    &&    equal;

59

60        return    equal;

61  }

    9.12.3.4       MemoryCopy2B()

    This function copies a TPM2B. This can be used when the TPM2B types are the same or different. No

    size checking is done on the destination so the caller should make sure that the destination is large

    enough.

    Family "2.0"                                            TCG Published                                            Page 253

    Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                  October 30, 2014
     Trusted Platform Module Library                                                           Part 4: Supporting Routines

     This function returns the number of octets in the data buffer of the TPM2B.

62   LIB_EXPORT    INT16

63   MemoryCopy2B(

64      TPM2B                     *dest,              //  OUT:  receiving         TPM2B

65      const   TPM2B             *source,            //  IN:   source    TPM2B

66      UINT16                    dSize               //  IN:   size  of    the     receiving    buffer

67      )

68   {

69

70      if(dest    ==  NULL)

71             return  0;

72      if(source      ==  NULL)

73             dest->size      =  0;

74      else

75      {

76             dest->size      =  source->size;

77             MemoryMove(dest->buffer,          source->buffer,        dest->size,          dSize);

78      }

79      return     dest->size;

80   }

     9.12.3.5   MemoryConcat2B()

     This function will concatenate the buffer contents of a TPM2B to an the buffer contents of             another  TPM2B

     and adjust the size accordingly (a := (a | b)).

81   LIB_EXPORT    void

82   MemoryConcat2B(

83      TPM2B                     *aInOut,            //  IN/OUT:     destination        2B

84      TPM2B                     *bIn,               //  IN:   second    2B

85      UINT16                    aSize               //  IN:   The   size    of    aInOut.buffer     (max  values   for

86                                                    //        aInOut.size)

87      )

88   {

89      MemoryMove(&aInOut->buffer[aInOut->size],

90                     bIn->buffer,

91                     bIn->size,

92                     aSize      -   aInOut->size);

93      aInOut->size       =   aInOut->size   +    bIn->size;

94      return;

95   }

     9.12.3.6   Memory2BEqual()

     This function will compare two TPM2B structures. To be equal, they             need     to  be the same size and the

     buffer contexts need to be the same in all octets.

     Return Value                         Meaning

     TRUE                                 size and buffer contents are the same

     FALSE                                size or buffer contents are not the same

96   LIB_EXPORT    BOOL

97   Memory2BEqual(

98      const   TPM2B             *aIn,               //  IN:   compare     value

99      const   TPM2B             *bIn                //  IN:   compare     value

100     )

101  {

102     if(aIn->size       !=     bIn->size)

103            return  FALSE;

     Page 254                                         TCG Published                                         Family "2.0"

     October 30, 2014                         Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                             Trusted Platform Module Library

104

105        return        MemoryEqual(aIn->buffer,                   bIn->buffer,      aIn->size);

106  }

     9.12.3.7        MemorySet()

     This function will set all the octets in the specified memory range to the specified octet value.

     NOTE:                   the dSize parameter forces the caller to know how big the receiving buffer is to             make   sure  that  there  is  no

                             possibility that the caller will inadvertently run over the end of the buffer.

107  LIB_EXPORT          void

108  MemorySet(

109        void                           *destination,             //  OUT:   memory   destination

110        char                             value,                  //  IN:   fill  value

111        UINT32                           size                    //  IN:   number    of  octets           to     fill

112        )

113  {

114        char      *p  =      (char     *)destination;

115        while     (size--)

116              *p++        =  value;

117        return;

118  }

     9.12.3.8        MemoryGetActionInputBuffer()

     This function returns the address of the buffer into which the command parameters will be unmarshaled                                              in

     preparation for calling the command actions.

119  BYTE     *

120  MemoryGetActionInputBuffer(

121        UINT32                           size                    //  Size,  in   bytes,  required                for   the    input

122                                                                 //  unmarshaling

123        )

124  {

125        BYTE                     *buf    =  NULL;

126

127        if(size       >      0)

128        {

129              //      In     this    implementation,          a  static     buffer   is  set              aside  for   action     output.

130              //      Other      implementations          may    apply     additional    optimization                  based  on    command

131              //      code       or  other     factors.

132              UINT32                   *p   =  s_actionInputBuffer;

133              buf     =      (BYTE     *)p;

134              pAssert(size               <  sizeof(s_actionInputBuffer));

135

136              //      size       of  an     element   in  the    buffer

137  #define     SZ                 sizeof(s_actionInputBuffer[0])

138

139              for(size           =   (size     +  SZ  -   1)  /  SZ;  size  >    0;  size--)

140                      *p++       =   0;

141  #undef      SZ

142        }

143        return        buf;

144  }

     9.12.3.9        MemoryGetActionOutputBuffer()

     This function returns the address of the buffer into which the command action code places its output

     values.

     Family "2.0"                                                   TCG Published                                                       Page 255

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                             October 30, 2014
     Trusted Platform Module Library                                                              Part 4: Supporting Routines

145  void     *

146  MemoryGetActionOutputBuffer(

147        TPM_CC                      command            //      Command  that   requires   the  buffer

148        )

149  {

150        //    In  this   implementation,            a  static  buffer   is  set  aside   for   action    output.

151        //    Other     implementations           may  apply   additional   optimization      based  on  the  command

152        //    code   or  other      factors.

153        command      =   0;            //      Unreferenced    parameter

154        return      s_actionOutputBuffer;

155  }

     9.12.3.10       MemoryGetResponseBuffer()

     This function returns the address into which the command response is marshaled from values in                        the

     action output buffer.

156  BYTE     *

157  MemoryGetResponseBuffer(

158        TPM_CC                      command            //      Command  that   requires   the  buffer

159        )

160  {

161        //    In  this   implementation,            a  static  buffer   is  set  aside   for   responses.

162        //    Other     implementation         may     apply  additional    optimization     based   on  the  command

163        //    code   or  other      factors.

164        command      =   0;            //      Unreferenced    parameter

165        return      s_responseBuffer;

166  }

     9.12.3.11       MemoryRemoveTrailingZeros()

     This function is used to adjust the length of an authorization value. It adjusts the size of the TPM2B so

     that it does not include octets at the end of the buffer that contain zero. The function returns the number

     of non-zero octets in the buffer.

167  UINT16

168  MemoryRemoveTrailingZeros                    (

169        TPM2B_AUTH                  *auth              //      IN/OUT:  value    to  adjust

170        )

171  {

172        BYTE                 *a  =  &auth->t.buffer[auth->t.size-1];

173        for(;     auth->t.size      >      0;  auth->t.size--)

174        {

175              if(*a--)

176                     break;

177        }

178        return      auth->t.size;

179  }

     9.13      Power.c

     9.13.1      Description

     This file contains functions that receive the simulated power state transitions of the TPM.

     9.13.2      Includes and Data Definitions

1    #define     POWER_C

2    #include        "InternalRoutines.h"

     Page 256                                             TCG Published                                          Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                          Trusted Platform Module Library

    9.13.3      Functions

    9.13.3.1        TPMInit()

    This function is used to process a power on event.

3   void

4   TPMInit(

5         void

6         )

7   {

8         //  Set   state  as  not  initialized.       This  means      that  Startup    is  required

9         s_initialized    =   FALSE;

10

11        return;

12  }

    9.13.3.2        TPMRegisterStartup()

    This  function  registers  the  fact  that  the  TPM   has  been    initialized  (a  TPM2_Startup()  has  completed

    successfully).

13  void

14  TPMRegisterStartup(

15        void

16        )

17  {

18        s_initialized    =   TRUE;

19

20        return;

21  }

    9.13.3.3        TPMIsStarted()

    Indicates   if  the  TPM   has  been  initialized  (a    TPM2_Startup()   has        completed  successfully  after   a

    _TPM_Init()).

    Return Value                          Meaning

    TRUE                                  TPM has been initialized

    FALSE                                 TPM has not been initialized

22  BOOL

23  TPMIsStarted(

24        void

25        )

26  {

27        return    s_initialized;

28  }

    9.14      PropertyCap.c

    9.14.1      Description

    This file contains the functions that are used for accessing the TPM_CAP_TPM_PROPERTY values.

    Family "2.0"                                     TCG Published                                            Page 257

    Level 00 Revision 01.16               Copyright © TCG 2006-2014                                 October 30, 2014
    Trusted Platform Module Library                                                             Part 4: Supporting Routines

    9.14.2    Includes

1   #include  "InternalRoutines.h"

    9.14.3    Functions

    9.14.3.1   PCRGetProperty()

    This function accepts a property selection and, if so, sets value to the value of the property.

    All the fixed values are vendor dependent or determined by a platform-specific specification.    The  values

    in the table below are examples and should be changed by the vendor.

    Return Value                         Meaning

    TRUE                                 referenced property exists and value set

    FALSE                                referenced property does not exist

2   static    BOOL

3   TPMPropertyIsDefined(

4      TPM_PT                    property,            //      IN:   property

5      UINT32                    *value               //      OUT:  property       value

6      )

7   {

8      switch(property)

9      {

10            case  TPM_PT_FAMILY_INDICATOR:

11                  //  from     the  title  page     of  the      specification

12                  //  For   this    specification,          the   value  is  "2.0".

13                  *value    =  TPM_SPEC_FAMILY;

14                  break;

15            case  TPM_PT_LEVEL:

16                  //  from     the  title  page     of  the      specification

17                  *value    =  TPM_SPEC_LEVEL;

18                  break;

19            case  TPM_PT_REVISION:

20                  //  from     the  title  page     of  the      specification

21                  *value    =  TPM_SPEC_VERSION;

22                  break;

23            case  TPM_PT_DAY_OF_YEAR:

24                  //  computed      from   the  date    value     on  the    title  page  of  the  specification

25                  *value    =  TPM_SPEC_DAY_OF_YEAR;

26                  break;

27            case  TPM_PT_YEAR:

28                  //  from     the  title  page     of  the      specification

29                  *value    =  TPM_SPEC_YEAR;

30                  break;

31            case  TPM_PT_MANUFACTURER:

32                  //  vendor   ID    unique     to  each    TPM   manufacturer

33                  *value    =  BYTE_ARRAY_TO_UINT32(MANUFACTURER);

34                  break;

35            case  TPM_PT_VENDOR_STRING_1:

36                  //  first    four    characters       of  the   vendor     ID  string

37                  *value    =  BYTE_ARRAY_TO_UINT32(VENDOR_STRING_1);

38                  break;

39            case  TPM_PT_VENDOR_STRING_2:

40                  //  second   four    characters       of   the  vendor     ID  string

41  #ifdef    VENDOR_STRING_2

42                  *value    =  BYTE_ARRAY_TO_UINT32(VENDOR_STRING_2);

43  #else

44                  *value    =  0;

45  #endif

    Page 258                                          TCG Published                                  Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

46                 break;

47           case  TPM_PT_VENDOR_STRING_3:

48                 //  third     four     characters   of      the       vendor   ID   string

49   #ifdef  VENDOR_STRING_3

50                 *value    =   BYTE_ARRAY_TO_UINT32(VENDOR_STRING_3);

51   #else

52                 *value    =   0;

53   #endif

54                 break;

55           case  TPM_PT_VENDOR_STRING_4:

56                 //  fourth     four     characters      of    the     vendor    ID   string

57   #ifdef  VENDOR_STRING_4

58                 *value    =   BYTE_ARRAY_TO_UINT32(VENDOR_STRING_4);

59   #else

60                 *value    =   0;

61   #endif

62                 break;

63           case  TPM_PT_VENDOR_TPM_TYPE:

64                 //  vendor-defined           value  indicating            the  TPM   model

65                 *value    =   1;

66                 break;

67           case  TPM_PT_FIRMWARE_VERSION_1:

68                 //  more     significant         32-bits    of     a  vendor-specific         value

69                 *value    =   gp.firmwareV1;

70                 break;

71           case  TPM_PT_FIRMWARE_VERSION_2:

72                 //  less     significant         32-bits    of     a  vendor-specific         value

73                 *value    =   gp.firmwareV2;

74                 break;

75           case  TPM_PT_INPUT_BUFFER:

76                 //  maximum       size   of  TPM2B_MAX_BUFFER

77                 *value    =   MAX_DIGEST_BUFFER;

78                 break;

79           case  TPM_PT_HR_TRANSIENT_MIN:

80                 //  minimum       number     of  transient         objects     that     can   be  held    in     TPM

81                 //  RAM

82                 *value    =   MAX_LOADED_OBJECTS;

83                 break;

84           case  TPM_PT_HR_PERSISTENT_MIN:

85                 //  minimum       number     of  persistent           objects   that    can   be   held      in

86                 //  TPM   NV   memory

87                 //  In   this     implementation,         there       is  no   minimum       number   of

88                 //  persistent         objects.

89                 *value    =   MIN_EVICT_OBJECTS;

90                 break;

91           case  TPM_PT_HR_LOADED_MIN:

92                 //  minimum       number     of  authorization            sessions      that  can    be   held   in

93                 //  TPM   RAM

94                 *value    =   MAX_LOADED_SESSIONS;

95                 break;

96           case  TPM_PT_ACTIVE_SESSIONS_MAX:

97                 //  number     of   authorization         sessions        that     may  be    active     at   a  time

98                 *value    =   MAX_ACTIVE_SESSIONS;

99                 break;

100          case  TPM_PT_PCR_COUNT:

101                //  number     of   PCR   implemented

102                *value    =   IMPLEMENTATION_PCR;

103                break;

104          case  TPM_PT_PCR_SELECT_MIN:

105                //  minimum       number     of  bytes    in    a     TPMS_PCR_SELECT.sizeOfSelect

106                *value    =   PCR_SELECT_MIN;

107                break;

108          case  TPM_PT_CONTEXT_GAP_MAX:

109                //  maximum       allowed    difference         (unsigned)         between    the    contextID

110                //  values     of   two   saved     session        contexts

111                *value    =   (1   <<   (sizeof(CONTEXT_SLOT)             *    8))   -  1;

     Family "2.0"                                      TCG Published                                                      Page 259

     Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                      Part 4: Supporting Routines

112                    break;
             
113          case      TPM_PT_NV_COUNTERS_MAX:
             
114                    //      maximum       number     of     NV  indexes       that    are     allowed    to      have  the
             
115                    //      TPMA_NV_COUNTER          attribute          SET
             
116                    //      In   this     implementation,            there      is   no   limitation       on    the   number
             
117                    //      of   counters,       except         for  the   size      of   the     NV   Index     memory.
             
118                    *value        =   0;
             
119                    break;
             
120          case      TPM_PT_NV_INDEX_MAX:
             
121                    //      maximum       size   of  an     NV   index     data      area
             
122                    *value        =   MAX_NV_INDEX_SIZE;
             
123                    break;
             
124          case      TPM_PT_MEMORY:
             
125                    //      a   TPMA_MEMORY       indicating         the      memory      management       method      for  the  TPM
             
126          {
             
127                    TPMA_MEMORY                          attributes        =    {0};
             
128                    attributes.sharedNV                  =  SET;
             
129                    attributes.objectCopiedToRam                        =  SET;
             
130          
             
131                    //      Note:     Different      compilers          may     require       a   different      method     to   cast
             
132                    //      a   bit   field     structure        to  a     UINT32.
             
133                    *value        =   *   (UINT32    *)     &attributes;
             
134                    break;
             
135          }
             
136          case      TPM_PT_CLOCK_UPDATE:
             
137                    //      interval,     in     seconds,        between        updates       to  the   copy     of
             
138                    //      TPMS_TIME_INFO           .clock      in  NV
             
139                    *value        =   (1  <<    NV_CLOCK_UPDATE_INTERVAL);
             
140                    break;
             
141          case      TPM_PT_CONTEXT_HASH:
             
142                    //      algorithm     used       for    the      integrity       hash     on  saved    contexts         and
             
143                    //      for   digesting       the       fuData   of    TPM2_FirmwareRead()
             
144                    *value        =   CONTEXT_INTEGRITY_HASH_ALG;
             
145                    break;
             
146          case      TPM_PT_CONTEXT_SYM:
             
147                    //      algorithm     used       for    encryption          of   saved       contexts
             
148                    *value        =   CONTEXT_ENCRYPT_ALG;
             
149                    break;
             
150          case      TPM_PT_CONTEXT_SYM_SIZE:
             
151                    //      size     of   the   key  used       for  encryption           of     saved  contexts
             
152                    *value        =   CONTEXT_ENCRYPT_KEY_BITS;
             
153                    break;
             
154          case      TPM_PT_ORDERLY_COUNT:
             
155                    //      maximum       difference        between        the  volatile          and   non-volatile
             
156                    //      versions      of    TPMA_NV_COUNTER            that      have     TPMA_NV_ORDERLY          SET
             
157                    *value        =   MAX_ORDERLY_COUNT;
             
158                    break;
             
159          case      TPM_PT_MAX_COMMAND_SIZE:
             
160                    //      maximum       value   for       'commandSize'
             
161                    *value        =   MAX_COMMAND_SIZE;
             
162                    break;
             
163          case      TPM_PT_MAX_RESPONSE_SIZE:
             
164                    //      maximum       value   for       'responseSize'
             
165                    *value        =   MAX_RESPONSE_SIZE;
             
166                    break;
             
167          case      TPM_PT_MAX_DIGEST:
             
168                    //      maximum       size   of  a      digest   that       can   be   produced      by      the   TPM
             
169                    *value        =   sizeof(TPMU_HA);
             
170                    break;
             
171          case      TPM_PT_MAX_OBJECT_CONTEXT:
             
172                    //      maximum       size   of  a      TPMS_CONTEXT        that      will    be    returned       by
             
173                    //      TPM2_ContextSave             for    object     context
             
174                    *value        =   0;
             
175          
             
176                    //      adding       sequence,       saved       handle     and   hierarchy
             
177                    *value        +=     sizeof(UINT64)          +   sizeof(TPMI_DH_CONTEXT)                  +

     Page 260                                              TCG Published                                                    Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                  Trusted Platform Module Library

178                                       sizeof(TPMI_RH_HIERARCHY);
             
179                        //  add  size      field    in  TPM2B_CONTEXT
             
180                        *value   +=    sizeof(UINT16);
             
181          
             
182                        //  add  integrity        hash      size
             
183                        *value   +=    sizeof(UINT16)           +
             
184                                       CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
             
185          
             
186                        //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
             
187                        *value   +=    sizeof(UINT64);
             
188          
             
189                        //  Add  OBJECT    structure            size
             
190                        *value   +=    sizeof(OBJECT);
             
191                        break;
             
192          case          TPM_PT_MAX_SESSION_CONTEXT:
             
193                        //  the  maximum        size    of   a  TPMS_CONTEXT         that        will  be   returned      by
             
194                        //  TPM2_ContextSave            for     object     context
             
195                        *value   =   0;
             
196          
             
197                        //  adding     sequence,        saved      handle      and  hierarchy
             
198                        *value   +=    sizeof(UINT64)           +  sizeof(TPMI_DH_CONTEXT)                  +
             
199                                       sizeof(TPMI_RH_HIERARCHY);
             
200                        //  Add  size      field    in  TPM2B_CONTEXT
             
201                        *value   +=    sizeof(UINT16);
             
202          
             
203                        //  Add  integrity        hash      size
             
204                        *value   +=    sizeof(UINT16)           +
             
205                                       CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
             
206                        //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
             
207                        *value   +=    sizeof(UINT64);
             
208          
             
209                        //  Add  SESSION        structure       size
             
210                        *value   +=    sizeof(SESSION);
             
211                        break;
             
212          case          TPM_PT_PS_FAMILY_INDICATOR:
             
213                        //  platform       specific     values        for  the      TPM_PT_PS         parameters     from
             
214                        //  the  relevant       platform-specific              specification
             
215                        //  In   this    reference      implementation,             all      of  these      values   are   0.
             
216                        *value   =   0;
             
217                        break;
             
218          case          TPM_PT_PS_LEVEL:
             
219                        //  level    of    the  platform-specific              specification
             
220                        *value   =   0;
             
221                        break;
             
222          case          TPM_PT_PS_REVISION:
             
223                        //  specification         Revision         times   100      for  the     platform-specific
             
224                        //  specification
             
225                        *value   =   0;
             
226                        break;
             
227          case          TPM_PT_PS_DAY_OF_YEAR:
             
228                        //  platform-specific           specification           day      of  year      using    TCG  calendar
             
229                        *value   =   0;
             
230                        break;
             
231          case          TPM_PT_PS_YEAR:
             
232                        //  platform-specific           specification           year     using        the   CE
             
233                        *value   =   0;
             
234                        break;
             
235          case          TPM_PT_SPLIT_MAX:
             
236                        //  number     of  split      signing      operations        supported         by   the  TPM
             
237                        *value   =   0;
             
238  #ifdef        TPM_ALG_ECC
             
239                        *value   =   sizeof(gr.commitArray)                *   8;
             
240  #endif
             
241                        break;
             
242          case          TPM_PT_TOTAL_COMMANDS:
             
243                        //  total    number     of    commands        implemented        in      the   TPM

     Family "2.0"                                          TCG Published                                                  Page 261

     Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

244                    //      Since      the    reference           implementation                does   not   have   any
             
245                    //      vendor-defined          commands,                this         will  be  the   same  as     the
             
246                    //      number        of  library       commands.
             
247          {
             
248                    UINT32         i;
             
249                    *value         =   0;
             
250          
             
251                    //      calculate         implemented             command             numbers
             
252                    for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
             
253                    {
             
254                               if(CommandIsImplemented(i))                            (*value)++;
             
255                    }
             
256                    break;
             
257          }
             
258          case         TPM_PT_LIBRARY_COMMANDS:
             
259                    //      number        of  commands         from       the         TPM   library    that  are    implemented
             
260          {
             
261                    UINT32         i;
             
262                    *value         =   0;
             
263          
             
264                    //      calculate         implemented             command             numbers
             
265                    for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
             
266                    {
             
267                               if(CommandIsImplemented(i))                            (*value)++;
             
268                    }
             
269                    break;
             
270          }
             
271          case         TPM_PT_VENDOR_COMMANDS:
             
272                    //      number        of  vendor     commands               that       are  implemented
             
273                    *value         =   0;
             
274                    break;
             
275          case         TPM_PT_PERMANENT:
             
276                    //      TPMA_PERMANENT
             
277          {
             
278                    TPMA_PERMANENT                                   flags         =  {0};
             
279                    if(gp.ownerAuth.t.size                        !=     0)
             
280                               flags.ownerAuthSet                 =   SET;
             
281                    if(gp.endorsementAuth.t.size                                !=    0)
             
282                               flags.endorsementAuthSet                         =     SET;
             
283                    if(gp.lockoutAuth.t.size                          !=     0)
             
284                               flags.lockoutAuthSet                   =   SET;
             
285                    if(gp.disableClear)
             
286                               flags.disableClear                 =   SET;
             
287                    if(gp.failedTries               >=      gp.maxTries)
             
288                               flags.inLockout           =     SET;
             
289                    //      In  this       implementation,                EPS         is   always   generated      by  TPM
             
290                    flags.tpmGeneratedEPS                      =     SET;
             
291          
             
292                    //      Note:      Different      compilers                 may       require   a  different       method  to  cast
             
293                    //      a   bit    field  structure               to     a     UINT32.
             
294                    *value         =   *   (UINT32    *)       &flags;
             
295                    break;
             
296          }
             
297          case         TPM_PT_STARTUP_CLEAR:
             
298                    //      TPMA_STARTUP_CLEAR
             
299          {
             
300                    TPMA_STARTUP_CLEAR                               flags         =  {0};
             
301                    if(g_phEnable)
             
302                               flags.phEnable         =     SET;
             
303                    if(gc.shEnable)
             
304                               flags.shEnable         =     SET;
             
305                    if(gc.ehEnable)
             
306                               flags.ehEnable         =     SET;
             
307                    if(gc.phEnableNV)
             
308                               flags.phEnableNV             =     SET;
             
309                    if(g_prevOrderlyState                      !=     SHUTDOWN_NONE)

     Page 262                                                   TCG Published                                                 Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                    Trusted Platform Module Library

310                               flags.orderly          =  SET;
             
311          
             
312                        //  Note:    Different           compilers           may  require     a  different       method  to    cast
             
313                        //  a   bit  field       structure       to       a  UINT32.
             
314                        *value    =  *   (UINT32         *)   &flags;
             
315                        break;
             
316          }
             
317          case          TPM_PT_HR_NV_INDEX:
             
318                        //  number       of  NV      indexes     currently        defined
             
319                        *value    =  NvCapGetIndexNumber();
             
320                        break;
             
321          case          TPM_PT_HR_LOADED:
             
322                        //  number       of  authorization            sessions          currently        loaded  into   TPM
             
323                        //  RAM
             
324                        *value    =  SessionCapGetLoadedNumber();
             
325                        break;
             
326          case          TPM_PT_HR_LOADED_AVAIL:
             
327                        //  number       of  additional          authorization          sessions,        of  any  type,
             
328                        //  that     could       be   loaded     into        TPM  RAM
             
329                        *value    =  SessionCapGetLoadedAvail();
             
330                        break;
             
331          case          TPM_PT_HR_ACTIVE:
             
332                        //  number       of  active      authorization            sessions       currently       being
             
333                        //  tracked      by      the  TPM
             
334                        *value    =  SessionCapGetActiveNumber();
             
335                        break;
             
336          case          TPM_PT_HR_ACTIVE_AVAIL:
             
337                        //  number       of  additional          authorization          sessions,        of  any  type,
             
338                        //  that     could       be   created
             
339                        *value    =  SessionCapGetActiveAvail();
             
340                        break;
             
341          case          TPM_PT_HR_TRANSIENT_AVAIL:
             
342                        //  estimate         of  the     number       of     additional    transient         objects    that
             
343                        //  could    be      loaded      into    TPM      RAM
             
344                        *value    =  ObjectCapGetTransientAvail();
             
345                        break;
             
346          case          TPM_PT_HR_PERSISTENT:
             
347                        //  number       of  persistent          objects          currently      loaded  into     TPM
             
348                        //  NV   memory
             
349                        *value    =  NvCapGetPersistentNumber();
             
350                        break;
             
351          case          TPM_PT_HR_PERSISTENT_AVAIL:
             
352                        //  number       of  additional          persistent       objects        that    could    be   loaded
             
353                        //  into     NV  memory
             
354                        *value    =  NvCapGetPersistentAvail();
             
355                        break;
             
356          case          TPM_PT_NV_COUNTERS:
             
357                        //  number       of  defined         NV  indexes          that  have     NV  TPMA_NV_COUNTER
             
358                        //  attribute        SET
             
359                        *value    =  NvCapGetCounterNumber();
             
360                        break;
             
361          case          TPM_PT_NV_COUNTERS_AVAIL:
             
362                        //  number       of  additional          NV   indexes     that     can       be  defined  with   their
             
363                        //  TPMA_NV_COUNTER              attribute           SET
             
364                        *value    =  NvCapGetCounterAvail();
             
365                        break;
             
366          case          TPM_PT_ALGORITHM_SET:
             
367                        //  region       code    for     the     TPM
             
368                        *value    =  gp.algorithmSet;
             
369                        break;
             
370          
             
371          case          TPM_PT_LOADED_CURVES:
             
372  #ifdef        TPM_ALG_ECC
             
373                        //  number       of  loaded      ECC     curves
             
374                        *value    =  CryptCapGetEccCurveNumber();
             
375  #else   //    TPM_ALG_ECC

     Family "2.0"                                           TCG Published                                                  Page 263

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting  Routines

376                  *value    =   0;

377        #endif    //  TPM_ALG_ECC

378                  break;

379

380            case      TPM_PT_LOCKOUT_COUNTER:

381                  //  current       value        of    the   lockout      counter

382                  *value    =   gp.failedTries;

383                  break;

384            case      TPM_PT_MAX_AUTH_FAIL:

385                  //  number       of     authorization           failures     before     DA   lockout    is    invoked

386                  *value    =   gp.maxTries;

387                  break;

388            case      TPM_PT_LOCKOUT_INTERVAL:

389                  //  number       of     seconds        before      the  value    reported    by

390                  //  TPM_PT_LOCKOUT_COUNTER                    is   decremented

391                  *value    =   gp.recoveryTime;

392                  break;

393            case      TPM_PT_LOCKOUT_RECOVERY:

394                  //  number       of     seconds        after    a  lockoutAuth       failure     before       use  of

395                  //  lockoutAuth             may    be  attempted        again

396                  *value    =   gp.lockoutRecovery;

397                  break;

398            case      TPM_PT_AUDIT_COUNTER_0:

399                  //  high-order             32  bits    of  the     command       audit  counter

400                  *value    =   (UINT32)           (gp.auditCounter            >>  32);

401                  break;

402            case      TPM_PT_AUDIT_COUNTER_1:

403                  //  low-order           32     bits    of  the     command   audit      counter

404                  *value    =   (UINT32)           (gp.auditCounter);

405                  break;

406            default:

407                  //  property         is     not    defined

408                  return    FALSE;

409                  break;

410        }

411

412        return    TRUE;

413  }

     9.14.3.2      TPMCapGetProperties()

     This  function  is  used  to  get    the       TPM_PT      values.      The  search     of  properties  will  start  at  property  and

     continue until propertyList has as many values as will fit, or the last property has been reported, or the list

     has as many values as requested in count.

     Return Value                               Meaning

     YES                                        more properties are available

     NO                                         no more properties to be reported

414  TPMI_YES_NO

415  TPMCapGetProperties(

416        TPM_PT                                           property,             //  IN:    the  starting         TPM  property

417        UINT32                                           count,                //  IN:    maximum  number       of     returned

418                                                                               //         propertie

419        TPML_TAGGED_TPM_PROPERTY                       *propertyList           //  OUT:       property    list

420        )

421  {

422        TPMI_YES_NO            more       =   NO;

423        UINT32                 i;

424

425        //  initialize      output        property       list

426        propertyList->count            =     0;

     Page 264                                                   TCG Published                                                 Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                              Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                           Trusted Platform Module Library

427

428        //  maximum        count      of    properties      we       may     return    is    MAX_PCR_PROPERTIES

429        if(count        >  MAX_TPM_PROPERTIES)              count         =   MAX_TPM_PROPERTIES;

430

431        //  If   property         is     less     than  PT_FIXED,            start     from     PT_FIXED.

432        if(property           <   PT_FIXED)       property        =  PT_FIXED;

433

434        //  Scan     through        the     TPM   properties         of      the  requested        group.

435        //  The      size     of  TPM       property    group        is   PT_GROUP     *     2  for   fix    and

436        //  variable          groups.

437        for(i    =   property;           i  <=    PT_FIXED     +     PT_GROUP       *  2;    i++)

438        {

439              UINT32                        value;

440              if(TPMPropertyIsDefined((TPM_PT)                            i,   &value))

441              {

442                     if(propertyList->count                 <     count)

443                     {

444

445                              //  If     the    list    is  not      full,     add     this     property

446                              propertyList->tpmProperty[propertyList->count].property                                  =

447                                    (TPM_PT)      i;

448                              propertyList->tpmProperty[propertyList->count].value                                  =  value;

449                              propertyList->count++;

450                     }

451                     else

452                     {

453                              //  If     the    return      list     is   full    but  there       are  more      properties

454                              //  available,          set   the      indication        and      exit  the    loop.

455                              more    =     YES;

456                              break;

457                     }

458              }

459        }

460        return       more;

461  }

     9.15      TpmFail.c

     9.15.1      Includes, Defines, and Types

1    #define            TPM_FAIL_C

2    #include           "InternalRoutines.h"

3    #include           <assert.h>

     On MS C compiler, can save the alignment state and set the alignment to 1 for the duration of the

     TPM_Types.h include.              This will avoid a lot of alignment warnings from the compiler for the unaligned

     structures. The alignment of the structures is not important as this function does not use any of the

     structures     in  TPM_Types.h            and   only     include   it   for     the  #defines    of   the  capabilities,  properties,  and

     command code values.

4    #pragma     pack(push,          1)

5    #include       "TPM_Types.h"

6    #pragma     pack      (pop)

7    #include       "swap.h"

     9.15.2      Typedefs

     These defines are used primarily for sizing of the local response buffer.

8    #pragma     pack(push,1)

9    typedef     struct       {

     Family "2.0"                                                 TCG Published                                                   Page 265

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                        October 30, 2014
    Trusted Platform Module Library                                                     Part 4: Supporting Routines

10     TPM_ST                tag;

11     UINT32                size;

12     TPM_RC                code;

13  }  HEADER;

14  typedef   struct      {

15     UINT16                size;

16     struct       {

17            UINT32         function;

18            UINT32         line;

19            UINT32         code;

20     }    values;

21     TPM_RC                returnCode;

22  }  GET_TEST_RESULT_PARAMETERS;

23  typedef   struct      {

24     TPMI_YES_NO                              moreData;

25     TPM_CAP                                  capability;   //     Always  TPM_CAP_TPM_PROPERTIES

26     TPML_TAGGED_TPM_PROPERTY                 tpmProperty;     //  a  single  tagged  property

27  }  GET_CAPABILITY_PARAMETERS;

28  typedef   struct      {

29     HEADER       header;

30     GET_TEST_RESULT_PARAMETERS               getTestResult;

31  }  TEST_RESPONSE;

32  typedef   struct      {

33     HEADER       header;

34     GET_CAPABILITY_PARAMETERS                getCap;

35  }  CAPABILITY_RESPONSE;

36  typedef   union    {

37     TEST_RESPONSE                      test;

38     CAPABILITY_RESPONSE                cap;

39  }  RESPONSES;

40  #pragma   pack(pop)

    Buffer to hold the responses. This may be a little larger than required due to padding that a compiler

    might add.

    NOTE:              This is not in Global.c because of the specialized data definitions above. Since the data contained in this

                       structure is not relevant outside of the execution of a single command (when the TPM is in failure mode. There

                       is no compelling reason to move all the typedefs to Global.h and this structure to Global.c.

41  #ifndef   __IGNORE_STATE__      //    Don't  define    this   value

42  static    BYTE     response[sizeof(RESPONSES)];

43  #endif

    9.15.3    Local Functions

    9.15.3.1    MarshalUint16()

    Function to marshal a 16 bit value to the output buffer.

44  static    INT32

45  MarshalUint16(

46     UINT16                integer,

47     BYTE                  **buffer

48     )

49  {

50     return       UINT16_Marshal(&integer,     buffer,      NULL);

51  }

    9.15.3.2    MarshalUint32()

    Function to marshal a 32 bit value to the output buffer.

    Page 266                                     TCG Published                                                       Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                     Level 00 Revision 01.16
    Part 4: Supporting Routines                                                            Trusted Platform Module Library

52  static     INT32

53  MarshalUint32(

54        UINT32                    integer,

55        BYTE                    **buffer

56        )

57  {

58        return       UINT32_Marshal(&integer,           buffer,   NULL);

59  }

    9.15.3.3        UnmarshalHeader()

    Funtion to unmarshal the 10-byte command header.

60  static     BOOL

61  UnmarshalHeader(

62        HEADER                  *header,

63        BYTE                    **buffer,

64        INT32                   *size

65        )

66  {

67        UINT32       usize;

68        TPM_RC       ucode;

69        if(          UINT16_Unmarshal(&header->tag,              buffer,   size)     !=  TPM_RC_SUCCESS

70              ||     UINT32_Unmarshal(&usize,            buffer,    size)  !=  TPM_RC_SUCCESS

71              ||     UINT32_Unmarshal(&ucode,            buffer,    size)  !=  TPM_RC_SUCCESS

72              )

73              return      FALSE;

74        header->size         =  usize;

75        header->code         =  ucode;

76        return       TRUE;

77  }

    9.15.4      Public Functions

    9.15.4.1        SetForceFailureMode()

    This function is called by the simulator     to  enable  failure  mode   testing.

78  LIB_EXPORT         void

79  SetForceFailureMode(

80        void

81        )

82  {

83        g_forceFailureMode          =   TRUE;

84        return;

85  }

    9.15.4.2        TpmFail()

    This function is called by TPM.lib when a failure occurs. It will set up the failure values         to  be  returned  on

    TPM2_GetTestResult().

86  void

87  TpmFail(

88        const     char                             *function,

89        int   line,                     int        code

90        )

91  {

92        //   Save    the    values  that     indicate    where   the  error    occurred.

93        //   On   a  64-bit     machine,     this  may   truncate     the  address   of  the  string

    Family "2.0"                                          TCG Published                                         Page 267

    Level 00 Revision 01.16                      Copyright © TCG 2006-2014                              October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting Routines

94         //   of   the     function         name         where     the  error   occurred.

95         s_failFunction           =     *(UINT32*)&function;

96         s_failLine        =    line;

97         s_failCode        =    code;

98

99         //   if   asserts        are    enabled,            then  do   an     assert    unless    the  failure     mode  code

100        //   is   being      tested

101        assert(g_forceFailureMode);

102

103        //   Clear     this      flag

104        g_forceFailureMode                 =     FALSE;

105

106        //   Jump     to  the    failure            mode      code.

107        //   Note:     only      get    here        if      asserts    are    off  or   if  we  are    testing  failure    mode

108        longjmp(&g_jumpBuffer[0],                           1);

109  }

     9.15.5      TpmFailureMode

     This function is called by the interface code when the platform is in failure mode.

110  void

111  TpmFailureMode            (

112        unsigned       int             inRequestSize,                     //  IN:    command    buffer  size

113        unsigned       char         *inRequest,                           //  IN:    command    buffer

114        unsigned       int          *outResponseSize,                     //  OUT:      response   buffer    size

115        unsigned       char         **outResponse                         //  OUT:      response   buffer

116        )

117  {

118        BYTE                        *buffer;

119        UINT32                         marshalSize;

120        UINT32                         capability;

121        HEADER                         header;                //  unmarshaled        command    header

122        UINT32                         pt;              //  unmarshaled       property      type

123        UINT32                         count;           //  unmarshaled       property      count

124

125        //   If   there      is  no     command             buffer,    then   just      return  TPM_RC_FAILURE

126        if(inRequestSize               ==     0     ||   inRequest     ==     NULL)

127              goto     FailureModeReturn;

128

129        //   If   the     header       is     not       correct   for     TPM2_GetCapability()          or

130        //   TPM2_GetTestResult()                       then     just  return      the  in  failure    mode  response;

131        buffer     =   inRequest;

132        if(!UnmarshalHeader(&header,                             &inRequest,       (INT32   *)&inRequestSize))

133              goto     FailureModeReturn;

134        if(       header.tag            !=       TPM_ST_NO_SESSIONS

135             ||   header.size           <     10)

136             goto     FailureModeReturn;

137

138        switch     (header.code)                 {

139        case     TPM_CC_GetTestResult:

140

141              //   make      sure      that         the     command    size   is   correct

142              if(header.size               !=       10)

143                      goto     FailureModeReturn;

144              buffer      =    &response[10];

145              marshalSize           =      MarshalUint16(3             *    sizeof(UINT32),        &buffer);

146              marshalSize           +=     MarshalUint32(s_failFunction,                    &buffer);

147              marshalSize           +=     MarshalUint32(s_failLine,                    &buffer);

148              marshalSize           +=     MarshalUint32(s_failCode,                    &buffer);

149              if(s_failCode             ==       FATAL_ERROR_NV_UNRECOVERABLE)

150                      marshalSize             +=    MarshalUint32(TPM_RC_NV_UNINITIALIZED,                      &buffer);

151              else

152                      marshalSize             +=    MarshalUint32(TPM_RC_FAILURE,                  &buffer);

     Page 268                                                        TCG Published                                            Family "2.0"

     October 30, 2014                                          Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                Trusted Platform Module Library

153                break;

154        

155        case       TPM_CC_GetCapability:

156                //    make       sure         that        the    size      of   the  command       is   exactly     the   size

157                //    returned             for         the     capability,          property,      and   count

158                if(              header.size!=                   (10    +   (3   *   sizeof(UINT32)))

159                                 //     also           verify       that    this     is  requesting       TPM   properties

160                      ||                   (UINT32_Unmarshal(&capability,                          &inRequest,

161                                                                                (INT32     *)&inRequestSize)

162                                 !=        TPM_RC_SUCCESS)

163                      ||      (capability                   !=   TPM_CAP_TPM_PROPERTIES)

164                      ||                   (UINT32_Unmarshal(&pt,                        &inRequest,      (INT32     *)&inRequestSize)

165                                 !=     TPM_RC_SUCCESS)

166                      ||                   (UINT32_Unmarshal(&count,                       &inRequest,         (INT32     *)&inRequestSize)

167                                 !=     TPM_RC_SUCCESS)

168                      )

169        

170                      goto        FailureModeReturn;

171        

172                //    If   in     failure                 mode   because        of   an  unrecoverable         read  error,       and  the

173                //    property             is       0     and   the     count    is  0,    then    this   is   an   indication     to

174                //    re-manufacture                      the    TPM.      Do   the  re-manufacture           but   stay  in    failure

175                //    mode       until           the      TPM    is     reset.

176                //    Note:       this           behavior           is  not     required      by   the   specification        and  it  is

177                //    OK   to     leave             the     TPM     permanently          bricked   due    to   an   unrecoverable      NV

178                //    error.

179                if(   count          ==       0     &&    pt    ==   0  &&     s_failCode      ==  FATAL_ERROR_NV_UNRECOVERABLE)

180                {

181                      g_manufactured                        =   FALSE;

182                      TPM_Manufacture(0);

183                }

184        

185                if(count          >     0)

186                      count          =     1;

187                else      if(pt         >     TPM_PT_FIRMWARE_VERSION_2)

188                      count          =     0;

189                if(pt      <     TPM_PT_MANUFACTURER)

190                      pt      =   TPM_PT_MANUFACTURER;

191        

192                //    set     up     for         return

193                buffer        =   &response[10];

194                //    if   the       request              was    for    a   PT   less    than     the   last   one

195                //    then       we     indicate               more,    otherwise,         not.

196                if(pt      <     TPM_PT_FIRMWARE_VERSION_2)

197                      *buffer++                  =     YES;

198                else

199                      *buffer++                  =     NO;

200        

201                marshalSize                =     1;

202        

203                //    indicate             the         capability          type

204                marshalSize                +=       MarshalUint32(capability,                     &buffer);

205                //    indicate             the         number       of  values       that  are     being  returned        (0  or   1)

206                marshalSize                +=       MarshalUint32(count,                 &buffer);

207                //    indicate             the         property

208                marshalSize                +=       MarshalUint32(pt,                &buffer);

209        

210                if(count          >     0)

211                      switch            (pt)           {

212                      case        TPM_PT_MANUFACTURER:

213                      //      the       vendor            ID    unique      to   each    TPM   manufacturer

214  #ifdef  MANUFACTURER

215                      pt      =   *(UINT32*)MANUFACTURER;

216  #else

217                      pt      =   0;

218  #endif

     Family "2.0"                                                        TCG Published                                                   Page 269

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

219                              break;

220                      case     TPM_PT_VENDOR_STRING_1:

221                              //   the       first   four    characters         of     the     vendor  ID    string

222  #ifdef  VENDOR_STRING_1

223                              pt   =     *(UINT32*)VENDOR_STRING_1;

224  #else

225                              pt   =     0;

226  #endif

227                              break;

228                      case     TPM_PT_VENDOR_STRING_2:

229                              //   the       second  four       characters         of  the     vendor  ID    string

230  #ifdef  VENDOR_STRING_2

231                              pt   =     *(UINT32*)VENDOR_STRING_2;

232  #else

233                              pt   =     0;

234  #endif

235                              break;

236                      case     TPM_PT_VENDOR_STRING_3:

237                              //   the       third   four    characters         of     the     vendor  ID    string

238  #ifdef  VENDOR_STRING_3

239                              pt   =     *(UINT32*)VENDOR_STRING_3;

240  #else

241                              pt   =     0;

242  #endif

243                              break;

244                      case     TPM_PT_VENDOR_STRING_4:

245                              //   the       fourth  four       characters         of  the     vendor  ID    string

246  #ifdef  VENDOR_STRING_4

247                              pt   =     *(UINT32*)VENDOR_STRING_4;

248  #else

249                              pt   =     0;

250  #endif

251

252                              break;

253                      case     TPM_PT_VENDOR_TPM_TYPE:

254                              //   vendor-defined            value      indicating          the  TPM   model

255                              //   We    just      make  up     a  number       here

256                              pt   =     1;

257                              break;

258                      case     TPM_PT_FIRMWARE_VERSION_1:

259                              //   the       more   significant         32-bits        of   a  vendor-specific        value

260                              //   indicating        the     version        of  the    firmware

261  #ifdef  FIRMWARE_V1

262                              pt   =     FIRMWARE_V1;

263  #else

264                              pt   =     0;

265  #endif

266                              break;

267                      default:           //  TPM_PT_FIRMWARE_VERSION_2:

268                              //   the       less   significant         32-bits        of   a  vendor-specific        value

269                              //   indicating        the     version        of  the    firmware

270  #ifdef  FIRMWARE_V2

271                              pt   =     FIRMWARE_V2;

272  #else

273                              pt   =     0;

274  #endif

275                              break;

276                      }

277                      marshalSize            +=    MarshalUint32(pt,            &buffer);

278                      break;

279              default:         //     default       for  switch         (cc)

280                      goto     FailureModeReturn;

281              }

282              //      Now  do     the    header

283              buffer       =   response;

284              marshalSize             =  marshalSize         +     10;  //    Add   the     header     size  to  the

     Page 270                                                  TCG Published                                            Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                                Level  00  Revision 01.16
     Part 4: Supporting Routines                                               Trusted  Platform Module Library

285                                             //  stuff  already  marshaled

286     MarshalUint16(TPM_ST_NO_SESSIONS,           &buffer);  //  structure   tag

287     MarshalUint32(marshalSize,     &buffer);    //     responseSize

288     MarshalUint32(TPM_RC_SUCCESS,        &buffer);     //  response  code

289

290     *outResponseSize      =   marshalSize;

291     *outResponse     =  (unsigned  char  *)&response;

292     return;

293

294  FailureModeReturn:

295

296     buffer     =  response;

297

298     marshalSize   =     MarshalUint16(TPM_ST_NO_SESSIONS,       &buffer);

299     marshalSize   +=    MarshalUint32(10,   &buffer);

300     marshalSize   +=    MarshalUint32(TPM_RC_FAILURE,      &buffer);

301

302     *outResponseSize      =   marshalSize;

303     *outResponse     =  (unsigned  char  *)response;

304     return;

305  }

     Family "2.0"                               TCG Published                           Page 271

     Level 00 Revision 01.16           Copyright © TCG 2006-2014                        October 30, 2014
    Trusted Platform Module Library                                                      Part 4: Supporting Routines

    10    Cryptographic Functions

    10.1     Introduction

    The files in this section provide cryptographic support for the other functions in the TPM and the interface

    to the Crypto Engine.

    10.2     CryptUtil.c

    10.2.1      Includes

1   #include       "TPM_Types.h"

2   #include       "CryptoEngine.h"         //  types  shared       by   CryptUtil  and    CryptoEngine.

3                                           //  Includes  the       function    prototypes  for  the

4                                           //  CryptoEngine        functions.

5   #include       "Global.h"

6   #include       "InternalRoutines.h"

7   #include       "MemoryLib_fp.h"

8   //#include          "CryptSelfTest_fp.h"

    10.2.2      TranslateCryptErrors()

    This function converts  errors  from the cryptographic library  into  TPM_RC_VALUES.

    Error Returns                     Meaning

    TPM_RC_VALUE                      CRYPT_FAIL

    TPM_RC_NO_RESULT                  CRYPT_NO_RESULT

    TPM_RC_SCHEME                     CRYPT_SCHEME

    TPM_RC_VALUE                      CRYPT_PARAMETER

    TPM_RC_SIZE                       CRYPT_UNDERFLOW

    TPM_RC_ECC_POINT                  CRYPT_POINT

    TPM_RC_CANCELLED                  CRYPT_CANCEL

9   static   TPM_RC

10  TranslateCryptErrors       (

11        CRYPT_RESULT              retVal                //        IN:  crypt  error  to  evaluate

12  )

13  {

14        switch  (retVal)

15        {

16        case  CRYPT_SUCCESS:

17              return  TPM_RC_SUCCESS;

18        case  CRYPT_FAIL:

19              return  TPM_RC_VALUE;

20        case  CRYPT_NO_RESULT:

21              return  TPM_RC_NO_RESULT;

22        case  CRYPT_SCHEME:

23              return  TPM_RC_SCHEME;

24        case  CRYPT_PARAMETER:

25              return  TPM_RC_VALUE;

26        case  CRYPT_UNDERFLOW:

27              return  TPM_RC_SIZE;

28        case  CRYPT_POINT:

29              return  TPM_RC_ECC_POINT;

30        case  CRYPT_CANCEL:

    Page 272                                      TCG Published                                       Family "2.0"

    October 30, 2014                     Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                Trusted Platform Module Library

31              return     TPM_RC_CANCELED;

32        default:   //    Other  unknown    warnings

33              return     TPM_RC_FAILURE;

34        }

35  }

    10.2.3      Random Number Generation               Functions

36  #ifdef    TPM_ALG_NULL       //%

37  #ifdef    _DRBG_STATE_SAVE        //%

    10.2.3.1       CryptDrbgGetPutState()

    Read or write the current state from the DRBG in the cryptoEngine.

38  void

39  CryptDrbgGetPutState(

40        GET_PUT                 direction            //  IN:   Get     from     or  put  to  DRBG

41        )

42  {

43        _cpri__DrbgGetPutState(direction,

44                                         sizeof(go.drbgState),

45                                         (BYTE   *)&go.drbgState);

46  }

47  #else       //%  00

48  //%#define       CryptDrbgGetPutState(ignored)              //   If  not      doing    state   save,  turn  this

49  //%                                                          //     into   a   null    macro

50  #endif      //%

    10.2.3.2       CryptStirRandom()

    Stir random entropy

51  void

52  CryptStirRandom(

53        UINT32                  entropySize,         //  IN:   size    of    entropy     buffer

54        BYTE                   *buffer               //  IN:   entropy       buffer

55        )

56  {

57        //  RNG    self  testing    code  may    be  inserted      here

58

59        //  Call   crypto  engine       random   number  stirring        function

60        _cpri__StirRandom(entropySize,               buffer);

61

62        return;

63  }

    10.2.3.3       CryptGenerateRandom()

    This is the interface to _cpri__GenerateRandom().

64  UINT16

65  CryptGenerateRandom(

66        UINT16                  randomSize,          //  IN:   size    of    random      number

67        BYTE                   *buffer               //  OUT:     buffer     of     random   number

68        )

69  {

70        UINT16                          result;

71        pAssert(randomSize          <=  MAX_RSA_KEY_BYTES         ||   randomSize        <=  PRIMARY_SEED_SIZE);

72        if(randomSize      ==   0)

    Family "2.0"                                       TCG Published                                            Page 273

    Level 00 Revision 01.16                  Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                            Part 4: Supporting Routines

73             return   0;

74

75       //    Call     crypto  engine       random  number    generation

76       result      =  _cpri__GenerateRandom(randomSize,                  buffer);

77       if(result      !=  randomSize)

78             FAIL(FATAL_ERROR_INTERNAL);

79

80       return      result;

81   }

82   #endif    //TPM_ALG_NULL      //%

     10.2.4    Hash/HMAC Functions

     10.2.4.1    CryptGetContextAlg()

     This function returns the hash algorithm associated with a hash context.

83   #ifdef    TPM_ALG_KEYEDHASH                     //%   1

84   TPM_ALG_ID

85   CryptGetContextAlg(

86       void                   *state                     //  IN:   the   context   to  check

87       )

88   {

89       HASH_STATE         *context      =  (HASH_STATE       *)state;

90       return      _cpri__GetContextAlg(&context->state);

91   }

     10.2.4.2    CryptStartHash()

     This function starts a hash and return the size, in bytes, of the digest.

     Return Value                            Meaning

     >0                                      the digest size of the algorithm

     =0                                      the hashAlg was TPM_ALG_NULL

92   UINT16

93   CryptStartHash(

94       TPMI_ALG_HASH             hashAlg,                //  IN:   hash  algorithm

95       HASH_STATE             *hashState                 //  OUT:  the   state    of   hash  stack.  It  will  be  used

96                                                         //        in   hash  update   and   completion

97       )

98   {

99       CRYPT_RESULT              retVal    =       0;

100

101      pAssert(hashState         !=     NULL);

102

103      TEST_HASH(hashAlg);

104

105      hashState->type        =  HASH_STATE_EMPTY;

106

107      //    Call     crypto  engine       start   hash     function

108      if((retVal     =   _cpri__StartHash(hashAlg,                FALSE,     &hashState->state))    >   0)

109            hashState->type         =     HASH_STATE_HASH;

110

111      return      retVal;

112  }

     Page 274                                              TCG Published                                         Family "2.0"

     October 30, 2014                        Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                  Trusted Platform Module Library

     10.2.4.3       CryptStartHashSequence()

     Start a  hash stack for a sequence object and return the size, in                    bytes,  of  the  digest.  This  call  uses  the

     form of  the hash state that requires context save and restored.

     Return   Value                           Meaning

     >0                                       the digest size of the algorithm

     =0                                       the hashAlg was TPM_ALG_NULL

113  UINT16

114  CryptStartHashSequence(

115      TPMI_ALG_HASH              hashAlg,                    //  IN:   hash   algorithm

116      HASH_STATE              *hashState                     //  OUT:  the    state    of   hash   stack.  It    will  be    used

117                                                             //        in   hash   update    and   completion

118      )

119  {

120      CRYPT_RESULT            retVal       =  0;

121

122      pAssert(hashState             !=     NULL);

123

124      TEST_HASH(hashAlg);

125

126      hashState->type         =     HASH_STATE_EMPTY;

127

128      //    Call  crypto      engine       start       hash  function

129      if((retVal       =  _cpri__StartHash(hashAlg,                    TRUE,     &hashState->state))       >     0)

130            hashState->type             =  HASH_STATE_HASH;

131

132      return      retVal;

133

134  }

     10.2.4.4       Crypt St artHM AC()

     This function starts an HMAC sequence and returns the size of the digest that will be produced.

     The caller must provide a block of memory in which the hash sequence state is kept.                            The caller  should

     not alter the contents of this buffer until the hash sequence is completed or abandoned.

     Return Value                             Meaning

     >0                                       the digest size of the algorithm

     =0                                       the hashAlg was TPM_ALG_NULL

135  UINT16

136  CryptStartHMAC(

137      TPMI_ALG_HASH              hashAlg,                    //  IN:   hash   algorithm

138      UINT16                     keySize,                    //  IN:   the   size  of  HMAC    key  in  byte

139      BYTE                    *key,                          //  IN:   HMAC   key

140      HMAC_STATE              *hmacState                     //  OUT:  the    state    of   HMAC   stack.  It    will  be    used

141                                                             //        in   HMAC   update    and   completion

142      )

143  {

144      HASH_STATE              *hashState            =  (HASH_STATE         *)hmacState;

145      CRYPT_RESULT            retVal;

146

147      //    This  has     to  come      before      the  pAssert       in   case   we  all   calling    this     function

148      //    during  testing.        If     so,    the    first    instance       will  have  no    arguments     but   the

149      //    hash  algorithm.        The       call     from  the  test      routine    will  have   arguments.        When

150      //    the   second      call  is     done,       then  we   return     to   the  test  dispatcher.

151      TEST_HASH(hashAlg);

     Family "2.0"                                               TCG Published                                             Page 275

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                       Part 4: Supporting Routines

152

153      pAssert(hashState     !=     NULL);

154

155      hashState->type    =  HASH_STATE_EMPTY;

156

157      if((retVal    =    _cpri__StartHMAC(hashAlg,         FALSE,     &hashState->state,    keySize,         key,

158                                              &hmacState->hmacKey.b))           >   0)

159            hashState->type     =  HASH_STATE_HMAC;

160

161      return    retVal;

162  }

     10.2.4.5    Crypt St artHM AC Sequ ence()

     This function starts an HMAC sequence and returns the size of the digest that will be produced.

     The caller must provide a block of memory in which the hash sequence state is kept.             The caller  should

     not alter the contents of this buffer until the hash sequence is completed or abandoned.

     This call is used to start a sequence HMAC that spans multiple TPM commands.

     Return Value                     Meaning

     >0                               the digest size of the algorithm

     =0                               the hashAlg was TPM_ALG_NULL

163  UINT16

164  CryptStartHMACSequence(

165      TPMI_ALG_HASH         hashAlg,          //  IN:   hash     algorithm

166      UINT16                keySize,          //  IN:   the     size  of  HMAC     key  in  byte

167      BYTE               *key,                //  IN:   HMAC     key

168      HMAC_STATE         *hmacState           //  OUT:     the   state    of  HMAC  stack.  It    will   be  used

169                                              //        in   HMAC     update  and   completion

170      )

171  {

172      HASH_STATE         *hashState        =  (HASH_STATE   *)hmacState;

173      CRYPT_RESULT       retVal;

174

175      TEST_HASH(hashAlg);

176

177      hashState->type    =  HASH_STATE_EMPTY;

178

179      if((retVal    =    _cpri__StartHMAC(hashAlg,         TRUE,     &hashState->state,

180                                              keySize,     key,      &hmacState->hmacKey.b))      >  0)

181            hashState->type     =  HASH_STATE_HMAC;

182

183      return    retVal;

184  }

     10.2.4.6    Crypt St artHM AC 2B( )

     This function starts an HMAC and returns the size of the digest that will be produced.

     This function is provided to support the most common use of starting an HMAC with a TPM2B key.

     The caller must provide a block of memory in which the hash sequence state is kept.             The caller should

     not alter the contents of this buffer until the hash sequence is completed or abandoned.

     Page 276                                    TCG Published                                             Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

     Return Value                     Meaning

     >0                               the digest size of the algorithm

     =0                               the hashAlg was TPM_ALG_NULL

185  LIB_EXPORT    UINT16

186  CryptStartHMAC2B(

187      TPMI_ALG_HASH          hashAlg,       //  IN:   hash   algorithm

188      TPM2B             *key,               //  IN:   HMAC   key

189      HMAC_STATE        *hmacState          //  OUT:    the  state       of  HMAC      stack.  It  will    be  used

190                                            //        in   HMAC      update    and     completion

191      )

192  {

193      return    CryptStartHMAC(hashAlg,     key->size,     key->buffer,            hmacState);

194  }

     10.2.4.7    Crypt St artHM AC Sequ ence2B()

     This function starts an HMAC sequence and returns the size of the digest that will be produced.

     This function is provided to support the most common use of starting an HMAC with a TPM2B key.

     The caller must provide a block of memory in which the hash sequence state is kept.              The caller  should

     not alter the contents of this buffer until the hash sequence is completed or abandoned.

     Return Value                     Meaning

     >0                               the digest size of the algorithm

     =0                               the hashAlg was TPM_ALG_NULL

195  UINT16

196  CryptStartHMACSequence2B(

197      TPMI_ALG_HASH          hashAlg,       //  IN:   hash   algorithm

198      TPM2B             *key,               //  IN:   HMAC   key

199      HMAC_STATE        *hmacState          //  OUT:    the  state       of  HMAC      stack.  It  will    be  used

200                                            //        in   HMAC      update    and     completion

201      )

202  {

203      return    CryptStartHMACSequence(hashAlg,       key->size,         key->buffer,         hmacState);

204  }

     10.2.4.8    CryptUpdateDigest()

     This function updates a digest (hash or HMAC) with an array of octets.

     This function can be used for both HMAC and hash functions so the digestState is                 void so that either

     state type can be passed.

205  LIB_EXPORT    void

206  CryptUpdateDigest(

207      void              *digestState,       //  IN:   the    state       of  hash      stack

208      UINT32                 dataSize,      //  IN:   the    size    of      data

209      BYTE              *data               //  IN:   data   to      be  hashed

210      )

211  {

212      HASH_STATE        *hashState      =  (HASH_STATE    *)digestState;

213

214      pAssert(digestState      !=  NULL);

215

216      if(hashState->type       !=  HASH_STATE_EMPTY   &&   data      !=  NULL      &&  dataSize    !=  0)

217      {

     Family "2.0"                              TCG Published                                                  Page 277

     Level 00 Revision 01.16               Copyright © TCG 2006-2014                                  October 30, 2014
     Trusted Platform Module Library                                                                                 Part 4: Supporting Routines

218             //     Call    crypto        engine       update  hash       function

219             _cpri__UpdateHash(&hashState->state,                             dataSize,           data);

220       }

221       return;

222  }

     10.2.4.9       CryptUpdateDigest2B()

     This function updates a digest (hash or HMAC) with a TPM2B.

     This function can be used for both HMAC and hash functions so the digestState is                                         void so that  either

     state type can be passed.

223  LIB_EXPORT        void

224  CryptUpdateDigest2B(

225       void                          *digestState,             //  IN:    the     digest         state

226       TPM2B                         *bIn                      //  IN:    2B    containing           the   data

227       )

228  {

229       //   Only    compute          the   digest      if  a   pointer    to      the    2B      is  provided.

230       //   In   CryptUpdateDigest(),                  if  size    is     zero    or     buffer      is    NULL,     then  no   change

231       //   to   the       digest     occurs.      This    function       should         not     provide       a  buffer   if   bIn  is

232       //   not     provided.

233       if(bIn       !=     NULL)

234             CryptUpdateDigest(digestState,                        bIn->size,            bIn->buffer);

235       return;

236  }

     10.2.4.10      CryptUpdateDigestInt()

     This function is used to include an integer value to a hash stack. The function marshals the integer into its

     canonical form before calling CryptUpdateHash().

237  LIB_EXPORT        void

238  CryptUpdateDigestInt(

239       void                          *state,                   //  IN:    the     state       of     hash  stack

240       UINT32                         intSize,                 //  IN:    the     size       of   'intValue'         in   byte

241       void                          *intValue                 //  IN:    integer        value       to    be     hashed

242       )

243  {

244

245  #if  BIG_ENDIAN_TPM             ==  YES

246       pAssert(             intValue       !=      NULL    &&  (intSize       ==  1      ||   intSize      ==     2

247                    ||      intSize        ==   4  ||    intSize      ==  8));

248       CryptUpdateHash(state,                   inSize,        (BYTE   *)intValue);

249  #else

250

251       BYTE                 marshalBuffer[8];

252       //   Point       to  the      big   end     of  an  little-endian          value

253       BYTE                 *p    =   &((BYTE      *)intValue)[intSize                -  1];

254       //   Point       to  the      big   end     of  an  big-endian         value

255       BYTE                 *q    =   marshalBuffer;

256

257       pAssert(intValue               !=   NULL);

258       switch       (intSize)

259       {

260       case     8:

261             *q++       =   *p--;

262             *q++       =   *p--;

263             *q++       =   *p--;

264             *q++       =   *p--;

265       case     4:

266             *q++       =   *p--;

     Page 278                                                     TCG Published                                                    Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                      Trusted Platform Module Library

267             *q++     =   *p--;

268       case    2:

269             *q++     =   *p--;

270       case    1:

271             *q    =  *p;

272             //    Call    update       the  hash

273             CryptUpdateDigest(state,                 intSize,      marshalBuffer);

274             break;

275       default:

276             FAIL(0);

277       }

278

279  #endif

280       return;

281  }

     10.2.4.11      CryptCompleteHash()

     This function completes a hash sequence and returns the digest.

     This function can be called to complete either an HMAC or hash sequence. The state type determines if

     the context type is a hash or HMAC. If an HMAC, then the call is forwarded to CryptCompleteHash().

     If  digestSize      is  smaller   than  the    digest  size  of   hash/HMAC         algorithm,       the  most  significant  bytes  of

     required size will be returned

     Return Value                               Meaning

     >=0                                        the number of bytes placed in digest

282  LIB_EXPORT       UINT16

283  CryptCompleteHash(

284       void                      *state,                 //    IN:     the   state    of   hash    stack

285       UINT16                       digestSize,          //    IN:     size  of    digest      buffer

286       BYTE                      *digest                 //    OUT:    hash      digest

287       )

288  {

289       HASH_STATE                *hashState        =  (HASH_STATE        *)state;              //  local      value

290

291       //  If    the      session   type     is   HMAC,  then      could     forward       this    to

292       //  the     HMAC    processing        and   not   cause     an  error.      However,        if  no

293       //  function        calls    this     routine     to  forward        it,  then      we  can't   get

294       //  test       coverage.     The      decision    is  to    assert    if    this    is    called     with

295       //  the     type    ==  HMAC     and  fix      anything     that     makes     the  wrong       call.

296       pAssert(hashState->type               ==    HASH_STATE_HASH);

297

298       //  Set     the    state     to  empty     so  that   it    doesn't       get  used     again

299       hashState->type           =  HASH_STATE_EMPTY;

300

301       //  Call       crypto   engine        complete    hash    function

302       return             _cpri__CompleteHash(&hashState->state,                       digestSize,          digest);

303  }

     10.2.4.12      CryptCompleteHash2B()

     This function is the same as CypteCompleteHash() but the digest is placed in a TPM2B. This is the most

     common use and this is provided for specification clarity. 'digest.size' should be set to indicate the number

     of bytes to place in the buffer

     Family "2.0"                                           TCG Published                                                Page 279

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                              Part 4: Supporting Routines

     Return Value                       Meaning

     >=0                                the number of bytes placed in 'digest.buffer'

304  LIB_EXPORT    UINT16

305  CryptCompleteHash2B(

306       void              *state,                    //  IN:   the   state     of  hash    stack

307       TPM2B             *digest                    //  IN:   the   size    of    the   buffer     Out:  requested

308                                                    //        number    of    byte

309       )

310  {

311       UINT16                       retVal   =  0;

312

313       if(digest     !=  NULL)

314             retVal  =   CryptCompleteHash(state,            digest->size,        digest->buffer);

315

316       return   retVal;

317  }

     10.2.4.13    CryptHashBlock()

     Hash a block of data and return the results. If the digest is larger than retSize, it is truncated     and        with  the

     least significant octets dropped.

     Return Value                       Meaning

     >=0                                the number of bytes placed in ret

318  LIB_EXPORT    UINT16

319  CryptHashBlock(

320       TPM_ALG_ID         algId,                    //  IN:   the   hash    algorithm     to    use

321       UINT16             blockSize,                //  IN:   size  of    the     data  block

322       BYTE              *block,                    //  IN:   address     of    the    block   to  hash

323       UINT16             retSize,                  //  IN:   size  of    the     return  buffer

324       BYTE              *ret                       //  OUT:  address       of    the   buffer

325       )

326  {

327       TEST_HASH(algId);

328

329       return   _cpri__HashBlock(algId,             blockSize,     block,     retSize,    ret);

330  }

     10.2.4.14    CryptCompleteHMAC()

     This function completes a HMAC sequence and returns the digest. If digestSize is smaller than the digest

     size of the HMAC algorithm, the most significant bytes of required size will be returned.

     Return Value                       Meaning

     >=0                                the number of bytes placed in digest

331  LIB_EXPORT    UINT16

332  CryptCompleteHMAC(

333       HMAC_STATE        *hmacState,                //  IN:   the   state     of  HMAC    stack

334       UINT32             digestSize,               //  IN:   size  of    digest       buffer

335       BYTE              *digest                    //  OUT:  HMAC    digest

336       )

337  {

338       HASH_STATE        *hashState;

339

340       pAssert(hmacState        !=   NULL);

     Page 280                                          TCG Published                                        Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part  4: Supporting Routines                                                      Trusted Platform  Module  Library

341        hashState    =     &hmacState->hashState;

342

343        pAssert(hashState->type     ==    HASH_STATE_HMAC);

344

345        hashState->type    =      HASH_STATE_EMPTY;

346

347        return  _cpri__CompleteHMAC(&hashState->state,               &hmacState->hmacKey.b,

348                                          digestSize,      digest);

349

350  }

     10.2.4.15     CryptCompleteHMAC2B()

     This function is the same as CryptCompleteHMAC() but the HMAC result is returned in a TPM2B         which   is

     the most common use.

     Return Value                      Meaning

     >=0                               the number of bytes placed in digest

351  LIB_EXPORT    UINT16

352  CryptCompleteHMAC2B(

353        HMAC_STATE         *hmacState,           //  IN:   the  state     of  HMAC  stack

354        TPM2B              *digest               //  OUT:      HMAC

355        )

356  {

357        UINT16                    retVal  =  0;

358        if(digest    !=    NULL)

359             retVal     =  CryptCompleteHMAC(hmacState,         digest->size,       digest->buffer);

360        return  retVal;

361  }

     10.2.4.16     CryptHashStateImportExport()

     This function is used to prepare a hash state context for LIB_EXPORT or to import it into the internal

     format. It is used by TPM2_ContextSave() and TPM2_ContextLoad() via SequenceDataImportExport().

     This is just a pass-through function to the crypto library.

362  void

363  CryptHashStateImportExport(

364        HASH_STATE         *internalFmt,         //  IN:   state     to  LIB_EXPORT

365        HASH_STATE         *externalFmt,         //  OUT:      exported   state

366        IMPORT_EXPORT         direction

367        )

368  {

369        _cpri__ImportExportHashState(&internalFmt->state,

370                                             (EXPORT_HASH_STATE          *)&externalFmt->state,

371                                             direction);

372  }

     10.2.4.17     CryptGetHashDigestSize()

     This function returns the digest size in bytes for a hash algorithm.

     Return Value                      Meaning

     0                                 digest size for TPM_ALG_NULL

     >0                                digest size

373  LIB_EXPORT    UINT16

     Family "2.0"                                   TCG Published                                        Page 281

     Level 00 Revision 01.16                Copyright © TCG 2006-2014                           October 30, 2014
     Trusted Platform Module Library                                                            Part 4: Supporting Routines

374  CryptGetHashDigestSize(

375       TPM_ALG_ID               hashAlg            //    IN:  hash  algorithm

376       )

377  {

378       return   _cpri__GetDigestSize(hashAlg);

379  }

     10.2.4.18    CryptGetHashBlockSize()

     Get the digest size in byte of a hash algorithm.

     Return Value                         Meaning

     0                                    block size for TPM_ALG_NULL

     >0                                   block size

380  LIB_EXPORT     UINT16

381  CryptGetHashBlockSize(

382       TPM_ALG_ID               hash               //    IN:  hash  algorithm       to  look   up

383       )

384  {

385       return   _cpri__GetHashBlockSize(hash);

386  }

     10.2.4.19    CryptGetHashAlgByIndex()

     This function is used to iterate through the hashes. TPM_ALG_NULL is returned for all indexes that are

     not  valid  hashes.  If  the  TPM    implements   3    hashes,    then  an   index    value  of  0  will  return  the  first

     implemented hash and an index value of 2 will return the last implemented hash. All other index values

     will return TPM_ALG_NULL.

     Return Value                         Meaning

     TPM_ALG_xxx()                        a hash algorithm

     TPM_ALG_NULL                         this can be used as a stop value

387  LIB_EXPORT     TPM_ALG_ID

388  CryptGetHashAlgByIndex(

389       UINT32                   index              //    IN:  the   index

390       )

391  {

392       return   _cpri__GetHashAlgByIndex(index);

393  }

     10.2.4.20    CryptSignHMAC()

     Sign a digest using an HMAC key. This an HMAC of a digest, not an HMAC of a message.

     Error Returns                        Meaning

394  static      TPM_RC

395  CryptSignHMAC(

396       OBJECT                   *signKey,                //   IN:   HMAC   key  sign    the    hash

397       TPMT_SIG_SCHEME          *scheme,                 //   IN:   signing     scheme

398       TPM2B_DIGEST             *hashData,               //   IN:   hash   to   be  signed

399       TPMT_SIGNATURE           *signature               //   OUT:  signature

400       )

401  {

     Page 282                                          TCG Published                                           Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part  4: Supporting Routines                                                            Trusted Platform  Module  Library

402        HMAC_STATE              hmacState;

403        UINT32                  digestSize;

404

405        //  HMAC  algorithm     self      testing       code   may  be    inserted  here

406

407        digestSize      =  CryptStartHMAC2B(scheme->details.hmac.hashAlg,

408                                                     &signKey->sensitive.sensitive.bits.b,

409                                                     &hmacState);

410

411        //  The   hash     algorithm  must       be  a  valid       one.

412        pAssert(digestSize      >     0);

413

414        CryptUpdateDigest2B(&hmacState,                 &hashData->b);

415

416        CryptCompleteHMAC(&hmacState,                digestSize,

417                                (BYTE        *)  &signature->signature.hmac.digest);

418

419        //  Set   HMAC     algorithm

420        signature->signature.hmac.hashAlg                   =  scheme->details.hmac.hashAlg;

421

422        return    TPM_RC_SUCCESS;

423  }

     10.2.4.21      CryptHMACVerifySignature()

     This function will verify a signature signed by a HMAC key.

     Error Returns                       Meaning

     TPM_RC_SIGNATURE                    if invalid input or signature is not genuine

424  static    TPM_RC

425  CryptHMACVerifySignature(

426        OBJECT             *signKey,                    //     IN:  HMAC  key  signed   the  hash

427        TPM2B_DIGEST       *hashData,                   //     IN:  digest  being   verified

428        TPMT_SIGNATURE     *signature                   //     IN:  signature  to   be  verified

429        )

430  {

431        HMAC_STATE                 hmacState;

432        TPM2B_DIGEST               digestToCompare;

433

434        digestToCompare.t.size            =  CryptStartHMAC2B(signature->signature.hmac.hashAlg,

435                                             &signKey->sensitive.sensitive.bits.b,                 &hmacState);

436

437        CryptUpdateDigest2B(&hmacState,                 &hashData->b);

438

439        CryptCompleteHMAC2B(&hmacState,                 &digestToCompare.b);

440

441        //  Compare     digest

442        if(MemoryEqual(digestToCompare.t.buffer,

443                           (BYTE      *)     &signature->signature.hmac.digest,

444                           digestToCompare.t.size))

445              return    TPM_RC_SUCCESS;

446        else

447              return    TPM_RC_SIGNATURE;

448

449  }

     10.2.4.22      CryptGenerateKeyedHash()

     This function creates a keyedHash object.

     Family "2.0"                                          TCG Published                                       Page 283

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                         October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

     Error Returns                            Meaning

     TPM_RC_SIZE                              sensitive data size is larger than allowed for the scheme

450  static  TPM_RC

451  CryptGenerateKeyedHash(

452     TPMT_PUBLIC                               *publicArea,                     //   IN/OUT:      the   public     area  template

453                                                                                //          for   the   new  key.

454     TPMS_SENSITIVE_CREATE                     *sensitiveCreate,                //   IN:    sensitive       creation     data

455     TPMT_SENSITIVE                            *sensitive,                      //   OUT:   sensitive        area

456     TPM_ALG_ID                                    kdfHashAlg,                  //   IN:    algorithm       for   the  KDF

457     TPM2B_SEED                                *seed,                           //   IN:    the   seed

458     TPM2B_NAME                                *name                            //   IN:    name  of    the  object

459     )

460  {

461     TPMT_KEYEDHASH_SCHEME                     *scheme;

462     TPM_ALG_ID                                    hashAlg;

463     UINT16                                        hashBlockSize;

464

465     scheme     =   &publicArea->parameters.keyedHashDetail.scheme;

466

467     pAssert(publicArea->type                      ==     TPM_ALG_KEYEDHASH);

468

469     //   Pick     the     limiting        hash    algorithm

470     if(scheme->scheme                 ==  TPM_ALG_NULL)

471           hashAlg         =   publicArea->nameAlg;

472     else     if(scheme->scheme                ==  TPM_ALG_XOR)

473           hashAlg         =   scheme->details.xor.hashAlg;

474     else

475           hashAlg         =   scheme->details.hmac.hashAlg;

476     hashBlockSize             =    CryptGetHashBlockSize(hashAlg);

477

478     //   if   this     is     a  signing      or      a   decryption     key,       then  then   the   limit

479     //   for   the     data      size     is  the        block     size  of    the  hash.  This      limit

480     //   is   set     because         larger      values       have     lower  entropy     because     of   the

481     //   HMAC     function.

482     if(publicArea->objectAttributes.sensitiveDataOrigin                                    ==    CLEAR)

483     {

484           if(          (         publicArea->objectAttributes.decrypt

485                           ||     publicArea->objectAttributes.sign)

486                   &&   sensitiveCreate->data.t.size                      >     hashBlockSize)

487

488                   return         TPM_RC_SIZE;

489     }

490     else

491     {

492           //   If     the     TPM     is  going       to  generate       the   data,      then  set   the   size  to    be  the

493           //   size       of     the  digest      of      the   algorithm

494           sensitive->sensitive.sym.t.size                            =   CryptGetHashDigestSize(hashAlg);

495           sensitiveCreate->data.t.size                          =  0;

496     }

497

498     //   Fill     in   the       sensitive        area

499     CryptGenerateNewSymmetric(sensitiveCreate,                                 sensitive,       kdfHashAlg,

500                                                   seed,        name);

501

502     //   Create       unique       area   in      public

503     CryptComputeSymmetricUnique(publicArea->nameAlg,

504                                                          sensitive,      &publicArea->unique.sym);

505

506     return     TPM_RC_SUCCESS;

507  }

     Page 284                                                      TCG Published                                                Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part 4: Supporting Routines                                                          Trusted Platform Module Library

     10.2.4.23     CryptKDFa()

     This function generates a key using the KDFa() formulation in Part 1 of the TPM specification. In this

     implementation, this is a macro invocation of _cpri__KDFa() in the hash module of the CryptoEngine().

     This macro sets once to FALSE so that KDFa() will iterate as many times as necessary to generate

     sizeInBits number of bits.

508  //%#define    CryptKDFa(hashAlg,        key,   label,       contextU,        contextV,       \

509  //%                         sizeInBits,    keyStream,           counterInOut)                \

510  //%           TEST_HASH(hashAlg);                                                            \

511  //%           _cpri__KDFa(                                                                   \

512  //%                             ((TPM_ALG_ID)hashAlg),                                       \

513  //%                             ((TPM2B   *)key),                                            \

514  //%                             ((const   char     *)label),                                 \

515  //%                             ((TPM2B   *)contextU),                                       \

516  //%                             ((TPM2B   *)contextV),                                       \

517  //%                             ((UINT32)sizeInBits),                                        \

518  //%                             ((BYTE   *)keyStream),                                       \

519  //%                             ((UINT32   *)counterInOut),                                  \

520  //%                             ((BOOL)   FALSE)                                             \

521  //%                          )

522  //%

     10.2.4.24     CryptKDFaOnce()

     This function generates a key using the KDFa() formulation in Part 1 of the TPM specification. In this

     implementation, this is a macro invocation of _cpri__KDFa() in the hash module of the CryptoEngine().

     This macro will call _cpri__KDFa() with once TRUE so that only one iteration is performed, regardless of

     sizeInBits.

523  //%#define    CryptKDFaOnce(hashAlg,           key,    label,   contextU,      contextV,            \

524  //%                                sizeInBits,     keyStream,        counterInOut)                  \

525  //%           TEST_HASH(hashAlg);                                                                   \

526  //%           _cpri__KDFa(                                                                          \

527  //%                             ((TPM_ALG_ID)hashAlg),                                              \

528  //%                             ((TPM2B   *)key),                                                   \

529  //%                             ((const   char     *)label),                                        \

530  //%                             ((TPM2B   *)contextU),                                              \

531  //%                             ((TPM2B   *)contextV),                                              \

532  //%                             ((UINT32)sizeInBits),                                               \

533  //%                             ((BYTE   *)keyStream),                                              \

534  //%                             ((UINT32   *)counterInOut),                                         \

535  //%                             ((BOOL)   TRUE)                                                     \

536  //%                          )

537  //%

     10.2.4.25     KDFa()

     This function is used  by   functions outside  of  CryptUtil() to access _cpri_KDFa().

538  void

539  KDFa(

540        TPM_ALG_ID            hash,                  //  IN:   hash    algorithm      used  in    HMAC

541        TPM2B                 *key,                  //  IN:   HMAC    key

542        const   char          *label,                //  IN:   a  null-terminated         label       for  KDF

543        TPM2B                 *contextU,             //  IN:   context      U

544        TPM2B                 *contextV,             //  IN:   context      V

545        UINT32                sizeInBits,            //  IN:   size    of   generated     key     in  bit

546        BYTE                  *keyStream,            //  OUT:     key  buffer

547        UINT32                *counterInOut          //  IN/OUT:       caller    may  provide     the      iteration

548                                                     //        counter      for  incremental          operations  to

     Family "2.0"                                       TCG Published                                                Page 285

     Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                        October 30, 2014
     Trusted Platform Module Library                                                     Part 4: Supporting Routines

549                                                      //       avoid  large  intermediate  buffers.

550        )

551  {

552        CryptKDFa(hash,        key,     label,  contextU,   contextV,    sizeInBits,

553                  keyStream,            counterInOut);

554  }

     10.2.4.26     CryptKDFe()

     This function generates a key using the KDFa() formulation in Part 1 of the TPM specification. In this

     implementation, this is a macro invocation of _cpri__KDFe() in the hash module of the CryptoEngine().

555  //%#define     CryptKDFe(hashAlg,         Z,     label,   partyUInfo,  partyVInfo,        \

556  //%                          sizeInBits,         keyStream)                               \

557  //%   TEST_HASH(hashAlg);                                                                 \

558  //%   _cpri__KDFe(                                                                        \

559  //%                 ((TPM_ALG_ID)hashAlg),                                                \

560  //%                 ((TPM2B        *)Z),                                                  \

561  //%                 ((const        char   *)label),                                       \

562  //%                 ((TPM2B        *)partyUInfo),                                         \

563  //%                 ((TPM2B        *)partyVInfo),                                         \

564  //%                 ((UINT32)sizeInBits),                                                 \

565  //%                 ((BYTE       *)keyStream)                                             \

566  //%                 )

567  //%

568  #endif    //TPM_ALG_KEYEDHASH             //%    1

     10.2.5      RSA Functions

     10.2.5.1      BuildRSA()

     Function to set the cryptographic elements of an RSA key into a structure to simplify the interface          to

     _cpri__ RSA function. This can/should be eliminated by building this structure into the object structure.

569  #ifdef    TPM_ALG_RSA                    //%  2

570  static    void

571  BuildRSA(

572        OBJECT                 *rsaKey,

573        RSA_KEY                *key

574        )

575  {

576        key->exponent    =     rsaKey->publicArea.parameters.rsaDetail.exponent;

577        if(key->exponent       ==    0)

578              key->exponent    =     RSA_DEFAULT_PUBLIC_EXPONENT;

579        key->publicKey      =  &rsaKey->publicArea.unique.rsa.b;

580

581        if(rsaKey->attributes.publicOnly              ||    rsaKey->privateExponent.t.size  ==   0)

582              key->privateKey        =   NULL;

583        else

584              key->privateKey        =   &(rsaKey->privateExponent.b);

585  }

     10.2.5.2      CryptTestKeyRSA()

     This function provides the interface to _cpri__TestKeyRSA(). If both p and q are provided, n will be set to

     p*q.

     If only p is provided, q is computed by q = n/p. If n mod p != 0, TPM_RC_BINDING is returned.

     The key is validated by checking that a d can be found such that e d mod ((p-1)*(q-1)) = 1. If d is found

     that satisfies this requirement, it will be placed in d.

     Page 286                                            TCG Published                                  Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014                 Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

     Error Returns                           Meaning

     TPM_RC_BINDING                          the public and private portions of the key are not matched

586  TPM_RC

587  CryptTestKeyRSA(

588     TPM2B                   *d,                       //     OUT:     receives    the   private       exponent

589     UINT32                        e,                  //     IN:   public      exponent

590     TPM2B                   *n,                       //     IN/OUT:      public     modulu

591     TPM2B                   *p,                       //     IN:   a   first    prime

592     TPM2B                   *q                        //     IN:   an     optional    second     prime

593     )

594  {

595     CRYPT_RESULT            retVal;

596

597     TEST(ALG_NULL_VALUE);

598

599     pAssert(d           !=  NULL  &&  n  !=     NULL  &&  p  !=    NULL);

600     //     Set     the  exponent

601     if(e      ==   0)

602            e    =  RSA_DEFAULT_PUBLIC_EXPONENT;

603     //     CRYPT_PARAMETER

604     retVal         =_cpri__TestKeyRSA(d,        e,    n,     p,   q);

605     if(retVal           ==  CRYPT_SUCCESS)

606            return       TPM_RC_SUCCESS;

607     else

608            return       TPM_RC_BINDING;         //    convert      CRYPT_PARAMETER

609  }

     10.2.5.3       CryptGenerateKeyRSA()

     This function is called to generate an RSA key from a provided seed. It calls _cpri__GenerateKeyRSA()

     to perform the computations. The implementation is vendor specific.

     Error Returns                           Meaning

     TPM_RC_RANGE                            the exponent value is not supported

     TPM_RC_CANCELLED                        key generation has been canceled

     TPM_RC_VALUE                            exponent is not prime or is less than 3; or could not find a prime using

                                             the provided parameters

610  static    TPM_RC

611  CryptGenerateKeyRSA(

612     TPMT_PUBLIC                       *publicArea,                    //  IN/OUT:     The   public     area  template       for

613                                                                       //        the    new   key.     The   public    key

614                                                                       //        area    will     be   replaced    by   the

615                                                                       //        product      of   two   primes    found     by

616                                                                       //        this    function

617     TPMT_SENSITIVE                    *sensitive,                     //  OUT:  the    sensitive       area  will     be

618                                                                       //        updated      to   contain    the    first

619                                                                       //        prime      and   the   symmetric

620                                                                       //        encryption        key

621     TPM_ALG_ID                        hashAlg,                        //  IN:   the   hash   algorithm       for  the     KDF

622     TPM2B_SEED                        *seed,                          //  IN:   Seed   for   the     creation

623     TPM2B_NAME                        *name,                          //  IN:   Object     name

624     UINT32                            *counter                        //  OUT:  last    iteration       of   the  counter

625  )

626  {

627     CRYPT_RESULT            retVal;

628     UINT32                  exponent         =  publicArea->parameters.rsaDetail.exponent;

629

630     TEST_HASH(hashAlg);

     Family "2.0"                                         TCG Published                                                       Page 287

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                               Part 4: Supporting  Routines

631     TEST(ALG_NULL_VALUE);

632

633     //     In  this      implementation,        only      the    default   exponent  is  allowed

634     if(exponent            !=  0  &&  exponent        !=  RSA_DEFAULT_PUBLIC_EXPONENT)

635            return        TPM_RC_RANGE;

636     exponent        =    RSA_DEFAULT_PUBLIC_EXPONENT;

637

638     *counter        =    0;

639

640     //     _cpri_GenerateKeyRSA            can     return        CRYPT_CANCEL   or   CRYPT_FAIL

641     retVal       =  _cpri__GenerateKeyRSA(&publicArea->unique.rsa.b,

642                                                           &sensitive->sensitive.rsa.b,

643                                                           publicArea->parameters.rsaDetail.keyBits,

644                                                           exponent,

645                                                           hashAlg,

646                                                           &seed->b,

647                                                           "RSA   key   by  vendor",

648                                                           &name->b,

649                                                           counter);

650

651     //     CRYPT_CANCEL           ->  TPM_RC_CANCELLED;          CRYPT_FAIL     ->   TPM_RC_VALUE

652     return       TranslateCryptErrors(retVal);

653

654  }

     10.2.5.4      CryptLoadPrivateRSA()

     This function is called to generate the private exponent of an RSA key. It uses CryptTestKeyRSA().

     Error Returns                             Meaning

     TPM_RC_BINDING                            public and private parts of rsaKey are not matched

655  TPM_RC

656  CryptLoadPrivateRSA(

657     OBJECT                        *rsaKey                 //     IN:  the  RSA  key  object

658     )

659  {

660     TPM_RC                        result;

661     TPMT_PUBLIC                   *publicArea      =  &rsaKey->publicArea;

662     TPMT_SENSITIVE                *sensitive    =     &rsaKey->sensitive;

663

664     //     Load     key    by  computing   the        private    exponent

665     //     TPM_RC_BINDING

666     result       =  CryptTestKeyRSA(&(rsaKey->privateExponent.b),

667                                            publicArea->parameters.rsaDetail.exponent,

668                                            &(publicArea->unique.rsa.b),

669                                            &(sensitive->sensitive.rsa.b),

670                                            NULL);

671     if(result          ==    TPM_RC_SUCCESS)

672            rsaKey->attributes.privateExp                      =  SET;

673

674     return       result;

675  }

     10.2.5.5      CryptSelectRSAScheme()

     This function is used by TPM2_RSA_Decrypt() and TPM2_RSA_Encrypt().                           It sets up the rules to select a

     scheme between input and object default. This function assume the RSA object is loaded. If a default

     scheme is defined in object, the default scheme should be chosen, otherwise, the input scheme should

     be chosen. In the case that both the object and scheme are not TPM_ALG_NULL, then if the schemes

     Page 288                                                 TCG Published                              Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                      Trusted Platform Module Library

     are the same, the input scheme will be chosen. if the scheme are not compatible, a NULL pointer will                            be

     returned.

     The return pointer may point to a TPM_ALG_NULL scheme.

676  TPMT_RSA_DECRYPT*

677  CryptSelectRSAScheme(

678     TPMI_DH_OBJECT                      rsaHandle,               //   IN:   handle       of   sign   key

679     TPMT_RSA_DECRYPT                    *scheme                  //   IN:   a    sign    or   decrypt      scheme

680     )

681  {

682     OBJECT                              *rsaObject;

683     TPMT_ASYM_SCHEME                    *keyScheme;

684     TPMT_RSA_DECRYPT                    *retVal       =   NULL;

685

686     //     Get  sign          object    pointer

687     rsaObject           =     ObjectGet(rsaHandle);

688     keyScheme           =     &rsaObject->publicArea.parameters.asymDetail.scheme;

689

690     //     if   the     default       scheme     of   the     object  is    TPM_ALG_NULL,         then     select     the

691     //     input     scheme

692     if(keyScheme->scheme                ==    TPM_ALG_NULL)

693     {

694             retVal         =  scheme;

695     }

696     //     if   the     object    scheme      is     not     TPM_ALG_NULL      and   the     input   scheme       is

697     //     TPM_ALG_NULL,          then    select         the  default      scheme    of    the    object.

698     else       if(scheme->scheme             ==   TPM_ALG_NULL)

699     {

700             //  if      input     scheme     is   NULL

701             retVal         =  (TPMT_RSA_DECRYPT              *)keyScheme;

702     }

703     //     get  here          if  both  the   object         scheme   and   the  input       scheme    are

704     //     not  TPM_ALG_NULL.           Need      to     insure  that      they  are     the    same.

705     //     IMPLEMENTATION             NOTE:   This       could   cause     problems      if   future    versions         have

706     //     schemes         that   have  more      values      than    just  a    hash    algorithm.        A  new     function

707     //     (IsSchemeSame())             might     be     needed  then.

708     else       if(         keyScheme->scheme             ==   scheme->scheme

709                     &&     keyScheme->details.anySig.hashAlg                     ==  scheme->details.anySig.hashAlg)

710     {

711             retVal         =  scheme;

712     }

713     //     two  different,            incompatible           schemes  specified        will     return     NULL

714     return      retVal;

715  }

     10.2.5.6       CryptDecryptRSA()

     This function is the         interface to _cpri__DecryptRSA(). It handles the return codes from that function and

     converts them from           CRYPT_RESULT to TPM_RC values. The rsaKey parameter must reference an RSA

     decryption key

     Error Returns                            Meaning

     TPM_RC_BINDING                           Public and private parts of the key are not cryptographically bound.

     TPM_RC_SIZE                              Size of data to decrypt is not the same as the key size.

     TPM_RC_VALUE                             Numeric         value  of  the  encrypted    data   is  greater     than  the  public

                                              exponent, or output buffer is too small for the decrypted message.

716  TPM_RC

717  CryptDecryptRSA(

718     UINT16                              *dataOutSize,            //   OUT:     size    of    plain   text     in    byte

     Family "2.0"                                                 TCG Published                                                      Page 289

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                                   Part 4: Supporting Routines

719     BYTE                                *dataOut,                       //   OUT:       plain       text

720     OBJECT                              *rsaKey,                        //   IN:     internal        RSA   key

721     TPMT_RSA_DECRYPT                    *scheme,                        //   IN:     selects         the  padding    scheme

722     UINT16                                 cipherInSize,                //   IN:     size       of   cipher    text      in  byte

723     BYTE                                *cipherIn,                      //   IN:     cipher         text

724     const     char                      *label                          //   IN:     a  label,       when    needed

725     )

726  {

727     RSA_KEY                       key;

728     CRYPT_RESULT                  retVal       =     CRYPT_SUCCESS;

729     UINT32                        dSize;                                        //   Place      to   put   temporary         value  for  the

730                                                                                 //   returned        data    size

731     TPMI_ALG_HASH                 hashAlg         =  TPM_ALG_NULL;              //   hash       algorithm      in   the  selected

732                                                                                 //   padding         scheme

733     TPM_RC                        result       =     TPM_RC_SUCCESS;

734

735     //  pointer     checks

736     pAssert(            (dataOutSize                 !=  NULL)      &&  (dataOut            !=  NULL)

737                 &&      (rsaKey         !=     NULL)     &&    (cipherIn            !=  NULL));

738

739     //  The   public        type      is    a     RSA    decrypt        key

740     pAssert(            (rsaKey->publicArea.type                        ==      TPM_ALG_RSA

741                 &&      rsaKey->publicArea.objectAttributes.decrypt                                        ==   SET));

742

743     //  Must    have    the        private           portion    loaded.             This     check   is    made     before   this

744     //  function        is     called.

745     pAssert(rsaKey->attributes.publicOnly                                   ==  CLEAR);

746

747     //  decryption          requires           that      the   private          modulus         be   present

748     if(rsaKey->attributes.privateExp                            ==      CLEAR)

749     {

750

751           //  Load      key       by  computing          the    private         exponent

752           //  CryptLoadPrivateRSA                        may  return        TPM_RC_BINDING

753           result    =   CryptLoadPrivateRSA(rsaKey);

754     }

755

756     //  the   input     buffer          must         be  the   size     of      the     key

757     if(result       ==  TPM_RC_SUCCESS)

758     {

759           if(cipherInSize               !=     rsaKey->publicArea.unique.rsa.t.size)

760                 result         =   TPM_RC_SIZE;

761           else

762           {

763                 BuildRSA(rsaKey,                     &key);

764

765                 //  Initialize              the      dOutSize       parameter

766                 dSize       =     *dataOutSize;

767

768                 //  For        OAEP     scheme,          initialize          the     hash       algorithm      for   padding

769                 if(scheme->scheme                    ==  TPM_ALG_OAEP)

770                 {

771                         hashAlg         =   scheme->details.oaep.hashAlg;

772                         TEST_HASH(hashAlg);

773                 }

774                 //  See        if     the   padding           mode  needs       to      be   tested

775                 TEST(scheme->scheme);

776

777                 //  _cpri__DecryptRSA                    may    return          CRYPT_PARAMETER            CRYPT_FAIL        CRYPT_SCHEME

778                 retVal         =   _cpri__DecryptRSA(&dSize,                         dataOut,        &key,     scheme->scheme,

779                                                                     cipherInSize,               cipherIn,       hashAlg,     label);

780

781                 //  Scheme            must     have      been   validated            when       the  key   was     loaded/imported

782                 pAssert(retVal                 !=    CRYPT_SCHEME);

783

784                 //  Set        the    return         size

     Page 290                                                      TCG Published                                                        Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                         Trusted Platform Module Library

785                  pAssert(dSize               <=     UINT16_MAX);

786                  *dataOutSize             =     (UINT16)dSize;

787

788                  //     CRYPT_PARAMETER                 ->     TPM_RC_VALUE,      CRYPT_FAIL          ->  TPM_RC_VALUE

789                  result       =   TranslateCryptErrors(retVal);

790              }

791        }

792        return    result;

793  }

     10.2.5.7       CryptEncryptRSA()

     This function provides the interface to _cpri__EncryptRSA(). The object referenced by rsaKey is required

     to be an RSA decryption key.

     Error Returns                               Meaning

     TPM_RC_SCHEME                               scheme is not supported

     TPM_RC_VALUE                                numeric value of dataIn is greater than the key modulus

794  TPM_RC

795  CryptEncryptRSA(

796        UINT16                           *cipherOutSize,              //    OUT:   size   of    cipher      text     in  byte

797        BYTE                             *cipherOut,                  //    OUT:   cipher     text

798        OBJECT                           *rsaKey,                     //    IN:   internal      RSA    key

799        TPMT_RSA_DECRYPT                 *scheme,                     //    IN:   selects     the      padding    scheme

800        UINT16                             dataInSize,                //    IN:   size    of  plain        text  in  byte

801        BYTE                             *dataIn,                     //    IN:   plain   text

802        const    char                    *label                       //    IN:   an  optional         label

803        )

804  {

805        RSA_KEY                            key;

806        CRYPT_RESULT                       retVal;

807        UINT32                             cOutSize;                                      //  Conversion         variable

808        TPMI_ALG_HASH                      hashAlg           =   TPM_ALG_NULL;            //  hash     algorithm         in  selected

809                                                                                          //  padding       scheme

810

811        //  must  have      a  pointer           to  a   key     and  some    data    to  encrypt

812        pAssert(rsaKey         !=    NULL        &&  dataIn      !=   NULL);

813

814        //  The   public       type    is     a   RSA    decryption         key

815        pAssert(         rsaKey->publicArea.type                      ==  TPM_ALG_RSA

816                  &&     rsaKey->publicArea.objectAttributes.decrypt                                   ==  SET);

817

818        //  If   the     cipher    buffer         must       be  provided     and     it  must     be  large     enough

819        //  for   the    result

820        pAssert(         cipherOut         !=     NULL

821                  &&     cipherOutSize               !=  NULL

822                  &&     *cipherOutSize              >=      rsaKey->publicArea.unique.rsa.t.size);

823

824        //  Only  need      the    public         key    and     exponent     for     encryption

825        BuildRSA(rsaKey,           &key);

826

827        //  Copy  the    size      to    the      conversion          buffer

828        cOutSize      =  *cipherOutSize;

829

830        //  For   OAEP   scheme,         initialize              the  hash  algorithm         for  padding

831        if(scheme->scheme            ==    TPM_ALG_OAEP)

832        {

833              hashAlg    =     scheme->details.oaep.hashAlg;

834              TEST_HASH(hashAlg);

835        }

836

     Family "2.0"                                                   TCG Published                                                 Page 291

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting Routines

837     //     This     is  a   public        key   operation       and     does    not   require         that  the    private       key

838     //     be  loaded.          To  verify      this,     need   to     do  the     full   algorithm

839     TEST(scheme->scheme);

840

841     //     Encrypt      the      data     with   the     public     exponent

842     //     _cpri__EncryptRSA               may   return       CRYPT_PARAMETER         or      CRYPT_SCHEME

843     retVal       =  _cpri__EncryptRSA(&cOutSize,cipherOut,                            &key,       scheme->scheme,

844                                                      dataInSize,        dataIn,       hashAlg,        label);

845

846     pAssert         (cOutSize         <=   UINT16_MAX);

847     *cipherOutSize               =  (UINT16)cOutSize;

848     //     CRYPT_PARAMETER             ->   TPM_RC_VALUE,           CRYPT_SCHEME          ->  TPM_RC_SCHEME

849     return       TranslateCryptErrors(retVal);

850  }

     10.2.5.8      CryptSignRSA()

     This function is used to sign a digest with an RSA signing key.

     Error Returns                               Meaning

     TPM_RC_BINDING                              public and private part of signKey are not properly bound

     TPM_RC_SCHEME                               scheme is not supported

     TPM_RC_VALUE                                hashData     is   larger   than  the   modulus       of  signKey,   or   the  size  of

                                                 hashData does not match hash algorithm in scheme

851  static    TPM_RC

852  CryptSignRSA(

853     OBJECT                                *signKey,                 //  IN:     RSA   key     signs   the       hash

854     TPMT_SIG_SCHEME                       *scheme,                  //  IN:     sign  scheme

855     TPM2B_DIGEST                          *hashData,                //  IN:     hash  to      be  signed

856     TPMT_SIGNATURE                        *sig                      //  OUT:      signature

857     )

858  {

859     UINT32                                 signSize;

860     RSA_KEY                                key;

861     CRYPT_RESULT                           retVal;

862     TPM_RC                                 result     =   TPM_RC_SUCCESS;

863

864     pAssert(                (signKey       !=   NULL)     &&   (scheme      !=    NULL)

865                             &&   (hashData       !=   NULL)     &&   (sig     !=    NULL));

866

867     //     assume       that     the   key     has   private     part       loaded    and     that    it    is  a  signing       key.

868     pAssert(            (signKey->attributes.publicOnly                         ==   CLEAR)

869                     &&  (signKey->publicArea.objectAttributes.sign                                ==  SET));

870

871     //     check    if      the     private     exponent       has   been     computed

872     if(signKey->attributes.privateExp                           ==   CLEAR)

873            //    May    return        TPM_RC_BINDING

874            result       =   CryptLoadPrivateRSA(signKey);

875

876     if(result           ==  TPM_RC_SUCCESS)

877     {

878            BuildRSA(signKey,                &key);

879

880            //    Make       sure    that    the     hash  is    tested

881            TEST_HASH(sig->signature.any.hashAlg);

882

883            //    Run    a   test      of   the   RSA     sign

884            TEST(scheme->scheme);

885

886            //    _crypi__SignRSA               can   return     CRYPT_SCHEME          and     CRYPT_PARAMETER

887            retVal       =   _cpri__SignRSA(&signSize,

     Page 292                                                     TCG Published                                                      Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part  4: Supporting Routines                                                               Trusted Platform  Module  Library

888                                                  sig->signature.rsassa.sig.t.buffer,

889                                                  &key,

890                                                  sig->sigAlg,

891                                                  sig->signature.any.hashAlg,

892                                                  hashData->t.size,           hashData->t.buffer);

893              pAssert(signSize          <=  UINT16_MAX);

894              sig->signature.rsassa.sig.t.size              =    (UINT16)signSize;

895

896              //  CRYPT_SCHEME     ->       TPM_RC_SCHEME;      CRYPT_PARAMTER           ->  TPM_RC_VALUE

897              result     =   TranslateCryptErrors(retVal);

898        }

899        return    result;

900  }

     10.2.5.9        CryptRSAVerifySignature()

     This function is used to verify signature signed by a RSA key.

     Error Returns                         Meaning

     TPM_RC_SIGNATURE                      if signature is not genuine

     TPM_RC_SCHEME                         signature scheme not supported

901  static    TPM_RC

902  CryptRSAVerifySignature(

903        OBJECT               *signKey,                 //  IN:   RSA     key  signed     the   hash

904        TPM2B_DIGEST         *digestData,              //  IN:   digest       being  signed

905        TPMT_SIGNATURE       *sig                      //  IN:   signature      to   be      verified

906        )

907  {

908        RSA_KEY                         key;

909        CRYPT_RESULT                    retVal;

910        TPM_RC                          result;

911

912        //  Validate         parameter  assumptions

913        pAssert((signKey     !=    NULL)      &&  (digestData        !=  NULL)  &&       (sig  !=  NULL));

914

915        TEST_HASH(sig->signature.any.hashAlg);

916        TEST(sig->sigAlg);

917

918        //  This     is  a   public-key-only      operation

919        BuildRSA(signKey,       &key);

920

921        //  Call     crypto  engine     to    verify   signature

922        //  _cpri_ValidateSignaturRSA             may    return     CRYPT_FAIL       or  CRYPT_SCHEME

923        retVal    =  _cpri__ValidateSignatureRSA(&key,

924                                                            sig->sigAlg,

925                                                            sig->signature.any.hashAlg,

926                                                            digestData->t.size,

927                                                            digestData->t.buffer,

928                                                            sig->signature.rsassa.sig.t.size,

929                                                            sig->signature.rsassa.sig.t.buffer,

930                                                            0);

931        //  _cpri__ValidateSignatureRSA               can  return     CRYPT_SUCCESS,           CRYPT_FAIL,  or

932        //  CRYPT_SCHEME.    Translate        CRYPT_FAIL        to   TPM_RC_SIGNATURE

933        if(retVal        ==  CRYPT_FAIL)

934              result     =   TPM_RC_SIGNATURE;

935        else

936              //  CRYPT_SCHEME     ->       TPM_RC_SCHEME

937              result     =   TranslateCryptErrors(retVal);

938

939        return    result;

940  }

     Family "2.0"                                         TCG Published                                            Page 293

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

941  #endif    //TPM_ALG_RSA                 //%  2

     10.2.6      ECC Functions

     10.2.6.1      CryptEccGetCurveDataPointer()

     This function returns a pointer to an ECC_CURVE_VALUES structure                           that  contains  the  parameters  for

     the key size and schemes for a given curve.

942  #ifdef    TPM_ALG_ECC    //%      3

943  static    const  ECC_CURVE              *

944  CryptEccGetCurveDataPointer(

945        TPM_ECC_CURVE         curveID                       //  IN:  id   of  the   curve

946        )

947  {

948        return    _cpri__EccGetParametersByCurveId(curveID);

949  }

     10.2.6.2      CryptEccGetKeySizeInBits()

     This function returns the size in bits of the key associated with a curve.

950  UINT16

951  CryptEccGetKeySizeInBits(

952        TPM_ECC_CURVE         curveID                       //  IN:  id   of  the   curve

953        )

954  {

955        const   ECC_CURVE                 *curve         =  CryptEccGetCurveDataPointer(curveID);

956        UINT16                                 keySizeInBits         =   0;

957

958        if(curve   !=  NULL)

959              keySizeInBits      =     curve->keySizeBits;

960

961        return    keySizeInBits;

962  }

     10.2.6.3      CryptEccGetKeySizeBytes()

     This macro returns the size of the ECC key in bytes. It uses CryptEccGetKeySizeInBits().

963  //   The  next  lines    will     be    placed     in     CyrptUtil_fp.h    with      the  //%   removed

964  //%   #define   CryptEccGetKeySizeInBytes(curve)                                      \

965  //%                  ((CryptEccGetKeySizeInBits(curve)+7)/8)

     10.2.6.4      CryptEccGetParameter()

     This  function  returns  a  pointer     to   an    ECC    curve    parameter.     The    parameter  is  selected  by  a  single

     character designator from the set of {pnabxyh}.

966  LIB_EXPORT      const    TPM2B       *

967  CryptEccGetParameter(

968        char                  p,                            //  IN:  the     parameter     selector

969        TPM_ECC_CURVE         curveId                       //  IN:  the     curve  id

970        )

971  {

972        const   ECC_CURVE              *curve     =  _cpri__EccGetParametersByCurveId(curveId);

973        const   TPM2B                  *parameter        =  NULL;

974

975        if(curve   !=  NULL)

     Page 294                                                  TCG Published                                           Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                             Level 00 Revision 01.16
      Part  4: Supporting Routines                                                     Trusted Platform Module Library

976         {

977             switch    (p)

978             {

979             case  'p':

980                   parameter     =  curve->curveData->p;

981                   break;

982             case  'n':

983                   parameter     =     curve->curveData->n;

984                   break;

985             case  'a':

986                   parameter     =     curve->curveData->a;

987                   break;

988             case  'b':

989                   parameter     =     curve->curveData->b;

990                   break;

991             case  'x':

992                   parameter     =     curve->curveData->x;

993                   break;

994             case  'y':

995                   parameter     =     curve->curveData->y;

996                   break;

997             case  'h':

998                   parameter     =     curve->curveData->h;

999                   break;

1000            default:

1001                  break;

1002            }

1003        }

1004        return  parameter;

1005  }

      10.2.6.5      CryptGetCurveSignScheme()

      This function will return a pointer to the scheme of the curve.

1006  const    TPMT_ECC_SCHEME         *

1007  CryptGetCurveSignScheme(

1008        TPM_ECC_CURVE           curveId              //  IN:    The  curve  selector

1009        )

1010  {

1011        const   ECC_CURVE                *curve   =     _cpri__EccGetParametersByCurveId(curveId);

1012        const   TPMT_ECC_SCHEME          *scheme     =   NULL;

1013

1014        if(curve  !=     NULL)

1015            scheme    =    &(curve->sign);

1016        return  scheme;

1017  }

      10.2.6.6      CryptEccIsPointOnCurve()

      This function will validate that an ECC point is on the curve of given curveID.

      Return Value                        Meaning

      TRUE                                if the point is on curve

      FALSE                               if the point is not on curve

1018  BOOL

1019  CryptEccIsPointOnCurve(

1020        TPM_ECC_CURVE           curveID,             //  IN:    ECC  curve  ID

1021        TPMS_ECC_POINT     *Q                        //  IN:    ECC  point

1022        )

      Family "2.0"                                       TCG Published                                  Page 295

      Level 00 Revision 01.16                 Copyright © TCG 2006-2014                   October 30, 2014
      Trusted Platform Module Library                                                                 Part 4: Supporting Routines

1023  {

1024     //     Make   sure   that    point   multiply        is  working

1025     TEST(TPM_ALG_ECC);

1026     //     Check      point  on  curve   logic       by  seeing    if  the   test    key  is  on  the    curve

1027

1028     //     Call   crypto     engine  function        to    check   if  a  ECC  public     point   is   on  the

1029     //     given      curve

1030     if(_cpri__EccIsPointOnCurve(curveID,                     Q))

1031            return     TRUE;

1032     else

1033            return     FALSE;

1034  }

      10.2.6.7      CryptNewEccKey()

      This function creates a random ECC key that is not derived from other parameters as is a Primary Key.

1035  TPM_RC

1036  CryptNewEccKey(

1037     TPM_ECC_CURVE                           curveID,               //  IN:   ECC   curve

1038     TPMS_ECC_POINT                       *publicPoint,             //  OUT:    public     point

1039     TPM2B_ECC_PARAMETER                  *sensitive                //  OUT:    private    area

1040     )

1041  {

1042     TPM_RC                           result      =   TPM_RC_SUCCESS;

1043     //     _cpri__GetEphemeralECC            may     return  CRYPT_PARAMETER

1044     if(_cpri__GetEphemeralEcc(publicPoint,                         sensitive,     curveID)    !=  CRYPT_SUCCESS)

1045            //     Something      is  wrong   with    the     key.

1046            result     =  TPM_RC_KEY;

1047

1048     return        result;

1049  }

      10.2.6.8      CryptEccPointMultiply()

      This function is used to perform a point multiply R = [d]Q. If Q is not provided,                       the  multiplication is

      performed using the generator point of the curve.

      Error Returns                       Meaning

      TPM_RC_ECC_POINT                    invalid optional ECC point pIn

      TPM_RC_NO_RESULT                    multiplication resulted in a point at infinity

      TPM_RC_CANCELED                     if a self-test was done, it might have been aborted

1050  TPM_RC

1051  CryptEccPointMultiply(

1052     TPMS_ECC_POINT                       *pOut,                    //  OUT:    output     point

1053     TPM_ECC_CURVE                           curveId,               //  IN:   curve   selector

1054     TPM2B_ECC_PARAMETER                  *dIn,                     //  IN:   public    scalar

1055     TPMS_ECC_POINT                       *pIn                      //  IN:   optional     point

1056     )

1057  {

1058     TPM2B_ECC_PARAMETER                  *n   =     NULL;

1059     CRYPT_RESULT                         retVal;

1060

1061     pAssert(pOut         !=  NULL    &&  dIn     !=  NULL);

1062

1063     if(pIn        !=  NULL)

1064     {

1065            n   =  dIn;

1066            dIn    =   NULL;

      Page 296                                                TCG Published                                          Family "2.0"

      October 30, 2014                            Copyright © TCG 2006-2014                            Level  00   Revision 01.16
      Part  4: Supporting Routines                                                                           Trusted Platform   Module     Library

1067        }

1068        //  Do   a     test  of    point   multiply

1069        TEST(TPM_ALG_ECC);

1070

1071        //  _cpri__EccPointMultiply                 may     return     CRYPT_POINT           or  CRYPT_NO_RESULT

1072        retVal      =  _cpri__EccPointMultiply(pOut,                    curveId,         dIn,    pIn,      n);

1073

1074        //  CRYPT_POINT->TPM_RC_ECC_POINT                     and    CRYPT_NO_RESULT->TPM_RC_NO_RESULT

1075        return      TranslateCryptErrors(retVal);

1076  }

      10.2.6.9       CryptGenerateKeyECC()

      This function generates an ECC key from a seed value.

      The method here may not work for objects that have an order (G) that with a different size than a private

      key.

      Error Returns                            Meaning

      TPM_RC_VALUE                             hash algorithm is not supported

1077  static    TPM_RC

1078  CryptGenerateKeyECC(

1079        TPMT_PUBLIC                *publicArea,             //    IN/OUT:       The   public         area     template     for   the  new

1080                                                            //          key.

1081        TPMT_SENSITIVE             *sensitive,              //    IN/OUT:       the   sensitive          area

1082        TPM_ALG_ID                 hashAlg,                 //    IN:   algorithm         for    the     KDF

1083        TPM2B_SEED                 *seed,                   //    IN:   the     seed     value

1084        TPM2B_NAME                 *name,                   //    IN:   the     name     of   the    object

1085        UINT32                     *counter                 //    OUT:     the  iteration            counter

1086        )

1087  {

1088        CRYPT_RESULT                      retVal;

1089

1090        TEST_HASH(hashAlg);

1091        TEST(ALG_ECDSA_VALUE);             //   ECDSA       is    used     to   verify       each    key

1092

1093        //  The     iteration      counter      has     no  meaning        for  ECC      key     generation.          The  parameter

1094        //  will       be   overloaded     for  those       implementations              that    have      a   requirement       for

1095        //  doing      pair-wise   consistency              checks     on  signing        keys.      If    the    counter   parameter

1096        //  is   0     or   NULL,  then    no   consistency          check      is   done.       If  it    is     other    than  0,   then

1097        //  a   consistency        check   is   run.        This   modification           allow      this      code   to   work  with

1098        //  the     existing       versions     of   the    CrytpoEngine            and   with       FIPS-compliant        versions

1099        //  as   well.

1100        *counter       =    (UINT32)(publicArea->objectAttributes.sign                               ==  SET);

1101

1102        //  _cpri__GenerateKeyEcc               only     has    one    error    return        (CRYPT_PARAMETER)            which      means

1103        //  that       the   hash  algorithm        is   not    supported.          This     should      not      be  possible

1104        retVal      =  _cpri__GenerateKeyEcc(&publicArea->unique.ecc,

1105                                                            &sensitive->sensitive.ecc,

1106                                                            publicArea->parameters.eccDetail.curveID,

1107                                                            hashAlg,       &seed->b,         "ECC    key      by  vendor",

1108                                                            &name->b,      counter);

1109        //  This       will  only  be     useful     if     _cpri__GenerateKeyEcc                return        CRYPT_CANCEL

1110        return      TranslateCryptErrors(retVal);

1111  }

      10.2.6.10      CryptSignECC()

      This function is used for ECC signing operations. If the signing scheme is a split scheme, and the signing

      operation is successful, the commit value is retired.

      Family "2.0"                                              TCG Published                                                            Page 297

      Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                                  October 30, 2014
      Trusted Platform Module Library                                                                   Part 4: Supporting Routines

      Error Returns                        Meaning

      TPM_RC_SCHEME                        unsupported scheme

      TPM_RC_VALUE                         invalid commit status (in case of a split scheme) or failed to generate

                                           r value.

1112  static  TPM_RC

1113  CryptSignECC(

1114     OBJECT                           *signKey,              //   IN:   ECC   key    to   sign  the   hash

1115     TPMT_SIG_SCHEME                  *scheme,               //   IN:   sign     scheme

1116     TPM2B_DIGEST                     *hashData,             //   IN:   hash     to  be   signed

1117     TPMT_SIGNATURE                   *signature             //   OUT:  signature

1118     )

1119  {

1120     TPM2B_ECC_PARAMETER                    r;

1121     TPM2B_ECC_PARAMETER                    *pr  =    NULL;

1122     CRYPT_RESULT                           retVal;

1123

1124     //   Run    a  test    of   the   ECC  sign      and  verify  if   it    has    not  already     been  run

1125     TEST_HASH(scheme->details.any.hashAlg);

1126     TEST(scheme->scheme);

1127

1128     if(CryptIsSplitSign(scheme->scheme))

1129     {

1130             //  When    this    code  was      written,     the  only  split        scheme    was  ECDAA

1131             //  (which     can  also  be       used  for    U-Prove).

1132             if(!CryptGenerateR(&r,

1133                                       &scheme->details.ecdaa.count,

1134                                       signKey->publicArea.parameters.eccDetail.curveID,

1135                                       &signKey->name))

1136                    return  TPM_RC_VALUE;

1137             pr  =  &r;

1138     }

1139     //   Call      crypto  engine     function       to   sign

1140     //   _cpri__SignEcc         may   return       CRYPT_SCHEME

1141     retVal      =  _cpri__SignEcc(&signature->signature.ecdsa.signatureR,

1142                                            &signature->signature.ecdsa.signatureS,

1143                                            scheme->scheme,

1144                                            scheme->details.any.hashAlg,

1145                                            signKey->publicArea.parameters.eccDetail.curveID,

1146                                            &signKey->sensitive.sensitive.ecc,

1147                                            &hashData->b,

1148                                            pr

1149                                            );

1150     if(CryptIsSplitSign(scheme->scheme)                     &&   retVal     ==  CRYPT_SUCCESS)

1151             CryptEndCommit(scheme->details.ecdaa.count);

1152     //   CRYPT_SCHEME->TPM_RC_SCHEME

1153     return      TranslateCryptErrors(retVal);

1154  }

      10.2.6.11      CryptECCVerifySignature()

      This function is used to verify a signature created with an ECC key.

      Error Returns                        Meaning

      TPM_RC_SIGNATURE                     if signature is not valid

      TPM_RC_SCHEME                        the signing scheme or hashAlg is not supported

1155  static  TPM_RC

1156  CryptECCVerifySignature(

1157     OBJECT                     *signKey,             //     IN:  ECC   key   signed      the   hash

      Page 298                                            TCG Published                                              Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                           Level  00  Revision 01.16
      Part  4: Supporting Routines                                                                              Trusted Platform Module Library

1158        TPM2B_DIGEST                *digestData,                 //   IN:     digest    being    signed

1159        TPMT_SIGNATURE              *signature                   //   IN:     signature      to  be     verified

1160        )

1161  {

1162        CRYPT_RESULT                         retVal;

1163

1164        TEST_HASH(signature->signature.any.hashAlg);

1165        TEST(signature->sigAlg);

1166

1167        //     This       implementation        uses     the     fact   that      all   the   defined       ECC       signing

1168        //     schemes        have  the      hash   as   the     first     parameter.

1169        //     _cpriValidateSignatureEcc                    may  return       CRYPT_FAIL         or     CRYP_SCHEME

1170        retVal         =  _cpri__ValidateSignatureEcc(&signature->signature.ecdsa.signatureR,

1171                                                               &signature->signature.ecdsa.signatureS,

1172                                                               signature->sigAlg,

1173                                                               signature->signature.any.hashAlg,

1174                                                               signKey->publicArea.parameters.eccDetail.curveID,

1175                                                               &signKey->publicArea.unique.ecc,

1176                                                               &digestData->b);

1177        if(retVal             ==  CRYPT_FAIL)

1178               return         TPM_RC_SIGNATURE;

1179        //     CRYPT_SCHEME->TPM_RC_SCHEME

1180        return         TranslateCryptErrors(retVal);

1181  }

      10.2.6.12        CryptGenerateR()

      This function computes the commit random value for a split signing scheme.

      If c is NULL, it indicates that r is being generated for TPM2_Commit(). If c is not NULL, the TPM will

      validate that the gr.commitArray bit associated with the input value of c is SET. If not, the TPM returns

      FALSE and no r value is generated.

      Return Value                                  Meaning

      TRUE                                          r value computed

      FALSE                                         no r value computed

1182  BOOL

1183  CryptGenerateR(

1184        TPM2B_ECC_PARAMETER                        *r,                        //   OUT:  the     generated            random    value

1185        UINT16                                     *c,                        //   IN/OUT:       count      value.

1186        TPMI_ECC_CURVE                              curveID,                  //   IN:   the     curve      for   the      value

1187        TPM2B_NAME                                 *name                      //   IN:   optional           name  of   a   key    to

1188                                                                              //         associate          with      'r'

1189        )

1190  {

1191        //     This       holds   the    marshaled       g_commitCounter.

1192        TPM2B_TYPE(8B,              8);

1193        TPM2B_8B                                   cntr     =  {8,{0}};

1194

1195        UINT32                                      iterations;

1196        const      TPM2B                           *n;

1197        UINT64                                      currentCount           =  gr.commitCounter;

1198        //     This       is  just  to   suppress        a     compiler       warning    about       a  conditional        expression

1199        //     being      a   constant.      This   is      because     of    the  macro      expansion           of  ryptKDFa

1200        TPMI_ALG_HASH                               hashAlg      =    CONTEXT_INTEGRITY_HASH_ALG;

1201

1202        n   =      CryptEccGetParameter('n',                   curveID);

1203        pAssert(r             !=  NULL   &&  n  !=  NULL);

1204

1205        //     If  this       is  the    commit     phase,       use   the    current    value          of  the   commit      counter

1206        if(c       !=     NULL)

      Family "2.0"                                                   TCG Published                                                         Page 299

      Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                              October 30, 2014
      Trusted Platform Module Library                                                                                            Part 4: Supporting Routines

1207     {

1208

1209            UINT16                      t1;

1210            //   if     the       array         bit       is   not       set,    can't        use   the     value.

1211            if(!BitIsSet((*c                       &  COMMIT_INDEX_MASK),                     gr.commitArray,

1212                                           sizeof(gr.commitArray)))

1213                    return           FALSE;

1214

1215            //   If     it       is     the     sign       phase,           figure     out    what      the     counter      value      was

1216            //   when         the       commitment             was       made.

1217            //

1218            //   When         gr.commitArray                   has       less    than         64K  bits,     the     extra

1219            //   bits         of     'c'       are    used        as     a  check      to     make     sure     that    the

1220            //   signing             operation             is     not       using      an     out  of   range     count      value

1221            t1   =   (UINT16)currentCount;

1222

1223            //   If     the       lower         bits       of     c   are       greater       or   equal     to   the      lower    bits     of  t1

1224            //   then         the       upper         bits     of     t1    must       be     one  more     than     the     upper    bits

1225            //   of     c

1226            if((*c         &     COMMIT_INDEX_MASK)                         >=   (t1   &      COMMIT_INDEX_MASK))

1227                    //     Since           the     counter           is     behind,        reduce      the   current         count

1228                    currentCount                   =  currentCount               -     (COMMIT_INDEX_MASK               +    1);

1229

1230            t1   =   (UINT16)currentCount;

1231            if((t1         &     ~COMMIT_INDEX_MASK)                        !=   (*c       &  ~COMMIT_INDEX_MASK))

1232                    return           FALSE;

1233            //   set       the       counter          to      the     value      that         was

1234            //   present             when       the       commitment             was   made

1235            currentCount                   =   (currentCount                &    0xffffffffffff0000)                 |  *c;

1236

1237     }

1238     //  Marshal           the       count         value       to     a     TPM2B      buffer      for   the     KDF

1239     cntr.t.size              =   sizeof(currentCount);

1240     UINT64_TO_BYTE_ARRAY(currentCount,                                          cntr.t.buffer);

1241

1242     //  Now     can       do     the         KDF     to   create           the  random       value      for     the    signing       operation

1243     //  During         the       creation            process,              we   may   generate         an   r   that      does   not   meet     the

1244     //  requirements                   of     the    random          value.

1245     //  want       to     generate             a     new     r.

1246

1247     r->t.size          =     n->size;

1248

1249     //  Arbitrary               upper         limit       on     the       number     of     times     that     we     can  look     for

1250     //  a  suitable              random           value.            The    normally          number     of     tries      will   be    1.

1251     for(iterations                  =     1;   iterations               <  1000000;)

1252     {

1253            BYTE              *pr       =     &r->b.buffer[0];

1254            int               i;

1255            CryptKDFa(hashAlg,                        &gr.commitNonce.b,                      "ECDAA     Commit",

1256                                  name,         &cntr.b,             n->size        *  8,     r->t.buffer,           &iterations);

1257

1258            //   random           value         must       be     less      than       the    prime

1259            if(CryptCompare(r->b.size,                                   r->b.buffer,              n->size,      n->buffer)         >=  0)

1260                    continue;

1261

1262            //   in     this         implementation                   it    is   required          that     at   least       bit

1263            //   in     the       upper         half       of     the       number     be     set

1264            for(i       =     n->size/2;              i    >   0;     i--)

1265                    if(*pr++               !=   0)

1266                              return           TRUE;

1267     }

1268     return      FALSE;

1269  }

      Page 300                                                                  TCG Published                                                        Family "2.0"

      October 30, 2014                                            Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
      Part 4: Supporting Routines                                                           Trusted Platform Module Library

      10.2.6.13     CryptCommit()

      This function is called when the count value is committed. The gr.commitArray value associated with              the

      current count value is SET and g_commitCounter is incremented. The low-order 16 bits of old value of             the

      counter is returned.

1270  UINT16

1271  CryptCommit(

1272        void

1273        )

1274  {

1275        UINT16          oldCount  =  (UINT16)gr.commitCounter;

1276        gr.commitCounter++;

1277        BitSet(oldCount    &     COMMIT_INDEX_MASK,  gr.commitArray,                sizeof(gr.commitArray));

1278        return  oldCount;

1279  }

      10.2.6.14     CryptEndCommit()

      This function is called when the signing operation using the committed value is completed. It clears             the

      gr.commitArray bit associated with the count value so that it can't be used again.

1280  void

1281  CryptEndCommit(

1282        UINT16                c               //  IN:     the  counter         value     of   the     commitment

1283        )

1284  {

1285        BitClear((c     &  COMMIT_INDEX_MASK),    gr.commitArray,              sizeof(gr.commitArray));

1286  }

      10.2.6.15     CryptCommitCompute()

      This function performs the computations for the TPM2_Commit() command. This could be a macro.

      Error Returns                      Meaning

      TPM_RC_NO_RESULT                   K, L, or E is the point at infinity

      TPM_RC_CANCELLED                   command was canceled

1287  TPM_RC

1288  CryptCommitCompute(

1289        TPMS_ECC_POINT               *K,                   //  OUT:          [d]B

1290        TPMS_ECC_POINT               *L,                   //  OUT:          [r]B

1291        TPMS_ECC_POINT               *E,                   //  OUT:          [r]M

1292        TPM_ECC_CURVE                curveID,              //  IN:        The  curve     for     the  computation

1293        TPMS_ECC_POINT               *M,                   //  IN:        M  (P1)

1294        TPMS_ECC_POINT               *B,                   //  IN:        B  (x2,   y2)

1295        TPM2B_ECC_PARAMETER          *d,                   //  IN:        the  private       scalar

1296        TPM2B_ECC_PARAMETER          *r                    //  IN:        the  computed       r   value

1297        )

1298  {

1299        TEST(ALG_ECDH_VALUE);

1300        //  CRYPT_NO_RESULT->TPM_RC_NO_RESULT        CRYPT_CANCEL->TPM_RC_CANCELLED

1301        return  TranslateCryptErrors(

1302                     _cpri__EccCommitCompute(K,        L   ,   E,         curveID,  M,   B,   d,   r));

1303  }

      Family "2.0"                                  TCG Published                                                     Page 301

      Level 00 Revision 01.16                Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                            Part 4: Supporting Routines

      10.2.6.16       CryptEccGetParameters()

      This function returns the ECC parameter details of the given curve

      Return Value                             Meaning

      TRUE                                     Get parameters success

      FALSE                                    Unsupported ECC curve ID

1304  BOOL

1305  CryptEccGetParameters(

1306        TPM_ECC_CURVE                         curveId,                //  IN:    ECC  curve  ID

1307        TPMS_ALGORITHM_DETAIL_ECC             *parameters             //  OUT:   ECC  parameter

1308        )

1309  {

1310        const     ECC_CURVE                   *curve     =  _cpri__EccGetParametersByCurveId(curveId);

1311        const     ECC_CURVE_DATA              *data;

1312        BOOL                                  found      =  curve    !=   NULL;

1313

1314        if(found)

1315        {

1316

1317              data  =   curve->curveData;

1318

1319              parameters->curveID          =  curve->curveId;

1320

1321              //  Key   size  in   bit

1322              parameters->keySize          =  curve->keySizeBits;

1323

1324              //  KDF

1325              parameters->kdf        =     curve->kdf;

1326

1327              //  Sign

1328              parameters->sign          =  curve->sign;

1329

1330              //  Copy  p   value

1331              MemoryCopy2B(&parameters->p.b,             data->p,     sizeof(parameters->p.t.buffer));

1332

1333              //  Copy  a   value

1334              MemoryCopy2B(&parameters->a.b,             data->a,     sizeof(parameters->a.t.buffer));

1335

1336              //  Copy  b   value

1337              MemoryCopy2B(&parameters->b.b,             data->b,     sizeof(parameters->b.t.buffer));

1338

1339              //  Copy  Gx    value

1340              MemoryCopy2B(&parameters->gX.b,               data->x,     sizeof(parameters->gX.t.buffer));

1341

1342              //  Copy  Gy    value

1343              MemoryCopy2B(&parameters->gY.b,               data->y,     sizeof(parameters->gY.t.buffer));

1344

1345              //  Copy  n   value

1346              MemoryCopy2B(&parameters->n.b,             data->n,     sizeof(parameters->n.t.buffer));

1347

1348              //  Copy  h   value

1349              MemoryCopy2B(&parameters->h.b,             data->h,     sizeof(parameters->h.t.buffer));

1350        }

1351        return    found;

1352  }

1353  #if   CC_ZGen_2Phase        ==  YES

      CryptEcc2PhaseKeyExchange() This is the interface to the key exchange function.

1354  TPM_RC

1355  CryptEcc2PhaseKeyExchange(

      Page 302                                              TCG Published                            Family "2.0"

      October 30, 2014                            Copyright © TCG 2006-2014                      Level 00 Revision 01.16
      Part 4: Supporting Routines                                                               Trusted Platform Module           Library

1356        TPMS_ECC_POINT                   *outZ1,                   //  OUT:  the        computed      point

1357        TPMS_ECC_POINT                   *outZ2,                   //  OUT:  optional            second    point

1358        TPM_ALG_ID                       scheme,                   //  IN:   the    key     exchange       scheme

1359        TPM_ECC_CURVE                    curveId,                  //  IN:   the    curve        for  the      computation

1360        TPM2B_ECC_PARAMETER              *dsA,                     //  IN:   static         private       TPM  key

1361        TPM2B_ECC_PARAMETER              *deA,                     //  IN:   ephemeral           private       TPM  key

1362        TPMS_ECC_POINT                   *QsB,                     //  IN:   static         public    party     B   key

1363        TPMS_ECC_POINT                   *QeB                      //  IN:   ephemeral           public    party    B    key

1364        )

1365  {

1366        return    (TranslateCryptErrors(_cpri__C_2_2_KeyExchange(outZ1,

1367                                                                                            outZ2,

1368                                                                                            scheme,

1369                                                                                            curveId,

1370                                                                                            dsA,

1371                                                                                            deA,

1372                                                                                            QsB,

1373                                                                                            QeB)));

1374  }

1375  #endif    //    CC_ZGen_2Phase

1376  #endif    //TPM_ALG_ECC      //%    3

      10.2.6.17      CryptIsSchemeAnonymous()

      This function is used to test a scheme to see if it is an anonymous scheme The only anonymous                               scheme

      is ECDAA. ECDAA can be used to do things like U-Prove.

1377  BOOL

1378  CryptIsSchemeAnonymous(

1379        TPM_ALG_ID             scheme                //  IN:   the     scheme       algorithm         to  test

1380        )

1381  {

1382  #ifdef    TPM_ALG_ECDAA

1383        return    (scheme  ==  TPM_ALG_ECDAA);

1384  #else

1385        UNREFERENCED(scheme);

1386        return    0;

1387  #endif

1388  }

      10.2.7      Symmetric Functions

      10.2.7.1       ParmDecryptSym()

      This function performs parameter decryption using symmetric block cipher.

1389  void

1390  ParmDecryptSym(

1391        TPM_ALG_ID             symAlg,               //  IN:   the     symmetric        algorithm

1392        TPM_ALG_ID             hash,                 //  IN:   hash    algorithm            for   KDFa

1393        UINT16                 keySizeInBits,        //  IN:   key     key   size       in  bit

1394        TPM2B              *key,                     //  IN:   KDF     HMAC  key

1395        TPM2B              *nonceCaller,             //  IN:   nonce   caller

1396        TPM2B              *nonceTpm,                //  IN:   nonce   TPM

1397        UINT32                 dataSize,             //  IN:   size    of    parameter           buffer

1398        BYTE               *data                     //  OUT:      buffer    to     be  decrypted

1399        )

1400  {

1401        //  KDF   output   buffer

1402        //  It   contains  parameters     for   the      CFB  encryption

1403        //  From  MSB  to  LSB,    they  are    the  key      and  iv

1404        BYTE                   symParmString[MAX_SYM_KEY_BYTES                   +  MAX_SYM_BLOCK_SIZE];

      Family "2.0"                                       TCG Published                                                       Page 303

      Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                             October 30, 2014
      Trusted Platform Module Library                                                                         Part 4: Supporting  Routines

1405        //  Symmetric     key    size    in  byte

1406        UINT16                   keySize     =   (keySizeInBits              +  7)    /   8;

1407        TPM2B_IV                 iv;

1408

1409        iv.t.size     =  CryptGetSymmetricBlockSize(symAlg,                           keySizeInBits);

1410        //  If    there  is  decryption          to     do...

1411        if(iv.t.size      >  0)

1412        {

1413              //  Generate     key    and    iv

1414              CryptKDFa(hash,         key,   "CFB",     nonceCaller,            nonceTpm,

1415                             keySizeInBits           +  (iv.t.size      *       8),   symParmString,            NULL);

1416              MemoryCopy(iv.t.buffer,                &symParmString[keySize],                    iv.t.size,

1417                             sizeof(iv.t.buffer));

1418

1419              CryptSymmetricDecrypt(data,               symAlg,         keySizeInBits,               TPM_ALG_CFB,

1420                                                 symParmString,         &iv,         dataSize,       data);

1421        }

1422        return;

1423  }

      10.2.7.2        ParmEncryptSym()

      This function performs parameter encryption using symmetric block cipher.

1424  void

1425  ParmEncryptSym(

1426        TPM_ALG_ID               symAlg,                //     IN:      symmetric         algorithm

1427        TPM_ALG_ID               hash,                  //     IN:      hash    algorithm            for  KDFa

1428        UINT16                   keySizeInBits,         //     IN:      AES     key   size       in  bit

1429        TPM2B                  *key,                    //     IN:      KDF     HMAC     key

1430        TPM2B                  *nonceCaller,            //     IN:      nonce   caller

1431        TPM2B                  *nonceTpm,               //     IN:      nonce   TPM

1432        UINT32                   dataSize,              //     IN:      size    of    parameter           buffer

1433        BYTE                   *data                    //     OUT:     buffer        to     be  encrypted

1434        )

1435  {

1436        //  KDF   output     buffer

1437        //  It    contains   parameters          for    the    CFB  encryption

1438        BYTE                     symParmString[MAX_SYM_KEY_BYTES                          +   MAX_SYM_BLOCK_SIZE];

1439

1440        //  Symmetric     key    size    in  bytes

1441        UINT16                   keySize     =   (keySizeInBits              +  7)    /   8;

1442

1443        TPM2B_IV                 iv;

1444

1445        iv.t.size     =  CryptGetSymmetricBlockSize(symAlg,                           keySizeInBits);

1446        //  See   if  there    is   any    encryption          to   do

1447        if(iv.t.size      >  0)

1448        {

1449              //  Generate     key    and    iv

1450              CryptKDFa(hash,         key,   "CFB",     nonceTpm,            nonceCaller,

1451                             keySizeInBits           +  (iv.t.size      *       8),   symParmString,            NULL);

1452

1453              MemoryCopy(iv.t.buffer,                &symParmString[keySize],                    iv.t.size,

1454                             sizeof(iv.t.buffer));

1455

1456              CryptSymmetricEncrypt(data,               symAlg,         keySizeInBits,               TPM_ALG_CFB,

1457                                                 symParmString,         &iv,         dataSize,       data);

1458        }

1459        return;

1460  }

      Page 304                                              TCG Published                                                   Family "2.0"

      October 30, 2014                               Copyright © TCG 2006-2014                                Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                            Trusted Platform Module Library

      10.2.7.3        CryptGenerateNewSymmetric()

      This function creates the sensitive symmetric values for an HMAC or symmetric key. If the sensitive area

      is zero, then the sensitive creation key data is copied. If it is not zero, then the TPM will generate a

      random value of the selected size.

1461  void

1462  CryptGenerateNewSymmetric(

1463        TPMS_SENSITIVE_CREATE                  *sensitiveCreate,                     //  IN:    sensitive         creation         data

1464        TPMT_SENSITIVE                         *sensitive,                           //  OUT:      sensitive      area

1465        TPM_ALG_ID                                hashAlg,                           //  IN:    hash     algorithm         for     the   KDF

1466        TPM2B_SEED                             *seed,                                //  IN:    seed     used     in   creation

1467        TPM2B_NAME                             *name                                 //  IN:    name     of  the      object

1468        )

1469  {

1470        //  This    function        is  called     to    create         a     key  and   obfuscation         value      for     a

1471        //  symmetric       key     that     can   either       be   a     block     cipher     or  an    XOR     key.     The     buffer

1472        //  in    sensitive->sensitive             will        hold     either.         When  we    call     the  function

1473        //  to    copy  the      input    value    or    generated             value     to   the   sensitive->sensitive

1474        //  buffer      we  will     need    to    have     a   size       for     the   output     buffer.       This     define

1475        //  computes        the  maximum       that     it     might       need    to    be   and   uses     that.     It  will      always

1476        //  be    smaller    than       the  largest        value       that       will  fit.

1477        #define     MAX_SENSITIVE_SIZE                                                                                                     \

1478              (MAX(sizeof(sensitive->sensitive.bits.t.buffer),                                                                             \

1479                    sizeof(sensitive->sensitive.sym.t.buffer)))

1480

1481        //  set   the   size     of     the  obfuscation            value

1482        sensitive->seedValue.t.size                  =   CryptGetHashDigestSize(hashAlg);

1483

1484        //  If    the   input    sensitive         size     is     zero,       then     create     both   the     sensitive        data

1485        //  and   the   obfuscation          value

1486        if(sensitiveCreate->data.t.size                        ==   0)

1487        {

1488              BYTE                                   symValues[MAX(MAX_DIGEST_SIZE,                          MAX_SYM_KEY_BYTES)

1489                                                                           +   MAX_DIGEST_SIZE];

1490              UINT16                                 requestSize;

1491

1492              //  Set   the      size   of   the   request          to     be   the     size  of    the   key     and   the

1493              //  obfuscation           value

1494              requestSize        =      sensitive->sensitive.sym.t.size

1495                                     +  sensitive->seedValue.t.size;

1496              pAssert(requestSize              <=  sizeof(symValues));

1497

1498              requestSize        =   _cpri__GenerateSeededRandom(requestSize,                                symValues,            hashAlg,

1499                                                                                         &seed->b,

1500                                                                                         "symmetric       sensitive",           &name->b,

1501                                                                                         NULL);

1502              pAssert(requestSize              !=  0);

1503

1504              //  Copy      the  new    key

1505              MemoryCopy(sensitive->sensitive.sym.t.buffer,

1506                                 symValues,        sensitive->sensitive.sym.t.size,

1507                                 MAX_SENSITIVE_SIZE);

1508

1509              //  copy      the  obfuscation         value

1510              MemoryCopy(sensitive->seedValue.t.buffer,

1511                                 &symValues[sensitive->sensitive.sym.t.size],

1512                                 sensitive->seedValue.t.size,

1513                                 sizeof(sensitive->seedValue.t.buffer));

1514        }

1515        else

1516        {

1517              //  Copy      input    symmetric       key       to   sensitive           area  as    long     as   it   will     fit

1518              MemoryCopy2B(&sensitive->sensitive.sym.b,                                  &sensitiveCreate->data.b,

1519                                    MAX_SENSITIVE_SIZE);

      Family "2.0"                                                 TCG Published                                                             Page 305

      Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                               October 30, 2014
      Trusted Platform Module Library                                                                   Part 4: Supporting Routines

1520

1521            //    Create     the  obfuscation         value

1522            _cpri__GenerateSeededRandom(sensitive->seedValue.t.size,

1523                                                         sensitive->seedValue.t.buffer,

1524                                                         hashAlg,       &seed->b,

1525                                                         "symmetric        obfuscation",       &name->b,         NULL);

1526     }

1527     return;

1528  }

      10.2.7.4      CryptGenerateKeySymmetric()

      This function derives a symmetric cipher key from the provided seed.

      Error Returns                           Meaning

      TPM_RC_KEY_SIZE                         key size in the public area does not match the size in the sensitive

                                              creation area

1529  static    TPM_RC

1530  CryptGenerateKeySymmetric(

1531     TPMT_PUBLIC                              *publicArea,                 //   IN/OUT:     The     public       area  template

1532                                                                           //         for   the     new    key.

1533     TPMS_SENSITIVE_CREATE                    *sensitiveCreate,            //   IN:   sensitive        creation        data

1534     TPMT_SENSITIVE                           *sensitive,                  //   OUT:  sensitive            area

1535     TPM_ALG_ID                                hashAlg,                    //   IN:   hash  algorithm            for   the   KDF

1536     TPM2B_SEED                               *seed,                       //   IN:   seed  used       in  creation

1537     TPM2B_NAME                               *name                        //   IN:   name  of      the    object

1538     )

1539  {

1540     //     If  this    is   not  a   new     key,   then     the  provided     key   data  must       be  the   right       size

1541     if(publicArea->objectAttributes.sensitiveDataOrigin                              ==    CLEAR)

1542     {

1543            if(         (sensitiveCreate->data.t.size                   *  8)

1544                  !=    publicArea->parameters.symDetail.sym.keyBits.sym)

1545                  return     TPM_RC_KEY_SIZE;

1546            //    Make  sure      that    the  key    size    is   OK.

1547            //    This  implementation         only      supports       symmetric     key   sizes      that      are

1548            //    multiples       of  8

1549            if(publicArea->parameters.symDetail.sym.keyBits.sym                             %    8     !=  0)

1550                  return     TPM_RC_KEY_SIZE;

1551     }

1552     else

1553     {

1554            //    TPM   is   going    to   generate      the  key  so      set  the   size

1555            sensitive->sensitive.sym.t.size

1556                  =    publicArea->parameters.symDetail.sym.keyBits.sym                             /  8;

1557            sensitiveCreate->data.t.size                   =  0;

1558     }

1559     //     Fill  in    the  sensitive         area

1560     CryptGenerateNewSymmetric(sensitiveCreate,                            sensitive,      hashAlg,

1561                                               seed,     name);

1562

1563     //     Create     unique     area    in   public

1564     CryptComputeSymmetricUnique(publicArea->nameAlg,

1565                                                    sensitive,     &publicArea->unique.sym);

1566

1567     return       TPM_RC_SUCCESS;

1568  }

      Page 306                                               TCG Published                                                 Family "2.0"

      October 30, 2014                             Copyright © TCG 2006-2014                               Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                Trusted Platform Module Library

      10.2.7.5        CryptXORObfuscation()

      This   function     implements          XOR      obfuscation.       It  should        not  be    called      if  the  hash   algorithm      is      not

      implemented. The only return value from this function is TPM_RC_SUCCESS.

1569  #ifdef    TPM_ALG_KEYEDHASH                 //%   5

1570  void

1571  CryptXORObfuscation(

1572        TPM_ALG_ID                  hash,                         //  IN:      hash     algorithm         for  KDF

1573        TPM2B                      *key,                          //  IN:      KDF   key

1574        TPM2B                      *contextU,                     //  IN:      contextU

1575        TPM2B                      *contextV,                     //  IN:      contextV

1576        UINT32                      dataSize,                     //  IN:      size     of   data  buffer

1577        BYTE                       *data                          //  IN/OUT:        data    to    be     XORed    in   place

1578        )

1579  {

1580        BYTE                        mask[MAX_DIGEST_SIZE];                     //    Allocate      a      digest    sized  buffer

1581        BYTE                       *pm;

1582        UINT32                      i;

1583        UINT32                      counter         =   0;

1584        UINT16                      hLen      =    CryptGetHashDigestSize(hash);

1585        UINT32                      requestSize             =  dataSize        *    8;

1586        INT32                       remainBytes             =  (INT32)         dataSize;

1587

1588        pAssert((key           !=  NULL)      &&    (data      !=     NULL)    &&    (hLen   !=    0));

1589

1590        //  Call      KDFa     to  generate         XOR     mask

1591        for(;     remainBytes          >  0;     remainBytes          -=    hLen)

1592        {

1593              //   Make     a  call       to  KDFa      to     get    next     iteration

1594              CryptKDFaOnce(hash,                  key,     "XOR",    contextU,             contextV,

1595                                       requestSize,            mask,      &counter);

1596

1597              //   XOR     next    piece      of    the     data

1598              pm   =  mask;

1599              for(i     =   hLen    <     remainBytes          ?    hLen    :  remainBytes;            i  >    0;  i--)

1600                      *data++      ^=     *pm++;

1601        }

1602        return;

1603  }

1604  #endif    //TPM_ALG_KEYED_HASH                   //%5

      10.2.8      Initialization and shut down

      10.2.8.1        CryptInitUnits()

      This function is called when the TPM receives a _TPM_Init() indication. After function returns, the hash

      algorithms should be available.

      NOTE:               The hash algorithms do not have to be tested, they just need to be available. They have                 to  be  tested  before  the

                          TPM can accept HMAC authorization or return any result that relies on a hash algorithm.

1605  void

1606  CryptInitUnits(

1607        void

1608        )

1609  {

1610        //  Initialize         the     vector       of   implemented           algorithms

1611        AlgorithmGetImplementedVector(&g_implementedAlgorithms);

1612

1613        //  Indicate        that    all       test     are     necessary

1614        CryptInitializeToTest();

      Family "2.0"                                                    TCG Published                                                       Page 307

      Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                           October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines

1615

1616        //   Call     crypto      engine       unit     initialization

1617        //   It   is  assumed       that       crypt    engine         initialization        should    always    succeed.

1618        //   Otherwise,       TPM      should      go   to     failure      mode.

1619        if(_cpri__InitCryptoUnits(&TpmFail)                            !=   CRYPT_SUCCESS)

1620              FAIL(FATAL_ERROR_INTERNAL);

1621        return;

1622  }

      10.2.8.2        CryptStopUnits()

      This function is only used in a simulated environment. There should be no reason to shut down the

      cryptography on an actual TPM other than loss of power. After receiving TPM2_Startup(), the TPM should

      be  able    to  accept      commands         until    it     loses   power  and,      unless   the   TPM   is  in  Failure   Mode,    the

      cryptographic algorithms should be available.

1623  void

1624  CryptStopUnits(

1625        void

1626        )

1627  {

1628        //   Call     crypto      engine       unit     stopping

1629        _cpri__StopCryptoUnits();

1630

1631        return;

1632  }

      10.2.8.3        CryptUtilStartup()

      This  function      is  called   by  TPM2_Startup()              to  initialize  the  functions  in  this  crypto  library   and  in  the

      provided    CryptoEngine().          In   this     implementation,        the    only  initialization  required    in  this  library  is

      initialization of the Commit nonce on TPM Reset.

      This function returns false if some problem prevents the functions from starting correctly. The TPM should

      go into failure mode.

1633  BOOL

1634  CryptUtilStartup(

1635        STARTUP_TYPE                type                           //  IN:  the    startup   type

1636        )

1637  {

1638        //   Make     sure    that     the     crypto       library       functions     are  ready.

1639        //   NOTE:    need    to    initialize          the        crypto   before      loading

1640        //   the   RND     state    may     trigger         a  self-test      which

1641        //   uses     the

1642        if(   !_cpri__Startup())

1643              return       FALSE;

1644

1645        //   Initialize       the      state   of       the    RNG.

1646        CryptDrbgGetPutState(PUT_STATE);

1647

1648        if(type       ==   SU_RESET)

1649        {

1650  #ifdef     TPM_ALG_ECC

1651              //   Get     a  new      random      commit          nonce

1652              gr.commitNonce.t.size                  =  sizeof(gr.commitNonce.t.buffer);

1653              _cpri__GenerateRandom(gr.commitNonce.t.size,                               gr.commitNonce.t.buffer);

1654              //   Reset      the   counter        and      commit     array

1655              gr.commitCounter              =  0;

1656              MemorySet(gr.commitArray,                        0,  sizeof(gr.commitArray));

1657  #endif     //   TPM_ALG_ECC

1658        }

      Page 308                                                         TCG Published                                           Family "2.0"

      October 30, 2014                                    Copyright © TCG 2006-2014                              Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                 Trusted Platform Module Library

1659

1660        //   If   the  shutdown       was   orderly,  then  the  values          recovered    from  NV    will

1661        //   be   OK   to  use.   If   the  shutdown  was   not  orderly,            then  a  TPM  Reset    was  required

1662        //   and  we   would     have  initialized    in    the  code        above.

1663

1664        return    TRUE;

1665  }

      10.2.9     Algorithm-Independent Functions

      10.2.9.1        Introduction

      These functions are used generically when a function of a general type (e.g., symmetric encryption) is

      required.  The functions will modify the parameters as required to interface to the indicated algorithms.

      10.2.9.2        CryptIsAsymAlgorithm()

      This function indicates if an algorithm is an asymmetric algorithm.

      Return Value                             Meaning

      TRUE                                     if it is an asymmetric algorithm

      FALSE                                    if it is not an asymmetric algorithm

1666  BOOL

1667  CryptIsAsymAlgorithm(

1668        TPM_ALG_ID                algID               //  IN:    algorithm       ID

1669        )

1670  {

1671        return    (

1672  #ifdef     TPM_ALG_RSA

1673                       algID  ==      TPM_ALG_RSA

1674  #endif

1675  #if   defined       TPM_ALG_RSA      &&   defined   TPM_ALG_ECC

1676                       ||

1677  #endif

1678  #ifdef     TPM_ALG_ECC

1679                       algID  ==  TPM_ALG_ECC

1680  #endif

1681                  );

1682  }

      10.2.9.3        CryptGetSymmetricBlockSize()

      This function returns the size in octets of the symmetric encryption block used                   by  an  algorithm  and  key

      size combination.

1683  INT16

1684  CryptGetSymmetricBlockSize(

1685        TPMI_ALG_SYM              algorithm,          //  IN:    symmetric       algorithm

1686        UINT16                    keySize             //  IN:    key  size       in  bit

1687        )

1688  {

1689        return    _cpri__GetSymmetricBlockSize(algorithm,                        keySize);

1690  }

      Family "2.0"                                        TCG Published                                              Page 309

      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines

      10.2.9.4        CryptSymmetricEncrypt()

      This function does in-place encryption of a buffer using the indicated symmetric algorithm, key,                               IV,  and

      mode. If the symmetric algorithm and mode are not defined, the TPM will fail.

1691  void

1692  CryptSymmetricEncrypt(

1693        BYTE                             *encrypted,                 //  OUT:  the      encrypted         data

1694        TPM_ALG_ID                       algorithm,                  //  IN:   algorithm         for     encryption

1695        UINT16                           keySizeInBits,              //  IN:   key   size       in   bit

1696        TPMI_ALG_SYM_MODE                mode,                       //  IN:   symmetric         encryption     mode

1697        BYTE                             *key,                       //  IN:   encryption           key

1698        TPM2B_IV                         *ivIn,                      //  IN/OUT:     Input       IV   and   output     chaining

1699                                                                     //        value       for   the     next   block

1700        UINT32                           dataSize,                   //  IN:   data     size     in   byte

1701        BYTE                             *data                       //  IN/OUT:     data       buffer

1702        )

1703  {

1704

1705        TPM2B_IV                         defaultIv          =    {0};

1706        TPM2B_IV                         *iv  =     (ivIn       !=   NULL)  ?  ivIn     :  &defaultIv;

1707

1708     TEST(algorithm);

1709

1710        pAssert(encrypted            !=  NULL       &&  key      !=  NULL);

1711

1712        //  this     check   can     pass     but    the    case     below     can  fail.       ALG_xx_VALUE    values  are

1713        //  defined     for     all   algorithms            but     the  TPM_ALG_xx        might     not   be.

1714        if(algorithm        ==  ALG_AES_VALUE               ||   algorithm     ==   ALG_SM4_VALUE)

1715        {

1716              if(mode   !=      TPM_ALG_ECB)

1717                     defaultIv.t.size            =   16;

1718              //  A     provided     IV  has     to     be  the      right  size

1719              pAssert(mode        ==     TPM_ALG_ECB            ||   iv->t.size     ==     16);

1720        }

1721        switch(algorithm)

1722        {

1723  #ifdef    TPM_ALG_AES

1724              case      TPM_ALG_AES:

1725              {

1726                     switch     (mode)

1727                     {

1728                        case      TPM_ALG_CTR:

1729                                _cpri__AESEncryptCTR(encrypted,                         keySizeInBits,          key,

1730                                                                         iv->t.buffer,     dataSize,           data);

1731                                break;

1732                        case      TPM_ALG_OFB:

1733                                _cpri__AESEncryptOFB(encrypted,                         keySizeInBits,          key,

1734                                                                         iv->t.buffer,     dataSize,           data);

1735                                break;

1736                        case      TPM_ALG_CBC:

1737                                _cpri__AESEncryptCBC(encrypted,                         keySizeInBits,          key,

1738                                                                         iv->t.buffer,     dataSize,           data);

1739                                break;

1740                        case      TPM_ALG_CFB:

1741                                _cpri__AESEncryptCFB(encrypted,                         keySizeInBits,          key,

1742                                                                         iv->t.buffer,     dataSize,           data);

1743                                break;

1744                        case      TPM_ALG_ECB:

1745                                _cpri__AESEncryptECB(encrypted,                         keySizeInBits,          key,

1746                                                                         dataSize,   data);

1747                                break;

1748                        default:

1749                                pAssert(0);

1750                     }

      Page 310                                                      TCG Published                                           Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
      Part 4: Supporting Routines                                                     Trusted Platform  Module  Library

1751              }

1752              break;

1753  #endif

1754  #ifdef    TPM_ALG_SM4

1755              case     TPM_ALG_SM4:

1756              {

1757                    switch  (mode)

1758                    {

1759                        case  TPM_ALG_CTR:

1760                              _cpri__SM4EncryptCTR(encrypted,       keySizeInBits,       key,

1761                                                     iv->t.buffer,        dataSize,     data);

1762                              break;

1763                        case  TPM_ALG_OFB:

1764                              _cpri__SM4EncryptOFB(encrypted,       keySizeInBits,       key,

1765                                                     iv->t.buffer,        dataSize,     data);

1766                              break;

1767                        case  TPM_ALG_CBC:

1768                              _cpri__SM4EncryptCBC(encrypted,       keySizeInBits,       key,

1769                                                     iv->t.buffer,        dataSize,     data);

1770                              break;

1771

1772                        case  TPM_ALG_CFB:

1773                              _cpri__SM4EncryptCFB(encrypted,       keySizeInBits,       key,

1774                                                     iv->t.buffer,        dataSize,     data);

1775                              break;

1776                        case  TPM_ALG_ECB:

1777                              _cpri__SM4EncryptECB(encrypted,       keySizeInBits,       key,

1778                                                     dataSize,      data);

1779                              break;

1780                        default:

1781                              pAssert(0);

1782                    }

1783              }

1784              break;

1785

1786  #endif

1787              default:

1788                    pAssert(FALSE);

1789                    break;

1790        }

1791

1792        return;

1793

1794  }

      10.2.9.5       CryptSymmetricDecrypt()

      This function does in-place decryption of a buffer using the indicated symmetric algorithm,       key,    IV,  and

      mode. If the symmetric algorithm and mode are not defined, the TPM will fail.

1795  void

1796  CryptSymmetricDecrypt(

1797        BYTE                      *decrypted,

1798        TPM_ALG_ID                   algorithm,      //  IN:  algorithm      for   encryption

1799        UINT16                       keySizeInBits,  //  IN:  key   size  in     bit

1800        TPMI_ALG_SYM_MODE            mode,           //  IN:  symmetric      encryption      mode

1801        BYTE                      *key,              //  IN:  encryption      key

1802        TPM2B_IV                  *ivIn,             //  IN/OUT:    IV  for   next    block

1803        UINT32                       dataSize,       //  IN:  data  size     in   byte

1804        BYTE                      *data              //  IN/OUT:    data  buffer

1805        )

1806  {

1807        BYTE                      *iv  =    NULL;

1808        BYTE                         defaultIV[sizeof(TPMT_HA)];

      Family "2.0"                                     TCG Published                                    Page 311

      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                           October 30, 2014
      Trusted Platform Module Library                                                                Part 4: Supporting Routines

1809

1810       TEST(algorithm);

1811

1812       if(

1813  #ifdef     TPM_ALG_AES

1814                 algorithm        ==   TPM_ALG_AES

1815  #endif

1816  #if  defined     TPM_ALG_AES         &&   defined      TPM_ALG_SM4

1817             ||

1818  #endif

1819  #ifdef     TPM_ALG_SM4

1820                 algorithm        ==   TPM_ALG_SM4

1821  #endif

1822          )

1823       {

1824             //  Both     SM4     and  AES     have  block   size    of  128  bits

1825             //  If    the    iv  is   not     provided,     create  a   default    of  0

1826             if(ivIn      ==   NULL)

1827             {

1828                   //  Initialize          the  default      IV

1829                   iv  =    defaultIV;

1830                   MemorySet(defaultIV,              0,  16);

1831             }

1832             else

1833             {

1834                   //  A    provided       IV   has  to  be  the     right  size

1835                   pAssert(mode        ==      TPM_ALG_ECB       ||  ivIn->t.size   ==     16);

1836                   iv  =    &(ivIn->t.buffer[0]);

1837             }

1838       }

1839

1840       switch(algorithm)

1841       {

1842  #ifdef     TPM_ALG_AES

1843       case      TPM_ALG_AES:

1844       {

1845

1846             switch    (mode)

1847             {

1848                   case     TPM_ALG_CTR:

1849                          _cpri__AESDecryptCTR(decrypted,                   keySizeInBits,       key,  iv,

1850                                                          dataSize,      data);

1851                          break;

1852                   case     TPM_ALG_OFB:

1853                          _cpri__AESDecryptOFB(decrypted,                   keySizeInBits,       key,  iv,

1854                                                          dataSize,      data);

1855                          break;

1856                   case     TPM_ALG_CBC:

1857                          _cpri__AESDecryptCBC(decrypted,                   keySizeInBits,       key,  iv,

1858                                                          dataSize,      data);

1859                          break;

1860                   case     TPM_ALG_CFB:

1861                          _cpri__AESDecryptCFB(decrypted,                   keySizeInBits,       key,  iv,

1862                                                          dataSize,      data);

1863                          break;

1864                   case     TPM_ALG_ECB:

1865                          _cpri__AESDecryptECB(decrypted,                   keySizeInBits,       key,

1866                                                          dataSize,      data);

1867                          break;

1868                   default:

1869                          pAssert(0);

1870             }

1871             break;

1872       }

1873  #endif     //TPM_ALG_AES

1874  #ifdef     TPM_ALG_SM4

      Page 312                                                TCG Published                                     Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                        Level 00   Revision 01.16
      Part 4: Supporting Routines                                                       Trusted Platform       Module  Library

1875     case      TPM_ALG_SM4   :

1876            switch   (mode)

1877            {

1878                 case  TPM_ALG_CTR:

1879                       _cpri__SM4DecryptCTR(decrypted,            keySizeInBits,         key,    iv,

1880                                                      dataSize,   data);

1881                       break;

1882                 case  TPM_ALG_OFB:

1883                       _cpri__SM4DecryptOFB(decrypted,            keySizeInBits,         key,    iv,

1884                                                      dataSize,   data);

1885                       break;

1886                 case  TPM_ALG_CBC:

1887                       _cpri__SM4DecryptCBC(decrypted,            keySizeInBits,         key,    iv,

1888                                                      dataSize,   data);

1889                       break;

1890                 case  TPM_ALG_CFB:

1891                       _cpri__SM4DecryptCFB(decrypted,            keySizeInBits,         key,    iv,

1892                                                      dataSize,   data);

1893                       break;

1894                 case  TPM_ALG_ECB:

1895                       _cpri__SM4DecryptECB(decrypted,            keySizeInBits,         key,

1896                                                      dataSize,   data);

1897                       break;

1898                 default:

1899                       pAssert(0);

1900            }

1901            break;

1902  #endif    //TPM_ALG_SM4

1903

1904     default:

1905            pAssert(FALSE);

1906            break;

1907     }

1908     return;

1909  }

      10.2.9.6     CryptSecretEncrypt()

      This function creates a secret value and its associated secret structure using an asymmetric algorithm.

      This function is used by TPM2_Rewrap() TPM2_MakeCredential(), and TPM2_Duplicate().

      Error Returns                      Meaning

      TPM_RC_ATTRIBUTES                  keyHandle does not reference a valid decryption key

      TPM_RC_KEY                         invalid ECC key (public point is not on the curve)

      TPM_RC_SCHEME                      RSA key with an unsupported padding scheme

      TPM_RC_VALUE                       numeric value of the data to be decrypted is greater      than   the  RSA

                                         key modulus

1910  TPM_RC

1911  CryptSecretEncrypt(

1912     TPMI_DH_OBJECT                         keyHandle,        //  IN:   encryption       key  handle

1913     const     char                      *label,              //  IN:   a  null-terminated       string    as   L

1914     TPM2B_DATA                          *data,               //  OUT:     secret   value

1915     TPM2B_ENCRYPTED_SECRET              *secret              //  OUT:     secret   structure

1916     )

1917  {

1918     TPM_RC            result     =  TPM_RC_SUCCESS;

1919     OBJECT            *encryptKey       =  ObjectGet(keyHandle);          //  TPM  key    used  for  encrypt

1920

1921     pAssert(data      !=   NULL     &&  secret   !=  NULL);

      Family "2.0"                                    TCG Published                                                 Page 313

      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                 October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines

1922

1923  //      The  output     secret     value       has     the  size        of  the    digest       produced  by      the    nameAlg.

1924  data->t.size         =   CryptGetHashDigestSize(encryptKey->publicArea.nameAlg);

1925

1926  pAssert(encryptKey->publicArea.objectAttributes.decrypt                                         ==    SET);

1927

1928  switch(encryptKey->publicArea.type)

1929  {

1930  #ifdef  TPM_ALG_RSA

1931          case     TPM_ALG_RSA:

1932          {

1933                TPMT_RSA_DECRYPT                                  scheme;

1934

1935                //  Use    OAEP      scheme

1936                scheme.scheme          =     TPM_ALG_OAEP;

1937                scheme.details.oaep.hashAlg                       =  encryptKey->publicArea.nameAlg;

1938

1939                //  Create        secret     data       from  RNG

1940                CryptGenerateRandom(data->t.size,                             data->t.buffer);

1941

1942                //  Encrypt       the     data      by   RSA  OAEP        into  encrypted         secret

1943                result     =   CryptEncryptRSA(&secret->t.size,                          secret->t.secret,

1944                                                          encryptKey,           &scheme,

1945                                                          data->t.size,              data->t.buffer,        label);

1946          }

1947          break;

1948  #endif  //TPM_ALG_RSA

1949

1950  #ifdef  TPM_ALG_ECC

1951          case     TPM_ALG_ECC:

1952          {

1953                TPMS_ECC_POINT                      eccPublic;

1954                TPM2B_ECC_PARAMETER                 eccPrivate;

1955                TPMS_ECC_POINT                      eccSecret;

1956                BYTE                                *buffer       =  secret->t.secret;

1957

1958                //  Need      to  make       sure   that      the    public     point      of     the  key  is     on  the

1959                //  curve      defined       by     the  key.

1960                if(!_cpri__EccIsPointOnCurve(

1961                                     encryptKey->publicArea.parameters.eccDetail.curveID,

1962                                     &encryptKey->publicArea.unique.ecc))

1963                      result      =  TPM_RC_KEY;

1964                else

1965                {

1966

1967                      //   Call      crypto      engine       to     create     an   auxiliary         ECC  key

1968                      //   We     assume     crypt       engine      initialization            should       always     success.

1969                      //   Otherwise,          TPM      should       go   to  failure      mode.

1970                      CryptNewEccKey(encryptKey->publicArea.parameters.eccDetail.curveID,

1971                                                 &eccPublic,             &eccPrivate);

1972

1973                      //   Marshal        ECC    public       to     secret     structure.        This      will   be  used     by   the

1974                      //   recipient         to     decrypt       the     secret     with     their    private      key.

1975                      secret->t.size             =  TPMS_ECC_POINT_Marshal(&eccPublic,                            &buffer,      NULL);

1976

1977                      //   Compute        ECDH      shared    secret          which  is    R   =  [d]Q      where   d  is   the

1978                      //   private        part      of   the  ephemeral         key  and       Q  is   the  public       part    of   a

1979                      //   TPM    key.       TPM_RC_KEY       error       return     from      CryptComputeECDHSecret

1980                      //   because        the    auxiliary           ECC  key   is   just      created      according       to   the

1981                      //   parameters          of   input     ECC        encrypt     key.

1982                      if(         CryptEccPointMultiply(&eccSecret,

1983                                                 encryptKey->publicArea.parameters.eccDetail.curveID,

1984                                                 &eccPrivate,

1985                                                 &encryptKey->publicArea.unique.ecc)

1986                           !=     CRYPT_SUCCESS)

1987                              result      =  TPM_RC_KEY;

      Page 314                                               TCG Published                                                       Family "2.0"

      October 30, 2014                             Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                  Trusted Platform Module Library

1988                        else

1989

1990                              //  The  secret       value   is     computed         from  Z    using   KDFe       as:

1991                              //  secret    :=     KDFe(HashID,           Z,   Use,  PartyUInfo,          PartyVInfo,          bits)

1992                              //  Where:

1993                              //  HashID        the    nameAlg        of   the  decrypt        key

1994                              //  Z     the     x   coordinate         (Px)     of   the  product      (P)    of   the   point

1995                              //        (Q)     of   the    secret        and   the  private        x  coordinate       (de,V)

1996                              //        of   the     decryption           key

1997                              //  Use   a   null-terminated               string     containing        "SECRET"

1998                              //  PartyUInfo           the  x   coordinate           of   the  point      in  the      secret

1999                              //                       (Qe,U    )

2000                              //  PartyVInfo           the  x   coordinate           of   the  public      key    (Qs,V     )

2001                              //  bits          the    number      of     bits  in   the     digest    of     HashID

2002                              //  Retrieve      seed   from     KDFe

2003

2004                              CryptKDFe(encryptKey->publicArea.nameAlg,                             &eccSecret.x.b,

2005                                            label,     &eccPublic.x.b,

2006                                            &encryptKey->publicArea.unique.ecc.x.b,

2007                                            data->t.size           *   8,     data->t.buffer);

2008                 }

2009            }

2010            break;

2011  #endif    //TPM_ALG_ECC

2012

2013     default:

2014            FAIL(FATAL_ERROR_INTERNAL);

2015            break;

2016     }

2017

2018     return     result;

2019  }

      10.2.9.7     CryptSecretDecrypt()

      Decrypt   a   secret  value     by   asymmetric         (or   symmetric)           algorithm      This   function     is     used   for

      ActivateCredential() and Import for asymmetric decryption, and StartAuthSession() for both asymmetric

      and symmetric decryption process

      Error Returns                        Meaning

      TPM_RC_ATTRIBUTES                    RSA key is not a decryption key

      TPM_RC_BINDING                       Invalid RSA key (public and private parts are not cryptographically

                                           bound.

      TPM_RC_ECC_POINT                     ECC point in the secret is not on the curve

      TPM_RC_INSUFFICIENT                  failed to retrieve ECC point from the secret

      TPM_RC_NO_RESULT                     multiplication resulted in ECC point at infinity

      TPM_RC_SIZE                          data to decrypt is not of the same size as RSA key

      TPM_RC_VALUE                         For RSA key, numeric value of the encrypted data is greater than the

                                           modulus, or the recovered data is larger than the output buffer. For

                                           keyedHash or symmetric key, the secret is larger than the size of the

                                           digest produced by the name algorithm.

      TPM_RC_FAILURE                       internal error

2020  TPM_RC

2021  CryptSecretDecrypt(

2022     TPM_HANDLE                            tpmKey,                    //   IN:  decrypt        key

2023     TPM2B_NONCE                        *nonceCaller,                 //   IN:  nonceCaller.           It     is  needed       for

2024                                                                      //        symmetric       decryption.            For

      Family "2.0"                                         TCG Published                                                           Page 315

      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                             October 30, 2014
      Trusted Platform Module Library                                                                 Part 4: Supporting Routines

2025                                                                     //        asymmetric    decryption,         this

2026                                                                     //        parameter     is   NULL

2027     const   char                           *label,                  //  IN:   a   null-terminated        string  as   L

2028     TPM2B_ENCRYPTED_SECRET                 *secret,                 //  IN:   input    secret

2029     TPM2B_DATA                             *data                    //  OUT:     decrypted  secret       value

2030     )

2031  {

2032     TPM_RC           result     =   TPM_RC_SUCCESS;

2033     OBJECT           *decryptKey           =   ObjectGet(tpmKey);             //TPM    key  used    for    decrypting

2034

2035     //   Decryption      for    secret

2036     switch(decryptKey->publicArea.type)

2037     {

2038

2039  #ifdef  TPM_ALG_RSA

2040          case     TPM_ALG_RSA:

2041          {

2042                TPMT_RSA_DECRYPT                        scheme;

2043

2044                //   Use  OAEP       scheme

2045                scheme.scheme           =   TPM_ALG_OAEP;

2046                scheme.details.oaep.hashAlg                     =    decryptKey->publicArea.nameAlg;

2047

2048                //   Set  the    output         buffer    capacity

2049                data->t.size         =     sizeof(data->t.buffer);

2050

2051                //   Decrypt     seed       by  RSA    OAEP

2052                result    =     CryptDecryptRSA(&data->t.size,                    data->t.buffer,       decryptKey,

2053                                                          &scheme,

2054                                                          secret->t.size,          secret->t.secret,label);

2055                if(       (result       ==     TPM_RC_SUCCESS)

2056                     &&   (data->t.size

2057                             >   CryptGetHashDigestSize(decryptKey->publicArea.nameAlg)))

2058                      result     =   TPM_RC_VALUE;

2059          }

2060          break;

2061  #endif  //TPM_ALG_RSA

2062

2063  #ifdef  TPM_ALG_ECC

2064          case     TPM_ALG_ECC:

2065          {

2066                TPMS_ECC_POINT                      eccPublic;

2067                TPMS_ECC_POINT                      eccSecret;

2068                BYTE                                *buffer     =    secret->t.secret;

2069                INT32                               size     =  secret->t.size;

2070

2071                //   Retrieve        ECC    point      from     secret   buffer

2072                result    =     TPMS_ECC_POINT_Unmarshal(&eccPublic,                       &buffer,  &size);

2073                if(result        ==  TPM_RC_SUCCESS)

2074                {

2075                      result     =   CryptEccPointMultiply(&eccSecret,

2076                                                decryptKey->publicArea.parameters.eccDetail.curveID,

2077                                                &decryptKey->sensitive.sensitive.ecc,

2078                                                &eccPublic);

2079

2080                      if(result         ==     TPM_RC_SUCCESS)

2081                      {

2082

2083                             //  Set       the  size    of      the  "recovered"   secret    value      to  be   the   size

2084                             //  of     the     digest    produced       by  the   nameAlg.

2085                             data->t.size           =

2086                                            CryptGetHashDigestSize(decryptKey->publicArea.nameAlg);

2087

2088                             //  The       secret      value    is   computed     from  Z  using   KDFe     as:

2089                             //  secret         :=  KDFe(HashID,         Z,  Use,  PartyUInfo,       PartyVInfo,       bits)

2090                             //  Where:

      Page 316                                              TCG Published                                             Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                          Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                         Trusted Platform Module Library

2091                            //     HashID         --  the     nameAlg         of    the     decrypt     key

2092                            //     Z  --       the    x    coordinate             (Px)   of   the     product       (P)   of   the   point

2093                            //                 (Q)    of      the     secret       and   the     private     x  coordinate          (de,V)

2094                            //                 of     the     decryption           key

2095                            //     Use     --     a   null-terminated               string       containing         "SECRET"

2096                            //     PartyUInfo             --  the      x     coordinate       of   the   point      in    the  secret

2097                            //                             (Qe,U       )

2098                            //     PartyVInfo             --  the      x     coordinate       of   the   public     key       (Qs,V     )

2099                            //     bits    --        the   number         of  bits      in   the   digest       of  HashID

2100                            //  Retrieve             seed     from     KDFe

2101                            CryptKDFe(decryptKey->publicArea.nameAlg,                                    &eccSecret.x.b,             label,

2102                                               &eccPublic.x.b,

2103                                               &decryptKey->publicArea.unique.ecc.x.b,

2104                                               data->t.size               *   8,   data->t.buffer);

2105                      }

2106                }

2107          }

2108          break;

2109  #endif  //TPM_ALG_ECC

2110

2111          case     TPM_ALG_KEYEDHASH:

2112                //  The   seed     size    can        not     be   bigger         than   the     digest   size      of    nameAlg

2113                if(secret->t.size              >

2114                            CryptGetHashDigestSize(decryptKey->publicArea.nameAlg))

2115                      result    =     TPM_RC_VALUE;

2116                else

2117                {

2118                      //  Retrieve         seed       by   XOR     Obfuscation:

2119                      //        seed    =  XOR(secret,                hash,       key,   nonceCaller,           nullNonce)

2120                      //        where:

2121                      //        secret         the    secret          parameter         from     the  TPM2_StartAuthHMAC

2122                      //                       command

2123                      //                       which       contains           the   seed     value

2124                      //        hash           nameAlg            of   tpmKey

2125                      //        key            the    key     or      data    value      in   the     object    referenced          by

2126                      //                       entityHandle               in  the    TPM2_StartAuthHMAC             command

2127                      //        nonceCaller           the     parameter            from     the   TPM2_StartAuthHMAC           command

2128                      //        nullNonce             a    zero-length             nonce

2129                      //  XOR   Obfuscation               in  place

2130                      CryptXORObfuscation(decryptKey->publicArea.nameAlg,

2131                                                           &decryptKey->sensitive.sensitive.bits.b,

2132                                                           &nonceCaller->b,                 NULL,

2133                                                           secret->t.size,               secret->t.secret);

2134                      //  Copy     decrypted          seed

2135                      MemoryCopy2B(&data->b,                      &secret->b,           sizeof(data->t.buffer));

2136                }

2137                break;

2138          case     TPM_ALG_SYMCIPHER:

2139                {

2140                      TPM2B_IV                                     iv     =   {0};

2141                      TPMT_SYM_DEF_OBJECT                          *symDef;

2142                      //  The   seed       size       can     not     be     bigger     than     the  digest        size  of   nameAlg

2143                      if(secret->t.size               >

2144                                   CryptGetHashDigestSize(decryptKey->publicArea.nameAlg))

2145                            result      =  TPM_RC_VALUE;

2146                      else

2147                      {

2148                            symDef      =  &decryptKey->publicArea.parameters.symDetail.sym;

2149                            iv.t.size          =     CryptGetSymmetricBlockSize(symDef->algorithm,

2150                                                                                                      symDef->keyBits.sym);

2151                            pAssert(iv.t.size                 !=      0);

2152                            if(nonceCaller->t.size                        >=  iv.t.size)

2153                                   MemoryCopy(iv.t.buffer,                         nonceCaller->t.buffer,                 iv.t.size,

2154                                                           sizeof(iv.t.buffer));

2155                            else

2156                                   MemoryCopy(iv.b.buffer,                         nonceCaller->t.buffer,

      Family "2.0"                                             TCG Published                                                             Page 317

      Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                                  October 30, 2014
      Trusted Platform Module Library                                                                   Part 4: Supporting Routines

2157                                                        nonceCaller->t.size,           sizeof(iv.t.buffer));

2158                                //  CFB    decrypt      in  place,       using  nonceCaller         as  iv

2159                                CryptSymmetricDecrypt(secret->t.secret,                        symDef->algorithm,

2160                                                            symDef->keyBits.sym,               TPM_ALG_CFB,

2161                                                            decryptKey->sensitive.sensitive.sym.t.buffer,

2162                                                            &iv,    secret->t.size,            secret->t.secret);

2163

2164                                //  Copy   decrypted        seed

2165                                MemoryCopy2B(&data->b,              &secret->b,       sizeof(data->t.buffer));

2166                          }

2167                  }

2168                  break;

2169              default:

2170                  pAssert(0);

2171                  break;

2172        }

2173        return    result;

2174  }

      10.2.9.8        CryptParameterEncryption()

      This function does in-place encryption of a response parameter.

2175  void

2176  CryptParameterEncryption(

2177        TPM_HANDLE              handle,                         //  IN:  encrypt      session       handle

2178        TPM2B                   *nonceCaller,                   //  IN:  nonce  caller

2179        UINT16                  leadingSizeInByte,              //  IN:  the    size   of   the     leading     size   field  in

2180                                                                //       byte

2181        TPM2B_AUTH              *extraKey,                      //  IN:  additional        key   material       other  than

2182                                                                //       session      auth

2183        BYTE                    *buffer                         //  IN/OUT:     parameter       buffer      to  be  encrypted

2184        )

2185  {

2186        SESSION           *session     =   SessionGet(handle);           //     encrypt     session

2187        TPM2B_TYPE(SYM_KEY,         (      sizeof(extraKey->t.buffer)

2188                                       +   sizeof(session->sessionKey.t.buffer)));

2189        TPM2B_SYM_KEY                  key;                         //   encryption        key

2190        UINT32                         cipherSize       =   0;      //   size   of    cipher     text

2191

2192        pAssert(session->sessionKey.t.size                  +   extraKey->t.size           <=   sizeof(key.t.buffer));

2193

2194        //  Retrieve      encrypted       data  size.

2195        if(leadingSizeInByte           ==  2)

2196        {

2197              //  Extract    the    first    two    bytes   as      the  size   field  as      the  data    size

2198              //  encrypt

2199              cipherSize     =  (UINT32)BYTE_ARRAY_TO_UINT16(buffer);

2200              //  advance    the    buffer

2201              buffer   =     &buffer[2];

2202        }

2203  #ifdef          TPM4B

2204        else   if(leadingSizeInByte             ==  4)

2205        {

2206              //  use  the   first     four     bytes   to  indicate     the    number      of   bytes      to  encrypt

2207              cipherSize     =  BYTE_ARRAY_TO_UINT32(buffer);

2208              //advance      pointer

2209              buffer   =     &buffer[4];

2210        }

2211  #endif

2212        else

2213        {

2214              pAssert(FALSE);

2215        }

      Page 318                                              TCG Published                                                  Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                               Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                               Trusted Platform Module Library

2216

2217     //     Compute    encryption             key     by   concatenating              sessionAuth        with     extra   key

2218     MemoryCopy2B(&key.b,                  &session->sessionKey.b,                      sizeof(key.t.buffer));

2219     MemoryConcat2B(&key.b,                      &extraKey->b,            sizeof(key.t.buffer));

2220

2221     if     (session->symmetric.algorithm                          ==     TPM_ALG_XOR)

2222

2223            //   XOR   parameter           encryption          formulation:

2224            //        XOR(parameter,               hash,       sessionAuth,             nonceNewer,         nonceOlder)

2225            CryptXORObfuscation(session->authHashAlg,                                      &(key.b),

2226                                                               &(session->nonceTPM.b),

2227                                                               nonceCaller,             cipherSize,         buffer);

2228     else

2229            ParmEncryptSym(session->symmetric.algorithm,                                       session->authHashAlg,

2230                                                      session->symmetric.keyBits.aes,                         &(key.b),

2231                                                      nonceCaller,            &(session->nonceTPM.b),

2232                                                      cipherSize,             buffer);

2233     return;

2234  }

      10.2.9.9       CryptParameterDecryption()

      This function does   in-place       decryption of a command parameter.

      Error Returns                               Meaning

      TPM_RC_SIZE                                 The number of bytes in the input buffer                is  less  than  the  number   of

                                                  bytes to be decrypted.

2235  TPM_RC

2236  CryptParameterDecryption(

2237     TPM_HANDLE                    handle,                                //  IN:     encrypted      session      handle

2238     TPM2B                        *nonceCaller,                           //  IN:     nonce    caller

2239     UINT32                        bufferSize,                            //  IN:     size     of  parameter      buffer

2240     UINT16                        leadingSizeInByte,                     //  IN:     the   size    of   the   leading     size    field  in

2241                                                                          //          byte

2242     TPM2B_AUTH                   *extraKey,                              //  IN:     the   authValue

2243     BYTE                         *buffer                                 //  IN/OUT:       parameter        buffer   to   be  decrypted

2244     )

2245  {

2246     SESSION                      *session         =   SessionGet(handle);                     //  encrypt     session

2247     //     The  HMAC     key     is  going        to     be   the     concatenation           of   the     session   key     and  any

2248     //     additional        key     material         (like       the    authValue).          The   size     of  both    of   these

2249     //     is   the  size     of     the     buffer       which       can    contain       a  TPMT_HA.

2250     TPM2B_TYPE(HMAC_KEY,                  (     sizeof(extraKey->t.buffer)

2251                                              +  sizeof(session->sessionKey.t.buffer)));

2252     TPM2B_HMAC_KEY                              key;                             //  decryption        key

2253     UINT32                                      cipherSize            =  0;      //  size     of  cipher     text

2254

2255     pAssert(session->sessionKey.t.size                                +  extraKey->t.size              <=   sizeof(key.t.buffer));

2256

2257     //     Retrieve      encrypted           data     size.

2258     if(leadingSizeInByte                  ==    2)

2259     {

2260            //   The   first       two     bytes       of     the   buffer         are  the    size     of   the

2261            //   data     to   be     decrypted

2262            cipherSize         =   (UINT32)BYTE_ARRAY_TO_UINT16(buffer);

2263            buffer     =  &buffer[2];                  //     advance         the     buffer

2264     }

2265  #ifdef    TPM4B

2266     else       if(leadingSizeInByte                  ==   4)

2267     {

2268            //   the   leading        size       is    four    bytes          so   get  the    four     byte   size   field

2269            cipherSize         =   BYTE_ARRAY_TO_UINT32(buffer);

      Family "2.0"                                                 TCG Published                                                           Page 319

      Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                            October 30, 2014
      Trusted Platform Module Library                                                             Part 4: Supporting Routines

2270              buffer    =  &buffer[4];           //advance    pointer

2271        }

2272  #endif

2273        else

2274        {

2275              pAssert(FALSE);

2276        }

2277        if(cipherSize        >     bufferSize)

2278              return    TPM_RC_SIZE;

2279

2280        //  Compute     decryption        key  by   concatenating      sessionAuth   with     extra  input  key

2281        MemoryCopy2B(&key.b,            &session->sessionKey.b,            sizeof(key.t.buffer));

2282        MemoryConcat2B(&key.b,              &extraKey->b,     sizeof(key.t.buffer));

2283

2284        if(session->symmetric.algorithm                 ==   TPM_ALG_XOR)

2285              //  XOR   parameter       decryption      formulation:

2286              //       XOR(parameter,          hash,    sessionAuth,   nonceNewer,   nonceOlder)

2287              //  Call     XOR     obfuscation      function

2288              CryptXORObfuscation(session->authHashAlg,                     &key.b,  nonceCaller,

2289                                                        &(session->nonceTPM.b),      cipherSize,     buffer);

2290        else

2291              //  Assume     that  it     is   one  of  the   symmetric     block  ciphers.

2292              ParmDecryptSym(session->symmetric.algorithm,                    session->authHashAlg,

2293                                               session->symmetric.keyBits.sym,

2294                                               &key.b,       nonceCaller,   &session->nonceTPM.b,

2295                                               cipherSize,        buffer);

2296

2297        return    TPM_RC_SUCCESS;

2298

2299  }

      10.2.9.10       CryptComputeSymmetricUnique()

      This function computes the unique field in public area for symmetric objects.

2300  void

2301  CryptComputeSymmetricUnique(

2302        TPMI_ALG_HASH              nameAlg,             //   IN:   object   name   algorithm

2303        TPMT_SENSITIVE             *sensitive,          //   IN:   sensitive  area

2304        TPM2B_DIGEST               *unique              //   OUT:  unique   buffer

2305        )

2306  {

2307        HASH_STATE         hashState;

2308

2309        pAssert(sensitive          !=   NULL   &&   unique    !=   NULL);

2310

2311        //  Compute     the     public    value     as  the  hash  of  sensitive.symkey       ||  unique.buffer

2312        unique->t.size          =  CryptGetHashDigestSize(nameAlg);

2313        CryptStartHash(nameAlg,               &hashState);

2314

2315        //  Add   obfuscation      value

2316        CryptUpdateDigest2B(&hashState,                 &sensitive->seedValue.b);

2317

2318        //  Add   sensitive        value

2319        CryptUpdateDigest2B(&hashState,                 &sensitive->sensitive.any.b);

2320

2321        CryptCompleteHash2B(&hashState,                 &unique->b);

2322

2323        return;

2324  }

2325  #if   0   //%

      Page 320                                              TCG Published                                       Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                     Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                  Trusted Platform Module Library

      10.2.9.11      CryptComputeSymValue()

      This function computes the seedValue field in asymmetric sensitive areas.

2326  void

2327  CryptComputeSymValue(

2328        TPM_HANDLE              parentHandle,         //    IN:     parent     handle     of   the    object    to     be  created

2329        TPMT_PUBLIC         *publicArea,              //    IN/OUT:       the   public     area       template

2330        TPMT_SENSITIVE      *sensitive,               //    IN:     sensitive       area

2331        TPM2B_SEED          *seed,                    //    IN:     the   seed

2332        TPMI_ALG_HASH           hashAlg,              //    IN:     hash  algorithm        for       KDFa

2333        TPM2B_NAME          *name                     //    IN:     object     name

2334        )

2335  {

2336        TPM2B_AUTH          *proof   =   NULL;

2337

2338        if(CryptIsAsymAlgorithm(publicArea->type))

2339        {

2340             //  Generate   seedValue           only  when      an  asymmetric       key   is     a   storage   key

2341             if(publicArea->objectAttributes.decrypt                      ==    SET

2342                        &&  publicArea->objectAttributes.restricted                           ==     SET)

2343             {

2344                   //   If  this     is  a  primary   object        in   the   endorsement           hierarchy,     use

2345                   //   ehProof      in  the    creation    of      the  symmetric     seed       so  that      child

2346                   //   objects      in  the    endorsement         hierarchy   are    voided         on   TPM2_Clear()

2347                   //   or  TPM2_ChangeEPS()

2348                   if(      parentHandle        ==    TPM_RH_ENDORSEMENT

2349                        &&  publicArea->objectAttributes.fixedTPM                      ==     SET)

2350                        proof     =  &gp.ehProof;

2351             }

2352             else

2353             {

2354                   sensitive->seedValue.t.size                  =   0;

2355                   return;

2356             }

2357        }

2358

2359        //  For  all    object    types,      the     size  of     seedValue    is   the   digest         size  of  nameAlg

2360        sensitive->seedValue.t.size                =  CryptGetHashDigestSize(publicArea->nameAlg);

2361

2362        //  Compute     seedValue        using  implementation-dependent               method

2363        _cpri__GenerateSeededRandom(sensitive->seedValue.t.size,

2364                                                   sensitive->seedValue.t.buffer,

2365                                                   hashAlg,

2366                                                   &seed->b,

2367                                                   "seedValue",

2368                                                   &name->b,

2369                                                   (TPM2B   *)proof);

2370        return;

2371  }

2372  #endif    //%

      10.2.9.12      CryptCreateObject()

      This function creates an object. It:

      a)  fills in the created key in public and sensitive area;

      b)  creates a random number in sensitive area for symmetric keys; and

      c)  compute the unique id in public area for symmetric keys.

      Family "2.0"                                        TCG Published                                                        Page 321

      Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines

      Error Returns                              Meaning

      TPM_RC_KEY_SIZE                            key size in the public area does not match the size in the sensitive

                                                 creation area for a symmetric key

      TPM_RC_RANGE                               for an RSA key, the exponent is not supported

      TPM_RC_SIZE                                sensitive data size is larger than allowed for the scheme for a keyed

                                                 hash object

      TPM_RC_VALUE                               exponent is not prime or could not find a prime using the provided

                                                 parameters for an RSA key; unsupported name algorithm for an ECC

                                                 key

2373  TPM_RC

2374  CryptCreateObject(

2375     TPM_HANDLE                                    parentHandle,                   //    IN/OUT:  indication        of  the  seed

2376                                                                                   //          source

2377     TPMT_PUBLIC                                *publicArea,                       //    IN/OUT:  public      area

2378     TPMS_SENSITIVE_CREATE                      *sensitiveCreate,                  //    IN:   sensitive      creation

2379     TPMT_SENSITIVE                             *sensitive                         //    OUT:     sensitive   area

2380     )

2381  {

2382     //   Next   value       is   a  placeholder            for    a   random      seed  that     is    used  in

2383     //   key   creation         when     the      parent     is   not   a   primary     seed.    It    has   the   same

2384     //   size   as    the      primary         seed.

2385

2386     TPM2B_SEED                   localSeed;                  //   data     to     seed  key      creation    if  this

2387                                                              //   is   not     a  primary        seed

2388

2389     TPM2B_SEED                  *seed       =  NULL;

2390     TPM_RC                       result        =     TPM_RC_SUCCESS;

2391

2392     TPM2B_NAME                   name;

2393     TPM_ALG_ID                   hashAlg          =  CONTEXT_INTEGRITY_HASH_ALG;

2394     OBJECT                      *parent;

2395     UINT32                       counter;

2396

2397     //   Set   the    sensitive          type        for  the    object

2398     sensitive->sensitiveType                      =  publicArea->type;

2399     ObjectComputeName(publicArea,                         &name);

2400

2401     //   For   all    objects,        copy        the     initial     auth     data

2402     sensitive->authValue                 =     sensitiveCreate->userAuth;

2403

2404     //   If   this    is    a   permanent            handle    assume      that   it    is    a  hierarchy

2405     if(HandleGetType(parentHandle)                         ==    TPM_HT_PERMANENT)

2406     {

2407           seed     =  HierarchyGetPrimarySeed(parentHandle);

2408     }

2409     else

2410     {

2411           //   If     not   hierarchy          handle,       get     parent

2412           parent      =     ObjectGet(parentHandle);

2413           hashAlg        =  parent->publicArea.nameAlg;

2414

2415           //   Use    random        value      as    seed    for     non-primary        objects

2416           localSeed.t.size               =     PRIMARY_SEED_SIZE;

2417           CryptGenerateRandom(PRIMARY_SEED_SIZE,                                  localSeed.t.buffer);

2418           seed     =  &localSeed;

2419     }

2420

2421     switch(publicArea->type)

2422     {

2423  #ifdef  TPM_ALG_RSA

2424           //   Create       RSA     key

      Page 322                                                    TCG Published                                                  Family "2.0"

      October 30, 2014                                    Copyright © TCG 2006-2014                               Level 00 Revision 01.16
      Part 4: Supporting Routines                                                               Trusted Platform Module  Library

2425     case     TPM_ALG_RSA:

2426           result     =     CryptGenerateKeyRSA(publicArea,                 sensitive,

2427                                                         hashAlg,      seed,   &name,     &counter);

2428           break;

2429  #endif  //   TPM_ALG_RSA

2430

2431  #ifdef  TPM_ALG_ECC

2432           //   Create       ECC   key

2433     case     TPM_ALG_ECC:

2434           result     =     CryptGenerateKeyECC(publicArea,                 sensitive,

2435                                                                 hashAlg,      seed,  &name,      &counter);

2436           break;

2437  #endif  //   TPM_ALG_ECC

2438

2439           //   Collect      symmetric         key  information

2440     case     TPM_ALG_SYMCIPHER:

2441           return     CryptGenerateKeySymmetric(publicArea,                    sensitiveCreate,

2442                                                                 sensitive,    hashAlg,       seed,   &name);

2443           break;

2444     case     TPM_ALG_KEYEDHASH:

2445           return     CryptGenerateKeyedHash(publicArea,                       sensitiveCreate,

2446                                                           sensitive,       hashAlg,      seed,   &name);

2447           break;

2448     default:

2449           pAssert(0);

2450           break;

2451     }

2452     if(result       ==     TPM_RC_SUCCESS)

2453     {

2454           TPM2B_AUTH                        *proof   =  NULL;

2455

2456           if(publicArea->objectAttributes.decrypt                         ==  SET

2457                         &&  publicArea->objectAttributes.restricted                      ==  SET)

2458           {

2459                 //   If     this     is  a  primary     object  in    the     endorsement    hierarchy,      use

2460                 //   ehProof         in  the  creation    of    the   symmetric      seed    so  that  child

2461                 //   objects         in  the  endorsement       hierarchy     are    voided      on  TPM2_Clear()

2462                 //   or     TPM2_ChangeEPS()

2463                 if(         parentHandle      ==    TPM_RH_ENDORSEMENT

2464                      &&     publicArea->objectAttributes.fixedTPM                    ==  SET)

2465                         proof     =  &gp.ehProof;

2466

2467                 //   For    all      object   types,    the     size  of   seedValue     is  the     digest  size

2468                 //   of     its   nameAlg

2469                 sensitive->seedValue.t.size

2470                         =   CryptGetHashDigestSize(publicArea->nameAlg);

2471

2472                 //   Compute         seedValue     using  implementation-dependent               method

2473                 _cpri__GenerateSeededRandom(sensitive->seedValue.t.size,

2474                                                              sensitive->seedValue.t.buffer,

2475                                                              hashAlg,

2476                                                              &seed->b,

2477                                                              "seedValuea",

2478                                                              &name.b,

2479                                                              (TPM2B   *)proof);

2480           }

2481           else

2482           {

2483                 sensitive->seedValue.t.size                  =  0;

2484           }

2485     }

2486

2487     return     result;

2488

2489  }

      Family "2.0"                                           TCG Published                                              Page 323

      Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                   October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines

      10.2.9.13     CryptObjectIsPublicConsistent()

      This function checks that the key sizes in the public area are consistent. For an asymmetric key, the size

      of the public key must match the size indicated by the public->parameters.

      Checks for the algorithm types matching the key type are handled by the unmarshaling operation.

      Return Value                              Meaning

      TRUE                                      sizes are consistent

      FALSE                                     sizes are not consistent

2490  BOOL

2491  CryptObjectIsPublicConsistent(

2492        TPMT_PUBLIC               *publicArea                   //  IN:  public      area

2493        )

2494  {

2495        BOOL                               OK   =   TRUE;

2496        switch  (publicArea->type)

2497        {

2498  #ifdef   TPM_ALG_RSA

2499              case     TPM_ALG_RSA:

2500                    OK  =     CryptAreKeySizesConsistent(publicArea);

2501                    break;

2502  #endif   //TPM_ALG_RSA

2503

2504  #ifdef   TPM_ALG_ECC

2505              case     TPM_ALG_ECC:

2506                    {

2507                           const      ECC_CURVE                                 *curveValue;

2508

2509                           //  Check       that     the    public       point   is   on   the  indicated   curve.

2510                           OK  =  CryptEccIsPointOnCurve(

2511                                                          publicArea->parameters.eccDetail.curveID,

2512                                                          &publicArea->unique.ecc);

2513                           if(OK)

2514                           {

2515                                  curveValue           =   CryptEccGetCurveDataPointer(

2516                                                                        publicArea->parameters.eccDetail.curveID);

2517                                  pAssert(curveValue                !=   NULL);

2518

2519                                  //   The     input       ECC  curve    must    be  a    supported  curve

2520                                  //   IF   a   scheme     is       defined     for  the   curve,    then  that  scheme      must

2521                                  //   be   used.

2522                                  OK   =        (curveValue->sign.scheme                  ==   TPM_ALG_NULL

2523                                           ||   (         publicArea->parameters.eccDetail.scheme.scheme

2524                                                   ==     curveValue->sign.scheme));

2525                                  OK   =   OK   &&     CryptAreKeySizesConsistent(publicArea);

2526                           }

2527                    }

2528                    break;

2529  #endif   //TPM_ALG_ECC

2530

2531              default:

2532                    //  Symmetric          object         common    checks

2533                    //  There     is      noting       to  check    with     a  symmetric      key   that  is    public  only.

2534                    //  Also      not     sure     that    there    is   anything        useful  to  be    done  with    it

2535                    //  either.

2536                    break;

2537        }

2538        return  OK;

2539  }

      Page 324                                                      TCG Published                                            Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                              Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                      Trusted Platform Module Library

      10.2.9.14      CryptObjectPublicPrivateMatch()

      This function checks the cryptographic binding between the public and sensitive areas.

      Error Returns                                  Meaning

      TPM_RC_TYPE                                    the type of the public and private areas are not the same

      TPM_RC_FAILURE                                 crypto error

      TPM_RC_BINDING                                 the public and private areas are not cryptographically matched.

2540  TPM_RC

2541  CryptObjectPublicPrivateMatch(

2542     OBJECT                          *object                   //     IN:  the  object     to  check

2543     )

2544  {

2545     TPMT_PUBLIC                             *publicArea;

2546     TPMT_SENSITIVE                          *sensitive;

2547     TPM_RC                                   result  =   TPM_RC_SUCCESS;

2548     BOOL                                     isAsymmetric         =  FALSE;

2549

2550     pAssert(object               !=     NULL);

2551     publicArea           =   &object->publicArea;

2552     sensitive         =     &object->sensitive;

2553     if(publicArea->type                     !=   sensitive->sensitiveType)

2554             return       TPM_RC_TYPE;

2555

2556     switch(publicArea->type)

2557     {

2558  #ifdef  TPM_ALG_RSA

2559     case       TPM_ALG_RSA:

2560             isAsymmetric             =   TRUE;

2561             //   The     public         and     private  key      sizes   need  to    be    consistent

2562             if(sensitive->sensitive.rsa.t.size                            !=   publicArea->unique.rsa.t.size/2)

2563                   result         =   TPM_RC_BINDING;

2564             else

2565             //   Load       key     by   computing       the  private         exponent

2566                   result         =   CryptLoadPrivateRSA(object);

2567             break;

2568  #endif

2569  #ifdef  TPM_ALG_ECC

2570             //   This       function         is  called       from   ObjectLoad()       which     has   already  checked  to

2571             //   see     that       the     public   point    is     on   the  curve    so    no  need  to  repeat  that

2572             //   check.

2573     case       TPM_ALG_ECC:

2574             isAsymmetric             =   TRUE;

2575             if(       publicArea->unique.ecc.x.t.size

2576                             !=   sensitive->sensitive.ecc.t.size)

2577                   result         =   TPM_RC_BINDING;

2578             else  if(publicArea->nameAlg                      !=     TPM_ALG_NULL)

2579             {

2580                   TPMS_ECC_POINT                              publicToCompare;

2581                   //     Compute         ECC     public  key

2582                   CryptEccPointMultiply(&publicToCompare,

2583                                                          publicArea->parameters.eccDetail.curveID,

2584                                                          &sensitive->sensitive.ecc,               NULL);

2585                   //     Compare         ECC     public  key

2586                   if(           (!Memory2BEqual(&publicArea->unique.ecc.x.b,

2587                                                          &publicToCompare.x.b))

2588                          ||     (!Memory2BEqual(&publicArea->unique.ecc.y.b,

2589                                                          &publicToCompare.y.b)))

2590                             result       =   TPM_RC_BINDING;

2591             }

2592             break;

      Family "2.0"                                                 TCG Published                                               Page 325

      Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                    October 30, 2014
      Trusted Platform Module Library                                                              Part 4: Supporting Routines

2593  #endif

2594     case     TPM_ALG_KEYEDHASH:

2595             break;

2596     case     TPM_ALG_SYMCIPHER:

2597             if(       (publicArea->parameters.symDetail.sym.keyBits.sym                       +  7)/8

2598                  !=   sensitive->sensitive.sym.t.size)

2599                   result     =   TPM_RC_BINDING;

2600             break;

2601     default:

2602             //   The  choice     here      is  an  assert  or   a    return  of  a  bad  type    for    the  object

2603             pAssert(0);

2604             break;

2605     }

2606

2607     //   For     asymmetric      keys,     the     algorithm    for  validating     the  linkage      between

2608     //   the     public   and    private       areas  is   algorithm    dependent.       For  symmetric      keys

2609     //   the     linkage     is  based     on   hashing    the  symKey  and      obfuscation     values.

2610     if(         result   ==     TPM_RC_SUCCESS        &&  !isAsymmetric

2611          &&     publicArea->nameAlg            !=  TPM_ALG_NULL)

2612     {

2613             TPM2B_DIGEST         uniqueToCompare;

2614

2615             //   Compute     unique    for     symmetric   key

2616             CryptComputeSymmetricUnique(publicArea->nameAlg,                        sensitive,

2617                                                       &uniqueToCompare);

2618             //   Compare     unique

2619             if(!Memory2BEqual(&publicArea->unique.sym.b,

2620                                        &uniqueToCompare.b))

2621                   result     =   TPM_RC_BINDING;

2622     }

2623     return       result;

2624

2625  }

      10.2.9.15      CryptGetSignHashAlg()

      Get the hash algorithm of signature from a TPMT_SIGNATURE structure.                    It  assumes    the signature is not

      NULL This is a function for easy access

2626  TPMI_ALG_HASH

2627  CryptGetSignHashAlg(

2628     TPMT_SIGNATURE              *auth                 //   IN:  signature

2629     )

2630  {

2631     pAssert(auth->sigAlg               !=  TPM_ALG_NULL);

2632

2633     //   Get     authHash       algorithm      based  on   signing   scheme

2634     switch(auth->sigAlg)

2635     {

2636

2637  #ifdef     TPM_ALG_RSA

2638             case     TPM_ALG_RSASSA:

2639                   return     auth->signature.rsassa.hash;

2640

2641             case     TPM_ALG_RSAPSS:

2642                   return     auth->signature.rsapss.hash;

2643

2644     #endif       //TPM_ALG_RSA

2645

2646     #ifdef       TPM_ALG_ECC

2647             case     TPM_ALG_ECDSA:

2648                   return     auth->signature.ecdsa.hash;

2649

2650     #endif       //TPM_ALG_ECC

      Page 326                                             TCG Published                                            Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                         Level  00 Revision 01.16
      Part 4: Supporting Routines                                                       Trusted Platform Module Library

2651

2652              case    TPM_ALG_HMAC:

2653                    return       auth->signature.hmac.hashAlg;

2654

2655              default:

2656                    return       TPM_ALG_NULL;

2657        }

2658  }

      10.2.9.16       CryptIsSplitSign()

      This function us used to determine if the             signing operation is a split signing  operation  that  required  a

      TPM2_Commit().

2659  BOOL

2660  CryptIsSplitSign(

2661        TPM_ALG_ID                   scheme             //  IN:   the  algorithm  selector

2662        )

2663  {

2664        if(       scheme     !=  scheme

2665  #     ifdef       TPM_ALG_ECDAA

2666              ||  scheme     ==  TPM_ALG_ECDAA

2667  #     endif       //  TPM_ALG_ECDAA

2668

2669           )

2670              return    TRUE;

2671        return    FALSE;

2672  }

      10.2.9.17       CryptIsSignScheme()

      This function indicates if a scheme algorithm is a sign algorithm.

2673  BOOL

2674  CryptIsSignScheme(

2675        TPMI_ALG_ASYM_SCHEME                   scheme

2676        )

2677  {

2678        BOOL                     isSignScheme      =    FALSE;

2679

2680        switch(scheme)

2681        {

2682  #ifdef      TPM_ALG_RSA

2683              //  If    RSA  is      implemented,     then  both  signing  schemes  are       required

2684        case      TPM_ALG_RSASSA:

2685        case      TPM_ALG_RSAPSS:

2686              isSignScheme           =  TRUE;

2687              break;

2688  #endif      //TPM_ALG_RSA

2689

2690  #ifdef      TPM_ALG_ECC

2691              //  If    ECC  is      implemented   ECDSA    is   required

2692        case      TPM_ALG_ECDSA:

2693  #ifdef      TPM_ALG_ECDAA

2694              //  ECDAA      is  optional

2695        case      TPM_ALG_ECDAA:

2696  #endif

2697  #ifdef          TPM_ALG_ECSCHNORR

2698              //  Schnorr        is     also  optional

2699        case      TPM_ALG_ECSCHNORR:

2700  #endif

2701  #ifdef      TPM_ALG_SM2

2702        case      TPM_ALG_SM2:

      Family "2.0"                                          TCG Published                                          Page 327

      Level 00 Revision 01.16                      Copyright © TCG 2006-2014                      October 30, 2014
      Trusted Platform Module Library                                                     Part 4: Supporting Routines

2703  #endif

2704              isSignScheme     =  TRUE;

2705              break;

2706  #endif   //TPM_ALG_ECC

2707        default:

2708              break;

2709        }

2710        return    isSignScheme;

2711  }

      10.2.9.18       CryptIsDecryptScheme()

      This function indicate if a scheme algorithm is a decrypt algorithm.

2712  BOOL

2713  CryptIsDecryptScheme(

2714        TPMI_ALG_ASYM_SCHEME             scheme

2715        )

2716  {

2717        BOOL          isDecryptScheme          =  FALSE;

2718

2719        switch(scheme)

2720        {

2721  #ifdef   TPM_ALG_RSA

2722              //  If  RSA  is  implemented,       then  both  decrypt   schemes  are  required

2723        case  TPM_ALG_RSAES:

2724        case  TPM_ALG_OAEP:

2725              isDecryptScheme        =  TRUE;

2726              break;

2727  #endif   //TPM_ALG_RSA

2728

2729  #ifdef   TPM_ALG_ECC

2730              //  If  ECC  is  implemented        ECDH  is  required

2731        case  TPM_ALG_ECDH:

2732  #ifdef   TPM_ALG_SM2

2733        case  TPM_ALG_SM2:

2734  #endif

2735  #ifdef      TPM_ALG_ECMQV

2736        case  TPM_ALG_ECMQV:

2737  #endif

2738              isDecryptScheme     =     TRUE;

2739              break;

2740  #endif   //TPM_ALG_ECC

2741        default:

2742              break;

2743        }

2744        return    isDecryptScheme;

2745  }

      10.2.9.19       CryptSelectSignScheme()

      This function is used by the attestation and signing commands.        It implements the rules for selecting the

      signature scheme to use in signing. This function requires that the signing key either be TPM_RH_NULL

      or be loaded.

      If a default scheme is defined in object, the default scheme should be chosen, otherwise, the input

      scheme should be chosen. In the case that both object and input scheme has a non-NULL scheme

      algorithm, if the schemes are compatible, the input scheme will be chosen.

      Page 328                                        TCG Published                                 Family "2.0"

      October 30, 2014                       Copyright © TCG 2006-2014                    Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                    Trusted Platform Module Library

      Error Returns                        Meaning

      TPM_RC_KEY                           key referenced by signHandle is not a signing key

      TPM_RC_SCHEME                        both    scheme       and   key's     default  scheme   are  empty;  or  scheme    is

                                           empty while key's default scheme requires explicit input scheme (split

                                           signing); or non-empty default key scheme differs from scheme

2746  TPM_RC

2747  CryptSelectSignScheme(

2748     TPMI_DH_OBJECT                 signHandle,                 //     IN:   handle    of  signing      key

2749     TPMT_SIG_SCHEME                *scheme                     //     IN/OUT:       signing  scheme

2750     )

2751  {

2752     OBJECT                         *signObject;

2753     TPMT_SIG_SCHEME                *objectScheme;

2754     TPMT_PUBLIC                    *publicArea;

2755     TPM_RC                         result     =     TPM_RC_SUCCESS;

2756

2757     //   If   the   signHandle     is     TPM_RH_NULL,           then      the  NULL      scheme  is   used,     regardless

2758     //   of   the   setting    of  scheme

2759     if(signHandle         ==   TPM_RH_NULL)

2760     {

2761           scheme->scheme       =   TPM_ALG_NULL;

2762           scheme->details.any.hashAlg                   =   TPM_ALG_NULL;

2763     }

2764     else

2765     {

2766           //   sign   handle   is     not     NULL  so...

2767           //   Get   sign     object   pointer

2768           signObject       =   ObjectGet(signHandle);

2769           publicArea       =   &signObject->publicArea;

2770

2771           //   is   this   a   signing     key?

2772           if(!publicArea->objectAttributes.sign)

2773                 result     =   TPM_RC_KEY;

2774           else

2775           {

2776                 //   "parms"   defined        to    avoid      long     code    lines.

2777                 TPMU_PUBLIC_PARMS             *parms        =    &publicArea->parameters;

2778                 if(CryptIsAsymAlgorithm(publicArea->type))

2779                       objectScheme         =  (TPMT_SIG_SCHEME              *)&parms->asymDetail.scheme;

2780                 else

2781                       objectScheme         =  (TPMT_SIG_SCHEME              *)&parms->keyedHashDetail.scheme;

2782

2783                 //   If   the  object      doesn't         have    a   default      scheme,     then   use   the

2784                 //   input     scheme.

2785                 if(objectScheme->scheme                 ==  TPM_ALG_NULL)

2786                 {

2787                       //   Input   and     default         can't      both  be      NULL

2788                       if(scheme->scheme             ==     TPM_ALG_NULL)

2789                               result   =   TPM_RC_SCHEME;

2790

2791                       //   Assume     that    the   scheme         is   compatible        with    the  key.   If  not,

2792                       //   we  will    generate         an  error       in  the     signing     operation.

2793

2794                 }

2795                 else     if(scheme->scheme          ==      TPM_ALG_NULL)

2796                 {

2797                       //   input   scheme     is    NULL       so     use   default

2798

2799                       //   First,     check   to    see     if     the     default    requires    that      the   caller

2800                       //   provided       scheme    data

2801                       if(CryptIsSplitSign(objectScheme->scheme))

2802                               result   =   TPM_RC_SCHEME;

      Family "2.0"                                           TCG Published                                                       Page 329

      Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                          October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting  Routines

2803                         else

2804                         {

2805                                 scheme->scheme           =   objectScheme->scheme;

2806                                 scheme->details.any.hashAlg

2807                                                    =     objectScheme->details.any.hashAlg;

2808                         }

2809                 }

2810                 else

2811                 {

2812                         //   Both   input      and       object   have     scheme     selectors

2813                         //   If  the    scheme        and    the  hash     are   not  the     same   then...

2814                         if(      objectScheme->scheme                 !=   scheme->scheme

2815                              ||  (      objectScheme->details.any.hashAlg

2816                                     !=  scheme->details.any.hashAlg))

2817                                 result      =  TPM_RC_SCHEME;

2818                 }

2819             }

2820

2821     }

2822     return     result;

2823  }

      10.2.9.20     CryptSign()

      Sign a digest with asymmetric key or HMAC. This function is called by attestation commands and the

      generic TPM2_Sign() command. This function checks the key scheme and digest size.                                It does not check

      if the sign operation is allowed for restricted key.             It should be checked before the function is called. The

      function will assert if the key is not a signing key.

      Error Returns                          Meaning

      TPM_RC_SCHEME                          signScheme is not compatible with the signing key type

      TPM_RC_VALUE                           digest value is greater than the modulus of signHandle or size of

                                             hashData does not match hash algorithm insignScheme (for an RSA

                                             key); invalid commit status or failed to generate r value (for an ECC

                                             key)

2824  TPM_RC

2825  CryptSign(

2826     TPMI_DH_OBJECT                      signHandle,               //  IN:   The   handle      of  sign  key

2827     TPMT_SIG_SCHEME                 *signScheme,                  //  IN:   sign   scheme.

2828     TPM2B_DIGEST                    *digest,                      //  IN:   The   digest      being     signed

2829     TPMT_SIGNATURE                  *signature                    //  OUT:  signature

2830     )

2831  {

2832     OBJECT                          *signKey          =  ObjectGet(signHandle);

2833     TPM_RC                              result     =     TPM_RC_SCHEME;

2834

2835     //   check      if  input    handle        is  a     sign  key

2836     pAssert(signKey->publicArea.objectAttributes.sign                                 ==   SET);

2837

2838     //   Must   have       the   private       portion       loaded.       This   check    is     made  during

2839     //   authorization.

2840     pAssert(signKey->attributes.publicOnly                            ==   CLEAR);

2841

2842     //   Initialize         signature          scheme

2843     signature->sigAlg            =  signScheme->scheme;

2844

2845     //   If    the  signature       algorithm            is  TPM_ALG_NULL,        then    we   are   done

2846     if(signature->sigAlg                ==     TPM_ALG_NULL)

2847             return      TPM_RC_SUCCESS;

2848

2849     //   All   the      schemes     other      than      TPM_ALG_NULL       have   a  hash     algorithm

      Page 330                                                    TCG Published                                        Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                                Level 00  Revision 01.16
      Part 4: Supporting Routines                                                                           Trusted Platform Module      Library

2850        TEST_HASH(signScheme->details.any.hashAlg);

2851

2852        //  Initialize       signature         hash

2853        //  Note:    need    to      do   the  check   for     alg     null        first   because      the   null     scheme

2854        //  doesn't      have     a   hashAlg     member.

2855        signature->signature.any.hashAlg                    =  signScheme->details.any.hashAlg;

2856

2857        //  perform      sign     operation       based  on    different           key     type

2858        switch    (signKey->publicArea.type)

2859        {

2860

2861  #ifdef    TPM_ALG_RSA

2862             case    TPM_ALG_RSA:

2863                     result    =     CryptSignRSA(signKey,                signScheme,          digest,     signature);

2864                     break;

2865  #endif    //TPM_ALG_RSA

2866

2867  #ifdef    TPM_ALG_ECC

2868             case    TPM_ALG_ECC:

2869                     result    =     CryptSignECC(signKey,                signScheme,          digest,     signature);

2870                     break;

2871  #endif    //TPM_ALG_ECC

2872             case    TPM_ALG_KEYEDHASH:

2873                     result    =     CryptSignHMAC(signKey,               signScheme,             digest,     signature);

2874                     break;

2875             default:

2876                     break;

2877        }

2878

2879        return    result;

2880  }

      10.2.9.21     CryptVerifySignature()

      This     function  is  used         to  verify  a    signature.              It  is   called    by    TPM2_VerifySignature()       and

      TPM2_PolicySigned().

      Since this operation only requires use of a public key, no consistency checks are necessary for the key to

      signature type because a caller can load any public key that they like with any scheme that they like. This

      routine simply makes sure that the signature is correct, whatever the type.

      This function requires that auth is not a NULL pointer.

      Error Returns                           Meaning

      TPM_RC_SIGNATURE                        the signature is not genuine

      TPM_RC_SCHEME                           the scheme is not supported

      TPM_RC_HANDLE                           an HMAC key was selected                 but    the  private  part  of  the  key  is  not

                                              loaded

2881  TPM_RC

2882  CryptVerifySignature(

2883        TPMI_DH_OBJECT               keyHandle,          //    IN:        The      handle     of  sign  key

2884        TPM2B_DIGEST              *digest,               //    IN:        The      digest     being     validated

2885        TPMT_SIGNATURE            *signature             //    IN:        signature

2886        )

2887  {

2888        //  NOTE:    ObjectGet           will  either    return        a  pointer         to   a  loaded      object   or

2889        //  will     assert.      It     will  never   return       a     non-valid        value.       This  makes    it   save

2890        //  to  initialize           'publicArea'      with    the        return       value      from  ObjectGet()         without

2891        //  checking     it    first.

2892        OBJECT                            *authObject    =     ObjectGet(keyHandle);

2893        TPMT_PUBLIC                       *publicArea    =     &authObject->publicArea;

      Family "2.0"                                           TCG Published                                                               Page 331

      Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                            October 30, 2014
      Trusted Platform Module Library                                                            Part 4: Supporting  Routines

2894     TPM_RC                          result     =     TPM_RC_SCHEME;

2895

2896     //    The  input      unmarshaling    should         prevent    any  input   signature     from  being

2897     //    a   NULL     signature,   but  just        in  case

2898     if(signature->sigAlg            ==   TPM_ALG_NULL)

2899              return    TPM_RC_SIGNATURE;

2900

2901     switch     (publicArea->type)

2902     {

2903

2904  #ifdef   TPM_ALG_RSA

2905     case      TPM_ALG_RSA:

2906              result    =  CryptRSAVerifySignature(authObject,                 digest,  signature);

2907              break;

2908  #endif   //TPM_ALG_RSA

2909

2910  #ifdef   TPM_ALG_ECC

2911     case      TPM_ALG_ECC:

2912              result    =  CryptECCVerifySignature(authObject,                 digest,  signature);

2913              break;

2914

2915  #endif   //   TPM_ALG_ECC

2916

2917     case      TPM_ALG_KEYEDHASH:

2918              if(authObject->attributes.publicOnly)

2919                    result  =  TPM_RCS_HANDLE;

2920              else

2921                    result  =  CryptHMACVerifySignature(authObject,                    digest,     signature);

2922              break;

2923

2924     default:

2925              break;

2926     }

2927     return     result;

2928

2929  }

      10.2.10     Math functions

      10.2.10.1     CryptDivide()

      This function interfaces to the math library for large number divide.

      Error Returns                      Meaning

      TPM_RC_SIZE                        quotient or remainder is too small to receive the result

2930  TPM_RC

2931  CryptDivide(

2932     TPM2B                     *numerator,                //  IN:   numerator

2933     TPM2B                     *denominator,              //  IN:   denominator

2934     TPM2B                     *quotient,                 //  OUT:  quotient   =  numerator     /  denominator.

2935     TPM2B                     *remainder                 //  OUT:  numerator     mod  denominator.

2936     )

2937  {

2938     pAssert(           numerator    !=   NULL     &&     denominator!=   NULL

2939                    &&  (quotient    !=   NULL     ||     remainder  !=   NULL)

2940                );

2941     //    assume       denominator  is   not      0

2942     pAssert(denominator->size             !=      0);

2943

2944     return     TranslateCryptErrors(_math__Div(numerator,

2945                                                                    denominator,

      Page 332                                                TCG Published                                      Family "2.0"

      October 30, 2014                          Copyright © TCG 2006-2014                           Level 00 Revision 01.16
      Part 4: Supporting Routines                                                             Trusted Platform Module Library

2946                                                                 quotient,

2947                                                                 remainder)

2948                                     );

2949  }

      10.2.10.2    CryptCompare()

      This function interfaces to the math library for large number, unsigned      compare.

      Return Value                 Meaning

      1                            if a > b

      0                            if a = b

      -1                           if a < b

2950  LIB_EXPORT    int

2951  CryptCompare(

2952       const   UINT32      aSize,        //      IN:             size  of   a

2953       const   BYTE      *a,             //      IN:             a  buffer

2954       const   UINT32      bSize,        //      IN:             size  of   b

2955       const   BYTE      *b              //      IN:             b  buffer

2956       )

2957  {

2958       return   _math__uComp(aSize,  a,  bSize,  b);

2959  }

      10.2.10.3    CryptCompareSigned()

      This function interfaces to the math library for large number, signed        compare.

      Return Value                 Meaning

      1                            if a > b

      0                            if a = b

      -1                           if a < b

2960  int

2961  CryptCompareSigned(

2962       UINT32              aSize,        //      IN:             size  of   a

2963       BYTE              *a,             //      IN:             a  buffer

2964       UINT32              bSize,        //      IN:             size  of   b

2965       BYTE              *b              //      IN:             b  buffer

2966       )

2967  {

2968       return   _math__Comp(aSize,   a,  bSize,  b);

2969  }

      10.2.10.4    CryptGetTestResult

      This function returns the results of a self-test function.

      NOTE:          the behavior in this function is NOT the correct behavior for a real TPM implementation.  An artificial behavior is

                     placed here due to the limitation of a software simulation environment.  For the correct behavior, consult the

                     part 3 specification for TPM2_GetTestResult().

2970  TPM_RC

2971  CryptGetTestResult(

2972       TPM2B_MAX_BUFFER        *outData          //              OUT:  test    result     data

      Family "2.0"                           TCG Published                                                     Page 333

      Level 00 Revision 01.16            Copyright © TCG 2006-2014                                             October 30, 2014
      Trusted Platform Module Library                                                                               Part 4: Supporting Routines

2973       )

2974  {

2975       outData->t.size                  =     0;

2976       return       TPM_RC_SUCCESS;

2977  }

      10.2.11    Capability Support

      10.2.11.1      CryptCapGetECCCurve()

      This function returns the list of implemented ECC curves.

      Return Value                                      Meaning

      YES                                               if no more ECC curve is available

      NO                                                if there are more ECC curves not reported

2978  #ifdef   TPM_ALG_ECC              //%       5

2979  TPMI_YES_NO

2980  CryptCapGetECCCurve(

2981       TPM_ECC_CURVE                       curveID,                   //    IN:   the     starting    ECC   curve

2982       UINT32                              maxCount,                  //    IN:   count    of     returned  curve

2983       TPML_ECC_CURVE                   *curveList                    //    OUT:     ECC   curve  list

2984       )

2985  {

2986       TPMI_YES_NO                            more    =     NO;

2987       UINT16                                 i;

2988       UINT32                                 count      =  _cpri__EccGetCurveCount();

2989       TPM_ECC_CURVE                          curve;

2990

2991       //  Initialize               output        property        list

2992       curveList->count                    =  0;

2993

2994       //  The      maximum         count         of     curves   we      may    return    is     MAX_ECC_CURVES

2995       if(maxCount            >     MAX_ECC_CURVES)               maxCount        =   MAX_ECC_CURVES;

2996

2997       //  Scan     the       eccCurveValues                array

2998       for(i     =  0;     i     <  count;          i++)

2999       {

3000             curve      =     _cpri__GetCurveIdByIndex(i);

3001             //     If  curveID               is  less      than  the       starting       curveID,   skip  it

3002             if(curve            <  curveID)

3003                    continue;

3004

3005             if(curveList->count                         <  maxCount)

3006             {

3007                    //     If       we     have     not     filled      up  the      return    list,  add   more    curves  to

3008                    //     it

3009                    curveList->eccCurves[curveList->count]                                     =  curve;

3010                    curveList->count++;

3011             }

3012             else

3013             {

3014                    //     If       the       return        list  is    full     but   we  still    have    curves

3015                    //     available,               report        this    and    stop     iterating

3016                    more         =  YES;

3017                    break;

3018             }

3019

3020       }

3021

3022       return       more;

3023

      Page 334                                                            TCG Published                                             Family "2.0"

      October 30, 2014                                          Copyright © TCG 2006-2014                              Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                    Trusted Platform Module Library

3024  }

      10.2.11.2     CryptCapGetEccCurveNumber()

      This function returns the number of ECC curves supported by the TPM.

3025  UINT32

3026  CryptCapGetEccCurveNumber(

3027        void

3028        )

3029  {

3030        //  There      is  an   array     that          holds  the     curve   data.  Its  size      divided  by  the

3031        //  size    of     an   entry     is     the    number     of  values     in  the  table.

3032        return    _cpri__EccGetCurveCount();

3033  }

3034  #endif    //TPM_ALG_ECC       //%       5

      10.2.11.3     CryptAreKeySizesConsistent()

      This function validates that the public key size values are consistent for an asymmetric key.

      NOTE:                This is not a comprehensive test of the public key.

      Return Value                                Meaning

      TRUE                                        sizes are consistent

      FALSE                                       sizes are not consistent

3035  BOOL

3036  CryptAreKeySizesConsistent(

3037        TPMT_PUBLIC             *publicArea                    //   IN:   the     public   area  to  check

3038        )

3039  {

3040        BOOL                    consistent              =  FALSE;

3041

3042        switch    (publicArea->type)

3043        {

3044  #ifdef    TPM_ALG_RSA

3045              case     TPM_ALG_RSA:

3046                    //     The  key    size         in  bits   is   filtered      by  the  unmarshaling

3047                    consistent         =      (         ((publicArea->parameters.rsaDetail.keyBits+7)/8)

3048                                                    ==  publicArea->unique.rsa.t.size);

3049                    break;

3050  #endif    //TPM_ALG_RSA

3051

3052  #ifdef    TPM_ALG_ECC

3053              case     TPM_ALG_ECC:

3054                    {

3055                           UINT16                          keySizeInBytes;

3056                           TPM_ECC_CURVE                   curveId     =  publicArea->parameters.eccDetail.curveID;

3057

3058                           keySizeInBytes               =  CryptEccGetKeySizeInBytes(curveId);

3059

3060                           consistent            =      keySizeInBytes         >  0

3061                                                    &&  publicArea->unique.ecc.x.t.size              <=  keySizeInBytes

3062                                                    &&  publicArea->unique.ecc.y.t.size              <=  keySizeInBytes;

3063                    }

3064                    break;

3065  #endif    //TPM_ALG_ECC

3066              default:

3067                    break;

      Family "2.0"                                                 TCG Published                                           Page 335

      Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                 October 30, 2014
      Trusted Platform Module Library                                                Part 4: Supporting Routines

3068        }

3069

3070        return  consistent;

3071  }

      10.2.11.4     CryptAlgSetImplemented()

      This function initializes the bit vector with one bit for each implemented algorithm. This function is called

      from _TPM_Init(). The vector of implemented algorithms should be generated by the part 2 parser so that

      the g_implementedAlgorithms vector can be a const. That's not how it is now

3072  void

3073  CryptAlgsSetImplemented(

3074        void

3075        )

3076  {

3077        AlgorithmGetImplementedVector(&g_implementedAlgorithms);

3078  }

      10.3      Ticket.c

      10.3.1      Introduction

      This clause contains the functions used for ticket computations.

      10.3.2      Includes

1     #include      "InternalRoutines.h"

      10.3.3      Functions

      10.3.3.1      TicketIsSafe()

      This function indicates if producing a ticket is safe. It checks           if  the leading bytes      of an input buffer is

      TPM_GENERATED_VALUE or its substring of canonical form.                    If  so, it is not safe to  produce ticket for an

      input buffer claiming to be TPM generated buffer

      Return Value                         Meaning

      TRUE                                 It is safe to produce ticket

      FALSE                                It is not safe to produce ticket

2     BOOL

3     TicketIsSafe(

4           TPM2B                 *buffer

5           )

6     {

7           TPM_GENERATED         valueToCompare        =  TPM_GENERATED_VALUE;

8           BYTE                  bufferToCompare[sizeof(valueToCompare)];

9           BYTE                  *marshalBuffer;

10

11          //  If  the   buffer     size  is  less  than  the     size      of  TPM_GENERATED_VALUE,       assume

12          //  it  is   not  safe   to    generate  a     ticket

13          if(buffer->size       <  sizeof(valueToCompare))

14                return  FALSE;

15

16          marshalBuffer     =   bufferToCompare;

      Page 336                                             TCG Published                                    Family "2.0"

      October 30, 2014                         Copyright © TCG 2006-2014             Level 00 Revision 01.16
    Part 4: Supporting Routines                                                         Trusted Platform Module Library

17        TPM_GENERATED_Marshal(&valueToCompare,                 &marshalBuffer,        NULL);

18        if(MemoryEqual(buffer->buffer,              bufferToCompare,        sizeof(valueToCompare)))

19              return     FALSE;

20        else

21              return     TRUE;

22  }

    10.3.3.2       TicketComputeVerified()

    This function creates a TPMT_TK_VERIFIED ticket.

23  void

24  TicketComputeVerified(

25        TPMI_RH_HIERARCHY           hierarchy,      //         IN:   hierarchy   constant      for  ticket

26        TPM2B_DIGEST                *digest,        //         IN:   digest

27        TPM2B_NAME                  *keyName,       //         IN:   name   of   key  that  signed  the  value

28        TPMT_TK_VERIFIED            *ticket         //         OUT:  verified    ticket

29        )

30  {

31        TPM2B_AUTH                  *proof;

32        HMAC_STATE                  hmacState;

33

34        //  Fill    in   ticket  fields

35        ticket->tag      =  TPM_ST_VERIFIED;

36        ticket->hierarchy        =  hierarchy;

37

38        //  Use     the  proof   value     of  the  hierarchy

39        proof    =  HierarchyGetProof(hierarchy);

40

41        //  Start   HMAC

42        ticket->digest.t.size           =  CryptStartHMAC2B(CONTEXT_INTEGRITY_HASH_ALG,

43                                                               &proof->b,        &hmacState);

44

45        //  add     TPM_ST_VERIFIED

46        CryptUpdateDigestInt(&hmacState,            sizeof(TPM_ST),          &ticket->tag);

47

48        //  add     digest

49        CryptUpdateDigest2B(&hmacState,             &digest->b);

50

51        //  add     key  name

52        CryptUpdateDigest2B(&hmacState,             &keyName->b);

53

54        //  complete     HMAC

55        CryptCompleteHMAC2B(&hmacState,             &ticket->digest.b);

56

57        return;

58  }

    10.3.3.3       TicketComputeAuth()

    This function creates a TPMT_TK_AUTH ticket.

59  void

60  TicketComputeAuth(

61        TPM_ST                      type,           //         IN:   the   type  of   ticket.

62        TPMI_RH_HIERARCHY           hierarchy,      //         IN:   hierarchy   constant      for  ticket

63        UINT64                      timeout,        //         IN:   timeout

64        TPM2B_DIGEST                *cpHashA,       //         IN:   input   cpHashA

65        TPM2B_NONCE                 *policyRef,     //         IN:   input   policyRef

66        TPM2B_NAME                  *entityName,    //         IN:   name   of   entity

67        TPMT_TK_AUTH                *ticket         //         OUT:  Created     ticket

68        )

69  {

    Family "2.0"                                      TCG Published                                           Page 337

    Level 00 Revision 01.16                      Copyright © TCG 2006-2014                            October 30, 2014
     Trusted Platform Module Library                                               Part 4: Supporting  Routines

70         TPM2B_AUTH                  *proof;

71         HMAC_STATE                   hmacState;

72

73         //  Get     proper  proof

74         proof    =  HierarchyGetProof(hierarchy);

75

76         //  Fill    in  ticket   fields

77         ticket->tag     =   type;

78         ticket->hierarchy        =  hierarchy;

79

80         //  Start   HMAC

81         ticket->digest.t.size        =   CryptStartHMAC2B(CONTEXT_INTEGRITY_HASH_ALG,

82                                                        &proof->b,       &hmacState);

83

84         //  Adding      TPM_ST_AUTH

85         CryptUpdateDigestInt(&hmacState,         sizeof(UINT16),    &ticket->tag);

86

87         //  Adding      timeout

88         CryptUpdateDigestInt(&hmacState,         sizeof(UINT64),    &timeout);

89

90         //  Adding      cpHash

91         CryptUpdateDigest2B(&hmacState,          &cpHashA->b);

92

93         //  Adding      policyRef

94         CryptUpdateDigest2B(&hmacState,          &policyRef->b);

95

96         //  Adding      keyName

97         CryptUpdateDigest2B(&hmacState,          &entityName->b);

98

99         //  Compute     HMAC

100        CryptCompleteHMAC2B(&hmacState,          &ticket->digest.b);

101

102        return;

103  }

     10.3.3.4       TicketComputeHashCheck()

     This function creates a TPMT_TK_HASHCHECK ticket.

104  void

105  TicketComputeHashCheck(

106        TPMI_RH_HIERARCHY            hierarchy,    //  IN:   hierarchy  constant   for   ticket

107        TPM_ALG_ID                   hashAlg,      //  IN:   the  hash  algorithm  used  to  create

108                                                   //        'digest'

109        TPM2B_DIGEST                *digest,       //  IN:   input  digest

110        TPMT_TK_HASHCHECK           *ticket        //  OUT:  Created    ticket

111        )

112  {

113        TPM2B_AUTH                  *proof;

114        HMAC_STATE                   hmacState;

115

116        //  Get     proper  proof

117        proof    =  HierarchyGetProof(hierarchy);

118

119        //  Fill    in  ticket   fields

120        ticket->tag     =   TPM_ST_HASHCHECK;

121        ticket->hierarchy        =  hierarchy;

122

123        ticket->digest.t.size        =   CryptStartHMAC2B(CONTEXT_INTEGRITY_HASH_ALG,

124                                                       &proof->b,       &hmacState);

125

126        //  Add     TPM_ST_HASHCHECK

127        CryptUpdateDigestInt(&hmacState,         sizeof(TPM_ST),    &ticket->tag);

128

     Page 338                                       TCG Published                                   Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014                 Level 00 Revision 01.16
     Part  4: Supporting Routines                                                 Trusted  Platform  Module  Library

129        //  Add     hash  algorithm

130        CryptUpdateDigestInt(&hmacState,          sizeof(hashAlg),    &hashAlg);

131

132        //  Add     digest

133        CryptUpdateDigest2B(&hmacState,           &digest->b);

134

135        //  Compute       HMAC

136        CryptCompleteHMAC2B(&hmacState,           &ticket->digest.b);

137

138        return;

139  }

     10.3.3.5       TicketComputeCreation()

     This function creates a TPMT_TK_CREATION ticket.

140  void

141  TicketComputeCreation(

142        TPMI_RH_HIERARCHY             hierarchy,   //  IN:    hierarchy  for   ticket

143        TPM2B_NAME                    *name,       //  IN:    object  name

144        TPM2B_DIGEST                  *creation,   //  IN:    creation   hash

145        TPMT_TK_CREATION              *ticket      //  OUT:     created  ticket

146        )

147  {

148        TPM2B_AUTH                    *proof;

149        HMAC_STATE                    hmacState;

150

151        //  Get     proper   proof

152        proof    =  HierarchyGetProof(hierarchy);

153

154        //  Fill    in    ticket  fields

155        ticket->tag       =  TPM_ST_CREATION;

156        ticket->hierarchy         =   hierarchy;

157

158        ticket->digest.t.size         =   CryptStartHMAC2B(CONTEXT_INTEGRITY_HASH_ALG,

159                                                       &proof->b,        &hmacState);

160

161        //  Add     TPM_ST_CREATION

162        CryptUpdateDigestInt(&hmacState,          sizeof(TPM_ST),     &ticket->tag);

163

164        //  Add     name

165        CryptUpdateDigest2B(&hmacState,           &name->b);

166

167        //  Add     creation    hash

168        CryptUpdateDigest2B(&hmacState,           &creation->b);

169

170        //  Compute       HMAC

171        CryptCompleteHMAC2B(&hmacState,           &ticket->digest.b);

172

173        return;

174  }

     10.4      CryptSelfTest.c

     10.4.1    Introduction

     The functions in this file are designed to support self-test of cryptographic functions in the TPM. The TPM

     allows the user to decide whether to run self-test on a demand basis or to run all the self-tests before

     proceeding.

     The self-tests are controlled by a set of bit vectors. The g_untestedDecryptionAlgorithms vector has a bit

     for each decryption algorithm that needs to be tested and g_untestedEncryptionAlgorithms has a bit for

     Family "2.0"                                    TCG Published                                   Page 339

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                 October 30, 2014
    Trusted Platform Module Library                                                                  Part 4: Supporting Routines

    each encryption algorithm that needs to be tested. Before an algorithm is used, the appropriate vector is

    checked (indexed using the algorithm ID). If the bit is SET, then the test function should be called.

1   #include        "Global.h"
    
2   #include        "CryptoEngine.h"
    
3   #include        "InternalRoutines.h"
    
4   #include        "AlgorithmCap_fp.h"

   10.4.2    Functions

   10.4.2.1       RunSelfTest()

   Local function to run self-test

5   static    TPM_RC
    
6   CryptRunSelfTests(
    
7      ALGORITHM_VECTOR                *toTest                //     IN:  the   vector      of  the  algorithms     to  test
    
8      )
    
9   {
    
10     TPM_ALG_ID                      alg;
    
11  
    
12     //     For   each  of  the    algorithms    that       are    in   the   toTestVecor,    need  to  run    a
    
13     //     test
    
14     for(alg      =    TPM_ALG_FIRST;      alg   <=     TPM_ALG_LAST;         alg++)
    
15     {
    
16            if(TEST_BIT(alg,         *toTest))
    
17            {
    
18                  TPM_RC                 result      =  CryptTestAlgorithm(alg,               toTest);
    
19                  if(result      !=  TPM_RC_SUCCESS)
    
20                        return     result;
    
21            }
    
22     }
    
23     return       TPM_RC_SUCCESS;

24  }

    10.4.2.2       CryptSelfTest()

    This function is called to start/complete a full self-test. If fullTest is NO, then only the untested algorithms

    will be run. If fullTest is YES, then g_untestedDecryptionAlgorithms is reinitialized and then all tests are

    run. This implementation of the reference design does not support processing outside the framework of a

    TPM command. As a consequence, this command does not complete until all tests are done. Since this

    can take a long time, the TPM will check after each test to see if the command is canceled. If so, then the

    TPM will returned TPM_RC_CANCELLED. To continue with the self-tests, call TPM2_SelfTest(fullTest ==

    No) and the TPM will complete the testing.

    Error Returns                      Meaning

    TPM_RC_CANCELED                    if the command is canceled

25  LIB_EXPORT

26  TPM_RC

27  CryptSelfTest(

28     TPMI_YES_NO               fullTest                 //  IN:    if   full  test    is  required

29     )

30  {

31     if(g_forceFailureMode)

32            FAIL(FATAL_ERROR_FORCED);

33

34     //     If   the   caller  requested      a  full       test,  then      reset  the   to  test  vector   so   that

35     //     all   the   tests  will  be    run

    Page 340                                              TCG Published                                            Family "2.0"

    October 30, 2014                          Copyright © TCG 2006-2014                              Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                           Trusted Platform Module Library

36     if(fullTest          ==    YES)

37     {

38            MemoryCopy(g_toTest,

39                                g_implementedAlgorithms,

40                                sizeof(g_toTest),                 sizeof(g_toTest));

41     }

42     return       CryptRunSelfTests(&g_toTest);

43  }

    10.4.2.3      CryptIncrementalSelfTest()

    This function is used to perform an incremental self-test. This implementation will perform the toTest

    values before returning. That is, it assumes that the TPM cannot perform background tasks between

    commands.

    This command may be canceled. If it is, then there is no return result. However, this command can be run

    again and the incremental progress will not be lost.

    Error Returns                                 Meaning

    TPM_RC_CANCELED                               processing of this command was canceled

    TPM_RC_TESTING                                if toTest list is not empty

    TPM_RC_VALUE                                  an algorithm in the toTest list is not implemented

44  TPM_RC

45  CryptIncrementalSelfTest(

46     TPML_ALG                      *toTest,                      //  IN:   list    of   algorithms        to  be  tested

47     TPML_ALG                      *toDoList                     //  OUT:    list   of     algorithms       needing   test

48     )

49  {

50     ALGORITHM_VECTOR                        toTestVector         =  {0};

51     TPM_ALG_ID                              alg;

52     UINT32                                     i;

53

54     pAssert(toTest             !=       NULL   &&    toDoList       !=    NULL);

55     if(toTest->count                 >  0)

56     {

57            //    Transcribe             the    toTest      list     into  the   toTestVector

58            for(i      =  0;    i     <  toTest->count;              i++)

59            {

60                  TPM_ALG_ID                       alg   =  toTest->algorithms[i];

61

62                  //      make     sure         that  the   algorithm        value     is     not  out  of    range

63                  if((alg          >     TPM_ALG_LAST)           ||  !TEST_BIT(alg,           g_implementedAlgorithms))

64                          return         TPM_RC_VALUE;

65                  SET_BIT(alg,                  toTestVector);

66            }

67            //    Run     the   test

68            if(CryptRunSelfTests(&toTestVector)                              ==  TPM_RC_CANCELED)

69                  return        TPM_RC_CANCELED;

70     }

71     //     Fill  in      the   toDoList           with     the   algorithms       that       are  still    untested

72     toDoList->count               =     0;

73

74     for(alg      =    TPM_ALG_FIRST;

75            toDoList->count                  <  MAX_ALG_LIST_SIZE            &&  alg    <=    TPM_ALG_LAST;

76            alg++)

77     {

78            if(TEST_BIT(alg,                    g_toTest))

79                  toDoList->algorithms[toDoList->count++]                                  =  alg;

80     }

81     return       TPM_RC_SUCCESS;

    Family "2.0"                                                   TCG Published                                              Page 341

    Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                             Part 4: Supporting Routines

82   }
     
      10.4.2.4       CryptInitializeToTest()
     
      This function will initialize the data structures for testing all the algorithms.                           This should not        be  called
     
      unless CryptAlgsSetImplemented() has been called
     
83   void
     
84   CryptInitializeToTest(
     
85         void
     
86         )
     
87   {
     
88         MemoryCopy(g_toTest,
     
89                            g_implementedAlgorithms,
     
90                            sizeof(g_toTest),
     
91                            sizeof(g_toTest));
     
92         //  Setting        the  algorithm        to  null        causes     the  test      function       to  just      clear
     
93         //  out     any    algorithms       for   which       there     is   no  test.
     
94         CryptTestAlgorithm(TPM_ALG_ERROR,                         &g_toTest);
     
95   
     
96         return;
     
97   }
     
      10.4.2.5       CryptTestAlgorithm()
     
      Only point of contact with the actual self tests. If a self-test fails, there is no return and the TPM goes into
     
      failure mode. The call to TestAlgorithm() uses an algorithms selector and a bit vector. When the test is
     
      run, the corresponding bit in toTest and in g_toTest is CLEAR. If toTest is NULL, then only the bit in
     
      g_toTest    is    CLEAR.          There   is   a   special      case      for  the     call    to   TestAlgorithm().         When      alg  is
     
      TPM_ALG_ERROR, TestAlgorithm() will CLEAR any bit in toTest for which it has no test. This allows the
     
      knowledge about which algorithms have test to be accessed through the interface that provides the test.
     
      Error Returns                             Meaning
     
      TPM_RC_SUCCESS                            test complete
     
      TPM_RC_CANCELED                           test was canceled
     
98   LIB_EXPORT
     
99   TPM_RC

100  CryptTestAlgorithm(

101        TPM_ALG_ID                         alg,

102        ALGORITHM_VECTOR                *toTest

103        )

104  {

105        TPM_RC                                   result       =   TPM_RC_SUCCESS;

106  #ifdef    SELF_TEST

107        //  This       is  the  function        prototype         for   TestAlgorithms().             It  is      here  and     not

108        //  in   a     _fp.h    file  to    avoid    a    compiler       error       when    SELF_TEST        is  not   defined      and

109        //  AlgorithmTexts.c            is  not      part     of  the    build.

110        TPM_RC      TestAlgorithm(TPM_ALG_ID                  alg,     ALGORITHM_VECTOR          *toTest);

111        result      =   TestAlgorithm(alg,           toTest);

112  #else

113        //  If   this      is   an  attempt      to  determine          the   algorithms         for   which      there     is  a

114        //  self       test,    pretend     that     all   of     them   do.     We  do    that  by    not    clearing       any

115        //  of   the       algorithm    bits.     When/if         this   function        is  called       to  run   tests,      it

116        //  will       over    report.     This   can     be     changed     so  that      any   call     to  check     on   which

117        //  algorithms          have  tests,      'toTest'        can    be   cleared.

118        if(alg      !=     TPM_ALG_ERROR)

119        {

120              CLEAR_BIT(alg,          g_toTest);

121              if(toTest         !=  NULL)

     Page 342                                                    TCG Published                                                     Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
     Part 4: Supporting Routines                              Trusted  Platform Module Library

122                CLEAR_BIT(alg,  *toTest);

123     }

124  #endif

125     return     result;

126  }

     Family "2.0"                             TCG Published            Page 343

     Level 00 Revision 01.16       Copyright © TCG 2006-2014           October 30, 2014
    Trusted Platform Module Library                                                  Part 4: Supporting Routines

                                                   Annex A

                                                  (informative)

                                          Implementation Dependent

    A.1  Introduction

    This header file contains definitions that are derived from the values in the annexes of TPM 2.0 Part 2.

    This file would change based on the implementation.

    The values shown in this version of the file reflect the example settings in TPM 2.0 Part 2.

    A.2  Implementation.h

1   #ifndef   _IMPLEMENTATION_H_

2   #define   _IMPLEMENTATION_H_

3   #include        "BaseTypes.h"

4   #include        "TPMB.h"

5   #undef   TRUE

6   #undef   FALSE

    This table is built in to TpmStructures() Change these definitions to turn  all  algorithms   or commands on or

    off

7   #define         ALG_YES          YES

8   #define         ALG_NO           NO

9   #define         CC_YES           YES

10  #define         CC_NO            NO

    From TPM 2.0 Part 2: Table 4 - Defines for Logic Values

11  #define   TRUE         1

12  #define   FALSE        0

13  #define   YES          1

14  #define   NO           0

15  #define   SET          1

16  #define   CLEAR        0

    From Vendor-Specific: Table 1 - Defines for Processor Values

17  #define   BIG_ENDIAN_TPM              NO

18  #define   LITTLE_ENDIAN_TPM           YES

19  #define   NO_AUTO_ALIGN               NO

    From Vendor-Specific: Table  2   -  Defines for Implemented Algorithms

20  #define   ALG_RSA                     ALG_YES

21  #define   ALG_SHA1                    ALG_YES

22  #define   ALG_HMAC                    ALG_YES

23  #define   ALG_AES                     ALG_YES

24  #define   ALG_MGF1                    ALG_YES

25  #define   ALG_XOR                     ALG_YES

26  #define   ALG_KEYEDHASH               ALG_YES

27  #define   ALG_SHA256                  ALG_YES

28  #define   ALG_SHA384                  ALG_YES

29  #define   ALG_SHA512                  ALG_NO

30  #define   ALG_SM3_256                 ALG_NO

31  #define   ALG_SM4                     ALG_NO

32  #define   ALG_RSASSA                  (ALG_YES*ALG_RSA)

33  #define   ALG_RSAES                   (ALG_YES*ALG_RSA)

34  #define   ALG_RSAPSS                  (ALG_YES*ALG_RSA)

    Page 344                                   TCG Published                                      Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                  Level        00 Revision 01.16
    Part 4: Supporting Routines                                          Trusted Platform Module Library

35  #define  ALG_OAEP                  (ALG_YES*ALG_RSA)

36  #define  ALG_ECC                   ALG_YES

37  #define  ALG_ECDH                  (ALG_YES*ALG_ECC)

38  #define  ALG_ECDSA                 (ALG_YES*ALG_ECC)

39  #define  ALG_ECDAA                 (ALG_YES*ALG_ECC)

40  #define  ALG_SM2                   (ALG_YES*ALG_ECC)

41  #define  ALG_ECSCHNORR             (ALG_YES*ALG_ECC)

42  #define  ALG_ECMQV                 (ALG_NO*ALG_ECC)

43  #define  ALG_SYMCIPHER             ALG_YES

44  #define  ALG_KDF1_SP800_56A        (ALG_YES*ALG_ECC)

45  #define  ALG_KDF2                  ALG_NO

46  #define  ALG_KDF1_SP800_108        ALG_YES

47  #define  ALG_CTR                   ALG_YES

48  #define  ALG_OFB                   ALG_YES

49  #define  ALG_CBC                   ALG_YES

50  #define  ALG_CFB                   ALG_YES

51  #define  ALG_ECB                   ALG_YES

    From Vendor-Specific: Table 4 - Defines for Key Size Constants

52  #define  RSA_KEY_SIZES_BITS               {1024,2048}

53  #define  RSA_KEY_SIZE_BITS_1024           RSA_ALLOWED_KEY_SIZE_1024

54  #define  RSA_KEY_SIZE_BITS_2048           RSA_ALLOWED_KEY_SIZE_2048

55  #define  MAX_RSA_KEY_BITS                 2048

56  #define  MAX_RSA_KEY_BYTES                256

57  #define  AES_KEY_SIZES_BITS               {128,256}

58  #define  AES_KEY_SIZE_BITS_128            AES_ALLOWED_KEY_SIZE_128

59  #define  AES_KEY_SIZE_BITS_256            AES_ALLOWED_KEY_SIZE_256

60  #define  MAX_AES_KEY_BITS                 256

61  #define  MAX_AES_KEY_BYTES                32

62  #define  MAX_AES_BLOCK_SIZE_BYTES                                    \

63                MAX(AES_128_BLOCK_SIZE_BYTES,                          \

64                MAX(AES_256_BLOCK_SIZE_BYTES,      0))

65  #define  SM4_KEY_SIZES_BITS               {128}

66  #define  SM4_KEY_SIZE_BITS_128            SM4_ALLOWED_KEY_SIZE_128

67  #define  MAX_SM4_KEY_BITS                 128

68  #define  MAX_SM4_KEY_BYTES                16

69  #define  MAX_SM4_BLOCK_SIZE_BYTES                                    \

70                MAX(SM4_128_BLOCK_SIZE_BYTES,      0)

71  #define  CAMELLIA_KEY_SIZES_BITS          {128}

72  #define  CAMELLIA_KEY_SIZE_BITS_128            CAMELLIA_ALLOWED_KEY_SIZE_128

73  #define  MAX_CAMELLIA_KEY_BITS            128

74  #define  MAX_CAMELLIA_KEY_BYTES           16

75  #define  MAX_CAMELLIA_BLOCK_SIZE_BYTES                               \

76                MAX(CAMELLIA_128_BLOCK_SIZE_BYTES,       0)

    From Vendor-Specific: Table 5 - Defines for Implemented Curves

77  #define  ECC_NIST_P256             YES

78  #define  ECC_NIST_P384             YES

79  #define  ECC_BN_P256               YES

80  #define  ECC_CURVES                {\

81  TPM_ECC_BN_P256,         TPM_ECC_NIST_P256,     TPM_ECC_NIST_P384}

82  #define  ECC_KEY_SIZES_BITS        {256,   384}

83  #define  ECC_KEY_SIZE_BITS_256

84  #define  ECC_KEY_SIZE_BITS_384

85  #define  MAX_ECC_KEY_BITS          384

86  #define  MAX_ECC_KEY_BYTES         48

    From Vendor-Specific: Table 6 - Defines for Implemented Commands

87  #define  CC_ActivateCredential                   CC_YES

88  #define  CC_Certify                              CC_YES

89  #define  CC_CertifyCreation                      CC_YES

    Family "2.0"                              TCG Published                       Page 345

    Level 00 Revision 01.16          Copyright © TCG 2006-2014                    October 30, 2014
     Trusted Platform Module Library                              Part 4: Supporting Routines

90   #define   CC_ChangeEPS                   CC_YES

91   #define   CC_ChangePPS                   CC_YES

92   #define   CC_Clear                       CC_YES

93   #define   CC_ClearControl                CC_YES

94   #define   CC_ClockRateAdjust             CC_YES

95   #define   CC_ClockSet                    CC_YES

96   #define   CC_Commit                      (CC_YES*ALG_ECC)

97   #define   CC_ContextLoad                 CC_YES

98   #define   CC_ContextSave                 CC_YES

99   #define   CC_Create                      CC_YES

100  #define   CC_CreatePrimary               CC_YES

101  #define   CC_DictionaryAttackLockReset   CC_YES

102  #define   CC_DictionaryAttackParameters  CC_YES

103  #define   CC_Duplicate                   CC_YES

104  #define   CC_ECC_Parameters              (CC_YES*ALG_ECC)

105  #define   CC_ECDH_KeyGen                 (CC_YES*ALG_ECC)

106  #define   CC_ECDH_ZGen                   (CC_YES*ALG_ECC)

107  #define   CC_EncryptDecrypt              CC_YES

108  #define   CC_EventSequenceComplete       CC_YES

109  #define   CC_EvictControl                CC_YES

110  #define   CC_FieldUpgradeData            CC_NO

111  #define   CC_FieldUpgradeStart           CC_NO

112  #define   CC_FirmwareRead                CC_NO

113  #define   CC_FlushContext                CC_YES

114  #define   CC_GetCapability               CC_YES

115  #define   CC_GetCommandAuditDigest       CC_YES

116  #define   CC_GetRandom                   CC_YES

117  #define   CC_GetSessionAuditDigest       CC_YES

118  #define   CC_GetTestResult               CC_YES

119  #define   CC_GetTime                     CC_YES

120  #define   CC_Hash                        CC_YES

121  #define   CC_HashSequenceStart           CC_YES

122  #define   CC_HierarchyChangeAuth         CC_YES

123  #define   CC_HierarchyControl            CC_YES

124  #define   CC_HMAC                        CC_YES

125  #define   CC_HMAC_Start                  CC_YES

126  #define   CC_Import                      CC_YES

127  #define   CC_IncrementalSelfTest         CC_YES

128  #define   CC_Load                        CC_YES

129  #define   CC_LoadExternal                CC_YES

130  #define   CC_MakeCredential              CC_YES

131  #define   CC_NV_Certify                  CC_YES

132  #define   CC_NV_ChangeAuth               CC_YES

133  #define   CC_NV_DefineSpace              CC_YES

134  #define   CC_NV_Extend                   CC_YES

135  #define   CC_NV_GlobalWriteLock          CC_YES

136  #define   CC_NV_Increment                CC_YES

137  #define   CC_NV_Read                     CC_YES

138  #define   CC_NV_ReadLock                 CC_YES

139  #define   CC_NV_ReadPublic               CC_YES

140  #define   CC_NV_SetBits                  CC_YES

141  #define   CC_NV_UndefineSpace            CC_YES

142  #define   CC_NV_UndefineSpaceSpecial     CC_YES

143  #define   CC_NV_Write                    CC_YES

144  #define   CC_NV_WriteLock                CC_YES

145  #define   CC_ObjectChangeAuth            CC_YES

146  #define   CC_PCR_Allocate                CC_YES

147  #define   CC_PCR_Event                   CC_YES

148  #define   CC_PCR_Extend                  CC_YES

149  #define   CC_PCR_Read                    CC_YES

150  #define   CC_PCR_Reset                   CC_YES

151  #define   CC_PCR_SetAuthPolicy           CC_YES

152  #define   CC_PCR_SetAuthValue            CC_YES

153  #define   CC_PolicyAuthorize             CC_YES

154  #define   CC_PolicyAuthValue             CC_YES

155  #define   CC_PolicyCommandCode           CC_YES

     Page 346                                 TCG Published       Family "2.0"

     October 30, 2014                  Copyright © TCG 2006-2014  Level 00 Revision 01.16
     Part 4: Supporting Routines                                         Trusted Platform Module Library

156  #define  CC_PolicyCounterTimer               CC_YES

157  #define  CC_PolicyCpHash                     CC_YES

158  #define  CC_PolicyDuplicationSelect          CC_YES

159  #define  CC_PolicyGetDigest                  CC_YES

160  #define  CC_PolicyLocality                   CC_YES

161  #define  CC_PolicyNameHash                   CC_YES

162  #define  CC_PolicyNV                         CC_YES

163  #define  CC_PolicyOR                         CC_YES

164  #define  CC_PolicyPassword                   CC_YES

165  #define  CC_PolicyPCR                        CC_YES

166  #define  CC_PolicyPhysicalPresence           CC_YES

167  #define  CC_PolicyRestart                    CC_YES

168  #define  CC_PolicySecret                     CC_YES

169  #define  CC_PolicySigned                     CC_YES

170  #define  CC_PolicyTicket                     CC_YES

171  #define  CC_PP_Commands                      CC_YES

172  #define  CC_Quote                            CC_YES

173  #define  CC_ReadClock                        CC_YES

174  #define  CC_ReadPublic                       CC_YES

175  #define  CC_Rewrap                           CC_YES

176  #define  CC_RSA_Decrypt                      (CC_YES*ALG_RSA)

177  #define  CC_RSA_Encrypt                      (CC_YES*ALG_RSA)

178  #define  CC_SelfTest                         CC_YES

179  #define  CC_SequenceComplete                 CC_YES

180  #define  CC_SequenceUpdate                   CC_YES

181  #define  CC_SetAlgorithmSet                  CC_YES

182  #define  CC_SetCommandCodeAuditStatus        CC_YES

183  #define  CC_SetPrimaryPolicy                 CC_YES

184  #define  CC_Shutdown                         CC_YES

185  #define  CC_Sign                             CC_YES

186  #define  CC_StartAuthSession                 CC_YES

187  #define  CC_Startup                          CC_YES

188  #define  CC_StirRandom                       CC_YES

189  #define  CC_TestParms                        CC_YES

190  #define  CC_Unseal                           CC_YES

191  #define  CC_VerifySignature                  CC_YES

192  #define  CC_ZGen_2Phase                      (CC_YES*ALG_ECC)

193  #define  CC_EC_Ephemeral                     (CC_YES*ALG_ECC)

194  #define  CC_PolicyNvWritten                  CC_YES

     From Vendor-Specific: Table 7 - Defines for  Implementation Values

195  #define  FIELD_UPGRADE_IMPLEMENTED           NO

196  #define  BSIZE                               UINT16

197  #define  BUFFER_ALIGNMENT                    4

198  #define  IMPLEMENTATION_PCR                  24

199  #define  PLATFORM_PCR                        24

200  #define  DRTM_PCR                            17

201  #define  HCRTM_PCR                           0

202  #define  NUM_LOCALITIES                      5

203  #define  MAX_HANDLE_NUM                      3

204  #define  MAX_ACTIVE_SESSIONS                 64

205  #define  CONTEXT_SLOT                        UINT16

206  #define  CONTEXT_COUNTER                     UINT64

207  #define  MAX_LOADED_SESSIONS                 3

208  #define  MAX_SESSION_NUM                     3

209  #define  MAX_LOADED_OBJECTS                  3

210  #define  MIN_EVICT_OBJECTS                   2

211  #define  PCR_SELECT_MIN                      ((PLATFORM_PCR+7)/8)

212  #define  PCR_SELECT_MAX                      ((IMPLEMENTATION_PCR+7)/8)

213  #define  NUM_POLICY_PCR_GROUP                1

214  #define  NUM_AUTHVALUE_PCR_GROUP             1

215  #define  MAX_CONTEXT_SIZE                    2048

216  #define  MAX_DIGEST_BUFFER                   1024

217  #define  MAX_NV_INDEX_SIZE                   2048

     Family "2.0"                                 TCG Published               Page 347

     Level 00 Revision 01.16         Copyright © TCG 2006-2014                October 30, 2014
     Trusted Platform Module Library                                            Part 4: Supporting Routines

218  #define   MAX_NV_BUFFER_SIZE                        1024

219  #define   MAX_CAP_BUFFER                            1024

220  #define   NV_MEMORY_SIZE                            16384

221  #define   NUM_STATIC_PCR                            16

222  #define   MAX_ALG_LIST_SIZE                         64

223  #define   TIMER_PRESCALE                            100000

224  #define   PRIMARY_SEED_SIZE                         32

225  #define   CONTEXT_ENCRYPT_ALG                       TPM_ALG_AES

226  #define   CONTEXT_ENCRYPT_KEY_BITS                  MAX_SYM_KEY_BITS

227  #define   CONTEXT_ENCRYPT_KEY_BYTES                 ((CONTEXT_ENCRYPT_KEY_BITS+7)/8)

228  #define   CONTEXT_INTEGRITY_HASH_ALG                TPM_ALG_SHA256

229  #define   CONTEXT_INTEGRITY_HASH_SIZE               SHA256_DIGEST_SIZE

230  #define   PROOF_SIZE                                CONTEXT_INTEGRITY_HASH_SIZE

231  #define   NV_CLOCK_UPDATE_INTERVAL                  12

232  #define   NUM_POLICY_PCR                            1

233  #define   MAX_COMMAND_SIZE                          4096

234  #define   MAX_RESPONSE_SIZE                         4096

235  #define   ORDERLY_BITS                              8

236  #define   MAX_ORDERLY_COUNT                         ((1<<ORDERLY_BITS)-1)

237  #define   ALG_ID_FIRST                              TPM_ALG_FIRST

238  #define   ALG_ID_LAST                               TPM_ALG_LAST

239  #define   MAX_SYM_DATA                              128

240  #define   MAX_RNG_ENTROPY_SIZE                      64

241  #define   RAM_INDEX_SPACE                           512

242  #define   RSA_DEFAULT_PUBLIC_EXPONENT               0x00010001

243  #define   ENABLE_PCR_NO_INCREMENT                   YES

244  #define   CRT_FORMAT_RSA                            YES

245  #define   PRIVATE_VENDOR_SPECIFIC_BYTES             \

246       ((MAX_RSA_KEY_BYTES/2)*(3+CRT_FORMAT_RSA*2))

     From TCG Algorithm Registry: Table 2 - Definition of TPM_ALG_ID Constants

247  typedef   UINT16                     TPM_ALG_ID;

248  #define   TPM_ALG_ERROR                       (TPM_ALG_ID)(0x0000)

249  #define   ALG_ERROR_VALUE                     0x0000

250  #if  defined  ALG_RSA   &&  ALG_RSA  ==  YES

251  #define   TPM_ALG_RSA                         (TPM_ALG_ID)(0x0001)

252  #endif

253  #define   ALG_RSA_VALUE                       0x0001

254  #if  defined  ALG_SHA   &&  ALG_SHA  ==  YES

255  #define   TPM_ALG_SHA                         (TPM_ALG_ID)(0x0004)

256  #endif

257  #define   ALG_SHA_VALUE                       0x0004

258  #if  defined  ALG_SHA1  &&  ALG_SHA1     ==  YES

259  #define   TPM_ALG_SHA1                        (TPM_ALG_ID)(0x0004)

260  #endif

261  #define   ALG_SHA1_VALUE                      0x0004

262  #if  defined  ALG_HMAC  &&  ALG_HMAC     ==  YES

263  #define   TPM_ALG_HMAC                        (TPM_ALG_ID)(0x0005)

264  #endif

265  #define   ALG_HMAC_VALUE                      0x0005

266  #if  defined  ALG_AES   &&  ALG_AES  ==  YES

267  #define   TPM_ALG_AES                         (TPM_ALG_ID)(0x0006)

268  #endif

269  #define   ALG_AES_VALUE                       0x0006

270  #if  defined  ALG_MGF1  &&  ALG_MGF1     ==  YES

271  #define   TPM_ALG_MGF1                        (TPM_ALG_ID)(0x0007)

272  #endif

273  #define   ALG_MGF1_VALUE                      0x0007

274  #if  defined  ALG_KEYEDHASH      &&  ALG_KEYEDHASH     ==  YES

275  #define   TPM_ALG_KEYEDHASH                   (TPM_ALG_ID)(0x0008)

276  #endif

277  #define   ALG_KEYEDHASH_VALUE                 0x0008

278  #if  defined  ALG_XOR   &&  ALG_XOR  ==  YES

279  #define   TPM_ALG_XOR                         (TPM_ALG_ID)(0x000A)

     Page 348                                     TCG Published                            Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                     Trusted  Platform Module Library

280  #endif

281  #define  ALG_XOR_VALUE                               0x000A

282  #if  defined  ALG_SHA256     &&      ALG_SHA256      ==  YES

283  #define  TPM_ALG_SHA256                              (TPM_ALG_ID)(0x000B)

284  #endif

285  #define  ALG_SHA256_VALUE                            0x000B

286  #if  defined  ALG_SHA384     &&      ALG_SHA384      ==  YES

287  #define  TPM_ALG_SHA384                              (TPM_ALG_ID)(0x000C)

288  #endif

289  #define  ALG_SHA384_VALUE                            0x000C

290  #if  defined  ALG_SHA512     &&      ALG_SHA512      ==  YES

291  #define  TPM_ALG_SHA512                              (TPM_ALG_ID)(0x000D)

292  #endif

293  #define  ALG_SHA512_VALUE                            0x000D

294  #define  TPM_ALG_NULL                                (TPM_ALG_ID)(0x0010)

295  #define  ALG_NULL_VALUE                              0x0010

296  #if  defined  ALG_SM3_256        &&  ALG_SM3_256         ==  YES

297  #define  TPM_ALG_SM3_256                             (TPM_ALG_ID)(0x0012)

298  #endif

299  #define  ALG_SM3_256_VALUE                           0x0012

300  #if  defined  ALG_SM4   &&   ALG_SM4     ==  YES

301  #define  TPM_ALG_SM4                                 (TPM_ALG_ID)(0x0013)

302  #endif

303  #define  ALG_SM4_VALUE                               0x0013

304  #if  defined  ALG_RSASSA     &&      ALG_RSASSA      ==  YES

305  #define  TPM_ALG_RSASSA                              (TPM_ALG_ID)(0x0014)

306  #endif

307  #define  ALG_RSASSA_VALUE                            0x0014

308  #if  defined  ALG_RSAES      &&  ALG_RSAES       ==  YES

309  #define  TPM_ALG_RSAES                               (TPM_ALG_ID)(0x0015)

310  #endif

311  #define  ALG_RSAES_VALUE                             0x0015

312  #if  defined  ALG_RSAPSS     &&      ALG_RSAPSS      ==  YES

313  #define  TPM_ALG_RSAPSS                              (TPM_ALG_ID)(0x0016)

314  #endif

315  #define  ALG_RSAPSS_VALUE                            0x0016

316  #if  defined  ALG_OAEP   &&      ALG_OAEP    ==  YES

317  #define  TPM_ALG_OAEP                                (TPM_ALG_ID)(0x0017)

318  #endif

319  #define  ALG_OAEP_VALUE                              0x0017

320  #if  defined  ALG_ECDSA      &&  ALG_ECDSA       ==  YES

321  #define  TPM_ALG_ECDSA                               (TPM_ALG_ID)(0x0018)

322  #endif

323  #define  ALG_ECDSA_VALUE                             0x0018

324  #if  defined  ALG_ECDH   &&      ALG_ECDH    ==  YES

325  #define  TPM_ALG_ECDH                                (TPM_ALG_ID)(0x0019)

326  #endif

327  #define  ALG_ECDH_VALUE                              0x0019

328  #if  defined  ALG_ECDAA      &&  ALG_ECDAA       ==  YES

329  #define  TPM_ALG_ECDAA                               (TPM_ALG_ID)(0x001A)

330  #endif

331  #define  ALG_ECDAA_VALUE                             0x001A

332  #if  defined  ALG_SM2   &&   ALG_SM2     ==  YES

333  #define  TPM_ALG_SM2                                 (TPM_ALG_ID)(0x001B)

334  #endif

335  #define  ALG_SM2_VALUE                               0x001B

336  #if  defined  ALG_ECSCHNORR          &&  ALG_ECSCHNORR        ==  YES

337  #define  TPM_ALG_ECSCHNORR                           (TPM_ALG_ID)(0x001C)

338  #endif

339  #define  ALG_ECSCHNORR_VALUE                         0x001C

340  #if  defined  ALG_ECMQV      &&  ALG_ECMQV       ==  YES

341  #define  TPM_ALG_ECMQV                               (TPM_ALG_ID)(0x001D)

342  #endif

343  #define  ALG_ECMQV_VALUE                             0x001D

344  #if  defined  ALG_KDF1_SP800_56A         &&  ALG_KDF1_SP800_56A        ==  YES

345  #define  TPM_ALG_KDF1_SP800_56A                      (TPM_ALG_ID)(0x0020)

     Family "2.0"                                     TCG Published                           Page 349

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                       October 30, 2014
     Trusted Platform Module Library                                          Part 4: Supporting Routines

346  #endif

347  #define   ALG_KDF1_SP800_56A_VALUE            0x0020

348  #if  defined  ALG_KDF2  &&  ALG_KDF2     ==  YES

349  #define   TPM_ALG_KDF2                        (TPM_ALG_ID)(0x0021)

350  #endif

351  #define   ALG_KDF2_VALUE                      0x0021

352  #if  defined  ALG_KDF1_SP800_108     &&  ALG_KDF1_SP800_108     ==  YES

353  #define   TPM_ALG_KDF1_SP800_108              (TPM_ALG_ID)(0x0022)

354  #endif

355  #define   ALG_KDF1_SP800_108_VALUE            0x0022

356  #if  defined  ALG_ECC   &&  ALG_ECC  ==  YES

357  #define   TPM_ALG_ECC                         (TPM_ALG_ID)(0x0023)

358  #endif

359  #define   ALG_ECC_VALUE                       0x0023

360  #if  defined  ALG_SYMCIPHER      &&  ALG_SYMCIPHER     ==  YES

361  #define   TPM_ALG_SYMCIPHER                   (TPM_ALG_ID)(0x0025)

362  #endif

363  #define   ALG_SYMCIPHER_VALUE                 0x0025

364  #if  defined  ALG_CAMELLIA   &&      ALG_CAMELLIA  ==  YES

365  #define   TPM_ALG_CAMELLIA                    (TPM_ALG_ID)(0x0026)

366  #endif

367  #define   ALG_CAMELLIA_VALUE                  0x0026

368  #if  defined  ALG_CTR   &&  ALG_CTR  ==  YES

369  #define   TPM_ALG_CTR                         (TPM_ALG_ID)(0x0040)

370  #endif

371  #define   ALG_CTR_VALUE                       0x0040

372  #if  defined  ALG_OFB   &&  ALG_OFB  ==  YES

373  #define   TPM_ALG_OFB                         (TPM_ALG_ID)(0x0041)

374  #endif

375  #define   ALG_OFB_VALUE                       0x0041

376  #if  defined  ALG_CBC   &&  ALG_CBC  ==  YES

377  #define   TPM_ALG_CBC                         (TPM_ALG_ID)(0x0042)

378  #endif

379  #define   ALG_CBC_VALUE                       0x0042

380  #if  defined  ALG_CFB   &&  ALG_CFB  ==  YES

381  #define   TPM_ALG_CFB                         (TPM_ALG_ID)(0x0043)

382  #endif

383  #define   ALG_CFB_VALUE                       0x0043

384  #if  defined  ALG_ECB   &&  ALG_ECB  ==  YES

385  #define   TPM_ALG_ECB                         (TPM_ALG_ID)(0x0044)

386  #endif

387  #define   ALG_ECB_VALUE                       0x0044

388  #define   TPM_ALG_FIRST                       (TPM_ALG_ID)(0x0001)

389  #define   ALG_FIRST_VALUE                     0x0001

390  #define   TPM_ALG_LAST                        (TPM_ALG_ID)(0x0044)

391  #define   ALG_LAST_VALUE                      0x0044

     From TCG  Algorithm Registry: Table 3 - Definition of TPM_ECC_CURVE      Constants

392  typedef   UINT16                     TPM_ECC_CURVE;

393  #define   TPM_ECC_NONE               (TPM_ECC_CURVE)(0x0000)

394  #define   TPM_ECC_NIST_P192          (TPM_ECC_CURVE)(0x0001)

395  #define   TPM_ECC_NIST_P224          (TPM_ECC_CURVE)(0x0002)

396  #define   TPM_ECC_NIST_P256          (TPM_ECC_CURVE)(0x0003)

397  #define   TPM_ECC_NIST_P384          (TPM_ECC_CURVE)(0x0004)

398  #define   TPM_ECC_NIST_P521          (TPM_ECC_CURVE)(0x0005)

399  #define   TPM_ECC_BN_P256            (TPM_ECC_CURVE)(0x0010)

400  #define   TPM_ECC_BN_P638            (TPM_ECC_CURVE)(0x0011)

401  #define   TPM_ECC_SM2_P256           (TPM_ECC_CURVE)(0x0020)

     From TCG Algorithm Registry: Table 4 - Defines for NIST_P192 ECC Values Data in CrpiEccData.c From

     TCG Algorithm Registry: Table 5 - Defines for NIST_P224 ECC Values Data in CrpiEccData.c From TCG

     Algorithm Registry: Table 6 - Defines for NIST_P256 ECC Values Data in CrpiEccData.c From TCG

     Algorithm Registry: Table 7 - Defines for NIST_P384 ECC Values Data in CrpiEccData.c From TCG

     Page 350                                     TCG Published                          Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014           Level 00 Revision 01.16
     Part 4: Supporting Routines                                              Trusted Platform Module Library

     Algorithm Registry: Table 8 - Defines for NIST_P521 ECC Values Data in CrpiEccData.c From               TCG

     Algorithm  Registry:  Table  9  -  Defines   for  BN_P256  ECC   Values  Data  in  CrpiEccData.c  From  TCG

     Algorithm Registry: Table 10 - Defines for BN_P638 ECC Values Data in CrpiEccData.c From                TCG

     Algorithm Registry: Table 11 - Defines for SM2_P256 ECC Values Data in CrpiEccData.c From               TCG

     Algorithm Registry: Table 12 - Defines for SHA1 Hash Values

402  #define    SHA1_DIGEST_SIZE        20

403  #define    SHA1_BLOCK_SIZE         64

404  #define    SHA1_DER_SIZE           15

405  #define    SHA1_DER                \

406       0x30,0x21,0x30,0x09,0x06,0x05,0x2B,0x0E,0x03,0x02,0x1A,0x05,0x00,0x04,0x14

     From TCG Algorithm Registry: Table 13 - Defines for SHA256 Hash Values

407  #define    SHA256_DIGEST_SIZE          32

408  #define    SHA256_BLOCK_SIZE           64

409  #define    SHA256_DER_SIZE             19

410  #define    SHA256_DER                  \

411  0x30,0x31,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20

     From TCG Algorithm Registry: Table 14 - Defines for SHA384 Hash Values

412  #define    SHA384_DIGEST_SIZE          48

413  #define    SHA384_BLOCK_SIZE           128

414  #define    SHA384_DER_SIZE             19

415  #define    SHA384_DER                  \

416  0x30,0x41,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30

     From TCG Algorithm Registry: Table 15 - Defines for SHA512 Hash Values

417  #define    SHA512_DIGEST_SIZE          64

418  #define    SHA512_BLOCK_SIZE           128

419  #define    SHA512_DER_SIZE             19

420  #define    SHA512_DER                  \

421  0x30,0x51,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40

     From TCG Algorithm Registry: Table 16 - Defines for SM3_256 Hash Values

422  #define    SM3_256_DIGEST_SIZE            32

423  #define    SM3_256_BLOCK_SIZE             64

424  #define    SM3_256_DER_SIZE               18

425  #define    SM3_256_DER                    \

426  0x30,0x30,0x30,0x0C,0x06,0x08,0x2A,0x81,0x1C,0x81,0x45,0x01,0x83,0x11,0x05,0x00,0x04,0x20

     From TCG Algorithm Registry: Table 17 - Defines for AES Symmetric Cipher Algorithm Constants

427  #define    AES_ALLOWED_KEY_SIZE_128               YES

428  #define    AES_ALLOWED_KEY_SIZE_192               YES

429  #define    AES_ALLOWED_KEY_SIZE_256               YES

430  #define    AES_128_BLOCK_SIZE_BYTES               16

431  #define    AES_192_BLOCK_SIZE_BYTES               16

432  #define    AES_256_BLOCK_SIZE_BYTES               16

     From TCG Algorithm Registry: Table 18 - Defines for SM4 Symmetric Cipher Algorithm Constants

     Family "2.0"                                      TCG Published                                   Page 351

     Level 00 Revision 01.16               Copyright © TCG 2006-2014                    October 30, 2014
     Trusted Platform Module Library                                                          Part 4: Supporting Routines

433  #define   SM4_ALLOWED_KEY_SIZE_128               YES

434  #define   SM4_128_BLOCK_SIZE_BYTES               16

     From TCG Algorithm Registry: Table 19 - Defines for CAMELLIA Symmetric Cipher Algorithm Constants

435  #define   CAMELLIA_ALLOWED_KEY_SIZE_128                  YES

436  #define   CAMELLIA_ALLOWED_KEY_SIZE_192                  YES

437  #define   CAMELLIA_ALLOWED_KEY_SIZE_256                  YES

438  #define   CAMELLIA_128_BLOCK_SIZE_BYTES                  16

439  #define   CAMELLIA_192_BLOCK_SIZE_BYTES                  16

440  #define   CAMELLIA_256_BLOCK_SIZE_BYTES                  16

     From TPM 2.0 Part 2: Table 13 - Definition of TPM_CC Constants

441  typedef   UINT32                 TPM_CC;

442  #define   TPM_CC_FIRST                                        (TPM_CC)(0x0000011F)

443  #define   TPM_CC_PP_FIRST                                     (TPM_CC)(0x0000011F)

444  #if  defined  CC_NV_UndefineSpaceSpecial             &&  CC_NV_UndefineSpaceSpecial           ==  YES

445  #define   TPM_CC_NV_UndefineSpaceSpecial                      (TPM_CC)(0x0000011F)

446  #endif

447  #if  defined  CC_EvictControl    &&  CC_EvictControl              ==  YES

448  #define   TPM_CC_EvictControl                                 (TPM_CC)(0x00000120)

449  #endif

450  #if  defined  CC_HierarchyControl        &&  CC_HierarchyControl           ==   YES

451  #define   TPM_CC_HierarchyControl                             (TPM_CC)(0x00000121)

452  #endif

453  #if  defined  CC_NV_UndefineSpace        &&  CC_NV_UndefineSpace           ==   YES

454  #define   TPM_CC_NV_UndefineSpace                             (TPM_CC)(0x00000122)

455  #endif

456  #if  defined  CC_ChangeEPS  &&   CC_ChangeEPS            ==  YES

457  #define   TPM_CC_ChangeEPS                                    (TPM_CC)(0x00000124)

458  #endif

459  #if  defined  CC_ChangePPS  &&   CC_ChangePPS            ==  YES

460  #define   TPM_CC_ChangePPS                                    (TPM_CC)(0x00000125)

461  #endif

462  #if  defined  CC_Clear  &&  CC_Clear     ==  YES

463  #define   TPM_CC_Clear                                        (TPM_CC)(0x00000126)

464  #endif

465  #if  defined  CC_ClearControl    &&  CC_ClearControl              ==  YES

466  #define   TPM_CC_ClearControl                                 (TPM_CC)(0x00000127)

467  #endif

468  #if  defined  CC_ClockSet   &&   CC_ClockSet         ==  YES

469  #define   TPM_CC_ClockSet                                     (TPM_CC)(0x00000128)

470  #endif

471  #if  defined  CC_HierarchyChangeAuth         &&  CC_HierarchyChangeAuth              ==  YES

472  #define   TPM_CC_HierarchyChangeAuth                          (TPM_CC)(0x00000129)

473  #endif

474  #if  defined  CC_NV_DefineSpace      &&  CC_NV_DefineSpace             ==  YES

475  #define   TPM_CC_NV_DefineSpace                               (TPM_CC)(0x0000012A)

476  #endif

477  #if  defined  CC_PCR_Allocate    &&  CC_PCR_Allocate              ==  YES

478  #define   TPM_CC_PCR_Allocate                                 (TPM_CC)(0x0000012B)

479  #endif

480  #if  defined  CC_PCR_SetAuthPolicy       &&  CC_PCR_SetAuthPolicy               ==  YES

481  #define   TPM_CC_PCR_SetAuthPolicy                            (TPM_CC)(0x0000012C)

482  #endif

483  #if  defined  CC_PP_Commands     &&  CC_PP_Commands           ==  YES

484  #define   TPM_CC_PP_Commands                                  (TPM_CC)(0x0000012D)

485  #endif

486  #if  defined  CC_SetPrimaryPolicy        &&  CC_SetPrimaryPolicy           ==   YES

487  #define   TPM_CC_SetPrimaryPolicy                             (TPM_CC)(0x0000012E)

488  #endif

489  #if  defined  CC_FieldUpgradeStart       &&  CC_FieldUpgradeStart               ==  YES

490  #define   TPM_CC_FieldUpgradeStart                            (TPM_CC)(0x0000012F)

491  #endif

     Page 352                                     TCG Published                                             Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                         Trusted Platform Module Library

492  #if  defined  CC_ClockRateAdjust         &&  CC_ClockRateAdjust            ==  YES

493  #define  TPM_CC_ClockRateAdjust                                  (TPM_CC)(0x00000130)

494  #endif

495  #if  defined  CC_CreatePrimary       &&  CC_CreatePrimary             ==  YES

496  #define  TPM_CC_CreatePrimary                                    (TPM_CC)(0x00000131)

497  #endif

498  #if  defined  CC_NV_GlobalWriteLock          &&  CC_NV_GlobalWriteLock              ==  YES

499  #define  TPM_CC_NV_GlobalWriteLock                               (TPM_CC)(0x00000132)

500  #endif

501  #define  TPM_CC_PP_LAST                                          (TPM_CC)(0x00000132)

502  #if  defined  CC_GetCommandAuditDigest           &&  CC_GetCommandAuditDigest                ==  YES

503  #define  TPM_CC_GetCommandAuditDigest                            (TPM_CC)(0x00000133)

504  #endif

505  #if  defined  CC_NV_Increment        &&  CC_NV_Increment          ==  YES

506  #define  TPM_CC_NV_Increment                                     (TPM_CC)(0x00000134)

507  #endif

508  #if  defined  CC_NV_SetBits      &&  CC_NV_SetBits           ==  YES

509  #define  TPM_CC_NV_SetBits                                       (TPM_CC)(0x00000135)

510  #endif

511  #if  defined  CC_NV_Extend       &&  CC_NV_Extend        ==  YES

512  #define  TPM_CC_NV_Extend                                        (TPM_CC)(0x00000136)

513  #endif

514  #if  defined  CC_NV_Write    &&      CC_NV_Write     ==  YES

515  #define  TPM_CC_NV_Write                                         (TPM_CC)(0x00000137)

516  #endif

517  #if  defined  CC_NV_WriteLock        &&  CC_NV_WriteLock          ==  YES

518  #define  TPM_CC_NV_WriteLock                                     (TPM_CC)(0x00000138)

519  #endif

520  #if  defined  CC_DictionaryAttackLockReset               &&  CC_DictionaryAttackLockReset             ==  YES

521  #define  TPM_CC_DictionaryAttackLockReset                        (TPM_CC)(0x00000139)

522  #endif

523  #if  defined  CC_DictionaryAttackParameters              &&      CC_DictionaryAttackParameters            ==  YES

524  #define  TPM_CC_DictionaryAttackParameters                       (TPM_CC)(0x0000013A)

525  #endif

526  #if  defined  CC_NV_ChangeAuth       &&  CC_NV_ChangeAuth             ==  YES

527  #define  TPM_CC_NV_ChangeAuth                                    (TPM_CC)(0x0000013B)

528  #endif

529  #if  defined  CC_PCR_Event       &&  CC_PCR_Event        ==  YES

530  #define  TPM_CC_PCR_Event                                        (TPM_CC)(0x0000013C)

531  #endif

532  #if  defined  CC_PCR_Reset       &&  CC_PCR_Reset        ==  YES

533  #define  TPM_CC_PCR_Reset                                        (TPM_CC)(0x0000013D)

534  #endif

535  #if  defined  CC_SequenceComplete        &&  CC_SequenceComplete               ==  YES

536  #define  TPM_CC_SequenceComplete                                 (TPM_CC)(0x0000013E)

537  #endif

538  #if  defined  CC_SetAlgorithmSet         &&  CC_SetAlgorithmSet            ==  YES

539  #define  TPM_CC_SetAlgorithmSet                                  (TPM_CC)(0x0000013F)

540  #endif

541  #if  defined  CC_SetCommandCodeAuditStatus               &&  CC_SetCommandCodeAuditStatus             ==  YES

542  #define  TPM_CC_SetCommandCodeAuditStatus                        (TPM_CC)(0x00000140)

543  #endif

544  #if  defined  CC_FieldUpgradeData        &&  CC_FieldUpgradeData               ==  YES

545  #define  TPM_CC_FieldUpgradeData                                 (TPM_CC)(0x00000141)

546  #endif

547  #if  defined  CC_IncrementalSelfTest         &&   CC_IncrementalSelfTest                ==  YES

548  #define  TPM_CC_IncrementalSelfTest                              (TPM_CC)(0x00000142)

549  #endif

550  #if  defined  CC_SelfTest    &&      CC_SelfTest     ==  YES

551  #define  TPM_CC_SelfTest                                         (TPM_CC)(0x00000143)

552  #endif

553  #if  defined  CC_Startup     &&  CC_Startup      ==  YES

554  #define  TPM_CC_Startup                                          (TPM_CC)(0x00000144)

555  #endif

556  #if  defined  CC_Shutdown    &&      CC_Shutdown     ==  YES

557  #define  TPM_CC_Shutdown                                         (TPM_CC)(0x00000145)

     Family "2.0"                                     TCG Published                                                Page 353

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                    Part 4: Supporting Routines

558  #endif

559  #if  defined  CC_StirRandom         &&   CC_StirRandom               ==  YES

560  #define   TPM_CC_StirRandom                                              (TPM_CC)(0x00000146)

561  #endif

562  #if  defined  CC_ActivateCredential                 &&   CC_ActivateCredential                 ==  YES

563  #define   TPM_CC_ActivateCredential                                      (TPM_CC)(0x00000147)

564  #endif

565  #if  defined  CC_Certify     &&     CC_Certify           ==  YES

566  #define   TPM_CC_Certify                                                 (TPM_CC)(0x00000148)

567  #endif

568  #if  defined  CC_PolicyNV       &&   CC_PolicyNV             ==  YES

569  #define   TPM_CC_PolicyNV                                                (TPM_CC)(0x00000149)

570  #endif

571  #if  defined  CC_CertifyCreation            &&      CC_CertifyCreation                ==  YES

572  #define   TPM_CC_CertifyCreation                                         (TPM_CC)(0x0000014A)

573  #endif

574  #if  defined  CC_Duplicate       &&     CC_Duplicate             ==  YES

575  #define   TPM_CC_Duplicate                                               (TPM_CC)(0x0000014B)

576  #endif

577  #if  defined  CC_GetTime     &&     CC_GetTime           ==  YES

578  #define   TPM_CC_GetTime                                                 (TPM_CC)(0x0000014C)

579  #endif

580  #if  defined  CC_GetSessionAuditDigest                   &&  CC_GetSessionAuditDigest                   ==  YES

581  #define   TPM_CC_GetSessionAuditDigest                                   (TPM_CC)(0x0000014D)

582  #endif

583  #if  defined  CC_NV_Read     &&     CC_NV_Read           ==  YES

584  #define   TPM_CC_NV_Read                                                 (TPM_CC)(0x0000014E)

585  #endif

586  #if  defined  CC_NV_ReadLock         &&     CC_NV_ReadLock               ==  YES

587  #define   TPM_CC_NV_ReadLock                                             (TPM_CC)(0x0000014F)

588  #endif

589  #if  defined  CC_ObjectChangeAuth               &&  CC_ObjectChangeAuth                   ==  YES

590  #define   TPM_CC_ObjectChangeAuth                                        (TPM_CC)(0x00000150)

591  #endif

592  #if  defined  CC_PolicySecret           &&  CC_PolicySecret                  ==  YES

593  #define   TPM_CC_PolicySecret                                            (TPM_CC)(0x00000151)

594  #endif

595  #if  defined  CC_Rewrap     &&   CC_Rewrap          ==   YES

596  #define   TPM_CC_Rewrap                                                  (TPM_CC)(0x00000152)

597  #endif

598  #if  defined  CC_Create     &&   CC_Create          ==   YES

599  #define   TPM_CC_Create                                                  (TPM_CC)(0x00000153)

600  #endif

601  #if  defined  CC_ECDH_ZGen       &&     CC_ECDH_ZGen             ==  YES

602  #define   TPM_CC_ECDH_ZGen                                               (TPM_CC)(0x00000154)

603  #endif

604  #if  defined  CC_HMAC   &&   CC_HMAC        ==      YES

605  #define   TPM_CC_HMAC                                                    (TPM_CC)(0x00000155)

606  #endif

607  #if  defined  CC_Import     &&   CC_Import          ==   YES

608  #define   TPM_CC_Import                                                  (TPM_CC)(0x00000156)

609  #endif

610  #if  defined  CC_Load   &&   CC_Load        ==      YES

611  #define   TPM_CC_Load                                                    (TPM_CC)(0x00000157)

612  #endif

613  #if  defined  CC_Quote   &&     CC_Quote        ==      YES

614  #define   TPM_CC_Quote                                                   (TPM_CC)(0x00000158)

615  #endif

616  #if  defined  CC_RSA_Decrypt         &&     CC_RSA_Decrypt               ==  YES

617  #define   TPM_CC_RSA_Decrypt                                             (TPM_CC)(0x00000159)

618  #endif

619  #if  defined  CC_HMAC_Start         &&   CC_HMAC_Start               ==  YES

620  #define   TPM_CC_HMAC_Start                                              (TPM_CC)(0x0000015B)

621  #endif

622  #if  defined  CC_SequenceUpdate             &&  CC_SequenceUpdate                 ==  YES

623  #define   TPM_CC_SequenceUpdate                                          (TPM_CC)(0x0000015C)

     Page 354                                                TCG Published                                             Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                                   Level 00  Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted  Platform Module Library

624  #endif

625  #if  defined  CC_Sign  &&    CC_Sign         ==  YES

626  #define  TPM_CC_Sign                                               (TPM_CC)(0x0000015D)

627  #endif

628  #if  defined  CC_Unseal      &&  CC_Unseal           ==  YES

629  #define  TPM_CC_Unseal                                             (TPM_CC)(0x0000015E)

630  #endif

631  #if  defined  CC_PolicySigned            &&  CC_PolicySigned           ==  YES

632  #define  TPM_CC_PolicySigned                                       (TPM_CC)(0x00000160)

633  #endif

634  #if  defined  CC_ContextLoad         &&      CC_ContextLoad        ==  YES

635  #define  TPM_CC_ContextLoad                                        (TPM_CC)(0x00000161)

636  #endif

637  #if  defined  CC_ContextSave         &&      CC_ContextSave        ==  YES

638  #define  TPM_CC_ContextSave                                        (TPM_CC)(0x00000162)

639  #endif

640  #if  defined  CC_ECDH_KeyGen         &&      CC_ECDH_KeyGen        ==  YES

641  #define  TPM_CC_ECDH_KeyGen                                        (TPM_CC)(0x00000163)

642  #endif

643  #if  defined  CC_EncryptDecrypt              &&  CC_EncryptDecrypt             ==  YES

644  #define  TPM_CC_EncryptDecrypt                                     (TPM_CC)(0x00000164)

645  #endif

646  #if  defined  CC_FlushContext            &&  CC_FlushContext           ==  YES

647  #define  TPM_CC_FlushContext                                       (TPM_CC)(0x00000165)

648  #endif

649  #if  defined  CC_LoadExternal            &&  CC_LoadExternal           ==  YES

650  #define  TPM_CC_LoadExternal                                       (TPM_CC)(0x00000167)

651  #endif

652  #if  defined  CC_MakeCredential              &&  CC_MakeCredential             ==  YES

653  #define  TPM_CC_MakeCredential                                     (TPM_CC)(0x00000168)

654  #endif

655  #if  defined  CC_NV_ReadPublic           &&      CC_NV_ReadPublic          ==  YES

656  #define  TPM_CC_NV_ReadPublic                                      (TPM_CC)(0x00000169)

657  #endif

658  #if  defined  CC_PolicyAuthorize             &&  CC_PolicyAuthorize                ==  YES

659  #define  TPM_CC_PolicyAuthorize                                    (TPM_CC)(0x0000016A)

660  #endif

661  #if  defined  CC_PolicyAuthValue             &&  CC_PolicyAuthValue                ==  YES

662  #define  TPM_CC_PolicyAuthValue                                    (TPM_CC)(0x0000016B)

663  #endif

664  #if  defined  CC_PolicyCommandCode               &&  CC_PolicyCommandCode               ==  YES

665  #define  TPM_CC_PolicyCommandCode                                  (TPM_CC)(0x0000016C)

666  #endif

667  #if  defined  CC_PolicyCounterTimer              &&      CC_PolicyCounterTimer              ==  YES

668  #define  TPM_CC_PolicyCounterTimer                                 (TPM_CC)(0x0000016D)

669  #endif

670  #if  defined  CC_PolicyCpHash            &&  CC_PolicyCpHash           ==  YES

671  #define  TPM_CC_PolicyCpHash                                       (TPM_CC)(0x0000016E)

672  #endif

673  #if  defined  CC_PolicyLocality              &&  CC_PolicyLocality             ==  YES

674  #define  TPM_CC_PolicyLocality                                     (TPM_CC)(0x0000016F)

675  #endif

676  #if  defined  CC_PolicyNameHash              &&  CC_PolicyNameHash             ==  YES

677  #define  TPM_CC_PolicyNameHash                                     (TPM_CC)(0x00000170)

678  #endif

679  #if  defined  CC_PolicyOR        &&  CC_PolicyOR         ==   YES

680  #define  TPM_CC_PolicyOR                                           (TPM_CC)(0x00000171)

681  #endif

682  #if  defined  CC_PolicyTicket            &&  CC_PolicyTicket           ==  YES

683  #define  TPM_CC_PolicyTicket                                       (TPM_CC)(0x00000172)

684  #endif

685  #if  defined  CC_ReadPublic          &&  CC_ReadPublic        ==   YES

686  #define  TPM_CC_ReadPublic                                         (TPM_CC)(0x00000173)

687  #endif

688  #if  defined  CC_RSA_Encrypt         &&      CC_RSA_Encrypt        ==  YES

689  #define  TPM_CC_RSA_Encrypt                                        (TPM_CC)(0x00000174)

     Family "2.0"                                         TCG Published                                   Page 355

     Level 00 Revision 01.16                      Copyright © TCG 2006-2014                               October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

690  #endif

691  #if  defined  CC_StartAuthSession              &&  CC_StartAuthSession                   ==  YES

692  #define   TPM_CC_StartAuthSession                                       (TPM_CC)(0x00000176)

693  #endif

694  #if  defined  CC_VerifySignature           &&      CC_VerifySignature                ==  YES

695  #define   TPM_CC_VerifySignature                                        (TPM_CC)(0x00000177)

696  #endif

697  #if  defined  CC_ECC_Parameters            &&  CC_ECC_Parameters                 ==  YES

698  #define   TPM_CC_ECC_Parameters                                         (TPM_CC)(0x00000178)

699  #endif

700  #if  defined  CC_FirmwareRead          &&  CC_FirmwareRead               ==  YES

701  #define   TPM_CC_FirmwareRead                                           (TPM_CC)(0x00000179)

702  #endif

703  #if  defined  CC_GetCapability         &&      CC_GetCapability              ==  YES

704  #define   TPM_CC_GetCapability                                          (TPM_CC)(0x0000017A)

705  #endif

706  #if  defined  CC_GetRandom     &&      CC_GetRandom             ==  YES

707  #define   TPM_CC_GetRandom                                              (TPM_CC)(0x0000017B)

708  #endif

709  #if  defined  CC_GetTestResult         &&      CC_GetTestResult              ==  YES

710  #define   TPM_CC_GetTestResult                                          (TPM_CC)(0x0000017C)

711  #endif

712  #if  defined  CC_Hash  &&  CC_Hash         ==      YES

713  #define   TPM_CC_Hash                                                   (TPM_CC)(0x0000017D)

714  #endif

715  #if  defined  CC_PCR_Read      &&  CC_PCR_Read              ==  YES

716  #define   TPM_CC_PCR_Read                                               (TPM_CC)(0x0000017E)

717  #endif

718  #if  defined  CC_PolicyPCR     &&      CC_PolicyPCR             ==  YES

719  #define   TPM_CC_PolicyPCR                                              (TPM_CC)(0x0000017F)

720  #endif

721  #if  defined  CC_PolicyRestart         &&      CC_PolicyRestart              ==  YES

722  #define   TPM_CC_PolicyRestart                                          (TPM_CC)(0x00000180)

723  #endif

724  #if  defined  CC_ReadClock     &&      CC_ReadClock             ==  YES

725  #define   TPM_CC_ReadClock                                              (TPM_CC)(0x00000181)

726  #endif

727  #if  defined  CC_PCR_Extend        &&  CC_PCR_Extend                ==  YES

728  #define   TPM_CC_PCR_Extend                                             (TPM_CC)(0x00000182)

729  #endif

730  #if  defined  CC_PCR_SetAuthValue              &&  CC_PCR_SetAuthValue                   ==  YES

731  #define   TPM_CC_PCR_SetAuthValue                                       (TPM_CC)(0x00000183)

732  #endif

733  #if  defined  CC_NV_Certify        &&  CC_NV_Certify                ==  YES

734  #define   TPM_CC_NV_Certify                                             (TPM_CC)(0x00000184)

735  #endif

736  #if  defined  CC_EventSequenceComplete                  &&  CC_EventSequenceComplete                  ==  YES

737  #define   TPM_CC_EventSequenceComplete                                  (TPM_CC)(0x00000185)

738  #endif

739  #if  defined  CC_HashSequenceStart             &&  CC_HashSequenceStart                      ==  YES

740  #define   TPM_CC_HashSequenceStart                                      (TPM_CC)(0x00000186)

741  #endif

742  #if  defined  CC_PolicyPhysicalPresence                 &&      CC_PolicyPhysicalPresence                 ==  YES

743  #define   TPM_CC_PolicyPhysicalPresence                                 (TPM_CC)(0x00000187)

744  #endif

745  #if  defined  CC_PolicyDuplicationSelect                    &&  CC_PolicyDuplicationSelect                    ==  YES

746  #define   TPM_CC_PolicyDuplicationSelect                                (TPM_CC)(0x00000188)

747  #endif

748  #if  defined  CC_PolicyGetDigest           &&      CC_PolicyGetDigest                ==  YES

749  #define   TPM_CC_PolicyGetDigest                                        (TPM_CC)(0x00000189)

750  #endif

751  #if  defined  CC_TestParms     &&      CC_TestParms             ==  YES

752  #define   TPM_CC_TestParms                                              (TPM_CC)(0x0000018A)

753  #endif

754  #if  defined  CC_Commit    &&  CC_Commit           ==   YES

755  #define   TPM_CC_Commit                                                 (TPM_CC)(0x0000018B)

     Page 356                                           TCG Published                                                       Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                   Trusted Platform Module Library

756  #endif

757  #if  defined    CC_PolicyPassword             &&  CC_PolicyPassword             ==   YES

758  #define  TPM_CC_PolicyPassword                                       (TPM_CC)(0x0000018C)

759  #endif

760  #if  defined    CC_ZGen_2Phase         &&     CC_ZGen_2Phase         ==  YES

761  #define  TPM_CC_ZGen_2Phase                                          (TPM_CC)(0x0000018D)

762  #endif

763  #if  defined    CC_EC_Ephemeral         &&    CC_EC_Ephemeral            ==     YES

764  #define  TPM_CC_EC_Ephemeral                                         (TPM_CC)(0x0000018E)

765  #endif

766  #if  defined    CC_PolicyNvWritten            &&      CC_PolicyNvWritten             ==  YES

767  #define  TPM_CC_PolicyNvWritten                                      (TPM_CC)(0x0000018F)

768  #endif

769  #define  TPM_CC_LAST                                                 (TPM_CC)(0x0000018F)

770  #ifndef  MAX

771  #define  MAX(a,   b)     ((a)   >  (b)     ?  (a)        :  (b))

772  #endif

773  #define  MAX_HASH_BLOCK_SIZE               (                                 \

774       MAX(ALG_SHA1     *  SHA1_BLOCK_SIZE,                                    \

775       MAX(ALG_SHA256      *     SHA256_BLOCK_SIZE,                            \

776       MAX(ALG_SHA384      *     SHA384_BLOCK_SIZE,                            \

777       MAX(ALG_SM3_256        *   SM3_256_BLOCK_SIZE,                          \

778       MAX(ALG_SHA512      *     SHA512_BLOCK_SIZE,                            \

779       0  ))))))

780  #define  MAX_DIGEST_SIZE                   (                                 \

781       MAX(ALG_SHA1     *  SHA1_DIGEST_SIZE,                                   \

782       MAX(ALG_SHA256      *     SHA256_DIGEST_SIZE,                           \

783       MAX(ALG_SHA384      *     SHA384_DIGEST_SIZE,                           \

784       MAX(ALG_SM3_256        *   SM3_256_DIGEST_SIZE,                         \

785       MAX(ALG_SHA512      *     SHA512_DIGEST_SIZE,                           \

786       0  ))))))

787  #if  MAX_DIGEST_SIZE        ==  0  ||   MAX_HASH_BLOCK_SIZE              ==     0

788  #error   "Hash  data     not    valid"

789  #endif

790  #define  HASH_COUNT      (ALG_SHA1+ALG_SHA256+ALG_SHA384+ALG_SM3_256+ALG_SHA512)

     Define the 2B structure that would hold any hash block

791  TPM2B_TYPE(MAX_HASH_BLOCK,             MAX_HASH_BLOCK_SIZE);

     Folloing typedef is for some old code

792  typedef  TPM2B_MAX_HASH_BLOCK                     TPM2B_HASH_BLOCK;

793  #ifndef  MAX

794  #define  MAX(a,   b)     ((a)   >  (b)     ?  (a)        :  (b))

795  #endif

796  #ifndef  ALG_CAMELLIA

797  #    define   ALG_CAMELLIA                        NO

798  #endif

799  #ifndef  MAX_CAMELLIA_KEY_BITS

800  #    define        MAX_CAMELLIA_KEY_BITS                    0

801  #    define        MAX_CAMELLIA_BLOCK_SIZE_BYTES                     0

802  #endif

803  #ifndef  ALG_SM4

804  #    define   ALG_SM4                  NO

805  #endif

806  #ifndef  MAX_SM4_KEY_BITS

807  #    define        MAX_SM4_KEY_BITS                   0

808  #    define        MAX_SM4_BLOCK_SIZE_BYTES                       0

809  #endif

810  #ifndef  ALG_AES

811  #    define   ALG_AES                  NO

812  #endif

813  #ifndef  MAX_AES_KEY_BITS

814  #    define        MAX_AES_KEY_BITS                   0

     Family "2.0"                                                TCG Published                     Page 357

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                       October 30, 2014
     Trusted Platform Module Library                                              Part  4:  Supporting  Routines

815  #    define       MAX_AES_BLOCK_SIZE_BYTES      0

816  #endif

817  #define  MAX_SYM_KEY_BITS       (                                        \

818               MAX(MAX_CAMELLIA_KEY_BITS       *  ALG_CAMELLIA,                \

819               MAX(MAX_SM4_KEY_BITS         *  ALG_SM4,                \

820               MAX(MAX_AES_KEY_BITS         *  ALG_AES,                \

821               0))))

822  #define     MAX_SYM_KEY_BYTES       ((MAX_SYM_KEY_BITS  +     7)  /  8)

823  #define  MAX_SYM_BLOCK_SIZE            (                                 \

824               MAX(MAX_CAMELLIA_BLOCK_SIZE_BYTES          *     ALG_CAMELLIA,  \

825               MAX(MAX_SM4_BLOCK_SIZE_BYTES       *      ALG_SM4,      \

826               MAX(MAX_AES_BLOCK_SIZE_BYTES       *      ALG_AES,      \

827               0))))

828  #if  MAX_SYM_KEY_BITS   ==   0     ||     MAX_SYM_BLOCK_SIZE  ==  0

829  #    error   Bad  size  for  MAX_SYM_KEY_BITS   or     MAX_SYM_BLOCK_SIZE

830  #endif

     Define the 2B structure for a seed

831  TPM2B_TYPE(SEED,    PRIMARY_SEED_SIZE);

832  #endif   //  _IMPLEMENTATION_H_

     Page 358                                     TCG Published                             Family "2.0"

     October 30, 2014                          Copyright © TCG 2006-2014             Level 00 Revision 01.16
    Part 4: Supporting Routines                                                          Trusted Platform Module Library

                                                         Annex B

                                                         (informative)

                                             Cryptographic Library Interface

    B.1      Introduction

    The files in this annex provide cryptographic support functions for the TPM.

    When possible, the functions in these files make calls to functions that are provided by a cryptographic

    library  (for  this  annex,  it  is  OpenSSL).   In  many    cases,    there  is  a  mismatch         between  the   function

    performed by the cryptographic library and the function needed by the TPM. In those cases, a function is

    provided in the code in this clause.

    There are cases where the cryptographic library could have been used for a specific function but not all

    functions of the same group. An example is that the OpenSSL version of CFB was not suitable for the

    requirements of the TPM. Rather than have one symmetric mode be provided in this code with the

    remaining modes provided by OpenSSL, all the symmetric modes are provided in this code.

    The provided cryptographic code is believed to be functionally correct but it might not be conformant with

    all applicable standards. For example, the RSA key generation schemes produces serviceable RSA keys

    but the method is not compliant with FIPS 186-3. Still, the implementation meets the major objective of

    the  implementation,    which        is  to  demonstrate  proper   TPM    behavior.      It  is  not  an  objective  of  this

    implementation to be submitted for certification.

    B.2      Integer Format

    The big integers passed to/from the function interfaces in the crypto engine are in BYTE buffers that have

    the same format used in the TPM 2.0 specification that states:

    "Integer values are considered to be an array of one or more bytes. The byte at offset zero within the

    array is the most significant byte of the integer."

    B.3      CryptoEngine.h

    B.3.1.   Introduction

    This file contains constant definition shared by CryptUtil() and the parts           of the Crypto Engine.

1   #ifndef   _CRYPT_PRI_H

2   #define   _CRYPT_PRI_H

3   #include        <stddef.h>

4   #include        "TpmBuildSwitches.h"

5   #include        "BaseTypes.h"

6   #include        "TpmError.h"

7   #include        "swap.h"

8   #include        "Implementation.h"

9   #include        "TPM_types.h"

10  //#include           "TPMB.h"

11  #include        "bool.h"

12  #include        "Platform.h"

13  #ifndef   NULL

14  #define   NULL       0

15  #endif

16  typedef   UINT16     NUMBYTES;               //  When     a  size  is  a  number     of      bytes

17  typedef   UINT32     NUMDIGITS;              //  When     a  size  is  a  number     of      "digits"

    Family "2.0"                                     TCG Published                                                 Page 359

    Level 00 Revision 01.16                      Copyright © TCG 2006-2014                                 October 30, 2014
    Trusted Platform Module Library                                                                       Part 4: Supporting Routines

    B.3.2.   General Purpose Macros

18  #ifndef  MAX

19  #  define     MAX(a,   b)     ((a)  >  (b)  ?  (a)     :  b)

20  #endif

    This is the definition of a bit array with one bit per algorithm

21  typedef  BYTE          ALGORITHM_VECTOR[(ALG_LAST_VALUE                 +     7)       /     8];

    B.3.3.   Self-test

    This structure is used to contain self-test tracking information for the crypto engine. Each of the major

    modules is given a 32-bit value in which it may maintain its own self test information. The convention for

    this state is that when all of the bits in this structure are 0, all functions need to be tested.

22  typedef  struct     {

23     UINT32              rng;

24     UINT32              hash;

25     UINT32              sym;

26  #ifdef   TPM_ALG_RSA

27     UINT32              rsa;

28  #endif

29  #ifdef   TPM_ALG_ECC

30     UINT32              ecc;

31  #endif

32  }  CRYPTO_SELF_TEST_STATE;

    B.3.4.   Hash-related Structures

33  typedef  struct     {

34     const   TPM_ALG_ID               alg;

35     const   NUMBYTES                 digestSize;

36     const   NUMBYTES                 blockSize;

37     const   NUMBYTES                 derSize;

38     const   BYTE                     der[20];

39  }  HASH_INFO;

    This value will change with each implementation. The value of 16 is used to account for any slop in the

    context values. The overall size needs to be as large as any of the hash contexts. The structure needs to

    start on an alignment boundary and be an even multiple of the alignment

40  #define  ALIGNED_SIZE(x,      b)       ((((x)  +  (b)     -    1)    /  (b))     *     (b))

41  #define  MAX_HASH_STATE_SIZE           ((2  *  MAX_HASH_BLOCK_SIZE)                       +  16)

42  #define  MAX_HASH_STATE_SIZE_ALIGNED                                                                      \

43                               ALIGNED_SIZE(MAX_HASH_STATE_SIZE,                         CRYPTO_ALIGNMENT)

    This is an byte array that will hold any of the hash contexts.

44  typedef  CRYPTO_ALIGNED       BYTE     ALIGNED_HASH_STATE[MAX_HASH_STATE_SIZE_ALIGNED];

    Macro to align an address to the next higher size

45  #define  AlignPointer(address,            align)                                                          \

46     ((((intptr_t)&(address))            +  (align    -     1))     &  ~(align        -     1))

    Macro to test alignment

47  #define  IsAddressAligned(address,             align)                                                     \

48                               (((intptr_t)(address)             &     (align   -     1))      ==   0)

    Page 360                                          TCG Published                                           Family "2.0"

    October 30, 2014                          Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                              Trusted Platform Module Library

    This is the structure that is used for passing a context into the hashing functions. It should be the same

    size as the function context used within the hashing functions. This is checked when the hash function is

    initialized. This version uses a new layout for the contexts and a different definition. The state buffer is an

    array of HASH_UNIT values so that a decent compiler will put the structure on a HASH_UNIT boundary.

    If the structure is not properly aligned, the code that manipulates the structure will copy to a properly

    aligned structure before it is used and copy the result back. This just makes things slower.

49  typedef  struct       _HASH_STATE

50  {

51       ALIGNED_HASH_STATE                         state;

52       TPM_ALG_ID                                 hashAlg;

53  }   CPRI_HASH_STATE,     *PCPRI_HASH_STATE;

54  extern   const     HASH_INFO             g_hashData[HASH_COUNT                 +     1];

    This is for the external hash       state. This implementation assumes that the size of the exported                               hash     state

    is no larger than the internal      hash state. There is a compile-time check to make sure that this is                              true.

55  typedef  struct       {

56       ALIGNED_HASH_STATE                     buffer;

57       TPM_ALG_ID                             hashAlg;

58  }   EXPORT_HASH_STATE;

59  typedef  enum      {

60       IMPORT_STATE,                    //    Converts      externally           formatted        state         to  internal

61       EXPORT_STATE                     //    Converts      internal         formatted       state          to  external

62  }   IMPORT_EXPORT;

    Values and structures for the random number generator. These values are defined in this header file so

    that the size of the RNG state can be known to TPM.lib. This allows the allocation of some space in NV

    memory   for   the    state   to    be      stored    on  an       orderly   shutdown.         The        GET_PUT          enum  is  used   by

    _cpri__DrbgGetPutState() to indicate the direction of data flow.

63  typedef  enum      {

64       GET_STATE,               //    Get     the   state        to   save   to     NV

65       PUT_STATE                //    Restore       the     state      from   NV

66  }   GET_PUT;

    The DRBG based on a symmetric block cipher is defined by three values,

    a)   the key size

    b)   the block size (the IV size)

    c)   the symmetric algorithm

67  #define  DRBG_KEY_SIZE_BITS                           MAX_AES_KEY_BITS

68  #define  DRBG_IV_SIZE_BITS                            (MAX_AES_BLOCK_SIZE_BYTES                    *     8)

69  #define  DRBG_ALGORITHM                               TPM_ALG_AES

70  #if  ((DRBG_KEY_SIZE_BITS                %  8)    !=  0)  ||       ((DRBG_IV_SIZE_BITS                %   8)  !=    0)

71  #error   "Key   size     and    IV    for   DRBG      must      be   even   multiples          of     8"

72  #endif

73  #if  (DRBG_KEY_SIZE_BITS              %     DRBG_IV_SIZE_BITS)             !=     0

74  #error   "Key   size     for    DRBG        must  be      even     multiple       of  the  cypher            block  size"

75  #endif

76  typedef  UINT32          DRBG_SEED[(DRBG_KEY_SIZE_BITS                            +   DRBG_IV_SIZE_BITS)                /  32];

77  typedef  struct       {

78       UINT64              reseedCounter;

79       UINT32              magic;

80       DRBG_SEED           seed;    //     contains         the   key  and    IV       for  the   counter           mode     DRBG

81       UINT32              lastValue[4];                //  used      when   the       TPM  does     continuous           self-test

82                                                        //  for      FIPS   compliance       of      DRBG

83  }   DRBG_STATE,       *pDRBG_STATE;

    Family "2.0"                                              TCG Published                                                              Page 361

    Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                                October 30, 2014
     Trusted Platform Module Library                                                           Part 4: Supporting Routines

     B.3.5.    Asymmetric           Structures  and   Values

84   #ifdef    TPM_ALG_ECC

     B.3.5.1.      ECC-related Structures

     This structure replicates the structure definition in TPM_Types.h. It is duplicated to avoid inclusion of all of

     TPM_Types.h This structure is similar to the RSA_KEY structure below. The purpose of these structures

     is to reduce the overhead of a function call and to make the code less dependent on key types as much

     as possible.

85   typedef   struct       {

86       UINT32                              curveID;           //  The  curve     identifier

87       TPMS_ECC_POINT                      *publicPoint;      //  Pointer   to   the  public        point

88       TPM2B_ECC_PARAMETER                 *privateKey;       //  Pointer   to   the  private       key

89   }  ECC_KEY;

90   #endif    //  TPM_ALG_ECC

91   #ifdef    TPM_ALG_RSA

     B.3.5.2.      RSA-related Structures

     This structure is a succinct representation of the cryptographic components of an RSA key.

92   typedef   struct       {

93       UINT32                exponent;              //  The  public    exponent  pointer

94       TPM2B                 *publicKey;            //  Pointer   to   the  public  modulus

95       TPM2B                 *privateKey;           //  The  private   exponent     (not  a  prime)

96   }  RSA_KEY;

97   #endif    //  TPM_ALG_RSA

     B.3.6.    Miscelaneous

98   #ifdef    TPM_ALG_RSA

99   #   ifdef     TPM_ALG_ECC

100  #         if      MAX_RSA_KEY_BYTES        >     MAX_ECC_KEY_BYTES

101  #                 define       MAX_NUMBER_SIZE                 MAX_RSA_KEY_BYTES

102  #         else

103  #                 define       MAX_NUMBER_SIZE                 MAX_ECC_KEY_BYTES

104  #         endif

105  #   else      //  RSA     but  no  ECC

106  #         define       MAX_NUMBER_SIZE                         MAX_RSA_KEY_BYTES

107  #   endif

108  #elif   defined   TPM_ALG_ECC

109  #   define        MAX_NUMBER_SIZE                             MAX_ECC_KEY_BYTES

110  #else

111  #   error     No  assymmetric      algorithm         implemented.

112  #endif

113  typedef   INT16           CRYPT_RESULT;

114  #define   CRYPT_RESULT_MIN              INT16_MIN

115  #define   CRYPT_RESULT_MAX              INT16_MAX

     <0                                      recoverable error

     0                                       success

     >0                                      command specific return value (generally a digest size)

116  #define   CRYPT_FAIL                    ((CRYPT_RESULT)        1)

117  #define   CRYPT_SUCCESS                 ((CRYPT_RESULT)        0)

118  #define   CRYPT_NO_RESULT               ((CRYPT_RESULT)        -1)

     Page 362                                             TCG Published                                      Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                   Trusted Platform Module  Library

119  #define   CRYPT_SCHEME         ((CRYPT_RESULT)  -2)

120  #define   CRYPT_PARAMETER      ((CRYPT_RESULT)  -3)

121  #define   CRYPT_UNDERFLOW      ((CRYPT_RESULT)  -4)

122  #define   CRYPT_POINT          ((CRYPT_RESULT)  -5)

123  #define   CRYPT_CANCEL         ((CRYPT_RESULT)  -6)

124  typedef   UINT64               HASH_CONTEXT[MAX_HASH_STATE_SIZE/sizeof(UINT64)];

125  #include      "CpriCryptPri_fp.h"

126  #ifdef    TPM_ALG_ECC

127  #  include    "CpriDataEcc.h"

128  #  include    "CpriECC_fp.h"

129  #endif

130  #include      "MathFunctions_fp.h"

131  #include      "CpriRNG_fp.h"

132  #include      "CpriHash_fp.h"

133  #include      "CpriSym_fp.h"

134  #ifdef    TPM_ALG_RSA

135  #  include        "CpriRSA_fp.h"

136  #endif

137  #endif   //  !_CRYPT_PRI_H

     Family "2.0"                        TCG Published                                 Page 363

     Level 00 Revision 01.16            Copyright © TCG 2006-2014  October 30, 2014
    Trusted Platform Module Library                                               Part 4: Supporting Routines

    B.4     OsslCryptoEngine.h

    B.4.1.   Introduction

    This is the header file used by the components of the CryptoEngine().     This file should not be included in

    any file other than the files in the crypto engine.

    Vendors may replace the implementation in this file by a local crypto engine. The implementation in this

    file is based on OpenSSL() library. Integer format: the big integers passed in/out the function interfaces in

    this library by a byte buffer (BYTE *) adopt the same format used in TPM 2.0 specification: Integer values

    are considered to be an array of one or more bytes.      The byte at offset zero within the array is the most

    significant byte of the integer.

    B.4.2.   Defines

1   #ifndef   _OSSL_CRYPTO_ENGINE_H

2   #define   _OSSL_CRYPTO_ENGINE_H

3   #include     <openssl/aes.h>

4   #include     <openssl/evp.h>

5   #include     <openssl/sha.h>

6   #include     <openssl/ec.h>

7   #include     <openssl/rand.h>

8   #include     <openssl/bn.h>

9   #include     <openSSL/ec_lcl.h>

10  #define       CRYPTO_ENGINE

11  #include     "CryptoEngine.h"

12  #include     "CpriMisc_fp.h"

13  #define   MAX_ECC_PARAMETER_BYTES   32

14  #define   MAX_2B_BYTES  MAX((MAX_RSA_KEY_BYTES           *  ALG_RSA),                \

15                                    MAX((MAX_ECC_PARAMETER_BYTES         *  ALG_ECC),  \

16                                      MAX_DIGEST_SIZE))

17  #define   assert2Bsize(a)         pAssert((a).size   <=  sizeof((a).buffer))

18  #ifdef   TPM_ALG_RSA

19  #    ifdef    RSA_KEY_SIEVE

20  #         include       "RsaKeySieve.h"

21  #         include       "RsaKeySieve_fp.h"

22  #    endif

23  #    include       "CpriRSA_fp.h"

24  #endif

    This is a structure to hold the parameters for the version of KDFa() used by the CryptoEngine(). This

    structure allows the state to be passed between multiple functions that use the same pseudo-random

    sequence.

25  typedef   struct   {

26       CPRI_HASH_STATE               iPadCtx;

27       CPRI_HASH_STATE               oPadCtx;

28       TPM2B                        *extra;

29       UINT32                       *outer;

30       TPM_ALG_ID                    hashAlg;

31       UINT16                        keySizeInBits;

32  }  KDFa_CONTEXT;

33  #endif   //  _OSSL_CRYPTO_ENGINE_H

    Page 364                                   TCG Published                                Family "2.0"

    October 30, 2014                    Copyright © TCG 2006-2014                 Level 00 Revision 01.16
    Part 4: Supporting Routines                                                             Trusted Platform Module Library

    B.5     MathFunctions.c

    B.5.1.    Introduction

    This file contains implementation of some of the big number primitives. This is used in order to reduce the

    overhead in dealing with data conversions to standard big number format.

    The simulator code uses the canonical form whenever possible in order to make the code in Part 3 more

    accessible.   The    canonical     data   formats    are  simple     and     not  well  suited  for  complex     big    number

    computations. This library provides functions that are found in typical big number libraries but they are

    written to handle the canonical data format of the reference TPM.

    In some cases, data is converted to a big number format used by a standard library, such as OpenSSL().

    This is done when the computations are complex enough warrant conversion. Vendors may replace the

    implementation in this file with a library that provides equivalent functions. A vendor may also rewrite the

    TPM code so that it uses a standard big number format instead of the canonical form and use the

    standard libraries instead of the code in this file.

    The implementation in this file makes use of the OpenSSL() library.

    Integer format: integers passed through the function interfaces in this library adopt the same format used

    in TPM 2.0 specification. It defines an integer as "an array of one or more octets with the most significant

    octet at the lowest index of the array." An additional value is needed to indicate the number of significant

    bytes.

1   #include     "OsslCryptoEngine.h"

    B.5.2.    Externally Accessible Functions

    B.5.2.1.     _math__Normalize2B()

    This function will normalize       the  value in a TPM2B. If there are       leading    bytes   of   zero,  the  first  non-zero

    byte is shifted up.

    Return Value                            Meaning

    0                                       no significant bytes, value is zero

    >0                                      number of significant bytes

2   LIB_EXPORT    UINT16

3   _math__Normalize2B(

4        TPM2B                  *b                       //   IN/OUT:    number       to  normalize

5        )

6   {

7        UINT16          from;

8        UINT16          to;

9        UINT16          size   =      b->size;

10

11       for(from    =   0;  b->buffer[from]         ==  0    &&  from   <  size;     from++);

12       b->size     -=  from;

13       for(to   =  0;  from   <      size;  to++,    from++     )

14            b->buffer[to]         =  b->buffer[from];

15       return   b->size;

16  }

    Family "2.0"                                         TCG Published                                               Page 365

    Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                  October 30, 2014
    Trusted Platform Module Library                                                                          Part 4: Supporting Routines

    B.5.2.2.      _math__Denormalize2B()

    This function is used to        adjust a TPM2B so that the number has                     the desired    number    of  bytes.   This  is

    accomplished by adding          bytes of zero at the start of the number.

    Return Value                                  Meaning

    TRUE                                          number de-normalized

    FALSE                                         number already larger than the desired      size

17  LIB_EXPORT      BOOL

18  _math__Denormalize2B(

19      TPM2B                       *in,                       //  IN:OUT       TPM2B      number   to  de-normalize

20      UINT32                         size                    //  IN:     the     desired  size

21      )

22  {

23      UINT32                 to;

24      UINT32                 from;

25      //    If  the     current         size    is  greater      than    the     requested  size,     see  if     this   can  be

26      //    normalized        to     a  value       smaller    than      the  requested     size      and  then   de-normalize

27      if(in->size         >   size)

28      {

29            _math__Normalize2B(in);

30            if(in->size           >     size)

31                    return    FALSE;

32      }

33      //    If  the     size  is        already     what   is    requested,       leave

34      if(in->size         ==  size)

35            return       TRUE;

36

37      //    move    the   bytes         to  the     'right'

38      for(from       =   in->size,          to   =  size;    from     >  0;)

39            in->buffer[--to]                =   in->buffer[--from];

40

41      //    'to'    will     always         be  greater    than    0     because     we  checked      for  equal  above.

42      for(;     to   >   0;)

43            in->buffer[--to]                =   0;

44

45      in->size       =   (UINT16)size;

46      return      TRUE;

47  }

    B.5.2.3.      _math__sub()

    This function to subtract one unsigned value from another c = a - b. c may be the same as a or b.

    Return Value                                  Meaning

    1                                             if (a > b) so no borrow

    0                                             if (a = b) so no borrow and b == a

    -1                                            if (a < b) so there was a borrow

48  LIB_EXPORT      int

49  _math__sub(

50      const     UINT32               aSize,                  //  IN:     size    of  a

51      const     BYTE              *a,                        //  IN:     a

52      const     UINT32               bSize,                  //  IN:     size    of  b

53      const     BYTE              *b,                        //  IN:     b

54      UINT16                      *cSize,                    //  OUT:       set  to  MAX(aSize,       bSize)

55      BYTE                        *c                         //  OUT:       the  difference

56      )

    Page 366                                                   TCG Published                                               Family "2.0"

    October 30, 2014                                  Copyright © TCG 2006-2014                              Level 00  Revision 01.16
     Part  4: Supporting Routines                                                                                              Trusted  Platform Module Library

57   {

58         int                                        borrow             =     0;

59         int                                        notZero               =     0;

60         int                                        i;

61         int                                        i2;

62

63         //     set      c     to       the         longer             of       a   or       b

64         *cSize          =     (UINT16)((aSize                               >     bSize)           ?  aSize   :   bSize);

65         //     pick        the         shorter                 of     a     and       b

66         i   =     (aSize            >     bSize)               ?   bSize           :     aSize;

67         i2     =     *cSize            -     i;

68         a   =     &a[aSize                -     1];

69         b   =     &b[bSize                -     1];

70         c   =     &c[*cSize                  -     1];

71         for(;        i     >     0;       i--)

72         {

73                   borrow            =     *a--           -     *b--         +     borrow;

74                   *c--        =     (BYTE)borrow;

75                   notZero              =     notZero               ||       borrow;

76                   borrow            >>=         8;

77         }

78         if(aSize              >     bSize)

79         {

80                   for(;i2              >     0;       i2--)

81                   {

82                            borrow               =     *a--         +     borrow;

83                            *c--           =     (BYTE)borrow;

84                            notZero                 =     notZero               ||     borrow;

85                            borrow               >>=         8;

86                   }

87         }

88         else         if(aSize                <     bSize)

89         {

90                   for(;i2              >     0;       i2--)

91                   {

92                            borrow               =     0     -     *b--         +   borrow;

93                            *c--           =     (BYTE)borrow;

94                            notZero                 =     notZero               ||     borrow;

95                            borrow               >>=         8;

96                   }

97         }

98         //     if    there             is       a     borrow,               then         b     >   a

99         if(borrow)

100                  return            -1;

101        //     either            a     >     b     or       they         are       the         same

102        return          notZero;

103  }

     B.5.2.4.           _math__Inc()

     This function increments a large, big-endian number                                                      value  by  one.

     Return Value                                                     Meaning

     0                                                                result is zero

     !0                                                               result is not zero

104  LIB_EXPORT            int

105  _math__Inc(

106        UINT32                                        aSize,                                   //     IN:  size   of  a

107        BYTE                                       *a                                          //     IN:  a

108        )

109  {

     Family "2.0"                                                                                 TCG Published                         Page 367

     Level 00 Revision 01.16                                                      Copyright © TCG 2006-2014                             October 30, 2014
     Trusted Platform Module Library                                                                    Part 4: Supporting Routines

110

111        for(a   =   &a[aSize-1];aSize             >     0;     aSize--)

112        {

113              if((*a--     +=     1)   !=  0)

114                    return     1;

115        }

116        return     0;

117  }

     B.5.2.5.     _math__Dec()

     This function decrements a large, ENDIAN value by one.

118  LIB_EXPORT       void

119  _math__Dec(

120        UINT32                     aSize,                      //  IN:   size   of   a

121        BYTE                      *a                           //  IN:   a

122        )

123  {

124        for(a   =   &a[aSize-1];           aSize     >  0;     aSize--)

125        {

126              if((*a--     -=     1)   !=  0xff)

127                    return;

128        }

129        return;

130  }

     B.5.2.6.     _math__Mul()

     This function is used to multiply two large integers: p = a* b. If the size of p is not specified (pSize ==

     NULL), the size of the results p is assumed to be aSize + bSize and the results are de-normalized so that

     the resulting size is exactly aSize + bSize. If pSize is provided, then the actual size of the result is

     returned. The initial value for pSize must be at least aSize + pSize.

     Return Value                             Meaning

     <0                                       indicates an error

     >= 0                                     the size of the product

131  LIB_EXPORT       int

132  _math__Mul(

133        const   UINT32             aSize,                      //  IN:   size   of   a

134        const   BYTE              *a,                          //  IN:   a

135        const   UINT32             bSize,                      //  IN:   size   of   b

136        const   BYTE              *b,                          //  IN:   b

137        UINT32                    *pSize,                      //  IN/OUT:     size     of  the  product

138        BYTE                      *p                           //  OUT:     product.    length   of  product  =  aSize  +

139                                                               //        bSize

140        )

141  {

142        BIGNUM                    *bnA;

143        BIGNUM                    *bnB;

144        BIGNUM                    *bnP;

145        BN_CTX                    *context;

146        int                       retVal   =   0;

147

148        //   First     check   that    pSize      is    large      enough   if  present

149        if((pSize      !=  NULL)       &&  (*pSize          <  (aSize    +  bSize)))

150              return    CRYPT_PARAMETER;

151        pAssert(pSize         ==   NULL    ||  *pSize          <=  MAX_2B_BYTES);

152        //

     Page 368                                                     TCG Published                                     Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                        Trusted Platform Module  Library

153        //   Allocate           space     for     BIGNUM       context

154        //

155        context       =   BN_CTX_new();

156        if(context           ==   NULL)

157              FAIL(FATAL_ERROR_ALLOCATION);

158        bnA   =  BN_CTX_get(context);

159        bnB   =  BN_CTX_get(context);

160        bnP   =  BN_CTX_get(context);

161        if   (bnP     ==     NULL)

162              FAIL(FATAL_ERROR_ALLOCATION);

163

164        //   Convert         the  inputs          to  BIGNUMs

165        //

166        if   (BN_bin2bn(a,             aSize,         bnA)     ==     NULL     ||  BN_bin2bn(b,  bSize,    bnB)   ==  NULL)

167              FAIL(FATAL_ERROR_INTERNAL);

168

169        //   Perform         the  multiplication

170        //

171        if   (BN_mul(bnP,             bnA,     bnB,   context)            !=   1)

172              FAIL(FATAL_ERROR_INTERNAL);

173

174        //   If  the      size    of      the     results      is     allowed      to  float,   then  set  the    return

175        //   size.       Otherwise,           it  might        be     necessary    to  de-normalize   the   results

176        retVal     =     BN_num_bytes(bnP);

177        if(pSize         ==     NULL)

178        {

179              BN_bn2bin(bnP,               &p[aSize         +  bSize        -  retVal]);

180              memset(p,           0,   aSize      +   bSize        -  retVal);

181              retVal         =   aSize     +   bSize;

182        }

183        else

184        {

185              BN_bn2bin(bnP,               p);

186              *pSize         =   retVal;

187        }

188

189        BN_CTX_end(context);

190        BN_CTX_free(context);

191        return     retVal;

192  }

     B.5.2.7.       _math__Div()

     Divide an integer (n) by an integer (d) producing a quotient (q) and a                         remainder  (r).  If  q or r is not needed,

     then the pointer to them may be set to NULL.

     Return Value                                    Meaning

     CRYPT_SUCCESS                                   operation complete

     CRYPT_UNDERFLOW                                 q or r is too small to receive the result

193  LIB_EXPORT       CRYPT_RESULT

194  _math__Div(

195        const    TPM2B                *n,                             //  IN:      numerator

196        const    TPM2B                *d,                             //  IN:      denominator

197        TPM2B                         *q,                             //  OUT:     quotient

198        TPM2B                         *r                              //  OUT:     remainder

199        )

200  {

201        BIGNUM                        *bnN;

202        BIGNUM                        *bnD;

203        BIGNUM                        *bnQ;

204        BIGNUM                        *bnR;

     Family "2.0"                                                        TCG Published                                          Page 369

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                   Part 4: Supporting Routines

205      BN_CTX                       *context;

206      CRYPT_RESULT                 retVal    =    CRYPT_SUCCESS;

207

208      //    Get       structures       for   the  big    number    representations

209      context         =    BN_CTX_new();

210      if(context           ==   NULL)

211               FAIL(FATAL_ERROR_ALLOCATION);

212      BN_CTX_start(context);

213      bnN      =   BN_CTX_get(context);

214      bnD      =   BN_CTX_get(context);

215      bnQ      =   BN_CTX_get(context);

216      bnR      =   BN_CTX_get(context);

217

218      //    Errors         in  BN_CTX_get()       are    sticky    so     only    need   to  check  the  last  allocation

219      if    (         bnR  ==   NULL

220               ||     BN_bin2bn(n->buffer,           n->size,      bnN)       ==  NULL

221               ||     BN_bin2bn(d->buffer,           d->size,      bnD)       ==  NULL)

222                      FAIL(FATAL_ERROR_INTERNAL);

223

224      //    Check        for   divide    by  zero.

225      if(BN_num_bits(bnD)                ==  0)

226               FAIL(FATAL_ERROR_DIVIDE_ZERO);

227

228      //    Perform        the  division

229      if    (BN_div(bnQ,           bnR,     bnN,  bnD,   context)         !=  1)

230               FAIL(FATAL_ERROR_INTERNAL);

231

232      //    Convert        the  BIGNUM       result      back  to  our    format

233      if(q        !=  NULL)        //   If   the  quotient     is      being      returned

234      {

235               if(!BnTo2B(q,           bnQ,  q->size))

236               {

237                      retVal    =  CRYPT_UNDERFLOW;

238                      goto     Done;

239               }

240         }

241      if(r        !=  NULL)        //   If   the  remainder        is  being      returned

242      {

243               if(!BnTo2B(r,           bnR,  r->size))

244                      retVal    =  CRYPT_UNDERFLOW;

245      }

246

247  Done:

248      BN_CTX_end(context);

249      BN_CTX_free(context);

250

251      return          retVal;

252  }

     B.5.2.8.        _math__uComp()

     This function compare two unsigned values.

     Return Value                               Meaning

     1                                          if (a > b)

     0                                          if (a = b)

     -1                                         if (a < b)

253  LIB_EXPORT          int

254  _math__uComp(

255      const        UINT32          aSize,                //    IN:     size       of  a

256      const        BYTE            *a,                   //    IN:     a

     Page 370                                               TCG Published                                         Family "2.0"

     October 30, 2014                                Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                                                        Trusted Platform   Module  Library

257        const         UINT32                  bSize,                                   //       IN:     size       of     b

258        const         BYTE                   *b                                        //       IN:     b

259        )

260  {

261        int                                  borrow         =     0;

262        int                                  notZero           =     0;

263        int                                  i;

264        //     If     a  has       more       digits           than           b,       then         a   is    greater        than  b  if

265        //     any       of  the       more         significant                     bytes           is     non     zero

266        if((i         =  (int)aSize                 -     (int)bSize)                     >     0)

267               for(;         i     >   0;     i--)

268                         if(*a++)             //       means         a     >     b

269                                   return           1;

270        //     If     b  has       more       digits           than           a,       then         b   is    greater        if  any  of  the

271        //     more      significant                   bytes         is       non         zero

272        if(i       <     0)     //     Means           that       b     is       longer             than      a

273               for(;         i     <   0;     i++)

274                         if(*b++)             //       means         that           b     >     a

275                                   return           -1;

276        //     Either        the       vales           are     the         same           size         or     the  upper     bytes    of  a  or  b  are

277        //     all       zero,        so     compare           the         rest

278        i   =  (aSize           >     bSize)           ?  bSize            :     aSize;

279        a   =  &a[i-1];

280        b   =  &b[i-1];

281        for(;         i  >   0;       i--)

282        {

283               borrow           =     *a--       -     *b--       +     borrow;

284               notZero             =   notZero            ||      borrow;

285               borrow           >>=       8;

286        }

287        //     if     there        is     a   borrow,             then           b     >     a

288        if(borrow)

289               return           -1;

290        //     either        a     >   b     or     they       are         the         same

291        return           notZero;

292  }

     B.5.2.9.         _math__Comp()

     Compare two signed integers:

     Return Value                                            Meaning

     1                                                       if a > b

     0                                                       if a = b

     -1                                                      if a < b

293  LIB_EXPORT             int

294  _math__Comp(

295        const         UINT32                  aSize,                                   //       IN:     size       of     a

296        const         BYTE                   *a,                                       //       IN:     a     buffer

297        const         UINT32                  bSize,                                   //       IN:     size       of     b

298        const         BYTE                   *b                                        //       IN:     b     buffer

299        )

300  {

301        int                  signA,          signB;                           //       sign         of     a  and      b

302

303        //     For       positive            or     0,    sign_a              is       1

304        //     for       negative,            sign_a           is       0

305        signA         =  ((a[0]           &   0x80)         ==       0)       ?     1     :     0;

306

307        //     For       positive            or     0,    sign_b              is       1

308        //     for       negative,            sign_b           is       0

     Family "2.0"                                                                         TCG Published                                                     Page 371

     Level 00 Revision 01.16                                            Copyright © TCG 2006-2014                                                      October 30, 2014
     Trusted Platform Module Library                                                                       Part 4: Supporting Routines

309     signB       =  ((b[0]         &  0x80)   ==    0)  ?  1   :  0;

310

311     if(signA           !=     signB)

312     {

313             return         signA     -    signB;

314     }

315

316     if(signA           ==     1)

317             //     do  unsigned           compare  function

318             return         _math__uComp(aSize,            a,     bSize,   b);

319     else

320             //     do  unsigned           compare  the    other      way

321             return         0   -  _math__uComp(aSize,            a,   bSize,   b);

322  }

     B.5.2.10.     _math__ModExp

     This function is used to do modular exponentiation in support of RSA. The most typical uses are: c = m^e

     mod n (RSA encrypt) and m = c^d mod n (RSA decrypt).                          When doing decryption, the e parameter of the

     function will contain the private exponent d instead of the public exponent e.

     If the results will not fit in the provided buffer, an error is returned (CRYPT_ERROR_UNDERFLOW). If

     the results is smaller than the buffer, the results is de-normalized.

     This version is intended for use with RSA and requires that m be less than n.

     Return Value                               Meaning

     CRYPT_SUCCESS                              exponentiation succeeded

     CRYPT_PARAMETER                            number to exponentiate is larger than the modulus

     CRYPT_UNDERFLOW                            result will not fit into the provided buffer

323  LIB_EXPORT        CRYPT_RESULT

324  _math__ModExp(

325     UINT32                           cSize,                  //  IN:   size    of  the     result

326     BYTE                             *c,                     //  OUT:     results      buffer

327     const       UINT32               mSize,                  //  IN:   size    of  number      to  be  exponentiated

328     const       BYTE                 *m,                     //  IN:   number      to  be  exponentiated

329     const       UINT32               eSize,                  //  IN:   size    of  power

330     const       BYTE                 *e,                     //  IN:   power

331     const       UINT32               nSize,                  //  IN:   modulus     size

332     const       BYTE                 *n                      //  IN:   modulu

333     )

334  {

335     CRYPT_RESULT                     retVal   =    CRYPT_SUCCESS;

336     BN_CTX                           *context;

337     BIGNUM                           *bnC;

338     BIGNUM                           *bnM;

339     BIGNUM                           *bnE;

340     BIGNUM                           *bnN;

341     INT32                            i;

342

343     context        =   BN_CTX_new();

344     if(context             ==     NULL)

345             FAIL(FATAL_ERROR_ALLOCATION);

346     BN_CTX_start(context);

347     bnC     =   BN_CTX_get(context);

348     bnM     =   BN_CTX_get(context);

349     bnE     =   BN_CTX_get(context);

350     bnN     =   BN_CTX_get(context);

351

352     //   Errors        for        BN_CTX_get      are  sticky    so    only    need    to  check   last  allocation

353     if(bnN         ==  NULL)

     Page 372                                                    TCG Published                                Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                  Trusted Platform     Module  Library

354               FAIL(FATAL_ERROR_ALLOCATION);

355

356     //convert            arguments

357     if     (         BN_bin2bn(m,          mSize,     bnM)     ==  NULL

358               ||     BN_bin2bn(e,          eSize,     bnE)     ==  NULL

359               ||     BN_bin2bn(n,          nSize,     bnN)     ==  NULL)

360                      FAIL(FATAL_ERROR_INTERNAL);

361

362     //     Don't     do        exponentiation         if  the      number    being  exponentiated     is

363     //     larger        than    the   modulus.

364     if(BN_ucmp(bnM,                 bnN)    >=  0)

365     {

366               retVal        =  CRYPT_PARAMETER;

367               goto   Cleanup;

368     }

369     //     Perform          the  exponentiation

370     if(!(BN_mod_exp(bnC,                    bnM,    bnE,    bnN,    context)))

371               FAIL(FATAL_ERROR_INTERNAL);

372

373     //     Convert          the  results

374     //     Make      sure      that    the  results       will     fit   in    the  provided  buffer.

375     if((unsigned)BN_num_bytes(bnC)                          >  cSize)

376     {

377               retVal        =  CRYPT_UNDERFLOW;

378               goto   Cleanup;

379     }

380     i   =     cSize      -     BN_num_bytes(bnC);

381     BN_bn2bin(bnC,               &c[i]);

382     memset(c,            0,    i);

383

384  Cleanup:

385     //     Free      up     allocated       BN  values

386     BN_CTX_end(context);

387     BN_CTX_free(context);

388     return           retVal;

389  }

     B.5.2.11.    _math__IsPrime()

     Check if an 32-bit integer is a prime.

     Return Value                               Meaning

     TRUE                                       if the integer is probably a prime

     FALSE                                      if the integer is definitely not a prime

390  LIB_EXPORT          BOOL

391  _math__IsPrime(

392     const         UINT32             prime

393     )

394  {

395     int              isPrime;

396     BIGNUM           *p;

397

398     //     Assume        the     size  variables          are  not  overflow,       which     should  not  happen  in

399     //     the       contexts       that    this    function       will    be  called.

400     if((p         =  BN_new())         ==   NULL)

401               FAIL(FATAL_ERROR_ALLOCATION);

402     if(!BN_set_word(p,                 prime))

403               FAIL(FATAL_ERROR_INTERNAL);

404

405     //

406     //     BN_is_prime           returning        -1  means        that  it    ran  into  an  error.

     Family "2.0"                                                  TCG Published                                           Page 373

     Level 00 Revision 01.16                            Copyright © TCG 2006-2014                              October 30, 2014
     Trusted Platform Module Library                                         Part 4: Supporting Routines

407     //  It  should     only   return  0  or  1

408     //

409     if((isPrime     =  BN_is_prime_ex(p,        BN_prime_checks,  NULL,  NULL))  <  0)

410           FAIL(FATAL_ERROR_INTERNAL);

411

412     if(p    !=  NULL)

413           BN_clear_free(p);

414     return      (isPrime  ==  1);

415  }

     Page 374                                       TCG Published                           Family "2.0"

     October 30, 2014                        Copyright © TCG 2006-2014               Level 00 Revision 01.16
    Part 4: Supporting Routines                                                     Trusted Platform Module Library

    B.6      CpriCryptPri.c

    B.6.1.     Introduction

    This file contains the interface to the initialization, startup and shutdown functions of the crypto library.

    B.6.2.     Includes and Locals

1   #include  "OsslCryptoEngine.h"

2   static     void  Trap(const  char  *function,   int  line,         int  code);

3   FAIL_FUNCTION            TpmFailFunction     =  (FAIL_FUNCTION)&Trap;

    B.6.3.     Functions

    B.6.3.1.     TpmFail()

    This is a shim function that is called when a failure occurs. It simply relays the call to the callback pointed

    to by TpmFailFunction(). It is only defined for the sake of NO_RETURN specifier that cannot be added to

    a function pointer with some compilers.

4   void

5   TpmFail(

6         const  char              *function,

7         int                      line,

8         int                      code)

9   {

10        TpmFailFunction(function,       line,  code);

11  }

    B.6.3.2.     FAILURE_TRAP()

    This function is called if the caller to _cpri__InitCryptoUnits()  doesn't  provide  a  call  back  address.

12  static     void

13  Trap(

14        const  char        *function,

15        int                line,

16        int                code

17        )

18  {

19        UNREFERENCED(function);

20        UNREFERENCED(line);

21        UNREFERENCED(code);

22        abort();

23  }

    B.6.3.3.     _cpri__InitCryptoUnits()

    This function calls the initialization functions of the other crypto modules that are part of the crypto engine

    for this implementation. This function should be called as a result of _TPM_Init(). The parameter to this

    function is a call back function it TPM.lib that is called when the crypto engine has a failure.

24  LIB_EXPORT       CRYPT_RESULT

25  _cpri__InitCryptoUnits(

26        FAIL_FUNCTION      failFunction

27        )

28  {

    Family "2.0"                                 TCG Published                                          Page 375

    Level 00 Revision 01.16               Copyright © TCG 2006-2014                                   October 30, 2014
    Trusted Platform Module Library                                                     Part 4: Supporting Routines

29     TpmFailFunction        =  failFunction;

30

31     _cpri__RngStartup();

32     _cpri__HashStartup();

33     _cpri__SymStartup();

34

35  #ifdef    TPM_ALG_RSA

36     _cpri__RsaStartup();

37  #endif

38

39  #ifdef    TPM_ALG_ECC

40     _cpri__EccStartup();

41  #endif

42

43     return     CRYPT_SUCCESS;

44  }

    B.6.3.4.      _cpri__StopCryptoUnits()

    This function calls the shutdown  functions  of  the  other  crypto  modules  that  are  part  of  the  crypto  engine

    for this implementation.

45  LIB_EXPORT    void

46  _cpri__StopCryptoUnits(

47     void

48     )

49  {

50     return;

51  }

    B.6.3.5.      _cpri__Startup()

    This function calls the startup functions of the other crypto modules that are part of the crypto       engine  for

    this implementation. This function should be called during processing of TPM2_Startup().

52  LIB_EXPORT    BOOL

53  _cpri__Startup(

54     void

55     )

56  {

57

58     return(        _cpri__HashStartup()

59                &&  _cpri__RngStartup()

60  #ifdef    TPM_ALG_RSA

61                &&  _cpri__RsaStartup()

62  #endif    //  TPM_ALG_RSA

63  #ifdef    TPM_ALG_ECC

64                &&  _cpri__EccStartup()

65  #endif    //  TPM_ALG_ECC

66                &&  _cpri__SymStartup());

67  }

    Page 376                                     TCG Published                                              Family "2.0"

    October 30, 2014                  Copyright © TCG 2006-2014                         Level 00 Revision 01.16
    Part 4: Supporting Routines                                                            Trusted Platform Module Library

    B.7     CpriRNG.c

1   //#define      __TPM_RNG_FOR_DEBUG__

    B.7.1.    Introduction

    This file contains the interface to the OpenSSL() random number functions.

    B.7.2.    Includes

2   #include    "OsslCryptoEngine.h"

3   int            s_entropyFailure;

    B.7.3.    Functions

    B.7.3.1.    _cpri__RngStartup()

    This function is called to initialize the random number generator. It collects entropy from the platform         to

    seed the OpenSSL() random number generator.

4   LIB_EXPORT     BOOL

5   _cpri__RngStartup(void)

6   {

7        UINT32           entropySize;

8        BYTE             entropy[MAX_RNG_ENTROPY_SIZE];

9        INT32            returnedSize           =  0;

10

11       //   Initialize  the      entropy       source

12       s_entropyFailure       =  FALSE;

13       _plat__GetEntropy(NULL,             0);

14

15       //   Collect    entropy   until     we     have    enough

16       for(entropySize        =  0;

17             entropySize   <     MAX_RNG_ENTROPY_SIZE             &&  returnedSize       >=  0;

18             entropySize   +=    returnedSize)

19       {

20             returnedSize     =  _plat__GetEntropy(&entropy[entropySize],

21                                                                   MAX_RNG_ENTROPY_SIZE          -  entropySize);

22       }

23       //   Got  some  entropy       on  the      last  call  and     did  not  get  an  error

24       if(returnedSize     >     0)

25       {

26             //  Seed  OpenSSL       with  entropy

27             RAND_seed(entropy,          entropySize);

28       }

29       else

30       {

31             s_entropyFailure        =   TRUE;

32       }

33       return    s_entropyFailure          ==     FALSE;

34  }

    B.7.3.2.    _cpri__DrbgGetPutState()

    This function is used to set the state of the RNG (direction == PUT_STATE) or to recover the state of the

    RNG (direction == GET_STATE).

    Family "2.0"                                          TCG Published                               Page 377

    Level 00 Revision 01.16                      Copyright © TCG 2006-2014                            October 30, 2014
    Trusted Platform Module Library                                                         Part 4: Supporting Routines

    NOTE:         This not currently supported on OpenSSL() version.

35  LIB_EXPORT    CRYPT_RESULT

36  _cpri__DrbgGetPutState(

37     GET_PUT                  direction,

38     int                      bufferSize,

39     BYTE                     *buffer

40     )

41  {

42     UNREFERENCED_PARAMETER(direction);

43     UNREFERENCED_PARAMETER(bufferSize);

44     UNREFERENCED_PARAMETER(buffer);

45

46     return     CRYPT_SUCCESS;             //     Function       is   not  implemented

47  }

    B.7.3.3.      _cpri__StirRandom()

    This function is called to add external entropy to     the OpenSSL() random      number  generator.

48  LIB_EXPORT    CRYPT_RESULT

49  _cpri__StirRandom(

50     INT32                    entropySize,

51     BYTE                     *entropy

52     )

53  {

54     if     (entropySize      >=  0)

55     {

56            RAND_add((const          void  *)entropy,        (int)   entropySize,  0.0);

57

58     }

59     return     CRYPT_SUCCESS;

60  }

    B.7.3.4.      _cpri__GenerateRandom()

    This function is called to get a string of random bytes from the OpenSSL() random number generator. The

    return value is the number of bytes placed in the buffer. If the number of bytes returned is not equal to the

    number of bytes requested (randomSize) it is indicative of a failure of the OpenSSL() random number

    generator and is probably fatal.

61  LIB_EXPORT    UINT16

62  _cpri__GenerateRandom(

63     INT32                    randomSize,

64     BYTE                     *buffer

65     )

66  {

67     //

68     //     We  don't  do  negative        sizes  or  ones   that     are  too  large

69     if     (randomSize    <  0   ||  randomSize      >  UINT16_MAX)

70            return     0;

71     //     RAND_bytes     uses   1   for  success    and    we  use  0

72     if(RAND_bytes(buffer,            randomSize)        ==  1)

73            return     (UINT16)randomSize;

74     else

75            return     0;

76  }

    Page 378                                            TCG Published                                    Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                      Level 00 Revision 01.16
    Part 4: Supporting Routines                                                 Trusted Platform Module Library

    B.7.3.4.1.    _cpri__GenerateSeededRandom()

    This funciton is used to generate a pseudo-random number from some seed values This funciton     returns

    the same result each time it is called with the same parameters

77  LIB_EXPORT    UINT16

78  _cpri__GenerateSeededRandom(

79     INT32                 randomSize,        //  IN:   the   size   of  the  request

80     BYTE               *random,              //  OUT:     receives   the   data

81     TPM_ALG_ID            hashAlg,           //  IN:   used   by   KDF  version   but  not  here

82     TPM2B              *seed,                //  IN:   the   seed   value

83     const    char      *label,               //  IN:   a  label    string    (optional)

84     TPM2B              *partyU,              //  IN:   other  data      (oprtional)

85     TPM2B              *partyV               //  IN:   still  more      (optional)

86     )

87  {

88

89     return     (_cpri__KDFa(hashAlg,   seed,     label,     partyU,     partyV,

90                               randomSize  *  8,  random,      NULL,     FALSE));

91  }

92  

    Family "2.0"                                TCG Published                                        Page 379

    Level 00 Revision 01.16            Copyright © TCG 2006-2014                               October 30, 2014
    Trusted Platform Module Library                                                   Part 4: Supporting Routines

    B.8     CpriHash.c

    B.8.1.    Description

    This file contains implementation of cryptographic functions for hashing.

    B.8.2.    Includes, Defines, and Types

1   #include          "OsslCryptoEngine.h"

2   #include          "CpriHashData.c"

3   #define     OSSL_HASH_STATE_DATA_SIZE        (MAX_HASH_STATE_SIZE          -  8)

4   typedef     struct   {

5        union        {

6               EVP_MD_CTX   context;

7               BYTE         data[OSSL_HASH_STATE_DATA_SIZE];

8        }  u;

9        INT16               copySize;

10  }  OSSL_HASH_STATE;

    Temporary aliasing of SM3 to SHA256 until SM3 is available

11  #define     EVP_sm3_256  EVP_sha256

    B.8.3.    Static Functions

    B.8.3.1.    GetHashServer()

    This function returns the address of the hash server  function

12  static    EVP_MD     *

13  GetHashServer(

14       TPM_ALG_ID         hashAlg

15  )

16  {

17       switch  (hashAlg)

18       {

19  #ifdef    TPM_ALG_SHA1

20       case   TPM_ALG_SHA1:

21              return   (EVP_MD  *)EVP_sha1();

22              break;

23  #endif

24  #ifdef    TPM_ALG_SHA256

25       case   TPM_ALG_SHA256:

26              return   (EVP_MD  *)EVP_sha256();

27              break;

28  #endif

29  #ifdef    TPM_ALG_SHA384

30       case   TPM_ALG_SHA384:

31              return   (EVP_MD  *)EVP_sha384();

32              break;

33  #endif

34  #ifdef    TPM_ALG_SHA512

35       case   TPM_ALG_SHA512:

36              return   (EVP_MD  *)EVP_sha512();

37              break;

38  #endif

39  #ifdef    TPM_ALG_SM3_256

40       case   TPM_ALG_SM3_256:

41              return   (EVP_MD  *)EVP_sm3_256();

42              break;

    Page 380                                     TCG Published                        Family "2.0"

    October 30, 2014                     Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                              Trusted Platform Module Library

43  #endif

44      case  TPM_ALG_NULL:

45            return     NULL;

46      default:

47            FAIL(FATAL_ERROR_INTERNAL);

48      }

49  }

    B.8.3.2.  MarshalHashState()

    This function copies an OpenSSL() hash context into a caller provided buffer.

    Return Value                            Meaning

    >0                                      the number of bytes of buf used.

50  static    UINT16

51  MarshalHashState(

52      EVP_MD_CTX                  *ctxt,                 //  IN:    Context    to  marshal

53      BYTE                        *buf                   //  OUT:   The  buffer    that    will   receive  the

54                                                         //         context.     This  buffer    is  at  least

55                                                         //         MAX_HASH_STATE_SIZE        byte

56      )

57  {

58      //    make  sure     everything         will  fit

59      pAssert(ctxt->digest->ctx_size                <=       OSSL_HASH_STATE_DATA_SIZE);

60

61      //    Copy  the   context         data

62      memcpy(buf,       (void*)         ctxt->md_data,       ctxt->digest->ctx_size);

63

64      return      (UINT16)ctxt->digest->ctx_size;

65  }

    B.8.3.3.  GetHashState()

    This function will unmarshal a caller provided buffer into an OpenSSL() hash context. The function                    returns

    the number of bytes copied (which may be zero).

66  static    UINT16

67  GetHashState(

68      EVP_MD_CTX                  *ctxt,                 //  OUT:   The  context       structure     to  receive  the

69                                                         //         result   of    unmarshaling.

70      TPM_ALG_ID                  algType,               //  IN:    The  hash    algorithm  selector

71      BYTE                        *buf                   //  IN:    Buffer   containing     marshaled    hash     data

72      )

73  {

74      EVP_MD                      *evpmdAlgorithm        =   NULL;

75

76      pAssert(ctxt         !=     NULL);

77

78      EVP_MD_CTX_init(ctxt);

79

80      evpmdAlgorithm           =  GetHashServer(algType);

81      if(evpmdAlgorithm           ==    NULL)

82            return     0;

83

84      //    This  also     allocates      the   ctxt->md_data

85      if((EVP_DigestInit_ex(ctxt,                   evpmdAlgorithm,      NULL))    !=  1)

86            FAIL(FATAL_ERROR_INTERNAL);

87

88      pAssert(ctxt->digest->ctx_size                <       sizeof(ALIGNED_HASH_STATE));

89      memcpy(ctxt->md_data,               buf,  ctxt->digest->ctx_size);

    Family "2.0"                                           TCG Published                                            Page 381

    Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting Routines

90        return       (UINT16)ctxt->digest->ctx_size;

91   }

     B.8.3.4.      GetHashInfoPointer()

     This function returns a pointer to the hash info for the algorithm. If the algorithm                       is  not  supported,    function

     returns a pointer to the data block associated with TPM_ALG_NULL.

92   static      const     HASH_INFO        *

93   GetHashInfoPointer(

94        TPM_ALG_ID                       hashAlg

95        )

96   {

97        UINT32       i,   tableSize;

98

99        //   Get     the     table       size  of  g_hashData

100       tableSize         =     sizeof(g_hashData)               /  sizeof(g_hashData[0]);

101

102       for(i     =  0;      i   <  tableSize      -   1;     i++)

103       {

104              if(g_hashData[i].alg                ==     hashAlg)

105                    return         &g_hashData[i];

106       }

107       return       &g_hashData[tableSize-1];

108  }

     B.8.4.      Hash Functions

     B.8.4.1.      _cpri__HashStartup()

     Function that is called to initialize the hash service. In this implementation, this function does nothing                             but

     it is called by the CryptUtilStartup() function and must be present.

109  LIB_EXPORT        BOOL

110  _cpri__HashStartup(

111       void

112       )

113  {

114       //   On   startup,          make  sure     that       the   structure      sizes     are     compatible.     It      would

115       //   be   nice       if     this  could    be     done      at    compile  time   but     I    couldn't   figure     it     out.

116       CPRI_HASH_STATE             *cpriState         =   NULL;

117  //       NUMBYTES                      evpCtxSize       =     sizeof(EVP_MD_CTX);

118       NUMBYTES                    cpriStateSize             =     sizeof(cpriState->state);

119  //       OSSL_HASH_STATE               *osslState;

120       NUMBYTES                    osslStateSize             =     sizeof(OSSL_HASH_STATE);

121  //       int                           dataSize     =   sizeof(osslState->u.data);

122       pAssert(cpriStateSize                  >=  osslStateSize);

123

124       return       TRUE;

125  }

     B.8.4.2.      _cpri__GetHashAlgByIndex()

     This function is used to iterate through the hashes. TPM_ALG_NULL is returned for all indexes that are

     not  valid  hashes.          If  the  TPM   implements           3   hashes,    then  an     index  value  of  0    will  return  the  first

     implemented       hash           and   and  index      of     2  will  return   the   last.  All    other  index    values       will  return

     TPM_ALG_NULL.

     Page 382                                                         TCG Published                                            Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

     Return Value                       Meaning

     TPM_ALG_xxx()                      a hash algorithm

     TPM_ALG_NULL                       this can be used as a  stop  value

126  LIB_EXPORT    TPM_ALG_ID

127  _cpri__GetHashAlgByIndex(

128      UINT32                 index            //       IN:  the   index

129      )

130  {

131      if(index   >=     HASH_COUNT)

132                return  TPM_ALG_NULL;

133      return    g_hashData[index].alg;

134  }

     B.8.4.3.      _cpri__GetHashBlockSize()

     Returns the size of the block used for the hash

     Return Value                       Meaning

     <0                                 the algorithm is not a supported hash

     >=                                 the digest size (0 for TPM_ALG_NULL)

135  LIB_EXPORT    UINT16

136  _cpri__GetHashBlockSize(

137      TPM_ALG_ID             hashAlg          //       IN:  hash  algorithm    to  look   up

138      )

139  {

140      return    GetHashInfoPointer(hashAlg)->blockSize;

141  }

     B.8.4.4.      _cpri__GetHashDER

     This function returns a pointer to the DER string for     the algorithm and  indicates  its  size.

142  LIB_EXPORT    UINT16

143  _cpri__GetHashDER(

144      TPM_ALG_ID             hashAlg,         //       IN:  the   algorithm    to  look   up

145      const     BYTE         **p

146      )

147  {

148      const     HASH_INFO           *q;

149      q   =     GetHashInfoPointer(hashAlg);

150      *p     =  &q->der[0];

151      return    q->derSize;

152  }

     B.8.4.5.      _cpri__GetDigestSize()

     Gets the digest size of the algorithm. The algorithm is required to be supported.

     Return Value                       Meaning

     =0                                 the digest size for TPM_ALG_NULL

     >0                                 the digest size of a hash algorithm

153  LIB_EXPORT    UINT16

     Family "2.0"                                TCG Published                                           Page 383

     Level 00 Revision 01.16                Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                         Part 4: Supporting Routines

154  _cpri__GetDigestSize(

155      TPM_ALG_ID          hashAlg                 //  IN:  hash  algorithm        to  look     up

156      )

157  {

158      return    GetHashInfoPointer(hashAlg)->digestSize;

159  }

     B.8.4.6.    _cpri__GetContextAlg()

     This function returns the algorithm associated  with a   hash context

160  LIB_EXPORT    TPM_ALG_ID

161  _cpri__GetContextAlg(

162      CPRI_HASH_STATE           *hashState            //   IN:   the   hash    context

163      )

164  {

165      return    hashState->hashAlg;

166  }

     B.8.4.7.    _cpri__CopyHashState

     This function is used to clone a CPRI_HASH_STATE. The return value is the size of the                state.

167  LIB_EXPORT    UINT16

168  _cpri__CopyHashState      (

169      CPRI_HASH_STATE           *out,                 //   OUT:  destination          of  the  state

170      CPRI_HASH_STATE           *in                   //   IN:   source    of  the    state

171      )

172  {

173      OSSL_HASH_STATE       *i     =  (OSSL_HASH_STATE     *)&in->state;

174      OSSL_HASH_STATE       *o     =  (OSSL_HASH_STATE     *)&out->state;

175      pAssert(sizeof(i)     <=  sizeof(in->state));

176

177      EVP_MD_CTX_init(&o->u.context);

178      EVP_MD_CTX_copy_ex(&o->u.context,               &i->u.context);

179      o->copySize   =     i->copySize;

180      out->hashAlg     =  in->hashAlg;

181      return    sizeof(CPRI_HASH_STATE);

182  }

     B.8.4.8.    _cpri__StartHash()

     Functions starts a hash stack Start a hash stack and returns the digest size. As a side effect, the value of

     stateSize in hashState is updated to indicate the number of bytes of state that were saved. This function

     calls GetHashServer() and that function will put the TPM into failure mode if the hash algorithm is not

     supported.

     Return Value                     Meaning

     0                                hash is TPM_ALG_NULL

     >0                               digest size

183  LIB_EXPORT    UINT16

184  _cpri__StartHash(

185      TPM_ALG_ID                hashAlg,              //   IN:   hash  algorithm

186      BOOL                      sequence,             //   IN:   TRUE  if    the  state     should     be  saved

187      CPRI_HASH_STATE           *hashState            //   OUT:  the   state      of  hash     stack.

188      )

189  {

190      EVP_MD_CTX          localState;

     Page 384                                        TCG Published                                            Family "2.0"

     October 30, 2014                      Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

191     OSSL_HASH_STATE             *state     =     (OSSL_HASH_STATE           *)&hashState->state;

192     BYTE                        *stateData         =     state->u.data;

193     EVP_MD_CTX                  *context;

194     EVP_MD                      *evpmdAlgorithm              =  NULL;

195     UINT16                        retVal      =  0;

196

197     if(sequence)

198            context       =   &localState;

199     else

200            context       =   &state->u.context;

201

202     hashState->hashAlg             =     hashAlg;

203

204     EVP_MD_CTX_init(context);

205     evpmdAlgorithm           =    GetHashServer(hashAlg);

206     if(evpmdAlgorithm             ==     NULL)

207            goto      Cleanup;

208

209     if(EVP_DigestInit_ex(context,                        evpmdAlgorithm,         NULL)   !=  1)

210            FAIL(FATAL_ERROR_INTERNAL);

211     retVal     =     (CRYPT_RESULT)EVP_MD_CTX_size(context);

212

213  Cleanup:

214     if(retVal         >  0)

215     {

216            if  (sequence)

217            {

218                   if((state->copySize                 =  MarshalHashState(context,           stateData))         ==  0)

219                   {

220                          //  If   MarshalHashState              returns     a    negative    number,     it  is  an  error

221                          //  code     and     not     a  hash   size   so   copy  the    error   code    to  be  the     return

222                          //  from     this       function       and  set    the  actual     stateSize    to  zero.

223                          retVal    =     state->copySize;

224                          state->copySize              =  0;

225                   }

226                   //     Do  the  cleanup

227                   EVP_MD_CTX_cleanup(context);

228            }

229            else

230                   state->copySize             =  -1;

231     }

232     else

233            state->copySize            =  0;

234     return     retVal;

235  }

     B.8.4.9.     _cpri__UpdateHash()

     Add data to a hash or HMAC stack.

236  LIB_EXPORT    void

237  _cpri__UpdateHash(

238     CPRI_HASH_STATE                   *hashState,               //     IN:  the   hash   context     information

239     UINT32                               dataSize,              //     IN:  the   size   of  data    to  be  added    to  the

240                                                                 //          digest

241     BYTE                              *data                     //     IN:  data  to    be   hashed

242     )

243  {

244     EVP_MD_CTX                    localContext;

245     OSSL_HASH_STATE             *state     =     (OSSL_HASH_STATE           *)&hashState->state;

246     BYTE                        *stateData         =     state->u.data;

247     EVP_MD_CTX                  *context;

248     CRYPT_RESULT                  retVal      =  CRYPT_SUCCESS;

249

     Family "2.0"                                                TCG Published                                                Page 385

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                 Part 4: Supporting Routines

250      //   If    there    is     no  context,        return

251      if(state->copySize             ==     0)

252             return;

253      if(state->copySize             >    0)

254      {

255             context      =   &localContext;

256             if((retVal          =   GetHashState(context,           hashState->hashAlg,      stateData))     <=  0)

257                    return;

258      }

259      else

260             context      =   &state->u.context;

261

262      if(EVP_DigestUpdate(context,                       data,  dataSize)  !=     1)

263             FAIL(FATAL_ERROR_INTERNAL);

264      else     if(      state->copySize              >   0

265                        &&    (retVal=        MarshalHashState(context,           stateData))     >=  0)

266      {

267             //  retVal       is     the  size       of  the  marshaled    data.  Make  sure  that    it  is  consistent

268             //  by  ensuring        that        we  didn't     get  more  than   allowed

269             if(retVal        <     state->copySize)

270                    FAIL(FATAL_ERROR_INTERNAL);

271             else

272                    EVP_MD_CTX_cleanup(context);

273      }

274      return;

275  }

     B.8.4.10.    _cpri__CompleteHash()

     Complete a hash or HMAC computation. This function will place the smaller of digestSize or the size of

     the digest in dOut. The number of bytes in the placed in the buffer is returned. If there is a failure, the

     returned value is <= 0.

     Return Value                              Meaning

     0                                         no data returned

     >0                                        the number of bytes in the digest

276  LIB_EXPORT     UINT16

277  _cpri__CompleteHash(

278      CPRI_HASH_STATE                     *hashState,           //   IN:   the   state  of  hash  stack

279      UINT32                              dOutSize,             //   IN:   size   of  digest  buffer

280      BYTE                                *dOut                 //   OUT:  hash   digest

281      )

282  {

283      EVP_MD_CTX                     localState;

284      OSSL_HASH_STATE               *state    =  (OSSL_HASH_STATE          *)&hashState->state;

285      BYTE                          *stateData       =   state->u.data;

286      EVP_MD_CTX                    *context;

287      UINT16                         retVal;

288      int                            hLen;

289      BYTE                           temp[MAX_DIGEST_SIZE];

290      BYTE                          *rBuffer     =   dOut;

291

292      if(state->copySize             ==     0)

293             return     0;

294      if(state->copySize             >    0)

295      {

296             context      =   &localState;

297             if((retVal          =   GetHashState(context,           hashState->hashAlg,      stateData))     <=  0)

298                    goto     Cleanup;

299      }

300      else

     Page 386                                                    TCG Published                                   Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                    Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                Trusted Platform Module Library

301             context      =  &state->u.context;

302

303       hLen     =  EVP_MD_CTX_size(context);

304       if((unsigned)hLen                >  dOutSize)

305             rBuffer      =  temp;

306       if(EVP_DigestFinal_ex(context,                    rBuffer,     NULL)   ==   1)

307       {

308             if(rBuffer          !=     dOut)

309             {

310                   if(dOut          !=     NULL)

311                   {

312                          memcpy(dOut,            temp,  dOutSize);

313                   }

314                   retVal        =   (UINT16)dOutSize;

315             }

316             else

317             {

318                   retVal        =   (UINT16)hLen;

319             }

320             state->copySize               =  0;

321       }

322       else

323       {

324             retVal   =      0;     //     Indicate   that  no  data  is  returned

325       }

326  Cleanup:

327       EVP_MD_CTX_cleanup(context);

328       return      retVal;

329  }

     B.8.4.11.     _cpri__ImportExportHashState()

     This function is used to import or export the hash state. This function would be called to export state when

     a sequence object was being prepared for export

330  LIB_EXPORT       void

331  _cpri__ImportExportHashState(

332       CPRI_HASH_STATE                     *osslFmt,            //  IN/OUT:   the      hash  state  formated  for  use

333                                                                //        by  openSSL

334       EXPORT_HASH_STATE                   *externalFmt,        //  IN/OUT:   the      exported  hash  state

335       IMPORT_EXPORT                          direction         //

336       )

337  {

338       UNREFERENCED_PARAMETER(direction);

339       UNREFERENCED_PARAMETER(externalFmt);

340       UNREFERENCED_PARAMETER(osslFmt);

341       return;

342

343  #if  0

344       if(direction          ==     IMPORT_STATE)

345       {

346             //    don't     have       the   import  export    functions     yet  so  just  copy

347             _cpri__CopyHashState(osslFmt,                  (CPRI_HASH_STATE           *)externalFmt);

348       }

349       else

350       {

351             _cpri__CopyHashState((CPRI_HASH_STATE                    *)externalFmt,         osslFmt);

352       }

353  #endif

354  }

     Family "2.0"                                              TCG Published                                          Page 387

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                             October 30, 2014
     Trusted Platform Module Library                                                                             Part 4: Supporting Routines

     B.8.4.12.        _cpri__HashBlock()

     Start a hash, hash a single block, update digest and return the size of the results.

     The digestSize parameter can be smaller than the digest. If so, only the more                                       significant   bytes  are

     returned.

     Return Value                                  Meaning

     >= 0                                          number of bytes in digest (may be zero)

355  LIB_EXPORT        UINT16

356  _cpri__HashBlock(

357        TPM_ALG_ID                      hashAlg,                //  IN:     The   hash  algorithm

358        UINT32                          dataSize,               //  IN:     size   of   buffer       to  hash

359        BYTE                           *data,                   //  IN:     the   buffer     to  hash

360        UINT32                          digestSize,             //  IN:     size   of   the  digest      buffer

361        BYTE                           *digest                  //  OUT:     hash  digest

362        )

363  {

364        EVP_MD_CTX                      hashContext;

365        EVP_MD                         *hashServer        =  NULL;

366        UINT16                          retVal     =  0;

367        BYTE                            b[MAX_DIGEST_SIZE];             //   temp  buffer        in  case     digestSize       not

368        //   a     full  digest

369        unsigned         int            dSize   =     _cpri__GetDigestSize(hashAlg);

370

371        //   If     there       is  no    digest      to  compute     return

372        if(dSize         ==     0)

373                return       0;

374

375        //   After       the     call     to  EVP_MD_CTX_init(),             will  need      to  call    EVP_MD_CTX_cleanup()

376        EVP_MD_CTX_init(&hashContext);                              //   Initialize       the    local       hash     context

377        hashServer           =   GetHashServer(hashAlg);                //   Find  the    hash       server

378

379        //   It     is   an     error     if  the     digest    size    is   non-zero     but    there       is   no  server

380        if(         (hashServer           ==  NULL)

381             ||     (EVP_DigestInit_ex(&hashContext,                        hashServer,      NULL)       !=   1)

382             ||     (EVP_DigestUpdate(&hashContext,                      data,     dataSize)         !=  1))

383                FAIL(FATAL_ERROR_INTERNAL);

384        else

385        {

386                //  If   the        size  of   the    digest    produced         (dSize)     is  larger       than    the  available

387                //  buffer          (digestSize),         then  put     the   digest    in   a   temp    buffer       and  only     copy

388                //  the      most      significant        part  into     the     available       buffer.

389                if(dSize         >  digestSize)

390                {

391                        if(EVP_DigestFinal_ex(&hashContext,                        b,   &dSize)      !=  1)

392                                FAIL(FATAL_ERROR_INTERNAL);

393                        memcpy(digest,          b,    digestSize);

394                        retVal      =   (UINT16)digestSize;

395                }

396                else

397                {

398                        if((EVP_DigestFinal_ex(&hashContext,                       digest,       &dSize))         !=  1)

399                                FAIL(FATAL_ERROR_INTERNAL);

400                        retVal      =   (UINT16)      dSize;

401                }

402        }

403        EVP_MD_CTX_cleanup(&hashContext);

404        return      retVal;

405  }

     Page 388                                                      TCG Published                                                  Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                  Trusted Platform Module Library

     B.8.5.    HMAC Functions

     B.8.5.1.      _cpri__St artHM AC

     This function is used to start an HMAC using a temp hash context. The function does the initialization of

     the hash with the HMAC key XOR iPad and updates the HMAC key XOR oPad.

     The function returns the number of bytes in a digest produced by hashAlg.

     Return Value                                       Meaning

     >= 0                                               number of bytes in digest produced by hashAlg (may be zero)

406  LIB_EXPORT          UINT16

407  _cpri__StartHMAC(

408        TPM_ALG_ID                                  hashAlg,                     //  IN:    the   algorithm    to      use

409        BOOL                                        sequence,                    //  IN:    indicates     if   the     state    should       be

410                                                                                 //         saved

411        CPRI_HASH_STATE                            *state,                       //  IN/OUT:      the   state  buffer

412        UINT16                                      keySize,                     //  IN:    the   size  of    the   HMAC    key

413        BYTE                                       *key,                         //  IN:    the   HMAC  key

414        TPM2B                                      *oPadKey                      //  OUT:   the    key  prepared       for      the  oPad     round

415        )

416  {

417        CPRI_HASH_STATE                   localState;

418        UINT16                            blockSize           =     _cpri__GetHashBlockSize(hashAlg);

419        UINT16                            digestSize;

420        BYTE                             *pb;                    //  temp        pointer

421        UINT32                            i;

422

423        //  If     the     key     size         is   larger         than   the       block  size,      then   the   hash    of   the     key

424        //  is     used       as   the       key

425        if(keySize            >   blockSize)

426        {

427               //     large       key     so       digest

428               if((digestSize                   =   _cpri__StartHash(hashAlg,                     FALSE,     &localState))           ==  0)

429                      return          0;

430               _cpri__UpdateHash(&localState,                                 keySize,      key);

431               _cpri__CompleteHash(&localState,                                  digestSize,       oPadKey->buffer);

432               oPadKey->size                 =     digestSize;

433        }

434        else

435        {

436               //     key     size       is     ok

437               memcpy(oPadKey->buffer,                           key,     keySize);

438               oPadKey->size                 =     keySize;

439        }

440        //  XOR       the     key     with         iPad   (0x36)

441        pb  =   oPadKey->buffer;

442        for(i      =  oPadKey->size;                 i    >   0;     i--)

443               *pb++       ^=     0x36;

444

445        //  if     the     keySize           is     smaller         than   a     block,     fill   the  rest   with       0x36

446        for(i      =  blockSize              -     oPadKey->size;             i  >   0;     i--)

447               *pb++       =     0x36;

448

449        //  Increase             the     oPadSize         to     a   full     block

450        oPadKey->size              =     blockSize;

451

452        //  Start       a     new     hash         with   the       HMAC   key

453        //  This      will        go     in     the  caller's          state         structure     and  may    be   a  sequence          or  not

454

455        if((digestSize                =   _cpri__StartHash(hashAlg,                         sequence,     state))      >    0)

456        {

     Family "2.0"                                                         TCG Published                                                          Page 389

     Level 00 Revision 01.16                                    Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

457

458              _cpri__UpdateHash(state,             oPadKey->size,           oPadKey->buffer);

459

460              //  XOR  the  key     block    with    0x5c      ^  0x36

461              for(pb   =    oPadKey->buffer,         i  =   blockSize;        i   >   0;  i--)

462                   *pb++    ^=  (0x5c     ^  0x36);

463        }

464

465        return    digestSize;

466  }

     B.8.5.2.     _cpri_Co mplet eHM AC()

     This function is called to complete an HMAC. It will finish the current digest, and start a new digest. It will

     then add the oPadKey and the completed digest and return the results in dOut. It will not return more than

     dOutSize bytes.

     Return Value                          Meaning

     >= 0                                  number of bytes in dOut (may be zero)

467  LIB_EXPORT      UINT16

468  _cpri__CompleteHMAC(

469        CPRI_HASH_STATE             *hashState,                   //  IN:   the   state      of  hash    stack

470        TPM2B                       *oPadKey,                     //  IN:   the   HMAC    key    in      oPad  format

471        UINT32                      dOutSize,                     //  IN:   size     of   digest     buffer

472        BYTE                        *dOut                         //  OUT:  hash      digest

473        )

474  {

475        BYTE                    digest[MAX_DIGEST_SIZE];

476        CPRI_HASH_STATE         *state    =  (CPRI_HASH_STATE              *)hashState;

477        CPRI_HASH_STATE         localState;

478        UINT16                  digestSize   =       _cpri__GetDigestSize(state->hashAlg);

479

480        _cpri__CompleteHash(hashState,                  digestSize,         digest);

481

482        //  Using    the    local   hash     state,     do  a     hash  with     the     oPad

483        if(_cpri__StartHash(state->hashAlg,                       FALSE,    &localState)         !=      digestSize)

484              return   0;

485

486        _cpri__UpdateHash(&localState,                  oPadKey->size,           oPadKey->buffer);

487        _cpri__UpdateHash(&localState,                  digestSize,         digest);

488        return    _cpri__CompleteHash(&localState,                      dOutSize,        dOut);

489  }

     B.8.6.    Mask and Key Generation Functions

     B.8.6.1.     _crypi_MGF1()

     This function performs MGF1 using the selected hash. MGF1 is T(n) = T(n-1) || H(seed || counter). This

     function  returns    the  length  of  the  mask    produced         which   could      be  zero    if  the   digest  algorithm  is  not

     supported

     Return Value                          Meaning

     0                                     hash algorithm not supported

     >0                                    should be the same as mSize

490  LIB_EXPORT      CRYPT_RESULT

491  _cpri__MGF1(

     Page 390                                              TCG Published                                                  Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                    Trusted Platform Module Library

492     UINT32                            mSize,                        //  IN:      length       of     the   mask     to   be  produced

493     BYTE                              *mask,                        //  OUT:     buffer          to   receive       the     mask

494     TPM_ALG_ID                        hashAlg,                      //  IN:      hash    to      use

495     UINT32                            sSize,                        //  IN:      size    of      the  seed

496     BYTE                              *seed                         //  IN:      seed    size

497     )

498  {

499     EVP_MD_CTX                                   hashContext;

500     EVP_MD                                    *hashServer           =   NULL;

501     CRYPT_RESULT                                 retVal      =  0;

502     BYTE                                         b[MAX_DIGEST_SIZE];                 //  temp        buffer     in  case     mask      is  not   an

503     //  even     multiple             of      a  full     digest

504     CRYPT_RESULT                                 dSize    =     _cpri__GetDigestSize(hashAlg);

505     unsigned         int                         digestSize         =   (UINT32)dSize;

506     UINT32                                       remaining;

507     UINT32                                       counter;

508     BYTE                                         swappedCounter[4];

509

510     //  Parameter              check

511     if(mSize         >   (1024*16))              //   Semi-arbitrary             maximum

512           FAIL(FATAL_ERROR_INTERNAL);

513

514     //  If    there         is    no      digest      to     compute    return

515     if(dSize         <=     0)

516           return         0;

517

518     EVP_MD_CTX_init(&hashContext);                                      //   Initialize              the   local    hash     context

519     hashServer           =     GetHashServer(hashAlg);                       //  Find      the       hash  server

520     if(hashServer                 ==  NULL)

521           //     If     there         is   no    server,        then    there        is  no      digest

522           return         0;

523

524     for(counter             =     0,  remaining           =     mSize;  remaining             >   0;  counter++)

525     {

526           //     Because          the      system        may    be     either    Endian...

527           UINT32_TO_BYTE_ARRAY(counter,                                 swappedCounter);

528

529           //     Start         the    hash       and     include        the  seed        and     counter

530           if(           (EVP_DigestInit_ex(&hashContext,                                 hashServer,           NULL)     !=  1)

531                  ||     (EVP_DigestUpdate(&hashContext,                               seed,       sSize)       !=   1)

532                  ||     (EVP_DigestUpdate(&hashContext,                               swappedCounter,               4)   !=  1)

533               )

534                  FAIL(FATAL_ERROR_INTERNAL);

535

536           //     Handling             the     completion        depends          on   how     much    space        remains       in   the  mask

537           //     buffer.          If      it     can  hold      the     entire       digest,         put   it   there.       If   not

538           //     put     the      digest         in   a   temp      buffer       and     only     copy     the     amount    that

539           //     will       fit       into       the  mask      buffer.

540           if(remaining                <    (unsigned)dSize)

541           {

542                  if(EVP_DigestFinal_ex(&hashContext,                                     b,      &digestSize)           !=   1)

543                             FAIL(FATAL_ERROR_INTERNAL);

544                  memcpy(mask,                    b,   remaining);

545                  break;

546           }

547           else

548           {

549                  if(EVP_DigestFinal_ex(&hashContext,                                     mask,        &digestSize)           !=   1)

550                             FAIL(FATAL_ERROR_INTERNAL);

551                  remaining                -=     dSize;

552                  mask          =  &mask[dSize];

553           }

554           retVal         =     (CRYPT_RESULT)mSize;

555     }

556

557     EVP_MD_CTX_cleanup(&hashContext);

     Family "2.0"                                                       TCG Published                                                          Page 391

     Level 00 Revision 01.16                                 Copyright © TCG 2006-2014                                                   October 30, 2014
     Trusted Platform Module Library                                                                            Part 4: Supporting Routines

558       return    retVal;

559  }

     B.8.6.2.    _cpri_KDFa()

     This function performs the key generation according to Part 1 of the TPM specification.

     This function returns the number of bytes generated which may be zero.

     The key and keyStream pointers are not allowed to be NULL. The other pointer values may be NULL.

     The value of sizeInBits must be no larger than (2^18)-1 = 256K bits (32385 bytes).

     The  once   parameter       is  set   to  allow   incremental          generation        of  a   large  value.     If  this  flag  is  TRUE,

     sizeInBits will be used in the HMAC computation but only one iteration of the KDF is performed. This

     would be used for XOR obfuscation so that the mask value can be generated in digest-sized chunks

     rather than having to be generated all at once in an arbitrarily large buffer and then XORed() into the

     result. If once is TRUE, then sizeInBits must be a multiple of 8.

     Any error in the processing of this command is considered fatal.

     Return Value                              Meaning

     0                                         hash algorithm is not supported or is TPM_ALG_NULL

     >0                                        the number of bytes in the keyStream buffer

560  LIB_EXPORT     UINT16

561  _cpri__KDFa(

562       TPM_ALG_ID                 hashAlg,                 //     IN:    hash      algorithm       used   in     HMAC

563       TPM2B                  *key,                        //     IN:    HMAC      key

564       const     char         *label,                      //     IN:    a   0-byte        terminated     label       used     in  KDF

565       TPM2B                  *contextU,                   //     IN:    context        U

566       TPM2B                  *contextV,                   //     IN:    context        V

567       UINT32                     sizeInBits,              //     IN:    size      of   generated       key   in     bit

568       BYTE                   *keyStream,                  //     OUT:       key   buffer

569       UINT32                 *counterInOut,               //     IN/OUT:         caller     may   provide       the     iteration

570                                                           //            counter        for    incremental        operations         to

571                                                           //            avoid     large       intermediate          buffers.

572       BOOL                       once                     //     IN:    TRUE      if   only   one  iteration            is  performed

573                                                           //            FALSE     if      iteration      count      determined      by

574                                                           //            "sizeInBits"

575       )

576  {

577       UINT32                                   counter       =   0;         //    counter     value

578       INT32                                    lLen   =   0;                //    length      of  the    label

579       INT16                                    hLen;                        //    length      of  the    hash

580       INT16                                    bytes;                       //    number      of  bytes     to   produce

581       BYTE                                    *stream     =     keyStream;

582       BYTE                                     marshaledUint32[4];

583       CPRI_HASH_STATE                          hashState;

584       TPM2B_MAX_HASH_BLOCK                     hmacKey;

585

586       pAssert(key     !=     NULL     &&   keyStream         !=   NULL);

587       pAssert(once       ==  FALSE        ||   (sizeInBits           &  7)  ==    0);

588

589       if(counterInOut        !=    NULL)

590             counter   =     *counterInOut;

591

592       //   Prepare    label      buffer.       Calculate          its       size  and     keep    the    last    0   byte

593       if(label  !=    NULL)

594             for(lLen     =   0;  label[lLen++]            !=     0;     );

595

596       //   Get  the   hash   size.         If  it    is   less       than   or    0,      either   the

597       //   algorithm     is  not      supported       or     the     hash   is    TPM_ALG_NULL

     Page 392                                                 TCG Published                                                           Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                                     Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                                  Trusted Platform Module  Library

598        //   In   either         case       the       digest       size  is    zero.        This      is   the  only      return

599        //   other       than       the     one       at   the     end.  All      other     exits     from      this    function

600        //   are     fatal       errors.           After       we  check     that     the   algorithm           is  supported

601        //   anything       else         that         goes     wrong     is  an   implementation            flaw.

602        if((hLen         =  (INT16)            _cpri__GetDigestSize(hashAlg))                         ==   0)

603             return         0;

604

605        //   If   the       size     of     the       request      is    larger       than  the       numbers       will  handle,

606        //   it   is     a  fatal        error.

607        pAssert(((sizeInBits                       +   7)/     8)  <=    INT16_MAX);

608

609        bytes     =   once       ?   hLen      :      (INT16)((sizeInBits             +     7)  /     8);

610

611        //   Generate       required               bytes

612        for  (;      bytes       >   0;     stream         =   &stream[hLen],         bytes        =  bytes     -   hLen)

613        {

614             if(bytes            <   hLen)

615                      hLen       =   bytes;

616

617             counter++;

618             //      Start       HMAC

619             if(_cpri__StartHMAC(hashAlg,

620                                                          FALSE,

621                                                          &hashState,

622                                                          key->size,

623                                                          &key->buffer[0],

624                                                          &hmacKey.b)                       <=  0)

625                      FAIL(FATAL_ERROR_INTERNAL);

626

627             //      Adding         counter

628             UINT32_TO_BYTE_ARRAY(counter,                               marshaledUint32);

629             _cpri__UpdateHash(&hashState,                               sizeof(UINT32),              marshaledUint32);

630

631             //      Adding         label

632             if(label            !=     NULL)

633                      _cpri__UpdateHash(&hashState,                               lLen,     (BYTE         *)label);

634

635             //      Adding         contextU

636             if(contextU                !=     NULL)

637                      _cpri__UpdateHash(&hashState,                               contextU->size,           contextU->buffer);

638

639             //      Adding         contextV

640             if(contextV                !=     NULL)

641                      _cpri__UpdateHash(&hashState,                               contextV->size,           contextV->buffer);

642

643             //      Adding         size       in     bits

644             UINT32_TO_BYTE_ARRAY(sizeInBits,                                  marshaledUint32);

645             _cpri__UpdateHash(&hashState,                               sizeof(UINT32),              marshaledUint32);

646

647             //      Compute         HMAC.         At     the   start    of    each   iteration,           hLen     is    set

648             //      to     the     smaller           of   hLen    and   bytes.       This      causes     bytes      to  decrement

649             //      exactly         to     zero       to     complete       the  loop

650             _cpri__CompleteHMAC(&hashState,                                 &hmacKey.b,           hLen,    stream);

651        }

652

653        //   Mask     off   bits         if    the        required       bits     is  not   a   multiple        of    byte     size

654        if((sizeInBits               %   8)    !=      0)

655             keyStream[0]                &=    ((1        <<   (sizeInBits        %   8))   -   1);

656        if(counterInOut                 !=     NULL)

657             *counterInOut                  =  counter;

658        return       (CRYPT_RESULT)((sizeInBits                          +   7)/8);

659  }

     Family "2.0"                                                         TCG Published                                                 Page 393

     Level 00 Revision 01.16                                     Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                                              Part 4: Supporting Routines

     B.8.6.3.     _cpri__KDFe()

     KDFe() as defined in TPM specification part 1.

     This function returns the number of bytes generated which may be zero.

     The Z and keyStream pointers are not allowed to be NULL. The other pointer values may be NULL. The

     value of sizeInBits must be no larger than (2^18)-1 = 256K bits (32385 bytes). Any error in the processing

     of this command is considered fatal.

     Return Value                                       Meaning

     0                                                  hash algorithm is not supported or is TPM_ALG_NULL

     >0                                                 the number of bytes in the keyStream buffer

660  LIB_EXPORT       UINT16

661  _cpri__KDFe(

662      TPM_ALG_ID                        hashAlg,                       //     IN:      hash      algorithm         used     in  HMAC

663      TPM2B                         *Z,                                //     IN:      Z

664      const     char                *label,                            //     IN:      a  0    terminated          label       using   in      KDF

665      TPM2B                         *partyUInfo,                       //     IN:      PartyUInfo

666      TPM2B                         *partyVInfo,                       //     IN:      PartyVInfo

667      UINT32                            sizeInBits,                    //     IN:      size      of  generated            key   in     bit

668      BYTE                          *keyStream                         //     OUT:        key    buffer

669      )

670  {

671      UINT32                  counter             =   0;               //     counter          value

672      UINT32                  lSize         =     0;

673      BYTE                 *stream             =     keyStream;

674      CPRI_HASH_STATE                                    hashState;

675      INT16                   hLen      =      (INT16)          _cpri__GetDigestSize(hashAlg);

676      INT16                   bytes;                                   //     number         of  bytes         to  generate

677      BYTE                    marshaledUint32[4];

678

679      pAssert(           keyStream                !=     NULL

680                         &&      Z  !=      NULL

681                         &&      ((sizeInBits                +     7)  /      8)   <   INT16_MAX);

682

683      if(hLen      ==    0)

684            return       0;

685

686      bytes     =  (INT16)((sizeInBits                          +  7)      /  8);

687

688      //    Prepare      label          buffer.              Calculate            its     size   and       keep    the    last      0  byte

689      if(label      !=     NULL)

690            for(lSize            =  0;      label[lSize++]                    !=   0;);

691

692      //    Generate       required               bytes

693      //The     inner      loop         of     that       KDF      uses:

694      //    Hashi      :=     H(counter               |   Z  |     OtherInfo)             (5)

695      //    Where:

696      //    Hashi          the      hash          generated            on     the     i-th     iteration           of  the     loop.

697      //    H()            an       approved             hash      function

698      //    counter        a     32-bit           counter          that       is   initialized             to  1   and    incremented

699      //                   on       each       iteration

700      //    Z              the      X   coordinate                 of  the        product        of  a     public      ECC     key     and  a

701      //                   different                 private       ECC        key.

702      //    OtherInfo               a   collection                 of  qualifying              data     for    the     KDF     defined      below.

703      //    In     this    specification,                    OtherInfo             will      be  constructed              by:

704      //           OtherInfo            :=        Use     |  PartyUInfo                |  PartyVInfo

705      for   (;     bytes      >     0;  stream            =  &stream[hLen],                  bytes      =  bytes       -  hLen)

706      {

707            if(bytes          <     hLen)

708                   hLen       =     bytes;

     Page 394                                                             TCG Published                                                                Family "2.0"

     October 30, 2014                                           Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
     Part  4: Supporting Routines                                                              Trusted Platform Module  Library

709

710            counter++;

711            //    Start      hash

712            if(_cpri__StartHash(hashAlg,                 FALSE,       &hashState)       ==  0)

713                  return         0;

714

715            //    Add     counter

716            UINT32_TO_BYTE_ARRAY(counter,                marshaledUint32);

717            _cpri__UpdateHash(&hashState,                sizeof(UINT32),             marshaledUint32);

718

719            //    Add     Z

720            if(Z      !=     NULL)

721                  _cpri__UpdateHash(&hashState,                   Z->size,      Z->buffer);

722

723            //    Add     label

724            if(label         !=     NULL)

725                  _cpri__UpdateHash(&hashState,                   lSize,   (BYTE     *)label);

726            else

727

728                  //      The    SP800-108         specification  requires      a    zero   between   the  label

729                  //      and    the     context.

730                  _cpri__UpdateHash(&hashState,                   1,  (BYTE     *)"");

731

732            //    Add     PartyUInfo

733            if(partyUInfo             !=   NULL)

734                  _cpri__UpdateHash(&hashState,                   partyUInfo->size,         partyUInfo->buffer);

735

736            //    Add     PartyVInfo

737            if(partyVInfo             !=   NULL)

738                  _cpri__UpdateHash(&hashState,                   partyVInfo->size,         partyVInfo->buffer);

739

740            //    Compute        Hash.     hLen    was  changed   to  be   the  smaller     of  bytes  or    hLen

741            //    at   the     start      of   each  iteration.

742            _cpri__CompleteHash(&hashState,                 hLen,     stream);

743        }

744

745        //  Mask  off        bits    if   the  required  bits     is  not  a    multiple    of  byte   size

746        if((sizeInBits           %   8)   !=   0)

747            keyStream[0]             &=   ((1  <<    (sizeInBits  %   8))  -    1);

748

749        return    (CRYPT_RESULT)((sizeInBits             +  7)    /   8);

750

751  }

     Family "2.0"                                           TCG Published                                             Page 395

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                               October 30, 2014
    Trusted Platform Module Library                                                  Part  4:  Supporting  Routines

    B.9      CpriHashData.c

    This file should be included by the library hash module.

1   const  HASH_INFO    g_hashData[HASH_COUNT            +  1]  =  {

2   #ifdef TPM_ALG_SHA1

3        {TPM_ALG_SHA1,      SHA1_DIGEST_SIZE,      SHA1_BLOCK_SIZE,

4        SHA1_DER_SIZE,      SHA1_DER},

5   #endif

6   #ifdef TPM_ALG_SHA256

7        {TPM_ALG_SHA256,    SHA256_DIGEST_SIZE,                 SHA256_BLOCK_SIZE,

8        SHA256_DER_SIZE,    SHA256_DER},

9   #endif

10  #ifdef TPM_ALG_SHA384

11       {TPM_ALG_SHA384,    SHA384_DIGEST_SIZE,                 SHA384_BLOCK_SIZE,

12       SHA384_DER_SIZE,    SHA384_DER},

13  #endif

14  #ifdef TPM_ALG_SM3_256

15       {TPM_ALG_SM3_256,   SM3_256_DIGEST_SIZE,                    SM3_256_BLOCK_SIZE,

16       SM3_256_DER_SIZE,   SM3_256_DER},

17  #endif

18  #ifdef TPM_ALG_SHA512

19       {TPM_ALG_SHA512,    SHA512_DIGEST_SIZE,                 SHA512_BLOCK_SIZE,

20       SHA512_DER_SIZE,    SHA512_DER},

21  #endif

22           {TPM_ALG_NULL,0,0,0,{0}}

23       };

    Page 396                                TCG Published                                      Family "2.0"

    October 30, 2014                     Copyright © TCG 2006-2014                   Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                     Trusted Platform Module Library

    B.10     CpriMisc.c

    B.10.1.    Includes

1   #include     "OsslCryptoEngine.h"

    B.10.2.    Functions

    B.10.2.1.    BnTo2B()

    This function is used to convert a BigNum() to a byte array of the specified size.                  If the number is too  large

    to fit, then 0 is returned. Otherwise, the number is converted into the low-order bytes of the provided                   array

    and the upper bytes are set to zero.

    Return Value                              Meaning

    0                                         failure (probably fatal)

    1                                         conversion successful

2   BOOL

3   BnTo2B(

4         TPM2B                      *outVal,               //  OUT:    place     for     the   result

5         BIGNUM                     *inVal,                //  IN:     number    to   convert

6         UINT16                     size                   //  IN:     size  of  the      output.

7         )

8   {

9         BYTE      *pb     =     outVal->buffer;

10

11        outVal->size         =  size;

12

13        size   =  size    -     (((UINT16)   BN_num_bits(inVal)             +   7)   /   8);

14        if(size   <   0)

15              return     FALSE;

16        for(;size     >   0;    size--)

17              *pb++   =   0;

18        BN_bn2bin(inVal,           pb);

19        return    TRUE;

20  }

    B.10.2.2.    Copy2B()

    This  function  copies        a  TPM2B    structure.    The  compiler     can't    generate     a   copy  of  a  TPM2B  generic

    structure because the actual size is not known. This function performs the copy on any TPM2B pair. The

    size of the destination should have been checked before this call to make sure that it will hold the TPM2B

    being copied.

    This replicates the functionality in the MemoryLib.c.

21  void

22  Copy2B(

23        TPM2B                      *out,                  //  OUT:    The   TPM2B       to   receive  the   copy

24        TPM2B                      *in                    //  IN:     the   TPM2B    to     copy

25        )

26  {

27        BYTE              *pIn     =     in->buffer;

28        BYTE              *pOut       =  out->buffer;

29        int                  count;

30        out->size     =   in->size;

31        for(count     =   in->size;       count  >    0;  count--)

    Family "2.0"                                            TCG Published                                            Page 397

    Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                          October 30, 2014
    Trusted Platform Module Library                                          Part 4: Supporting Routines

32             *pOut++  =  *pIn++;

33     return;

34  }

    B.10.2.3.  BnFrom2B()

    This function creates a BIGNUM from a TPM2B and fails if the conversion  fails.

35  BIGNUM  *

36  BnFrom2B(

37     BIGNUM              *out,            //  OUT:  The  BIGNUM

38     const   TPM2B       *in              //  IN:   the  TPM2B  to  copy

39     )

40  {

41     if(BN_bin2bn(in->buffer,      in->size,  out)  ==   NULL)

42             FAIL(FATAL_ERROR_INTERNAL);

43     return   out;

44  }

    Page 398                                TCG Published                            Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014                       Level 00 Revision 01.16
    Part 4: Supporting Routines                                                           Trusted Platform Module Library

    B.11     CpriSym.c

    B.11.1.  Introduction

    This file contains the implementation of the symmetric block cipher modes allowed for a TPM. These

    function only use the single block encryption and decryption functions of OpesnSSL().

    Currently, this module only supports AES encryption. The SM4 code actually calls an AES routine

    B.11.2.  Includes, Defines, and Typedefs

1   #include      "OsslCryptoEngine.h"

    The following sets of defines are used to allow use of the SM4              algorithm    identifier  while  waiting  for  the

    SM4 implementation code to appear.

2   typedef     AES_KEY  SM4_KEY;

3   #define     SM4_set_encrypt_key         AES_set_encrypt_key

4   #define     SM4_set_decrypt_key         AES_set_decrypt_key

5   #define     SM4_decrypt                 AES_decrypt

6   #define     SM4_encrypt                 AES_encrypt

    B.11.3.  Utility  Functions

    B.11.3.1.   _cpri_SymStartup()

7   LIB_EXPORT    BOOL

8   _cpri__SymStartup(

9         void

10  )

11  {

12        return  TRUE;

13  }

    B.11.3.2.   _cpri__GetSymmetricBlockSize()

    This function returns the block size of the algorithm.

    Return Value                       Meaning

    <= 0                               cipher not supported

    >0                                 the cipher block size in bytes

14  LIB_EXPORT    INT16

15  _cpri__GetSymmetricBlockSize(

16        TPM_ALG_ID             symmetricAlg,   //    IN:   the       symmetric       algorithm

17        UINT16                 keySizeInBits   //    IN:   the       key   size

18        )

19  {

20        switch  (symmetricAlg)

21        {

22  #ifdef   TPM_ALG_AES

23        case  TPM_ALG_AES:

24  #endif

25  #ifdef   TPM_ALG_SM4     //  Both  AES  and  SM4   use   the       same     block  size

26        case  TPM_ALG_SM4:

27  #endif

28              if(keySizeInBits   !=  0)   //   This  is    mostly         to  have   a  reference      to

    Family "2.0"                                 TCG Published                                                  Page 399

    Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                    October 30, 2014
    Trusted Platform Module Library                                                                           Part 4: Supporting Routines

29                   //      keySizeInBits            for  the     compiler

30                   return          16;

31             else

32                   return          0;

33             break;

34

35     default:

36             return        0;

37     }

38  }

    B.11.4.  AES     Encryption

    B.11.4.1.  _cpri__AESEncryptCBC()

    This function performs AES encryption in CBC chain mode. The input dIn buffer is encrypted into dOut.

    The input iv buffer is required to have a size equal to the block size (16 bytes). The dInSize is required to

    be a multiple of the block size.

    Return Value                                Meaning

    CRYPT_SUCCESS                               if success

    CRYPT_PARAMETER                             dInSize is not a multiple of the block size

39  LIB_EXPORT       CRYPT_RESULT

40  _cpri__AESEncryptCBC(

41     BYTE                          *dOut,                     //   OUT:

42     UINT32                            keySizeInBits,         //   IN:    key   size     in  bit

43     BYTE                          *key,                      //   IN:    key   buffer.      The     size   of  this    buffer  in

44                                                              //          bytes     is   (keySizeInBits         +   7)  /  8

45     BYTE                          *iv,                       //   IN/OUT:      IV   for     decryption.

46     UINT32                            dInSize,               //   IN:    data     size     (is  required       to  be  a  multiple

47                                                              //          of   16   bytes)

48     BYTE                          *dIn                       //   IN:    data     buffer

49     )

50  {

51     AES_KEY                   AesKey;

52     BYTE                  *pIv;

53     INT32                     dSize;                    //  Need     a   signed    version

54     int                       i;

55

56     pAssert(dOut              !=  NULL     &&  key      !=  NULL     &&  iv   !=   NULL     &&  dIn    !=  NULL);

57

58     if(dInSize            ==  0)

59             return        CRYPT_SUCCESS;

60

61     pAssert(dInSize               <=   INT32_MAX);

62     dSize      =  (INT32)dInSize;

63

64     //    For     CBC,    the     data     size    must     be   an     even  multiple      of    the

65     //    cipher       block      size

66     if((dSize          %  16)     !=   0)

67             return        CRYPT_PARAMETER;

68

69     //    Create       AES    encrypt        key   schedule

70     if    (AES_set_encrypt_key(key,                     keySizeInBits,            &AesKey)      !=   0)

71             FAIL(FATAL_ERROR_INTERNAL);

72

73     //    XOR     the     data    block      into   the     IV,   encrypt      the     IV   into    the    IV

74     //    and     then    copy        the  IV  to   the     output

75     for(;      dSize      >   0;      dSize    -=  16)

76     {

    Page 400                                                    TCG Published                                                   Family "2.0"

    October 30, 2014                                  Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                           Trusted Platform Module Library

77               pIv    =   iv;

78               for(i      =  16;     i   >  0;      i--)

79                      *pIv++         ^=  *dIn++;

80               AES_encrypt(iv,              iv,     &AesKey);

81               pIv    =   iv;

82               for(i      =  16;     i   >  0;      i--)

83                      *dOut++        =   *pIv++;

84         }

85         return       CRYPT_SUCCESS;

86   }

     B.11.4.2.    _cpri__AESDecryptCBC()

     This function performs AES decryption in CBC chain mode. The input dIn buffer is decrypted into dOut.

     The input iv buffer is required to have a size equal to the block size (16 bytes). The dInSize is required                                to

     be a multiple of the block size.

     Return Value                                 Meaning

     CRYPT_SUCCESS                                if success

     CRYPT_PARAMETER                              dInSize is not a multiple of the block size

87   LIB_EXPORT         CRYPT_RESULT

88   _cpri__AESDecryptCBC(

89         BYTE                        *dOut,                      //   OUT:   the      decrypted       data

90         UINT32                          keySizeInBits,          //   IN:    key   size     in   bit

91         BYTE                        *key,                       //   IN:    key   buffer.       The     size  of  this      buffer    in

92                                                                 //          bytes     is   (keySizeInBits         +    7)   /  8

93         BYTE                        *iv,                        //   IN/OUT:      IV  for      decryption.        The  size       of  this

94                                                                 //          buffer    is    16     byte

95         UINT32                          dInSize,                //   IN:    data     size

96         BYTE                        *dIn                        //   IN:    data     buffer

97         )

98   {

99         AES_KEY                 AesKey;

100        BYTE                *pIv;

101        int                     i;

102        BYTE                    tmp[16];

103        BYTE                *pT     =   NULL;

104        INT32                   dSize;

105

106        pAssert(dOut            !=  NULL       &&  key    !=   NULL     &&  iv   !=   NULL     &&   dIn   !=  NULL);

107

108        if(dInSize          ==  0)

109              return        CRYPT_SUCCESS;

110

111        pAssert(dInSize             <=     INT32_MAX);

112        dSize     =  (INT32)dInSize;

113

114        //   For     CBC,   the     data       size    must    be   an  even     multiple       of   the

115        //   cipher      block      size

116        if((dSize        %  16)     !=     0)

117              return        CRYPT_PARAMETER;

118

119        //   Create      AES    key     schedule

120        if   (AES_set_decrypt_key(key,                      keySizeInBits,           &AesKey)       !=   0)

121              FAIL(FATAL_ERROR_INTERNAL);

122

123        //   Copy    the    input       data       to  a  temp     buffer,      decrypt     the     buffer    into     the     output;

124        //   XOR     in  the    IV,     and    copy       the  temp     buffer    to  the      IV   and   repeat.

125        for(;     dSize     >   0;      dSize      -=  16)

126        {

     Family "2.0"                                                  TCG Published                                                         Page 401

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                                         Part 4: Supporting Routines

127              pT     =     tmp;

128              for(i         =  16;        i>    0;    i--)

129                        *pT++       =     *dIn++;

130              AES_decrypt(tmp,                      dOut,       &AesKey);

131              pIv       =   iv;

132              pT     =     tmp;

133              for(i         =  16;        i>    0;    i--)

134              {

135                        *dOut++           ^=    *pIv;

136                        *pIv++         =     *pT++;

137              }

138        }

139        return       CRYPT_SUCCESS;

140  }

     B.11.4.3.      _cpri__AESEncryptCFB()

     This  function        performs          AES       encryption          in  CFB      chain       mode.      The   dOut    buffer  receives  the   values

     encrypted dIn. The input iv is assumed to be the size of an encryption block (16 bytes). The iv buffer will

     be modified to contain the last encrypted block.

     Return Value                                        Meaning

     CRYPT_SUCCESS                                       no non-fatal errors

141  LIB_EXPORT         CRYPT_RESULT

142  _cpri__AESEncryptCFB(

143        BYTE                              *dOut,                        //      OUT:    the      encrypted

144        UINT32                               keySizeInBits,             //      IN:     key   size      in   bit

145        BYTE                              *key,                         //      IN:     key   buffer.        The    size  of   this   buffer  in

146                                                                        //              bytes       is  (keySizeInBits         +  7)  /  8

147        BYTE                              *iv,                          //      IN/OUT:       IV    for     decryption.

148        UINT32                               dInSize,                   //      IN:     data     size

149        BYTE                              *dIn                          //      IN:     data     buffer

150        )

151  {

152        BYTE                   *pIv          =  NULL;

153        AES_KEY                    AesKey;

154        INT32                      dSize;                        //     Need    a    signed         version     of    dInSize

155        int                        i;

156

157        pAssert(dOut               !=     NULL      &&  key      !=     NULL    &&      iv   !=     NULL    &&  dIn   !=  NULL);

158

159        if(dInSize             ==   0)

160              return           CRYPT_SUCCESS;

161

162        pAssert(dInSize                   <=    INT32_MAX);

163        dSize     =     (INT32)dInSize;

164

165        //   Create         AES     encryption              key   schedule

166        if   (AES_set_encrypt_key(key,                            keySizeInBits,                 &AesKey)       !=    0)

167              FAIL(FATAL_ERROR_INTERNAL);

168

169        //   Encrypt           the     IV       into    the     IV,     XOR     in   the     data,      and     copy  to  output

170        for(;     dSize        >    0;       dSize      -=   16)

171        {

172              //     Encrypt           the      current         value       of  the     IV

173              AES_encrypt(iv,                   iv,     &AesKey);

174              pIv       =   iv;

175              for(i         =  (int)(dSize              <    16)     ?  dSize        :  16;      i  >   0;   i--)

176                        //     XOR     the      data    into      the       IV  to      create      the     cipher    text

177                        //     and     put      into    the      output

178                        *dOut++           =     *pIv++      ^=   *dIn++;

179        }

     Page 402                                                                  TCG Published                                                   Family "2.0"

     October 30, 2014                                           Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                           Trusted Platform Module Library

180     //      If   the       inner        loop       (i   loop)         was     smaller         than     16,     then    dSize    would  have   been

181     //      smaller           than      16    and      it     is   now     negative.           If     it   is     negative,     then   it  indicates

182     //      how     many         bytes        are  needed          to   pad      out      the     IV   for     the    next  round.

183     for(;        dSize           <  0;     dSize++)

184             *pIv++            =     0;

185     return          CRYPT_SUCCESS;

186  }

     B.11.4.4.      _cpri__AESDecryptCFB()

     This function performs AES decrypt in CFB chain mode. The dOut buffer receives the values decrypted

     from dIn.

     The input iv is assumed to be the size of an encryption block (16 bytes). The iv buffer will be modified to

     contain the last decoded block, padded with zeros

     Return Value                                      Meaning

     CRYPT_SUCCESS                                     no non-fatal errors

187  LIB_EXPORT         CRYPT_RESULT

188  _cpri__AESDecryptCFB(

189     BYTE                                *dOut,                          //       OUT:     the     decrypted         data

190     UINT32                                 keySizeInBits,               //       IN:   key     size       in   bit

191     BYTE                                *key,                           //       IN:   key     buffer.         The    size  of  this   buffer  in

192                                                                         //             bytes       is     (keySizeInBits        +  7)  /   8

193     BYTE                                *iv,                            //       IN/OUT:       IV     for     decryption.

194     UINT32                                 dInSize,                     //       IN:   data       size

195     BYTE                                *dIn                            //       IN:   data       buffer

196     )

197  {

198     BYTE                         *pIv      =  NULL;

199     BYTE                            tmp[16];

200     int                             i;

201     BYTE                         *pT;

202     AES_KEY                         AesKey;

203     INT32                           dSize;

204

205     pAssert(dOut                    !=  NULL       &&   key       !=   NULL      &&    iv     !=   NULL       &&  dIn  !=   NULL);

206

207     if(dInSize                ==    0)

208             return            CRYPT_SUCCESS;

209

210     pAssert(dInSize                     <=    INT32_MAX);

211     dSize        =     (INT32)dInSize;

212

213     //      Create         AES      encryption             key     schedule

214     if      (AES_set_encrypt_key(key,                              keySizeInBits,                 &AesKey)        !=   0)

215             FAIL(FATAL_ERROR_INTERNAL);

216

217     for(;        dSize           >  0;     dSize       -=     16)

218     {

219             //      Encrypt             the   IV   into       the      temp      buffer

220             AES_encrypt(iv,                      tmp,      &AesKey);

221             pT      =     tmp;

222             pIv        =   iv;

223             for(i          =     (dSize       <    16)     ?  dSize        :     16;   i   >   0;     i--)

224                        //     Copy      the      current          cipher         text     to   IV,     XOR

225                        //     with      the      temp      buffer       and      put      into     the     output

226                        *dOut++          =     *pT++     ^     (*pIv++         =  *dIn++);

227     }

228     //      If   the       inner        loop       (i   loop)         was     smaller         than     16,     then    dSize

229     //      would         have      been      smaller         than      16       and   it     is   now     negative

230     //      If   it       is     negative,         then       it      indicates           how     may     fill    bytes

     Family "2.0"                                                           TCG Published                                                          Page 403

     Level 00 Revision 01.16                                      Copyright © TCG 2006-2014                                                October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

231     //   are       needed        to     pad   out     the     IV  for   the      next     round.

232     for(;       dSize         <  0;     dSize++)

233             *pIv++         =     0;

234

235     return         CRYPT_SUCCESS;

236  }

     B.11.4.5.  _cpri__AESEncryptCTR()

     This function performs AES encryption/decryption in CTR chain mode. The dIn buffer is encrypted into

     dOut. The input iv buffer is assumed to have a size equal to the AES block size (16 bytes). The iv will be

     incremented by the number of blocks (full and partial) that were encrypted.

     Return Value                                  Meaning

     CRYPT_SUCCESS                                 no non-fatal errors

237  LIB_EXPORT        CRYPT_RESULT

238  _cpri__AESEncryptCTR(

239     BYTE                             *dOut,                       //    OUT:     the     encrypted      data

240     UINT32                              keySizeInBits,            //    IN:   key     size     in  bit

241     BYTE                             *key,                        //    IN:   key     buffer.      The      size  of   this   buffer  in

242                                                                   //          bytes       is   (keySizeInBits          +  7)  /  8

243     BYTE                             *iv,                         //    IN/OUT:       IV  for      decryption.

244     UINT32                              dInSize,                  //    IN:   data       size

245     BYTE                             *dIn                         //    IN:   data       buffer

246     )

247  {

248     BYTE                         tmp[16];

249     BYTE                      *pT;

250     AES_KEY                      AesKey;

251     int                          i;

252     INT32                        dSize;

253

254     pAssert(dOut                 !=  NULL     &&   key     !=     NULL  &&    iv     !=   NULL     &&   dIn  !=   NULL);

255

256     if(dInSize             ==    0)

257             return         CRYPT_SUCCESS;

258

259     pAssert(dInSize                  <=   INT32_MAX);

260     dSize       =     (INT32)dInSize;

261

262     //   Create         AES      encryption           schedule

263     if   (AES_set_encrypt_key(key,                            keySizeInBits,             &AesKey)       !=   0)

264             FAIL(FATAL_ERROR_INTERNAL);

265

266     for(;       dSize         >  0;     dSize     -=     16)

267     {

268             //     Encrypt           the  current        value    of    the      IV(counter)

269             AES_encrypt(iv,                   (BYTE      *)tmp,   &AesKey);

270

271             //increment              the      counter      (counter     is       big-endian        so   start     at   end)

272             for(i       =     15;    i    >=  0;   i--)

273                       if((iv[i]           +=  1)   !=    0)

274                               break;

275

276             //     XOR     the       encrypted        counter     value       with       input     and  put      into  output

277             pT     =  tmp;

278             for(i       =     (dSize      <   16)     ?  dSize    :     16;   i   >   0;  i--)

279                       *dOut++        =    *dIn++      ^  *pT++;

280     }

281     return         CRYPT_SUCCESS;

282  }

     Page 404                                                         TCG Published                                                     Family "2.0"

     October 30, 2014                                        Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                           Trusted Platform Module Library

     B.11.4.6.   _cpri__AESDecryptCTR()

     Counter mode decryption uses the same algorithm as encryption. The _cpri__AESDecryptCTR() function

     is implemented as a macro call to _cpri__AESEncryptCTR(). (skip)

283  //%  #define       _cpri__AESDecryptCTR(dOut,                         keySize,     key,     iv,   dInSize,      dIn)    \

284  //%                _cpri__AESEncryptCTR(                                                              \

285  //%                                                           ((BYTE   *)dOut),                       \

286  //%                                                           ((UINT32)keySize),                      \

287  //%                                                           ((BYTE   *)key),                        \

288  //%                                                           ((BYTE   *)iv),                         \

289  //%                                                           ((UINT32)dInSize),                      \

290  //%                                                           ((BYTE   *)dIn)                         \

291  //%                                                        )

292  //%

293  //   The   //%     is     used       by  the    prototype      extraction         program     to    cause   it  to    include       the

294  //   line  in      the       prototype        file    after    removing       the     //%.    Need    an    extra   line      with

     nothing on it so that a blank line will separate this macro from the next definition.

     B.11.4.7.   _cpri__AESEncryptECB()

     AES encryption in ECB mode. The data buffer is modified to contain the cipher text.

     Return Value                                    Meaning

     CRYPT_SUCCESS                                   no non-fatal errors

295  LIB_EXPORT         CRYPT_RESULT

296  _cpri__AESEncryptECB(

297       BYTE                            *dOut,                    //     OUT:  encrypted         data

298       UINT32                              keySizeInBits,        //     IN:   key   size    in  bit

299       BYTE                            *key,                     //     IN:   key   buffer.     The     size  of  this       buffer   in

300                                                                 //           bytes     is  (keySizeInBits        +   7)     /  8

301       UINT32                              dInSize,              //     IN:   data   size

302       BYTE                            *dIn                      //     IN:   clear     text    buffer

303       )

304  {

305       AES_KEY                     AesKey;

306       INT32                       dSize;

307

308       pAssert(dOut                !=  NULL     &&  key      !=  NULL    &&   dIn   !=  NULL);

309

310       if(dInSize              ==  0)

311             return            CRYPT_SUCCESS;

312

313       pAssert(dInSize                 <=  INT32_MAX);

314       dSize      =  (INT32)dInSize;

315

316       //    For     ECB,      the     data     size    must     be  an   even     multiple     of    the

317       //    cipher         block      size

318       if((dSize            %  16)     !=  0)

319             return            CRYPT_PARAMETER;

320       //    Create         AES    encrypting           key     schedule

321       if    (AES_set_encrypt_key(key,                          keySizeInBits,       &AesKey)       !=  0)

322             FAIL(FATAL_ERROR_INTERNAL);

323

324       for(;      dSize        >   0;      dSize    -=  16)

325       {

326             AES_encrypt(dIn,                   dOut,    &AesKey);

327             dIn     =      &dIn[16];

328             dOut        =     &dOut[16];

329       }

     Family "2.0"                                                   TCG Published                                                        Page 405

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                         Part 4: Supporting Routines

330     return        CRYPT_SUCCESS;

331  }

     B.11.4.8.   _cpri__AESDecryptECB()

     This function performs AES decryption using ECB (not recommended). The cipher text dIn is                                  decrypted

     into dOut.

     Return Value                               Meaning

     CRYPT_SUCCESS                              no non-fatal errors

332  LIB_EXPORT       CRYPT_RESULT

333  _cpri__AESDecryptECB(

334     BYTE                            *dOut,                   //    OUT:  the    clear      text    data

335     UINT32                          keySizeInBits,           //    IN:   key   size    in  bit

336     BYTE                            *key,                    //    IN:   key   buffer.     The     size  of  this   buffer  in

337                                                              //          bytes     is  (keySizeInBits        +  7)  /  8

338     UINT32                          dInSize,                 //    IN:   data   size

339     BYTE                            *dIn                     //    IN:   cipher    text    buffer

340     )

341  {

342     AES_KEY                     AesKey;

343     INT32                       dSize;

344

345     pAssert(dOut                !=  NULL    &&  key      !=  NULL    &&  dIn   !=  NULL);

346

347     if(dInSize              ==  0)

348              return         CRYPT_SUCCESS;

349

350     pAssert(dInSize                 <=  INT32_MAX);

351     dSize    =     (INT32)dInSize;

352

353     //  For       ECB,      the     data    size    must     be  an  even     multiple     of    the

354     //  cipher           block      size

355     if((dSize            %  16)     !=  0)

356              return         CRYPT_PARAMETER;

357

358     //  Create           AES    decryption          key  schedule

359     if  (AES_set_decrypt_key(key,                        keySizeInBits,         &AesKey)       !=  0)

360              FAIL(FATAL_ERROR_INTERNAL);

361

362     for(;    dSize          >   0;  dSize       -=  16)

363     {

364              AES_decrypt(dIn,               dOut,    &AesKey);

365              dIn   =     &dIn[16];

366              dOut     =     &dOut[16];

367     }

368     return        CRYPT_SUCCESS;

369  }

     B.11.4.9.   _cpri__AESEncryptOFB()

     This function performs AES encryption/decryption in OFB chain mode. The dIn buffer is modified to

     contain the encrypted/decrypted text.

     The input iv buffer is assumed to have a size equal to the block size (16 bytes). The returned value of iv

     will be the nth encryption of the IV, where n is the number of blocks (full or partial) in the data stream.

     Page 406                                                    TCG Published                                                Family "2.0"

     October 30, 2014                                   Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                Trusted Platform Module Library

     Return Value                                 Meaning

     CRYPT_SUCCESS                                no non-fatal errors

370  LIB_EXPORT        CRYPT_RESULT

371  _cpri__AESEncryptOFB(

372       BYTE                          *dOut,                       //  OUT:     the     encrypted/decrypted                data

373       UINT32                           keySizeInBits,            //  IN:   key     size       in   bit

374       BYTE                          *key,                        //  IN:   key     buffer.         The    size  of    this     buffer    in

375                                                                  //        bytes       is     (keySizeInBits          +    7)  /  8

376       BYTE                          *iv,                         //  IN/OUT:       IV     for     decryption.         The  size      of  this

377                                                                  //        buffer         is   16     byte

378       UINT32                           dInSize,                  //  IN:   data       size

379       BYTE                          *dIn                         //  IN:   data       buffer

380       )

381  {

382       BYTE                 *pIv;

383       AES_KEY                  AesKey;

384       INT32                    dSize;

385       int                      i;

386

387       pAssert(dOut             !=   NULL    &&   key      !=   NULL   &&   iv     !=   NULL       &&  dIn   !=  NULL);

388

389       if(dInSize           ==   0)

390             return         CRYPT_SUCCESS;

391

392       pAssert(dInSize               <=  INT32_MAX);

393       dSize     =  (INT32)dInSize;

394

395       //   Create       AES     key     schedule

396       if   (AES_set_encrypt_key(key,                         keySizeInBits,           &AesKey)        !=    0)

397             FAIL(FATAL_ERROR_INTERNAL);

398

399       //   This    is      written      so    that        dIn  and   dOut     may     be   the     same

400

401       for(;     dSize      >    0;     dSize    -=     16)

402       {

403             //     Encrypt         the  current           value  of   the     "IV"

404             AES_encrypt(iv,                iv,   &AesKey);

405

406             //     XOR     the     encrypted        IV    into   dIn  to      create       the     cipher       text  (dOut)

407             pIv    =    iv;

408             for(i       =  (dSize       <   16)     ?     dSize  :   16;   i   >   0;     i--)

409                    *dOut++          =   (*pIv++        ^  *dIn++);

410       }

411       return       CRYPT_SUCCESS;

412  }

     B.11.4.10._cpri__AESDecryptOFB()

     OFB encryption and decryption use the same algorithms for both. The _cpri__AESDecryptOFB()                                              function

     is implemented as a macro call to _cpri__AESEncrytOFB(). (skip)

413  //%#define        _cpri__AESDecryptOFB(dOut,keySizeInBits,                                   key,    iv,   dInSize,       dIn)      \

414  //%               _cpri__AESEncryptOFB                   (                                                     \

415  //%                                                         ((BYTE   *)dOut),                                  \

416  //%                                                         ((UINT32)keySizeInBits),                           \

417  //%                                                         ((BYTE   *)key),                                   \

418  //%                                                         ((BYTE   *)iv),                                    \

419  //%                                                         ((UINT32)dInSize),                                 \

420  //%                                                         ((BYTE   *)dIn)                                    \

421  //%                                                      )

422  //%

     Family "2.0"                                                    TCG Published                                                           Page 407

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                               October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

423  #ifdef     TPM_ALG_SM4                    //%

     B.11.5.  SM4     Encryption

     B.11.5.1.  _cpri__SM4EncryptCBC()

     This function performs SM4 encryption in CBC chain mode. The input dIn buffer is encrypted into dOut.

     The input iv buffer is required to have a size equal to the block size (16 bytes). The dInSize is required to

     be a multiple of the block size.

     Return Value                                  Meaning

     CRYPT_SUCCESS                                 if success

     CRYPT_PARAMETER                               dInSize is not a multiple of the block size

424  LIB_EXPORT       CRYPT_RESULT

425  _cpri__SM4EncryptCBC(

426     BYTE                          *dOut,                    //    OUT:

427     UINT32                            keySizeInBits,        //    IN:    key   size     in  bit

428     BYTE                          *key,                     //    IN:    key   buffer.      The     size   of  this    buffer  in

429                                                             //           bytes     is   (keySizeInBits         +   7)  /  8

430     BYTE                          *iv,                      //    IN/OUT:      IV   for     decryption.

431     UINT32                            dInSize,              //    IN:    data     size     (is  required       to  be  a  multiple

432                                                             //           of   16   bytes)

433     BYTE                          *dIn                      //    IN:    data     buffer

434     )

435  {

436     SM4_KEY                   Sm4Key;

437     BYTE                  *pIv;

438     INT32                     dSize;                   //   Need     a   signed    version

439     int                       i;

440

441     pAssert(dOut              !=  NULL       &&  key   !=   NULL     &&  iv   !=   NULL     &&  dIn    !=  NULL);

442

443     if(dInSize            ==  0)

444             return        CRYPT_SUCCESS;

445

446     pAssert(dInSize               <=     INT32_MAX);

447     dSize      =  (INT32)dInSize;

448

449     //    For     CBC,    the     data       size    must   be   an     even  multiple      of    the

450     //    cipher       block      size

451     if((dSize          %  16)     !=     0)

452             return        CRYPT_PARAMETER;

453

454     //    Create       SM4    encrypt          key   schedule

455     if    (SM4_set_encrypt_key(key,                       keySizeInBits,          &Sm4Key)      !=   0)

456             FAIL(FATAL_ERROR_INTERNAL);

457

458     //    XOR     the     data    block        into    the  IV,   encrypt      the     IV   into    the    IV

459     //    and     then    copy        the    IV  to    the  output

460     for(;      dSize      >   0;      dSize      -=  16)

461     {

462             pIv   =    iv;

463             for(i      =  16;     i   >    0;    i--)

464                   *pIv++          ^=  *dIn++;

465             SM4_encrypt(iv,                iv,   &Sm4Key);

466             pIv   =    iv;

467             for(i      =  16;     i   >    0;    i--)

468                   *dOut++         =   *pIv++;

469     }

470     return        CRYPT_SUCCESS;

     Page 408                                                   TCG Published                                                    Family "2.0"

     October 30, 2014                                    Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                           Trusted Platform Module Library

471  }

     B.11.5.2.     _cpri__SM4DecryptCBC()

     This function performs SM4 decryption in CBC chain mode. The input dIn buffer is decrypted into dOut.

     The input iv buffer is required to have a size equal to the block size (16 bytes). The dInSize is required                               to

     be a multiple of the block size.

     Return Value                                 Meaning

     CRYPT_SUCCESS                                if success

     CRYPT_PARAMETER                              dInSize is not a multiple of the block size

472  LIB_EXPORT        CRYPT_RESULT

473  _cpri__SM4DecryptCBC(

474     BYTE                            *dOut,                    //   OUT:   the      decrypted       data

475     UINT32                             keySizeInBits,         //   IN:    key   size     in   bit

476     BYTE                            *key,                     //   IN:    key   buffer.       The     size  of  this      buffer    in

477                                                               //          bytes     is   (keySizeInBits         +    7)   /  8

478     BYTE                            *iv,                      //   IN/OUT:      IV  for      decryption.        The  size       of  this

479                                                               //          buffer    is    16     byte

480     UINT32                             dInSize,               //   IN:    data     size

481     BYTE                            *dIn                      //   IN:    data     buffer

482     )

483  {

484     SM4_KEY                     Sm4Key;

485     BYTE                    *pIv;

486     int                         i;

487     BYTE                        tmp[16];

488     BYTE                    *pT     =   NULL;

489     INT32                       dSize;

490

491     pAssert(dOut                !=  NULL     &&  key    !=   NULL     &&  iv   !=   NULL     &&   dIn   !=  NULL);

492

493     if(dInSize              ==  0)

494             return          CRYPT_SUCCESS;

495

496     pAssert(dInSize                 <=  INT32_MAX);

497     dSize       =     (INT32)dInSize;

498

499     //   For       CBC,     the     data     size    must    be   an  even     multiple       of   the

500     //   cipher          block      size

501     if((dSize            %  16)     !=  0)

502             return          CRYPT_PARAMETER;

503

504     //   Create          SM4    key     schedule

505     if   (SM4_set_decrypt_key(key,                        keySizeInBits,           &Sm4Key)       !=   0)

506             FAIL(FATAL_ERROR_INTERNAL);

507

508     //   Copy         the   input       data     to  a  temp     buffer,      decrypt     the     buffer    into     the     output;

509     //   XOR       in    the    IV,     and   copy      the  temp     buffer    to  the      IV   and   repeat.

510     for(;       dSize       >   0;     dSize     -=  16)

511     {

512             pT     =     tmp;

513             for(i        =  16;     i>  0;    i--)

514                       *pT++     =   *dIn++;

515             SM4_decrypt(tmp,                 dOut,      &Sm4Key);

516             pIv       =  iv;

517             pT     =     tmp;

518             for(i        =  16;     i>  0;    i--)

519             {

520                       *dOut++       ^=  *pIv;

     Family "2.0"                                                 TCG Published                                                         Page 409

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                                   Part 4: Supporting Routines

521                     *pIv++         =     *pT++;

522              }

523        }

524        return       CRYPT_SUCCESS;

525  }

     B.11.5.3.      _cpri__SM4EncryptCFB()

     This  function     performs          SM4    encryption          in  CFB      chain       mode.      The   dOut    buffer  receives  the   values

     encrypted dIn. The input iv is assumed to be the size of an encryption block (16 bytes). The iv buffer will

     be modified to contain the last encrypted block.

     Return Value                                   Meaning

     CRYPT_SUCCESS                                  no non-fatal errors

526  LIB_EXPORT         CRYPT_RESULT

527  _cpri__SM4EncryptCFB(

528        BYTE                           *dOut,                     //      OUT:    the      encrypted

529        UINT32                            keySizeInBits,          //      IN:     key   size      in   bit

530        BYTE                           *key,                      //      IN:     key   buffer.        The    size  of   this   buffer  in

531                                                                  //              bytes       is  (keySizeInBits         +  7)  /  8

532        BYTE                           *iv,                       //      IN/OUT:       IV    for     decryption.

533        UINT32                            dInSize,                //      IN:     data     size

534        BYTE                           *dIn                       //      IN:     data     buffer

535        )

536  {

537        BYTE                *pIv;

538        SM4_KEY                 Sm4Key;

539        INT32                   dSize;                     //     Need    a    signed         version     of    dInSize

540        int                     i;

541

542        pAssert(dOut            !=     NULL   &&   key     !=     NULL    &&      iv   !=     NULL    &&  dIn   !=  NULL);

543

544        if(dInSize          ==   0)

545              return        CRYPT_SUCCESS;

546

547        pAssert(dInSize                <=  INT32_MAX);

548        dSize     =  (INT32)dInSize;

549

550        //   Create      SM4     encryption           key   schedule

551        if   (SM4_set_encrypt_key(key,                      keySizeInBits,                 &Sm4Key)       !=    0)

552              FAIL(FATAL_ERROR_INTERNAL);

553

554        //   Encrypt        the     IV     into   the     IV,     XOR     in   the     data,      and     copy  to  output

555        for(;     dSize     >    0;       dSize   -=   16)

556        {

557              //     Encrypt        the    current        value       of  the     IV

558              SM4_encrypt(iv,                iv,   &Sm4Key);

559              pIv    =   iv;

560              for(i      =  (int)(dSize            <   16)     ?  dSize        :  16;      i  >   0;   i--)

561                     //     XOR     the    data    into     the       IV  to      create      the     cipher    text

562                     //     and     put    into    the     output

563                     *dOut++           =   *pIv++     ^=   *dIn++;

564        }

565        return       CRYPT_SUCCESS;

566  }

     B.11.5.4.      _cpri__SM4DecryptCFB()

     This function performs SM4 decrypt in CFB chain mode. The dOut buffer receives the values decrypted

     from dIn.

     Page 410                                                            TCG Published                                                   Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                  Trusted Platform Module Library

     The input iv is assumed to be the size of an encryption block (16 bytes). The iv buffer                                      will be modified  to

     contain the last decoded block, padded with zeros

     Return Value                                  Meaning

     CRYPT_SUCCESS                                 no non-fatal errors

567  LIB_EXPORT        CRYPT_RESULT

568  _cpri__SM4DecryptCFB(

569     BYTE                             *dOut,                       //      OUT:     the     decrypted      data

570     UINT32                              keySizeInBits,            //      IN:   key     size     in  bit

571     BYTE                             *key,                        //      IN:   key     buffer.      The     size  of  this   buffer  in

572                                                                   //            bytes       is   (keySizeInBits        +  7)  /  8

573     BYTE                             *iv,                         //      IN/OUT:       IV   for     decryption.

574     UINT32                              dInSize,                  //      IN:   data       size

575     BYTE                             *dIn                         //      IN:   data       buffer

576     )

577  {

578     BYTE                     *pIv;

579     BYTE                         tmp[16];

580     int                          i;

581     BYTE                     *pT;

582     SM4_KEY                      Sm4Key;

583     INT32                        dSize;

584

585     pAssert(dOut                 !=  NULL     &&   key     !=     NULL    &&    iv     !=   NULL     &&  dIn  !=   NULL);

586

587     if(dInSize               ==  0)

588             return           CRYPT_SUCCESS;

589

590     pAssert(dInSize                  <=   INT32_MAX);

591     dSize       =     (INT32)dInSize;

592

593     //   Create           SM4    encryption           key     schedule

594     if   (SM4_set_encrypt_key(key,                            keySizeInBits,               &Sm4Key)      !=   0)

595             FAIL(FATAL_ERROR_INTERNAL);

596

597     for(;       dSize        >   0;     dSize     -=     16)

598     {

599             //     Encrypt           the  IV   into      the      temp    buffer

600             SM4_encrypt(iv,                  tmp,     &Sm4Key);

601             pT     =     tmp;

602             pIv       =   iv;

603             for(i         =  (dSize       <   16)     ?  dSize      :     16;   i   >   0;   i--)

604                       //     Copy    the     current       cipher         text     to   IV,     XOR

605                       //     with    the     temp     buffer      and     put      into     the   output

606                       *dOut++        =    *pT++    ^     (*pIv++       =  *dIn++);

607     }

608     //   If     the       inner      loop     (i   loop)       was     smaller         than     16,  then     dSize

609     //   would           have    been     smaller        than     16      and   it     is   now   negative

610     //   If     it       is  negative,         then      it    indicates           how     may   fill    bytes

611     //   are       needed        to     pad   out     the     IV  for     the      next     round.

612     for(;       dSize        <   0;     dSize++)

613             *iv++         =  0;

614

615     return         CRYPT_SUCCESS;

616  }

     B.11.5.5.   _cpri__SM4EncryptCTR()

     This function performs SM4 encryption/decryption in CTR chain mode. The dIn buffer is encrypted into

     dOut. The input iv buffer is assumed to have a size equal to the SM4 block size (16 bytes). The iv will be

     incremented by the number of blocks (full and partial) that were encrypted.

     Family "2.0"                                                     TCG Published                                                       Page 411

     Level 00 Revision 01.16                                 Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

     Return Value                                    Meaning

     CRYPT_SUCCESS                                   no non-fatal errors

617  LIB_EXPORT        CRYPT_RESULT

618  _cpri__SM4EncryptCTR(

619       BYTE                            *dOut,                      //  OUT:     the     encrypted      data

620       UINT32                             keySizeInBits,           //  IN:   key     size     in  bit

621       BYTE                            *key,                       //  IN:   key     buffer.      The      size    of  this      buffer  in

622                                                                   //        bytes       is   (keySizeInBits           +  7)     /  8

623       BYTE                            *iv,                        //  IN/OUT:       IV  for      decryption.

624       UINT32                             dInSize,                 //  IN:   data       size

625       BYTE                            *dIn                        //  IN:   data       buffer

626       )

627  {

628       BYTE                     tmp[16];

629       BYTE                 *pT;

630       SM4_KEY                  Sm4Key;

631       int                      i;

632       INT32                    dSize;

633

634       pAssert(dOut             !=     NULL      &&   key  !=  NULL    &&    iv     !=   NULL     &&   dIn     !=  NULL);

635

636       if(dInSize           ==   0)

637             return         CRYPT_SUCCESS;

638

639       pAssert(dInSize                 <=    INT32_MAX);

640       dSize     =     (INT32)dInSize;

641

642       //   Create       SM4     encryption             schedule

643       if   (SM4_set_encrypt_key(key,                          keySizeInBits,           &Sm4Key)       !=   0)

644             FAIL(FATAL_ERROR_INTERNAL);

645

646       for(;     dSize      >    0;       dSize--)

647       {

648             //     Encrypt         the      current       value   of  the      IV(counter)

649             SM4_encrypt(iv,                     (BYTE     *)tmp,  &Sm4Key);

650

651             //increment               the       counter

652             for(i       =  0;      i     <  16;     i++)

653                       if((iv[i]             +=  1)   !=   0)

654                            break;

655

656             //     XOR     the     encrypted           counter    value     with       input     and  put      into   output

657             pT     =  tmp;

658             for(i       =  (dSize           <   16)    ?  dSize   :   16;   i   >   0;  i--)

659                       *dOut++         =     *dIn++     ^  *pT++;

660       }

661       return       CRYPT_SUCCESS;

662  }

     B.11.5.6.   _cpri__SM4DecryptCTR()

     Counter mode decryption uses the same algorithm as encryption. The _cpri__SM4DecryptCTR()                                              function

     is implemented as a macro call to _cpri__SM4EncryptCTR(). (skip)

663  //%  #define         _cpri__SM4DecryptCTR(dOut,                      keySize,         key,   iv,     dInSize,        dIn)   \

664  //%                  _cpri__SM4EncryptCTR(                                                                \

665  //%                                                          ((BYTE  *)dOut),                             \

666  //%                                                          ((UINT32)keySize),                           \

667  //%                                                          ((BYTE  *)key),                              \

668  //%                                                          ((BYTE  *)iv),                               \

669  //%                                                          ((UINT32)dInSize),                           \

     Page 412                                                         TCG Published                                                       Family "2.0"

     October 30, 2014                                         Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                           Trusted Platform Module Library

670  //%                                                           ((BYTE   *)dIn)                         \

671  //%                                                        )

672  //%

673  //   The   //%     is     used       by  the    prototype      extraction         program     to    cause   it  to  include      the

674  //   line   in     the       prototype        file    after    removing       the     //%.    Need    an    extra   line   with

     nothing on it so that a blank line will separate this macro from the next definition.

     B.11.5.7.   _cpri__SM4EncryptECB()

     SM4 encryption in ECB mode. The data buffer is modified to contain the cipher text.

     Return Value                                    Meaning

     CRYPT_SUCCESS                                   no non-fatal errors

675  LIB_EXPORT         CRYPT_RESULT

676  _cpri__SM4EncryptECB(

677       BYTE                            *dOut,                    //     OUT:  encrypted         data

678       UINT32                              keySizeInBits,        //     IN:   key   size    in  bit

679       BYTE                            *key,                     //     IN:   key   buffer.     The     size  of  this    buffer   in

680                                                                 //           bytes     is  (keySizeInBits        +   7)  /  8

681       UINT32                              dInSize,              //     IN:   data   size

682       BYTE                            *dIn                      //     IN:   clear     text    buffer

683       )

684  {

685       SM4_KEY                     Sm4Key;

686       INT32                       dSize;

687

688       pAssert(dOut                !=  NULL     &&  key      !=  NULL    &&   dIn   !=  NULL);

689

690       if(dInSize              ==  0)

691              return           CRYPT_SUCCESS;

692

693       pAssert(dInSize                 <=  INT32_MAX);

694       dSize      =  (INT32)dInSize;

695

696       //    For     ECB,      the     data     size    must     be  an   even     multiple     of    the

697       //    cipher         block      size

698       if((dSize            %  16)     !=  0)

699              return           CRYPT_PARAMETER;

700       //    Create         SM4    encrypting           key     schedule

701       if    (SM4_set_encrypt_key(key,                          keySizeInBits,       &Sm4Key)       !=  0)

702              FAIL(FATAL_ERROR_INTERNAL);

703

704       for(;      dSize        >   0;      dSize    -=  16)

705       {

706              SM4_encrypt(dIn,                  dOut,    &Sm4Key);

707              dIn    =      &dIn[16];

708              dOut       =     &dOut[16];

709       }

710       return        CRYPT_SUCCESS;

711  }

     B.11.5.8.   _cpri__SM4DecryptECB()

     This function performs SM4 decryption using ECB (not recommended). The cipher text dIn is decrypted

     into dOut.

     Family "2.0"                                                   TCG Published                                                     Page 413

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                         Part 4: Supporting Routines

     Return Value                              Meaning

     CRYPT_SUCCESS                             no non-fatal errors

712  LIB_EXPORT      CRYPT_RESULT

713  _cpri__SM4DecryptECB(

714     BYTE                           *dOut,                   //    OUT:  the    clear      text     data

715     UINT32                         keySizeInBits,           //    IN:   key   size    in   bit

716     BYTE                           *key,                    //    IN:   key   buffer.      The     size  of  this     buffer    in

717                                                             //          bytes     is  (keySizeInBits         +    7)  /  8

718     UINT32                         dInSize,                 //    IN:   data   size

719     BYTE                           *dIn                     //    IN:   cipher    text     buffer

720     )

721  {

722     SM4_KEY                    Sm4Key;

723     INT32                      dSize;

724

725     pAssert(dOut               !=  NULL    &&  key      !=  NULL    &&  dIn   !=  NULL);

726

727     if(dInSize             ==  0)

728             return         CRYPT_SUCCESS;

729

730     pAssert(dInSize                <=  INT32_MAX);

731     dSize    =    (INT32)dInSize;

732

733     //  For      ECB,      the     data    size    must     be  an  even     multiple      of   the

734     //  cipher          block      size

735     if((dSize           %  16)     !=  0)

736             return         CRYPT_PARAMETER;

737

738     //  Create          SM4    decryption          key  schedule

739     if  (SM4_set_decrypt_key(key,                       keySizeInBits,         &Sm4Key)        !=  0)

740             FAIL(FATAL_ERROR_INTERNAL);

741

742     for(;    dSize         >   0;  dSize       -=  16)

743     {

744             SM4_decrypt(dIn,               dOut,    &Sm4Key);

745             dIn   =     &dIn[16];

746             dOut     =     &dOut[16];

747     }

748     return       CRYPT_SUCCESS;

749  }

     B.11.5.9.  _cpri__SM4EncryptOFB()

     This function performs SM4 encryption/decryption in OFB chain mode. The dIn buffer is modified to

     contain the encrypted/decrypted text.

     The input iv buffer is assumed to have a size equal to the block size (16 bytes). The returned value of iv

     will be the nth encryption of the IV, where n is the number of blocks (full or partial) in the data stream.

     Return Value                              Meaning

     CRYPT_SUCCESS                             no non-fatal errors

750  LIB_EXPORT      CRYPT_RESULT

751  _cpri__SM4EncryptOFB(

752     BYTE                           *dOut,                   //    OUT:  the    encrypted/decrypted              data

753     UINT32                         keySizeInBits,           //    IN:   key   size    in   bit

754     BYTE                           *key,                    //    IN:   key   buffer.      The     size  of  this     buffer    in

755                                                             //          bytes     is  (keySizeInBits         +    7)  /  8

756     BYTE                           *iv,                     //    IN/OUT:     IV  for     decryption.        The  size      of  this

757                                                             //          buffer    is   16  byte

     Page 414                                                   TCG Published                                                   Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                             Trusted Platform  Module  Library

758        UINT32                           dInSize,                  //  IN:   data       size

759        BYTE                          *dIn                         //  IN:   data       buffer

760        )

761  {

762        BYTE                 *pIv;

763        SM4_KEY                  Sm4Key;

764        INT32                    dSize;

765        int                      i;

766

767        pAssert(dOut             !=   NULL    &&   key      !=   NULL   &&   iv     !=   NULL     &&  dIn  !=  NULL);

768

769        if(dInSize           ==   0)

770              return         CRYPT_SUCCESS;

771

772        pAssert(dInSize               <=  INT32_MAX);

773        dSize     =  (INT32)dInSize;

774

775        //   Create       SM4     key     schedule

776        if   (SM4_set_encrypt_key(key,                         keySizeInBits,           &Sm4Key)      !=   0)

777              FAIL(FATAL_ERROR_INTERNAL);

778

779        //   This    is      written      so    that        dIn  and   dOut     may     be  the   same

780

781        for(;     dSize      >    0;     dSize    -=     16)

782        {

783              //     Encrypt         the  current           value  of   the     "IV"

784              SM4_encrypt(iv,                iv,   &Sm4Key);

785

786              //     XOR     the     encrypted        IV    into   dIn  to      create      the   cipher       text  (dOut)

787              pIv    =    iv;

788              for(i       =  (dSize       <   16)     ?     dSize  :   16;   i   >   0;     i--)

789                     *dOut++          =   (*pIv++        ^  *dIn++);

790        }

791        return       CRYPT_SUCCESS;

792  }

     B.11.5.10._cpri__SM4DecryptOFB()

     OFB encryption and decryption use the same algorithms for both. The _cpri__SM4DecryptOFB()                                    function

     is implemented as a macro call to _cpri__SM4EncrytOFB(). (skip)

793  //%#define         _cpri__SM4DecryptOFB(dOut,keySizeInBits,                                 key,    iv,  dInSize,    dIn)  \

794  //%                _cpri__SM4EncryptOFB                   (                                                  \

795  //%                                                          ((BYTE   *)dOut),                               \

796  //%                                                          ((UINT32)keySizeInBits),                        \

797  //%                                                          ((BYTE   *)key),                                \

798  //%                                                          ((BYTE   *)iv),                                 \

799  //%                                                          ((UINT32)dInSize),                              \

800  //%                                                          ((BYTE   *)dIn)                                 \

801  //%                                                       )

802  //%

803  #endif             //%     TPM_ALG_SM4

     Family "2.0"                                                     TCG Published                                                Page 415

     Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                     October 30, 2014
    Trusted Platform Module Library                                                 Part 4: Supporting Routines

    B.12     RSA Files

    B.12.1.  CpriRSA.c

    B.12.1.1.    Introduction

    This file contains implementation of crypto primitives for RSA. This is a simulator of a crypto engine.

    Vendors may replace the implementation in this file with their own library functions.

    Integer format: the big integers passed in/out to the function interfaces in this library adopt the same

    format used in TPM 2.0 specification: Integer values are considered to be an array of one or more bytes.

    The byte at offset zero within the array is the most significant byte of the integer. The interface uses

    TPM2B as a big number format for numeric values passed to/from CryptUtil().

    B.12.1.2.    Includes

1   #include   "OsslCryptoEngine.h"

2   #ifdef     TPM_ALG_RSA

    B.12.1.3.    Local Functions

    B.12.1.3.1.    RsaPrivateExponent()

    This function computes the private exponent de = 1 mod (p-1)*(q-1) The inputs are the public modulus

    and one of the primes.

    The results are returned in the key->private structure. The size of that structure is expanded to hold the

    private exponent. If the computed value is smaller than the public modulus, the private exponent is de-

    normalized.

    Return Value                      Meaning

    CRYPT_SUCCESS                     private exponent computed

    CRYPT_PARAMETER                   prime is not half the size of the modulus, or the modulus is not evenly

                                      divisible by the prime, or no private exponent could be computed

                                      from the input parameters

3   static   CRYPT_RESULT

4   RsaPrivateExponent(

5         RSA_KEY           *key               //  IN:  the      key   to  augment  with   the  private

6                                              //       exponent

7         )

8   {

9         BN_CTX            *context;

10        BIGNUM            *bnD;

11        BIGNUM            *bnN;

12        BIGNUM            *bnP;

13        BIGNUM            *bnE;

14        BIGNUM            *bnPhi;

15        BIGNUM            *bnQ;

16        BIGNUM            *bnQr;

17        UINT32               fill;

18

19        CRYPT_RESULT         retVal  =  CRYPT_SUCCESS;         //    Assume  success

20

21        pAssert(key   !=  NULL  &&   key->privateKey  !=       NULL  &&  key->publicKey  !=   NULL);

22

23        context  =  BN_CTX_new();

    Page 416                                   TCG Published                                                   Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                        Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                                            Trusted Platform Module Library

24        if(context            ==     NULL)
          
25              FAIL(FATAL_ERROR_ALLOCATION);
          
26        BN_CTX_start(context);
          
27        bnE   =     BN_CTX_get(context);
          
28        bnD   =     BN_CTX_get(context);
          
29        bnN   =     BN_CTX_get(context);
          
30        bnP   =     BN_CTX_get(context);
          
31        bnPhi       =     BN_CTX_get(context);
          
32        bnQ   =     BN_CTX_get(context);
          
33        bnQr     =     BN_CTX_get(context);
          
34        
          
35        if(bnQr           ==  NULL)
          
36              FAIL(FATAL_ERROR_ALLOCATION);
          
37        
          
38        //   Assume           the    size      of    the       public        key      value     is     within         range
          
39        pAssert(key->publicKey->size                                  <=     MAX_RSA_KEY_BYTES);
          
40        
          
41        if(         BN_bin2bn(key->publicKey->buffer,                                      key->publicKey->size,                          bnN)   ==  NULL
          
42             ||     BN_bin2bn(key->privateKey->buffer,                                      key->privateKey->size,                           bnP)    ==  NULL)
          
43        
          
44              FAIL(FATAL_ERROR_INTERNAL);
          
45        
          
46        //   If     P     size     is     not     1/2    of    n      size,       then     this     is     not     a     valid        value     for  this
          
47        //   implementation.                   This      will         also       catch     the     case     were         P     is  input     as     zero.
          
48        //   This         generates         a     return       rather            than   an     assert       because            the    key    being       loaded
          
49        //   might        be     SW    generated            and       wrong.
          
50        if(BN_num_bits(bnP)                       <  BN_num_bits(bnN)/2)
          
51        {
          
52              retVal          =    CRYPT_PARAMETER;
          
53              goto        Cleanup;
          
54        }
          
55        //   Get       q  =   n/p;
          
56        if   (BN_div(bnQ,                 bnQr,      bnN,      bnP,          context)       !=     1)
          
57              FAIL(FATAL_ERROR_INTERNAL);
          
58        
          
59        //   If     there        is    a   remainder,              then      this      is   not     a   valid         n
          
60        if(BN_num_bytes(bnQr)                        !=     0  ||     BN_num_bits(bnQ)                  !=     BN_num_bits(bnP))
          
61        {
          
62              retVal          =    CRYPT_PARAMETER;                               //   problem         may     be     recoverable
          
63              goto        Cleanup;
          
64        }
          
65        //   Get       compute         Phi     =     (p  -     1)(q       -  1)   =    pq   -   p   -   q   +   1     =     n  -   p  -   q  +   1
          
66        if(         BN_copy(bnPhi,                   bnN)      ==     NULL
          
67             ||     !BN_sub(bnPhi,                   bnPhi,        bnP)
          
68             ||     !BN_sub(bnPhi,                   bnPhi,        bnQ)
          
69             ||     !BN_add_word(bnPhi,                        1))
          
70              FAIL(FATAL_ERROR_INTERNAL);
          
71        
          
72        //   Compute          the      multiplicative                 inverse
          
73        BN_set_word(bnE,                   key->exponent);
          
74        if(BN_mod_inverse(bnD,                           bnE,      bnPhi,         context)         ==   NULL)
          
75        {
          
76              //       Going       to     assume         that      the       error     is   caused         by   a     bad
          
77              //       set    of     parameters.               Specifically,               an   exponent           that        is
          
78              //       not    compatible             with      the        primes.       In     an   implementation                    that
          
79              //       has    better        visibility                to     the  error        codes,       this         might        be
          
80              //       refined         so   that         failures            in   the   library         would         return
          
81              //       a  more       informative               value.            Should     not     assume         here        that
          
82              //       the    error        codes         will      remain         unchanged.
          
83        
          
84              retVal          =    CRYPT_PARAMETER;
          
85              goto        Cleanup;
          
86        }
          
87        
          
88        fill     =     key->publicKey->size                        -  BN_num_bytes(bnD);
          
89        BN_bn2bin(bnD,                 &key->privateKey->buffer[fill]);

    Family "2.0"                                                         TCG Published                                                                 Page 417

    Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                                         October 30, 2014
     Trusted Platform Module Library                                                                     Part 4: Supporting Routines

90      memset(key->privateKey->buffer,                    0,     fill);

91

92      //  Change     the  size   of  the        private      key     so     that   it  is  known   to    contain

93      //  a  private      exponent   rather         than     a  prime.

94      key->privateKey->size          =      key->publicKey->size;

95

96   Cleanup:

97      BN_CTX_end(context);

98      BN_CTX_free(context);

99      return     retVal;

100  }

     B.12.1.3.2.   _cpri__TestKeyRSA()

     This function computes the private exponent de = 1 mod (p-1)*(q-1) The inputs are the public modulus

     and one of the primes or two primes.

     If both primes are provided, the public modulus is computed. If only one prime is provided, the second

     prime is computed. In either case, a private exponent is produced and placed in d.

     If no modular inverse exists, then CRYPT_PARAMETER is returned.

     Return Value                      Meaning

     CRYPT_SUCCESS                     private exponent (d) was generated

     CRYPT_PARAMETER                   one or more parameters are invalid

101  LIB_EXPORT    CRYPT_RESULT

102  _cpri__TestKeyRSA(

103     TPM2B                 *d,                          //     OUT:     the  address      to  receive      the  private

104                                                        //           exponent

105     UINT32                    exponent,                //     IN:   the     public   modulu

106     TPM2B                 *publicKey,                  //     IN/OUT:       an   input   if  only    one  prime  is

107                                                        //           provided.        an  output    if  both    primes   are

108                                                        //           provided

109     TPM2B                 *prime1,                     //     IN:   a     first  prime

110     TPM2B                 *prime2                      //     IN:   an    optional       second  prime

111     )

112  {

113     BN_CTX                *context;

114     BIGNUM                *bnD;

115     BIGNUM                *bnN;

116     BIGNUM                *bnP;

117     BIGNUM                *bnE;

118     BIGNUM                *bnPhi;

119     BIGNUM                *bnQ;

120     BIGNUM                *bnQr;

121     UINT32                fill;

122

123     CRYPT_RESULT          retVal       =  CRYPT_SUCCESS;                    //   Assume      success

124

125     pAssert(publicKey         !=   NULL       &&  prime1      !=    NULL);

126     //  Make   sure     that  the  sizes          are  within       range

127     pAssert(       prime1->size           <=  MAX_RSA_KEY_BYTES/2

128                &&  publicKey->size            <=  MAX_RSA_KEY_BYTES);

129     pAssert(      prime2  ==   NULL       ||  prime2->size             <  MAX_RSA_KEY_BYTES/2);

130

131     if(publicKey->size/2           !=     prime1->size)

132            return  CRYPT_PARAMETER;

133

134     context    =   BN_CTX_new();

135     if(context     ==   NULL)

136            FAIL(FATAL_ERROR_ALLOCATION);

137     BN_CTX_start(context);

     Page 418                                              TCG Published                                                 Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                                Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                      Trusted Platform Module Library

138     bnE   =     BN_CTX_get(context);                            //    public         exponent             (e)
        
139     bnD   =     BN_CTX_get(context);                            //    private         exponent               (d)
        
140     bnN   =     BN_CTX_get(context);                            //    public         modulus           (n)
        
141     bnP   =     BN_CTX_get(context);                            //    prime1         (p)
        
142     bnPhi       =  BN_CTX_get(context);                         //    (p-1)(q-1)
        
143     bnQ   =     BN_CTX_get(context);                            //    prime2         (q)
        
144     bnQr     =     BN_CTX_get(context);                         //    n     mod   p
        
145     
        
146     if(bnQr        ==    NULL)
        
147           FAIL(FATAL_ERROR_ALLOCATION);
        
148     
        
149     if(BN_bin2bn(prime1->buffer,                          prime1->size,               bnP)        ==      NULL)
        
150           FAIL(FATAL_ERROR_INTERNAL);
        
151     
        
152     //   If     prime2       is     provided,       then     compute        n
        
153     if(prime2           !=   NULL)
        
154     {
        
155           //       Two   primes         provided      so     use    them    to       compute           n
        
156           if(BN_bin2bn(prime2->buffer,                            prime2->size,                bnQ)          ==   NULL)
        
157                    FAIL(FATAL_ERROR_INTERNAL);
        
158     
        
159           //       Make     sure    that      the   sizes       of    the   primes             are     compatible
        
160           if(BN_num_bits(bnQ)                   !=    BN_num_bits(bnP))
        
161           {
        
162                    retVal        =  CRYPT_PARAMETER;
        
163                    goto      Cleanup;
        
164           }
        
165           //       Multiply         the     primes    to     get    the     public          modulus
        
166     
        
167           if(BN_mul(bnN,                 bnP,   bnQ,      context)          !=    1)
        
168                    FAIL(FATAL_ERROR_INTERNAL);
        
169     
        
170           //       if   the     space       provided      for     the       public       modulus             is   large    enough,
        
171           //       save     the     created     value
        
172           if(BN_num_bits(bnN)                   !=    (publicKey->size                   *     8))
        
173           {
        
174                    retVal        =  CRYPT_PARAMETER;
        
175                    goto      Cleanup;
        
176           }
        
177           BN_bn2bin(bnN,                 publicKey->buffer);
        
178     }
        
179     else
        
180     {
        
181           //       One   prime      provided        so    find      the     second          prime         by     division
        
182           BN_bin2bn(publicKey->buffer,                            publicKey->size,                     bnN);
        
183     
        
184           //       Get   q   =   n/p;
        
185           if(BN_div(bnQ,                 bnQr,     bnN,      bnP,     context)           !=    1)
        
186                    FAIL(FATAL_ERROR_INTERNAL);
        
187     
        
188           //       If   there       is   a  remainder,          then        this     is     not     a     valid      n
        
189           if(BN_num_bytes(bnQr)                     !=    0  ||     BN_num_bits(bnQ)                      !=     BN_num_bits(bnP))
        
190           {
        
191                    retVal        =  CRYPT_PARAMETER;                        //       problem           may       be  recoverable
        
192                    goto      Cleanup;
        
193           }
        
194     }
        
195     //   Get       compute       Phi     =  (p  -   1)(q     -    1)     =  pq    -   p     -  q    +     1   =   n  -  p  -  q  +  1
        
196     BN_copy(bnPhi,               bnN);
        
197     BN_sub(bnPhi,               bnPhi,      bnP);
        
198     BN_sub(bnPhi,               bnPhi,      bnQ);
        
199     BN_add_word(bnPhi,                   1);
        
200     //   Compute         the     multiplicative              inverse
        
201     BN_set_word(bnE,                exponent);
        
202     if(BN_mod_inverse(bnD,                      bnE,    bnPhi,        context)           ==    NULL)
        
203     {

     Family "2.0"                                                TCG Published                                                          Page 419

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                                       October 30, 2014
     Trusted Platform Module Library                                                                                 Part 4: Supporting Routines

204             //       Going       to     assume       that  the   error     is   caused       by  a    bad   set   of   parameters.

205             //       Specifically,              an   exponent    that      is   not  compatible            with   the     primes.

206             //       In     an   implementation            that  has    better       visibility         to   the  error   codes,

207             //       this       might       be  refined    so    that   failures         in  the      library     would   return

208             //       a     more  informative          value.

209             //       Do     not  assume         that  the  error       codes     will    remain       unchanged.

210             retVal          =    CRYPT_PARAMETER;

211             goto           Cleanup;

212     }

213     //     Return           the  private        exponent.

214     //     Make         sure     it     is  normalized     to    have      the   correct         size.

215     d->size             =   publicKey->size;

216     fill       =     d->size         -   BN_num_bytes(bnD);

217     BN_bn2bin(bnD,                   &d->buffer[fill]);

218     memset(d->buffer,                       0,  fill);

219  Cleanup:

220     BN_CTX_end(context);

221     BN_CTX_free(context);

222     return           retVal;

223  }

     B.12.1.3.3.         RSAEP()

     This function performs the RSAEP operation defined in PKCS#1v2.1. It is an                                       exponentiation   of  a  value

     (m) with the public exponent (e), modulo the public (n).

     Return Value                                   Meaning

     CRYPT_SUCCESS                                  encryption complete

     CRYPT_PARAMETER                                number to exponentiate is larger than the modulus

224  static     CRYPT_RESULT

225  RSAEP   (

226     UINT32                               dInOutSize,             //   OUT   size     of  the     encrypted        block

227     BYTE                                *dInOut,                 //   OUT:     the   encrypted        data

228     RSA_KEY                             *key                     //   IN:   the     key  to      use

229     )

230  {

231     UINT32                       e;

232     BYTE                         exponent[4];

233     CRYPT_RESULT                 retVal;

234

235     e   =   key->exponent;

236     if(e       ==       0)

237             e     =     RSA_DEFAULT_PUBLIC_EXPONENT;

238     UINT32_TO_BYTE_ARRAY(e,                          exponent);

239

240     //!!!         Can       put  check          for  test  of    RSA   here

241

242     retVal           =     _math__ModExp(dInOutSize,                  dInOut,       dInOutSize,         dInOut,       4,  exponent,

243                                                      key->publicKey->size,           key->publicKey->buffer);

244

245     //     Exponentiation                   result    is   stored     in-place,      thus        no   space  shortage     is  possible.

246     pAssert(retVal                   !=     CRYPT_UNDERFLOW);

247

248     return           retVal;

249  }

     B.12.1.3.4.         RSADP()

     This function performs the RSADP operation defined in PKCS#1v2.1. It is an exponentiation of a value (c)

     with the private exponent (d), modulo the public modulus (n). The decryption is in place.

     Page 420                                                        TCG Published                                                     Family "2.0"

     October 30, 2014                                     Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                         Trusted Platform Module Library

     This function also checks the size of the private key. If the size indicates                               that  only  a   prime  value  is

     present, the key is converted to being a private exponent.

     Return Value                             Meaning

     CRYPT_SUCCESS                            decryption succeeded

     CRYPT_PARAMETER                          the value to decrypt is larger than the modulus

250  static     CRYPT_RESULT

251  RSADP   (

252     UINT32                       dInOutSize,               //   IN/OUT:       size    of    decrypted       data

253     BYTE                     *dInOut,                      //   IN/OUT:       the     decrypted      data

254     RSA_KEY                  *key                          //   IN:   the     key

255     )

256  {

257     CRYPT_RESULT         retVal;

258

259     //!!!     Can   put     check     for     RSA  tested       here

260

261     //   Make     sure   that    the      pointers      are     provided      and     that      the  private      key   is  present

262     //   If   the   private      key      is   present      it   is   assumed         to  have     been  created        by

263     //   so   is   presumed      good      _cpri__PrivateExponent

264     pAssert(key         !=   NULL     &&   dInOut      !=   NULL     &&

265                   key->publicKey->size              ==     key->publicKey->size);

266

267     //   make     sure   that    the      value    to   be     decrypted      is      smaller      than  the      modulus

268     //   note:     this     check     is   redundant        as   is   also    performed         by   _math__ModExp()

269     //   which     is   optimized         for  use     in   RSA   operations

270     if(_math__uComp(key->publicKey->size,                            key->publicKey->buffer,

271                              dInOutSize,           dInOut)       <=   0)

272             return     CRYPT_PARAMETER;

273

274     //   _math__ModExp           can  return       CRYPT_PARAMTER             or   CRYPT_UNDERFLOW           but  actual

275     //   underflow       is  not      possible      because       everything          is    in  the    same   buffer.

276     retVal     =   _math__ModExp(dInOutSize,                    dInOut,       dInOutSize,          dInOut,

277                                            key->privateKey->size,                  key->privateKey->buffer,

278                                            key->publicKey->size,                  key->publicKey->buffer);

279

280     //   Exponentiation          result        is  stored       in-place,         thus    no    space    shortage       is  possible.

281     pAssert(retVal           !=  CRYPT_UNDERFLOW);

282

283     return     retVal;

284  }

     B.12.1.3.5.   OaepEncode()

     This function performs OAEP          padding. The size of the                buffer    to  receive    the  OAEP   padded   data     must

     equal the size of the modulus

     Return Value                             Meaning

     CRYPT_SUCCESS                            encode successful

     CRYPT_PARAMETER                          hashAlg is not valid

     CRYPT_FAIL                               message size is too large

285  static     CRYPT_RESULT

286  OaepEncode(

287     UINT32               paddedSize,               //   IN:     pad   value       size

288     BYTE                *padded,                   //   OUT:     the     pad  data

289     TPM_ALG_ID           hashAlg,                  //   IN:     algorithm         to  use     for    padding

290     const     char      *label,                    //   IN:     null-terminated             string     (may   be  NULL)

     Family "2.0"                                              TCG Published                                                    Page 421

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                           October 30, 2014
     Trusted Platform Module Library                                                                                          Part 4: Supporting Routines

291     UINT32                         messageSize,                    //     IN:      the    message     size

292     BYTE                          *message                         //     IN:      the    message     being      padded

293  #ifdef     TEST_RSA                                               //

294     ,    BYTE                          *testSeed                   //     IN:      optional        seed    used     for  testing.

295  #endif     //     TEST_RSA                                        //

296  )

297  {

298     UINT32                         padLen;

299     UINT32                         dbSize;

300     UINT32                         i;

301     BYTE                           mySeed[MAX_DIGEST_SIZE];

302     BYTE                          *seed      =     mySeed;

303     INT32                          hLen      =     _cpri__GetDigestSize(hashAlg);

304     BYTE                           mask[MAX_RSA_KEY_BYTES];

305     BYTE                          *pp;

306     BYTE                          *pm;

307     UINT32                         lSize        =     0;

308     CRYPT_RESULT                   retVal          =     CRYPT_SUCCESS;

309

310     pAssert(padded                     !=    NULL         &&    message         !=     NULL);

311

312     //   A   value             of     zero      is       not    allowed         because        the    KDF   can't    produce        a   result

313     //   if     the         digest           size        is     zero.

314     if(hLen           <=       0)

315             return             CRYPT_PARAMETER;

316

317     //   If     a     label           is     provided,            get     the      length      of   the    string,       including       the

318     //   terminator

319     if(label             !=       NULL)

320             lSize           =     (UINT32)strlen(label)                         +    1;

321

322     //   Basic           size         check

323     //   messageSize                   <=    k        2hLen        2

324     if(messageSize                     >     paddedSize            -   2     *  hLen      -    2)

325             return             CRYPT_FAIL;

326

327     //   Hash         L     even       if    it       is     null

328     //   Offset             into       padded            leaving       room        for    masked      seed     and  byte  of       zero

329     pp   =   &padded[hLen                    +     1];

330     retVal         =     _cpri__HashBlock(hashAlg,                                 lSize,      (BYTE     *)label,        hLen,     pp);

331

332     //   concatenate                   PS    of       k      mLen      2hLen           2

333     padLen         =     paddedSize                -     messageSize            -    (2   *    hLen)  -    2;

334     memset(&pp[hLen],                        0,       padLen);

335     pp[hLen+padLen]                       =  0x01;

336     padLen         +=       1;

337     memcpy(&pp[hLen+padLen],                                    message,        messageSize);

338

339     //   The       total           size      of       db     =  hLen      +     pad    +  mSize;

340     dbSize         =     hLen+padLen+messageSize;

341

342     //   If     testing,               then        use       the   provided            seed.       Otherwise,       use  values

343     //   from         the         RNG

344  #ifdef     TEST_RSA

345     if(testSeed                   !=   NULL)

346             seed         =     testSeed;

347     else

348  #endif     //     TEST_RSA

349             _cpri__GenerateRandom(hLen,                                      mySeed);

350

351     //   mask         =     MGF1       (seed,            nSize        hLen         1)

352     if((retVal                 =   _cpri__MGF1(dbSize,                          mask,        hashAlg,      hLen,    seed))      <   0)

353             return             retVal;          //       Don't     expect          an     error    because     hash      size   is     not  zero

354                                                 //       was    detected           in     the  call   to    _cpri__HashBlock()              above.

355

356     //   Create             the       masked          db

     Page 422                                                                    TCG Published                                                      Family "2.0"

     October 30, 2014                                               Copyright © TCG 2006-2014                                      Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                             Trusted Platform Module       Library

357        pm  =   mask;

358        for(i    =  dbSize;              i  >      0;     i--)

359               *pp++     ^=    *pm++;

360        pp  =   &padded[hLen                +      1];

361

362        //  Run     the     masked          data          through    MGF1

363        if((retVal          =  _cpri__MGF1(hLen,                     &padded[1],        hashAlg,         dbSize,    pp))  <  0)

364               return       retVal;             //     Don't    expect      zero  here  as   the     only  case     for   zero

365                                                //     was  detected        in   the   call  to   _cpri__HashBlock()             above.

366

367        //  Now     XOR     the       seed         to     create   masked       seed

368        pp  =   &padded[1];

369        pm  =   seed;

370        for(i    =  hLen;          i     >  0;        i--)

371               *pp++     ^=    *pm++;

372

373        //  Set     the     first           byte       to   zero

374        *padded     =    0x00;

375        return      CRYPT_SUCCESS;

376  }

     B.12.1.3.6.       OaepDecode()

     This function performs OAEP padding checking. The size of the buffer to receive the recovered data. If

     the padding is not valid, the dSize size is set to zero and the function returns CRYPT_NO_RESULTS.

     The dSize parameter is used as an input to indicate the size available in the buffer. If insufficient space is

     available, the size is not changed and the return code is CRYPT_FAIL.

     Return Value                                         Meaning

     CRYPT_SUCCESS                                        decode complete

     CRYPT_PARAMETER                                      the value to decode was larger than the modulus

     CRYPT_FAIL                                           the padding is wrong or the buffer to receive the results is too small

377  static    CRYPT_RESULT

378  OaepDecode(

379        UINT32                           *dataOutSize,               //     IN/OUT:    the   recovered     data     size

380        BYTE                             *dataOut,                   //     OUT:  the   recovered         data

381        TPM_ALG_ID                          hashAlg,                 //     IN:   algorithm      to  use   for    padding

382        const    char                    *label,                     //     IN:   null-terminated         string    (may     be  NULL)

383        UINT32                              paddedSize,              //     IN:   the  size  of      the  padded    data

384        BYTE                             *padded                     //     IN:   the  padded     data

385        )

386  {

387        UINT32                 dSizeSave;

388        UINT32                 i;

389        BYTE                   seedMask[MAX_DIGEST_SIZE];

390        INT32                  hLen         =      _cpri__GetDigestSize(hashAlg);

391

392        BYTE                   mask[MAX_RSA_KEY_BYTES];

393        BYTE                   *pp;

394        BYTE                   *pm;

395        UINT32                 lSize            =     0;

396        CRYPT_RESULT           retVal              =   CRYPT_SUCCESS;

397

398        //  Unknown         hash

399        pAssert(hLen           >      0     &&     dataOutSize       !=     NULL  &&   dataOut       !=   NULL  &&  padded       !=  NULL);

400

401        //  If   there         is     a     label,         get  its  size       including    the     terminating    0x00

402        if(label       !=      NULL)

403               lSize     =     (UINT32)strlen(label)                     +  1;

404

     Family "2.0"                                                       TCG Published                                                   Page 423

     Level 00 Revision 01.16                                   Copyright © TCG 2006-2014                                        October 30, 2014
     Trusted Platform Module Library                                                                                         Part 4: Supporting Routines

405     //  Set       the       return          size     to  zero         so     that     it  doesn't        have  to    be     done   on  each

406     //  failure

407     dSizeSave            =     *dataOutSize;

408     *dataOutSize               =     0;

409

410     //  Strange             size     (anything           smaller             can't    be     an    OAEP     padded   block)

411     //  Also         check        for       no   leading        0

412     if(paddedSize                 <  (unsigned)((2                 *     hLen)     +  2)     ||    *padded     !=   0)

413            return           CRYPT_FAIL;

414

415     //  Use       the       hash     size        to   determine              what     to  put      through     MGF1     in  order

416     //  to     recover            the       seedMask

417     if((retVal              =  _cpri__MGF1(hLen,                      seedMask,           hashAlg,

418                                                          paddedSize-hLen-1,                    &padded[hLen+1]))            <  0)

419            return           retVal;

420

421     //  Recover             the      seed       into     seedMask

422     pp  =   &padded[1];

423     pm  =   seedMask;

424     for(i      =     hLen;        i  >      0;   i--)

425            *pm++         ^=    *pp++;

426

427     //  Use       the       seed     to     generate            the      data    mask

428     if((retVal              =  _cpri__MGF1(paddedSize-hLen-1,                                  mask,        hashAlg,

429                                                          hLen,        seedMask))          <    0)

430            return           retVal;

431

432     //  Use       the       mask     generated           from         seed     to     recover      the      padded   data

433     pp  =   &padded[hLen+1];

434     pm  =   mask;

435     for(i      =     paddedSize-hLen-1;                      i  >     0;     i--)

436            *pm++         ^=    *pp++;

437

438     //  Make         sure      that         the   recovered              data    has      the    hash    of  the    label

439     //  Put       trial        value        in    the    seed         mask

440     if((retVal=_cpri__HashBlock(hashAlg,                                         lSize,(BYTE            *)label,     hLen,     seedMask))    <  0)

441            return           retVal;

442

443     if(memcmp(seedMask,                         mask,    hLen)           !=  0)

444            return           CRYPT_FAIL;

445

446     //  find         the       start        of   the     data

447     pm  =   &mask[hLen];

448     for(i      =     paddedSize-(2*hLen)-1;                           i   >  0;    i--)

449     {

450            if(*pm++            !=    0)

451                      break;

452     }

453     if(i    ==       0)

454            return           CRYPT_PARAMETER;

455

456     //  pm     should          be    pointing            at     the      first     part      of    the   data

457     //  and       i  is        one   greater          than      the       number      of     bytes      to   move

458     i--;

459     if(i    >     dSizeSave)

460     {

461            //     Restore            dSize

462            *dataOutSize                  =  dSizeSave;

463            return           CRYPT_FAIL;

464     }

465     memcpy(dataOut,                  pm,        i);

466     *dataOutSize               =     i;

467     return        CRYPT_SUCCESS;

468  }

     Page 424                                                                TCG Published                                                 Family "2.0"

     October 30, 2014                                        Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                       Trusted Platform Module Library

     B.12.1.3.7.   PKSC1v1_5Encode()

     This function performs the encoding for RSAES-PKCS1-V1_5-ENCRYPT as defined in PKCS#1V2.1

     Return Value                           Meaning

     CRYPT_SUCCESS                          data encoded

     CRYPT_PARAMETER                        message size is too large

469  static  CRYPT_RESULT

470  RSAES_PKSC1v1_5Encode(

471     UINT32                      paddedSize,                //   IN:   pad     value     size

472     BYTE                       *padded,                    //   OUT:   the     pad   data

473     UINT32                      messageSize,               //   IN:   the     message     size

474     BYTE                       *message                    //   IN:   the     message     being    padded

475     )

476  {

477     UINT32              ps  =   paddedSize        -    messageSize         -   3;

478     if(messageSize          >   paddedSize        -    11)

479           return       CRYPT_PARAMETER;

480

481     //   move  the      message     to    the     end  of      the   buffer

482     memcpy(&padded[paddedSize                  -  messageSize],            message,       messageSize);

483

484     //   Set   the     first    byte    to  0x00       and     the   second    to    0x02

485     *padded    =    0;

486     padded[1]       =   2;

487

488     //   Fill  with     random      bytes

489     _cpri__GenerateRandom(ps,                  &padded[2]);

490

491     //   Set   the     delimiter      for   the      random      field     to  0

492     padded[2+ps]        =   0;

493

494     //   Now,  the      only    messy     part.      Make      sure   that     all   the   ps   bytes     are   non-zero

495     //   In   this     implementation,            use  the      value     of   the   current       index

496     for(ps++;       ps  >   1;  ps--)

497     {

498           if(padded[ps]         ==    0)

499                padded[ps]        =    0x55;            //   In   the   <   0.5%     of  the    cases   that     the  random

500                                                        //   value     is   0,  just     pick    a  value    to  put  into

501                                                        //   the     spot.

502     }

503     return     CRYPT_SUCCESS;

504  }

     B.12.1.3.8.   RSAES_Decode()

     This function performs the decoding for RSAES-PKCS1-V1_5-ENCRYPT as defined                                    in PKCS#1V2.1

     Return Value                           Meaning

     CRYPT_SUCCESS                          decode successful

     CRYPT_FAIL                             decoding error or results would no fit into provided buffer

505  static  CRYPT_RESULT

506  RSAES_Decode(

507     UINT32                     *messageSize,               //   IN/OUT:       recovered       message     size

508     BYTE                       *message,                   //   OUT:   the     recovered       message

509     UINT32                      codedSize,                 //   IN:   the     encoded     message     size

510     BYTE                       *coded                      //   IN:   the     encoded     message

511     )

     Family "2.0"                                              TCG Published                                                   Page 425

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                        October 30, 2014
     Trusted Platform Module Library                                                                                         Part 4:  Supporting  Routines

512  {

513        BOOL                 fail       =     FALSE;

514        UINT32               ps;

515

516        fail    =   (codedSize             <   11);

517        fail    |=     (coded[0]           !=  0x00)          ||     (coded[1]           !=  0x02);

518        for(ps      =  2;    ps   <     codedSize;            ps++)

519        {

520              if(coded[ps]              ==     0)

521                       break;

522        }

523        ps++;

524

525        //  Make       sure  that          ps  has      not       gone      over       the   end       and   that    there    are  at  least   8

526        //  bytes      of    pad     data.

527        fail    |=     ((ps  >=      codedSize)               ||     ((ps-2)        <    8));

528        if((*messageSize                <     codedSize           -   ps)       ||  fail)

529              return       CRYPT_FAIL;

530

531        *messageSize         =    codedSize             -     ps;

532        memcpy(message,              &coded[ps],              codedSize             -    ps);

533        return      CRYPT_SUCCESS;

534  }

     B.12.1.3.9.       PssEncode()

     This  function    creates       an       encoded         block      of    data    that     is  the      size  of  modulus.  The  function    uses  the

     maximum salt size that will fit in the encoded block.

     Return Value                                     Meaning

     CRYPT_SUCCESS                                    encode successful

     CRYPT_PARAMETER                                  hashAlg is not a supported hash algorithm

535  static    CRYPT_RESULT

536  PssEncode            (

537        UINT32               eOutSize,                            //     IN:    size     of      the      encode    data  buffer

538        BYTE                 *eOut,                               //     OUT:       encoded         data     buffer

539        TPM_ALG_ID           hashAlg,                             //     IN:    hash     algorithm           to   use    for  the  encoding

540        UINT32               hashInSize,                          //     IN:    size     of      digest      to   encode

541        BYTE                 *hashIn                              //     IN:    the      digest

542  #ifdef    TEST_RSA                                              //

543        ,   BYTE                  *saltIn                         //     IN:    optional            parameter       for   testing

544  #endif    //     TEST_RSA                                       //

545  )

546  {

547        INT32                                  hLen        =  _cpri__GetDigestSize(hashAlg);

548        BYTE                                   salt[MAX_RSA_KEY_BYTES                            -     1];

549        UINT16                                 saltSize;

550        BYTE                                   *ps   =     salt;

551        CRYPT_RESULT                           retVal;

552        UINT16                                 mLen;

553        CPRI_HASH_STATE                        hashState;

554

555        //  These      are   fatal            errors       indicating               bad  TPM        firmware

556        pAssert(eOut         !=      NULL      &&    hLen         >   0     &&  hashIn       !=        NULL  );

557

558        //  Get     the    size      of       the   mask

559        mLen    =   (UINT16)(eOutSize                   -     hLen       -  1);

560

561        //  Maximum        possible            salt     size         is     mask    length          -  1

562        saltSize       =   mLen      -     1;

563

     Page 426                                                               TCG Published                                                 Family "2.0"

     October 30, 2014                                         Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                Trusted Platform Module Library

564     //    Use    the       maximum               salt     size   allowed       by   FIPS  186-4

565     if(saltSize               >     hLen)

566           saltSize               =     (UINT16)hLen;

567

568  //using  eOut       for         scratch             space

569     //    Set    the       first          8      bytes     to   zero

570     memset(eOut,                 0,       8);

571

572     //    Get    set       the         salt

573  #ifdef   TEST_RSA

574     if(saltIn           !=       NULL)

575     {

576           saltSize               =     hLen;

577           memcpy(salt,                    saltIn,          hLen);

578     }

579     else

580  #endif   //     TEST_RSA

581           _cpri__GenerateRandom(saltSize,                                    salt);

582

583     //    Create        the         hash         of  the    pad     ||  input      hash   ||  salt

584     _cpri__StartHash(hashAlg,                               FALSE,      &hashState);

585     _cpri__UpdateHash(&hashState,                                   8,  eOut);

586     _cpri__UpdateHash(&hashState,                                   hashInSize,      hashIn);

587     _cpri__UpdateHash(&hashState,                                   saltSize,       salt);

588     _cpri__CompleteHash(&hashState,                                     hLen,  &eOut[eOutSize         -  hLen    -   1]);

589

590     //    Create        a     mask

591     if((retVal             =     _cpri__MGF1(mLen,                   eOut,     hashAlg,       hLen,   &eOut[mLen]))        <  0)

592     {

593           //     Currently                _cpri__MGF1            is     not  expected     to    return   a   CRYPT_RESULT         error.

594           pAssert(0);

595     }

596     //    Since      this           implementation               uses     key  sizes      that   are  all    even    multiples        of

597     //    8,     just      need           to     make     sure   that     the  most      significant     bit     is  CLEAR

598     eOut[0]         &=     0x7f;

599

600     //    Before        we       mess         up     the   eOut     value,     set  the   last   byte    to   0xbc

601     eOut[eOutSize                   -     1]     =   0xbc;

602

603     //    XOR    a   byte           of    0x01       at    the   position      just      before  where      the  salt  will       be  XOR'ed

604     eOut      =  &eOut[mLen                   -     saltSize     -   1];

605     *eOut++         ^=     0x01;

606

607     //    XOR    the       salt           data       into   the     buffer

608     for(;        saltSize              >  0;        saltSize--)

609           *eOut++             ^=       *ps++;

610

611     //    and    we     are         done

612     return       CRYPT_SUCCESS;

613  }

     B.12.1.3.10. PssDecode()

     This function checks that the PSS encoded block was built from the provided digest. If the check is

     successful, CRYPT_SUCCESS is returned. Any other value indicates an error.

     This implementation of PSS decoding is intended for the reference TPM implementation and is not at all

     generalized.    It is used to check signatures over hashes and assumptions are made about the sizes of

     values. Those assumptions are enforce by this implementation. This implementation does allow for a

     variable size salt value to have been used by the creator of the signature.

     Family "2.0"                                                           TCG Published                                                     Page 427

     Level 00 Revision 01.16                                    Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                                         Part 4: Supporting Routines

     Return Value                                         Meaning

     CRYPT_SUCCESS                                        decode successful

     CRYPT_SCHEME                                         hashAlg is not a supported hash algorithm

     CRYPT_FAIL                                           decode operation failed

614  static  CRYPT_RESULT

615  PssDecode(

616     TPM_ALG_ID                           hashAlg,                         //     IN:   hash  algorithm         to   use     for   the    encoding

617     UINT32                               dInSize,                         //     IN:   size  of   the     digest    to      compare

618     BYTE                              *dIn,                               //     In:   the   digest       to  compare

619     UINT32                               eInSize,                         //     IN:   size  of   the     encoded        data

620     BYTE                              *eIn,                               //     IN:   the   encoded      data

621     UINT32                               saltSize                         //     IN:   the   expected         size  of      the   salt

622     )

623  {

624     INT32                                hLen         =   _cpri__GetDigestSize(hashAlg);

625     BYTE                                 mask[MAX_RSA_KEY_BYTES];

626     BYTE                              *pm       =     mask;

627     BYTE                                 pad[8]           =     {0};

628     UINT32                               i;

629     UINT32                               mLen;

630     BOOL                                 fail         =   FALSE;

631     CRYPT_RESULT                         retVal;

632     CPRI_HASH_STATE                      hashState;

633

634     //   These      errors            are       indicative               of   failures       due  to      programmer        error

635     pAssert(dIn             !=     NULL         &&       eIn    !=    NULL);

636

637     //   check      the      hash           scheme

638     if(hLen         ==   0)

639           return         CRYPT_SCHEME;

640

641     //   most       significant                 bit       must       be   zero

642     fail   =     ((eIn[0]             &     0x80)         !=    0);

643

644     //   last       byte     must           be     0xbc

645     fail   |=       (eIn[eInSize                   -     1]     !=   0xbc);

646

647     //   Use     the     hLen         bytes           at     the     end     of   the  buffer     to      generate       a  mask

648     //   Doesn't         start           at     the       end       which     is  a    flag  byte

649     mLen   =     eInSize           -     hLen         -   1;

650     if((retVal           =   _cpri__MGF1(mLen,                           mask,    hashAlg,        hLen,       &eIn[mLen]))        <  0)

651           return         retVal;

652     if(retVal           ==   0)

653           return         CRYPT_FAIL;

654

655     //   Clear      the      MSO         of     the       mask       to   make    it   consistent         with      the     encoding.

656     mask[0]         &=   0x7F;

657

658     //   XOR     the     data         into         the       mask     to     recover   the     salt.      This      sequence

659     //   advances           eIn       so     that         it    will      end     up   pointing       to  the   seed        data

660     //   which      is      the       hash         of     the       signature         data

661     for(i     =     mLen;       i     >     0;     i--)

662           *pm++         ^=   *eIn++;

663

664     //   Find       the     first           byte         of     0x01     after    a    string     of  all     0x00

665     for(pm       =  mask,          i     =   mLen;           i  >    0;   i--)

666     {

667           if(*pm         ==     0x01)

668                     break;

669           else

670                     fail     |=       (*pm++             !=     0);

671     }

     Page 428                                                                 TCG Published                                                  Family "2.0"

     October 30, 2014                                               Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                             Trusted Platform Module Library

672        fail      |=     (i   ==   0);

673

674        //  if     we    have      failed,      will     continue      using     the     entire    mask     as   the     salt   value  so

675        //  that         the  timing       attacks       will    not   disclose       anything         (I   don't    think     that    this

676        //  is     a     problem    for     TPM   applications          but,     usually,      we      don't    fail     so  this

677        //  doesn't           cost  anything).

678        if(fail)

679        {

680               i   =     mLen;

681               pm     =  mask;

682        }

683        else

684        {

685               pm++;

686               i--;

687        }

688        //  If     the       salt   size    was   provided,          then   the   recovered        size     must     match

689        fail      |=     (saltSize      !=   0   &&   i  !=    saltSize);

690

691        //  i     contains         the  salt     size    and     pm   points     to   the   salt.      Going     to   use    the   input

692        //  hash         and  the   seed     to   recreate        the   hash     in   the   lower      portion       of  eIn.

693        _cpri__StartHash(hashAlg,                     FALSE,      &hashState);

694

695        //  add       the     pad   of  8   zeros

696        _cpri__UpdateHash(&hashState,                        8,   pad);

697

698        //  add       the     provided      digest       value

699        _cpri__UpdateHash(&hashState,                        dInSize,       dIn);

700

701        //  and       the     salt

702        _cpri__UpdateHash(&hashState,                        i,   pm);

703

704        //  get       the     result

705        retVal        =  _cpri__CompleteHash(&hashState,                      MAX_DIGEST_SIZE,              mask);

706

707        //  retVal           will   be  the     size     of  the     digest   or     zero.     If  not      equal    to  the    indicated

708        //  digest           size,  then     the     signature        doesn't     match

709        fail      |=     (retVal    !=     hLen);

710        fail      |=     (memcmp(mask,          eIn,     hLen)    !=   0);

711        if(fail)

712               return         CRYPT_FAIL;

713        else

714               return         CRYPT_SUCCESS;

715  }

     B.12.1.3.11. PKSC1v1_5SignEncode()

     Encode a message using                PKCS1v1().5 method.

     Return Value                                  Meaning

     CRYPT_SUCCESS                                 encode complete

     CRYPT_SCHEME                                  hashAlg is not a supported hash algorithm

     CRYPT_PARAMETER                               eOutSize is not large enough or hInSize does                not  match   the   digest

                                                   size of hashAlg

716  static    CRYPT_RESULT

717  RSASSA_Encode(

718        UINT32                          eOutSize,                //   IN:   the   size     of  the     resulting         block

719        BYTE                        *eOut,                       //   OUT:   the     encoded       block

720        TPM_ALG_ID                      hashAlg,                 //   IN:   hash     algorithm         for  PKSC1v1_5

721        UINT32                          hInSize,                 //   IN:   size     of  hash      to  be   signed

722        BYTE                        *hIn                         //   IN:   hash     buffer

     Family "2.0"                                                   TCG Published                                                         Page 429

     Level 00 Revision 01.16                             Copyright © TCG 2006-2014                                              October 30, 2014
     Trusted Platform Module Library                                                                                 Part 4: Supporting Routines

723     )

724  {

725     BYTE                            *der;

726     INT32                              derSize        =     _cpri__GetHashDER(hashAlg,                 &der);

727     INT32                              fillSize;

728

729     pAssert(eOut             !=     NULL      &&   hIn      !=      NULL);

730

731     //   Can't     use       this       scheme        if    the     algorithm       doesn't      have  a    DER  string      defined.

732     if(derSize        ==      0     )

733           return      CRYPT_SCHEME;

734

735     //   If   the     digest           size    of     'hashAl'          doesn't     match   the      input  digest      size,  then

736     //   the   DER    will          misidentify             the     digest     so   return   an      error

737     if((unsigned)_cpri__GetDigestSize(hashAlg)                                       !=     hInSize)

738           return      CRYPT_PARAMETER;

739

740     fillSize       =  eOutSize             -   derSize          -   hInSize     -   3;

741

742     //   Make   sure         that       this      combination            will   fit     in  the  provided        space

743     if(fillSize           <   8)

744           return      CRYPT_PARAMETER;

745     //   Start     filling

746     *eOut++     =     0;     //     initial        byte         of  zero

747     *eOut++     =     1;     //     byte      of   0x01

748     for(;     fillSize           >     0;  fillSize--)

749           *eOut++         =   0xff;        //     bunch         of  0xff

750     *eOut++     =     0;     //     another        0

751     for(;     derSize         >     0;     derSize--)

752           *eOut++         =   *der++;              //       copy    the   DER

753     for(;     hInSize         >     0;     hInSize--)

754           *eOut++         =   *hIn++;              //       copy    the   hash

755     return     CRYPT_SUCCESS;

756  }

     B.12.1.3.12. RSASSA_Decode()

     This function performs the RSASSA decoding of a signature.

     Return Value                                  Meaning

     CRYPT_SUCCESS                                 decode successful

     CRYPT_FAIL                                    decode unsuccessful

     CRYPT_SCHEME                                  haslAlg is not supported

757  static  CRYPT_RESULT

758  RSASSA_Decode(

759     TPM_ALG_ID                         hashAlg,                     //   IN:   hash     algorithm      to   use  for    the  encoding

760     UINT32                             hInSize,                     //   IN:   size     of  the  digest     to   compare

761     BYTE                            *hIn,                           //   In:   the   digest      to  compare

762     UINT32                             eInSize,                     //   IN:   size     of  the  encoded    data

763     BYTE                            *eIn                            //   IN:   the   encoded     data

764     )

765  {

766     BOOL                               fail    =   FALSE;

767     BYTE                            *der;

768     INT32                              derSize        =     _cpri__GetHashDER(hashAlg,                 &der);

769     INT32                              hashSize          =  _cpri__GetDigestSize(hashAlg);

770     INT32                              fillSize;

771

772     pAssert(hIn           !=     NULL      &&     eIn       !=  NULL);

773

774     //   Can't     use       this       scheme        if    the     algorithm       doesn't      have  a    DER  string

     Page 430                                                           TCG Published                                              Family "2.0"

     October 30, 2014                                        Copyright © TCG 2006-2014                               Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                      Trusted Platform    Module  Library

775        //  defined     or  if    the    provided       hash       isn't     the  right     size

776        if(derSize      ==  0     ||  (unsigned)hashSize              !=     hInSize)

777              return    CRYPT_SCHEME;

778

779        //  Make    sure    that      this   combination           will   fit     in   the  provided    space

780        //  Since   no    data    movement       takes      place,       can     just  walk     though  this

781        //  and    accept   nearly       random   values.          This      can  only      be  called  from

782        //  _cpri__ValidateSignature()                  so  eInSize          is   known     to  be  in  range.

783        fillSize    =   eInSize       -  derSize     -  hashSize          -   3;

784

785        //  Start   checking

786        fail   |=   (*eIn++       !=  0);    //  initial        byte     of   zero

787        fail   |=   (*eIn++       !=  1);    //  byte   of      0x01

788        for(;    fillSize      >  0;     fillSize--)

789              fail  |=    (*eIn++        !=  0xff);     //  bunch        of   0xff

790        fail   |=   (*eIn++       !=  0);    //  another        0

791        for(;    derSize    >     0;  derSize--)

792              fail  |=    (*eIn++        !=  *der++);       //     match     the  DER

793        for(;    hInSize    >     0;  hInSize--)

794              fail  |=    (*eIn++        !=  *hIn++);       //     match     the  hash

795        if(fail)

796              return    CRYPT_FAIL;

797        return     CRYPT_SUCCESS;

798  }

     B.12.1.4.    Externally Accessible Functions

     B.12.1.4.1.      _cpri__RsaStartup()

     Function that is called to initialize the hash        service. In this implementation,                this  function  does  nothing  but

     it is called by the CryptUtilStartup() function           and must be present.

799  LIB_EXPORT       BOOL

800  _cpri__RsaStartup(

801        void

802        )

803  {

804        return     TRUE;

805  }

     B.12.1.4.2.      _cpri__EncryptRSA()

     This is the entry point for encryption using RSA. Encryption is use of the public exponent. The padding

     parameter determines what padding will be used.

     The cOutSize parameter must be at least as large as the size of the key.

     If the padding is RSA_PAD_NONE, dIn is treaded as a number. It must be lower in value than the key

     modulus.

     Family "2.0"                                              TCG Published                                                     Page 431

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                                                   Part 4: Supporting Routines

     NOTE:            If dIn has fewer bytes than cOut, then we don't add low-order zeros to dIn to make it the size of the RSA key for

                      the call to RSAEP. This is because the high order bytes of dIn might have a numeric value that is greater than

                      the value of the key modulus. If this had low-order zeros added, it would have a numeric value larger than the

                      modulus even though it started out with a lower numeric value.

     Return Value                                 Meaning

     CRYPT_SUCCESS                                encryption complete

     CRYPT_PARAMETER                              cOutSize is too small (must be the size of the modulus)

     CRYPT_SCHEME                                 padType is not a supported scheme

806  LIB_EXPORT    CRYPT_RESULT

807  _cpri__EncryptRSA(

808     UINT32                    *cOutSize,                         //  OUT:     the      size     of   the  encrypted        data

809     BYTE                      *cOut,                             //  OUT:     the      encrypted         data

810     RSA_KEY                   *key,                              //  IN:      the  key      to   use     for   encryption

811     TPM_ALG_ID                     padType,                      //  IN:      the  type      of     padding

812     UINT32                         dInSize,                      //  IN:      the  amount        of   data     to   encrypt

813     BYTE                      *dIn,                              //  IN:      the  data      to     encrypt

814     TPM_ALG_ID                     hashAlg,                      //  IN:      in   case     this     is   needed

815     const     char            *label                             //  IN:      in   case     it   is   needed

816     )

817  {

818     CRYPT_RESULT              retVal             =   CRYPT_SUCCESS;

819

820     pAssert(cOutSize               !=     NULL);

821

822     //   All   encryption          schemes              return     the  same       size     of   data

823     if(*cOutSize           <  key->publicKey->size)

824           return       CRYPT_PARAMETER;

825     *cOutSize       =     key->publicKey->size;

826

827     switch     (padType)

828     {

829     case     TPM_ALG_NULL:                //     'raw'       encryption

830           {

831                //      dIn    can      have         more     bytes   than     cOut      as   long     as  the      extra   bytes

832                //      are    zero

833                for(;          dInSize         >     *cOutSize;       dInSize--)

834                {

835                           if(*dIn++           !=     0)

836                               return             CRYPT_PARAMETER;

837

838                }

839                //      If     dIn  is     smaller            than    cOut,    fill      cOut     with     zeros

840                if(dInSize              <  *cOutSize)

841                           memset(cOut,               0,   *cOutSize        -  dInSize);

842

843                //      Copy   the         rest       of   the    value

844                memcpy(&cOut[*cOutSize-dInSize],                                   dIn,   dInSize);

845                //      If     the  size          of     dIn  is    the  same       as   cOut     dIn     could     be  larger    than

846                //      the    modulus.              If   it  is,     then     RSAEP()       will     catch     it.

847           }

848           break;

849     case     TPM_ALG_RSAES:

850           retVal       =   RSAES_PKSC1v1_5Encode(*cOutSize,                              cOut,       dInSize,       dIn);

851           break;

852     case     TPM_ALG_OAEP:

853           retVal       =   OaepEncode(*cOutSize,                     cOut,        hashAlg,       label,       dInSize,     dIn

854  #ifdef   TEST_RSA

855                                                     ,NULL

856  #endif

857                                                  );

858           break;

     Page 432                                                        TCG Published                                                    Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                   Trusted Platform Module Library

859        default:

860              return   CRYPT_SCHEME;

861        }

862        //  All   the  schemes          that  do    padding     will    come  here      for     the   encryption        step

863        //  Check   that       the     Encoding     worked

864        if(retVal      !=  CRYPT_SUCCESS)

865              return   retVal;

866

867        //  Padding    OK      so   do  the   encryption

868        return    RSAEP(*cOutSize,            cOut,     key);

869  }

     B.12.1.4.3.     _cpri__DecryptRSA()

     This is the entry point for decryption using RSA. Decryption is use of the private exponent. The                            padType

     parameter determines what padding was used.

     Return Value                              Meaning

     CRYPT_SUCCESS                             successful completion

     CRYPT_PARAMETER                           cInSize is not the same as the size of the public modulus of key; or

                                               numeric value of the encrypted data is greater than the modulus

     CRYPT_FAIL                                dOutSize is not large enough for the result

     CRYPT_SCHEME                              padType is not supported

870  LIB_EXPORT      CRYPT_RESULT

871  _cpri__DecryptRSA(

872        UINT32                     *dOutSize,             //    OUT:    the   size     of   the  decrypted         data

873        BYTE                       *dOut,                 //    OUT:    the   decrypted         data

874        RSA_KEY                    *key,                  //    IN:   the    key   to   use     for   decryption

875        TPM_ALG_ID                  padType,              //    IN:   the    type   of     padding

876        UINT32                      cInSize,              //    IN:   the    amount     of   data     to   decrypt

877        BYTE                       *cIn,                  //    IN:   the    data   to     decrypt

878        TPM_ALG_ID                  hashAlg,              //    IN:   in   case    this     is   needed    for     the   scheme

879        const    char              *label                 //    IN:   in   case    it   is   needed       for  the  scheme

880        )

881  {

882        CRYPT_RESULT               retVal;

883

884        //  Make   sure    that        the  necessary     parameters         are   provided

885        pAssert(cIn        !=     NULL  &&    dOut  !=    NULL  &&    dOutSize      !=     NULL  &&   key      !=  NULL);

886

887        //  Size   is  checked          to  make    sure  that     the    decryption        works     properly

888        if(cInSize     !=      key->publicKey->size)

889              return   CRYPT_PARAMETER;

890

891        //  For   others       that     do  padding,      do  the    decryption        in   place     and  then

892        //  go   handle    the      decoding.

893        if((retVal     =   RSADP(cInSize,           cIn,      key))   !=   CRYPT_SUCCESS)

894              return   retVal;                //    Decryption       failed

895

896        //  Remove     padding

897        switch    (padType)

898        {

899        case    TPM_ALG_NULL:

900              if(*dOutSize          <   key->publicKey->size)

901                   return         CRYPT_FAIL;

902              *dOutSize        =   key->publicKey->size;

903              memcpy(dOut,          cIn,    *dOutSize);

904              return   CRYPT_SUCCESS;

905        case    TPM_ALG_RSAES:

906              return   RSAES_Decode(dOutSize,                 dOut,     cInSize,       cIn);

     Family "2.0"                                            TCG Published                                                       Page 433

     Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                    Part 4: Supporting Routines

907           break;

908     case     TPM_ALG_OAEP:

909           return    OaepDecode(dOutSize,            dOut,      hashAlg,        label,      cInSize,     cIn);

910           break;

911     default:

912           return    CRYPT_SCHEME;

913           break;

914     }

915  }

     B.12.1.4.4.   _cpri__SignRSA()

     This function is used to generate an RSA signature of the type indicated in scheme.

     Return Value                          Meaning

     CRYPT_SUCCESS                         sign operation completed normally

     CRYPT_SCHEME                          scheme or hashAlg are not supported

     CRYPT_PARAMETER                       hInSize does not match hashAlg (for RSASSA)

916  LIB_EXPORT    CRYPT_RESULT

917  _cpri__SignRSA(

918     UINT32                 *sigOutSize,             //  OUT:     size      of  signature

919     BYTE                   *sigOut,                 //  OUT:     signature

920     RSA_KEY                *key,                    //  IN:      key   to  use

921     TPM_ALG_ID                scheme,               //  IN:      the   scheme      to   use

922     TPM_ALG_ID                hashAlg,              //  IN:      hash  algorithm           for  PKSC1v1_5

923     UINT32                    hInSize,              //  IN:      size  of      digest      to   be  signed

924     BYTE                   *hIn                     //  IN:      digest    buffer

925     )

926  {

927     CRYPT_RESULT           retVal;

928

929     //   Parameter         checks

930     pAssert(sigOutSize             !=  NULL    &&   sigOut   !=  NULL      &&  key     !=  NULL     &&  hIn  !=  NULL);

931

932     //   For   all  signatures         the    size  is  the    size    of  the     key     modulus

933     *sigOutSize         =  key->publicKey->size;

934     switch     (scheme)

935     {

936     case     TPM_ALG_NULL:

937           *sigOutSize      =  0;

938           return    CRYPT_SUCCESS;

939     case     TPM_ALG_RSAPSS:

940           //   PssEncode      can      return  CRYPT_PARAMETER

941           retVal    =      PssEncode(*sigOutSize,           sigOut,    hashAlg,         hInSize,        hIn

942  #ifdef   TEST_RSA

943                                        ,    NULL

944  #endif

945                                        );

946           break;

947     case     TPM_ALG_RSASSA:

948           //   RSASSA_Encode           can  return  CRYPT_PARAMETER            or   CRYPT_SCHEME

949           retVal    =      RSASSA_Encode(*sigOutSize,            sigOut,       hashAlg,         hInSize,     hIn);

950           break;

951     default:

952           return    CRYPT_SCHEME;

953     }

954     if(retVal       !=     CRYPT_SUCCESS)

955           return    retVal;

956     //   Do   the   encryption         using   the  private      key

957     //   RSADP     can     return  CRYPT_PARAMETR

958     return     RSADP(*sigOutSize,sigOut,                key);

     Page 434                                           TCG Published                                                   Family "2.0"

     October 30, 2014                             Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                  Trusted Platform Module Library

959  }

     B.12.1.4.5.     _cpri__ValidateSignatureRSA()

     This  function   is  used   to  validate  an   RSA        signature.  If  the   signature    is  valid   CRYPT_SUCCESS    is

     returned.   If  the  signature  is  not   valid,  CRYPT_FAIL          is  returned.     Other    return  codes  indicate  either

     parameter problems or fatal errors.

     Return Value                            Meaning

     CRYPT_SUCCESS                           the signature checks

     CRYPT_FAIL                              the signature does not check

     CRYPT_SCHEME                            unsupported scheme or hash algorithm

960  LIB_EXPORT      CRYPT_RESULT

961  _cpri__ValidateSignatureRSA(

962        RSA_KEY               *key,                     //  IN:   key   to      use

963        TPM_ALG_ID                scheme,               //  IN:   the   scheme       to   use

964        TPM_ALG_ID                hashAlg,              //  IN:   hash      algorithm

965        UINT32                    hInSize,              //  IN:   size      of   digest   to   be  checked

966        BYTE                  *hIn,                     //  IN:   digest        buffer

967        UINT32                    sigInSize,            //  IN:   size      of   signature

968        BYTE                  *sigIn,                   //  IN:   signature

969        UINT16                    saltSize              //  IN:   salt      size     for  PSS

970        )

971  {

972        CRYPT_RESULT              retVal;

973

974        //  Fatal      programming    errors

975        pAssert(key       !=  NULL    &&  sigIn     !=  NULL  &&  hIn       !=   NULL);

976

977        //  Errors     that   might   be   caused       by  calling     parameters

978        if(sigInSize      !=  key->publicKey->size)

979              return   CRYPT_FAIL;

980        //  Decrypt    the    block

981        if((retVal     =  RSAEP(sigInSize,          sigIn,    key))     !=      CRYPT_SUCCESS)

982              return   CRYPT_FAIL;

983        switch    (scheme)

984        {

985        case  TPM_ALG_NULL:

986              return   CRYPT_SCHEME;

987              break;

988        case  TPM_ALG_RSAPSS:

989              return   PssDecode(hashAlg,           hInSize,      hIn,      sigInSize,    sigIn,   saltSize);

990              break;

991        case  TPM_ALG_RSASSA:

992              return   RSASSA_Decode(hashAlg,               hInSize,    hIn,      sigInSize,       sigIn);

993              break;

994        default:

995              break;

996        }

997        return    CRYPT_SCHEME;

998  }

999  #ifndef     RSA_KEY_SIEVE

     B.12.1.4.6.     _cpri__GenerateKeyRSA()

     Generate an RSA key from a provided seed

     Family "2.0"                                          TCG Published                                             Page 435

     Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                       October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines

      Return Value                             Meaning

      CRYPT_FAIL                               exponent is not prime or is less than 3; or could not find a prime using

                                               the provided parameters

      CRYPT_CANCEL                             operation was canceled

1000  LIB_EXPORT    CRYPT_RESULT

1001  _cpri__GenerateKeyRSA(

1002     TPM2B                       *n,                   //     OUT:      The   public       modulu

1003     TPM2B                       *p,                   //     OUT:      One   of   the     prime    factors     of  n

1004     UINT16                        keySizeInBits,      //     IN:    Size     of   the     public   modulus     in     bit

1005     UINT32                        e,                  //     IN:    The     public       exponent

1006     TPM_ALG_ID                    hashAlg,            //     IN:    hash     algorithm         to  use   in   the  key

1007                                                       //            generation           proce

1008     TPM2B                       *seed,                //     IN:    the     seed     to   use

1009     const    char               *label,               //     IN:    A   label     for     the   generation     process.

1010     TPM2B                       *extra,               //     IN:    Party     1   data     for     the  KDF

1011     UINT32                      *counter              //     IN/OUT:        Counter       value    to   allow  KFD    iteration

1012                                                       //            to   be   propagated           across     multiple     routine

1013     )

1014  {

1015     UINT32                        lLen;               //     length      of   the    label

1016                                                       //     (counting        the    terminating         0);

1017     UINT16                        digestSize       =  _cpri__GetDigestSize(hashAlg);

1018

1019     TPM2B_HASH_BLOCK                     oPadKey;

1020

1021     UINT32                      outer;

1022     UINT32                      inner;

1023     BYTE                        swapped[4];

1024

1025     CRYPT_RESULT                retVal;

1026     int                         i,    fill;

1027     const    static         char          defaultLabel[]         =  "RSA     key";

1028     BYTE                        *pb;

1029

1030     CPRI_HASH_STATE               h1;                 //     contains        the     hash  of      the

1031                                                       //         HMAC    key     w/  iPad

1032     CPRI_HASH_STATE               h2;                 //     contains        the     hash  of      the

1033                                                       //         HMAC    key     w/  oPad

1034     CPRI_HASH_STATE               h;                  //     the    working       hash     context

1035

1036     BIGNUM                      *bnP;

1037     BIGNUM                      *bnQ;

1038     BIGNUM                      *bnT;

1039     BIGNUM                      *bnE;

1040     BIGNUM                      *bnN;

1041     BN_CTX                      *context;

1042     UINT32                        rem;

1043

1044     //   Make    sure       that     hashAlg   is     valid  hash

1045     pAssert(digestSize                !=  0);

1046

1047     //   if  present,       use       externally      provided      counter

1048     if(counter          !=  NULL)

1049           outer      =  *counter;

1050     else

1051           outer      =  1;

1052

1053     //   Validate       exponent

1054     UINT32_TO_BYTE_ARRAY(e,                   swapped);

1055

1056     //   Need    to     check     that    the  exponent      is     prime    and     not   less    than    3

1057     if(   e  !=  0      &&  (e    <   3   ||   !_math__IsPrime(e)))

      Page 436                                                TCG Published                                                     Family "2.0"

      October 30, 2014                              Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                            Trusted Platform Module Library

1058           return              CRYPT_FAIL;
         
1059     
         
1060     //   Get      structures                 for     the   big    number    representations
         
1061     context          =     BN_CTX_new();
         
1062     if(context                ==   NULL)
         
1063           FAIL(FATAL_ERROR_ALLOCATION);
         
1064     BN_CTX_start(context);
         
1065     bnP   =   BN_CTX_get(context);
         
1066     bnQ   =   BN_CTX_get(context);
         
1067     bnT   =   BN_CTX_get(context);
         
1068     bnE   =   BN_CTX_get(context);
         
1069     bnN   =   BN_CTX_get(context);
         
1070     if(bnN        ==       NULL)
         
1071           FAIL(FATAL_ERROR_INTERNAL);
         
1072     
         
1073     //   Set      Q     to     zero.         This     is   used   as  a    flag.     The  prime      is  computed       in      P.  When  a
         
1074     //   new      prime           is     found,       Q   is  checked      to  see   if   it    is   zero.      If   so,     P  is  copied
         
1075     //   to   Q      and       a   new       P  is    found.      When     both   P  and    Q   are  non-zero,          the     modulus   and
         
1076     //   private              exponent          are      computed     and   a  trial      encryption/decryption                 is
         
1077     //   performed.                   If     the     encrypt/decrypt           fails,     assume     that   at     least     one    of   the
         
1078     //   primes            is     composite.             Since    we  don't    know    which    one,     set    Q   to  zero        and  start
         
1079     //   over        and       find       a     new   pair    of  primes.
         
1080     BN_zero(bnQ);
         
1081     
         
1082     //   Need        to       have       some     label
         
1083     if(label            ==     NULL)
         
1084           label            =   (const           char     *)&defaultLabel;
         
1085     //   Get      the         label       size
         
1086     for(lLen            =     0;   label[lLen++]              !=  0;);
         
1087     
         
1088     //   Start          the       hash       using       the  seed    and   get   the     intermediate         hash     value
         
1089     _cpri__StartHMAC(hashAlg,                              FALSE,     &h1,     seed->size,      seed->buffer,           &oPadKey.b);
         
1090     _cpri__StartHash(hashAlg,                              FALSE,     &h2);
         
1091     _cpri__UpdateHash(&h2,                            oPadKey.b.size,          oPadKey.b.buffer);
         
1092     
         
1093     n->size          =     (keySizeInBits                 +7)/8;
         
1094     pAssert(n->size                      <=     MAX_RSA_KEY_BYTES);
         
1095     p->size          =     n->size           /  2;
         
1096     if(e     ==      0)
         
1097           e   =      RSA_DEFAULT_PUBLIC_EXPONENT;
         
1098     
         
1099     BN_set_word(bnE,                      e);
         
1100     
         
1101     //   The      first           test       will     increment       the   counter       from  zero.
         
1102     for(outer              +=     1;     outer       !=   0;  outer++)
         
1103     {
         
1104           if(_plat__IsCanceled())
         
1105           {
         
1106                      retVal           =   CRYPT_CANCEL;
         
1107                      goto         Cleanup;
         
1108           }
         
1109     
         
1110           //      Need         to     fill      in    the     candidate     with     the  hash
         
1111           fill          =     digestSize;
         
1112           pb      =     p->buffer;
         
1113     
         
1114           //      Reset           the     inner       counter
         
1115           inner            =   0;
         
1116           for(i            =   p->size;           i   >   0;  i   -=  digestSize)
         
1117           {
         
1118                      inner++;
         
1119                      //       Initialize             the   HMAC   with     saved     state
         
1120                      _cpri__CopyHashState(&h,                         &h1);
         
1121     
         
1122                      //       Hash       the    inner      counter    (the     one   that      changes     on   each    HMAC        iteration)
         
1123                      UINT32_TO_BYTE_ARRAY(inner,                           swapped);

      Family "2.0"                                                      TCG Published                                                       Page 437

      Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                            October 30, 2014
      Trusted Platform Module Library                                                                             Part 4: Supporting Routines

1124               _cpri__UpdateHash(&h,                        4,     swapped);
         
1125               _cpri__UpdateHash(&h,                        lLen,         (BYTE      *)label);
         
1126     
         
1127               //      Is     there   any       party       1   data
         
1128               if(extra           !=  NULL)
         
1129                       _cpri__UpdateHash(&h,                          extra->size,         extra->buffer);
         
1130     
         
1131               //      Include        the      outer     counter          (the       one   that    changes       on  each  prime
         
1132               //      prime      candidate          generation
         
1133               UINT32_TO_BYTE_ARRAY(outer,                                swapped);
         
1134               _cpri__UpdateHash(&h,                        4,     swapped);
         
1135               _cpri__UpdateHash(&h,                        2,     (BYTE      *)&keySizeInBits);
         
1136               if(i        <  fill)
         
1137                       fill       =   i;
         
1138               _cpri__CompleteHash(&h,                          fill,         pb);
         
1139     
         
1140               //      Restart        the      oPad   hash
         
1141               _cpri__CopyHashState(&h,                            &h2);
         
1142     
         
1143               //      Add    the     last      hashed         data
         
1144               _cpri__UpdateHash(&h,                        fill,         pb);
         
1145     
         
1146               //      gives      a   completed          HMAC
         
1147               _cpri__CompleteHash(&h,                          fill,         pb);
         
1148               pb      +=     fill;
         
1149     }
         
1150     //        Set     the    Most    significant               2     bits    and     the  low     bit  of  the      candidate
         
1151     p->buffer[0]                 |=  0xC0;
         
1152     p->buffer[p->size                      -   1]   |=     1;
         
1153     
         
1154     //        Convert        the     candidate          to     a     BN
         
1155     BN_bin2bn(p->buffer,                        p->size,             bnP);
         
1156     
         
1157     //        If   this      is      the   second       prime,           make    sure     that    it   differs      from  the
         
1158     //        first       prime      by    at   least         2^100
         
1159     if(!BN_is_zero(bnQ))
         
1160     {
         
1161               //      bnQ    is      non-zero       if     we     already        found    it
         
1162               if(BN_ucmp(bnP,                  bnQ)     <     0)
         
1163                       BN_sub(bnT,              bnQ,     bnP);
         
1164               else
         
1165                       BN_sub(bnT,              bnP,     bnQ);
         
1166               if(BN_num_bits(bnT)                    <     100)          //  Difference         has    to  be   at  least      100  bits
         
1167                       continue;
         
1168     }
         
1169     //        Make    sure       that      the     prime       candidate            (p)   is  not     divisible     by    the  exponent
         
1170     //        and     that       (p-1)     is   not     divisible            by     the   exponent
         
1171     //        Get     the    remainder          after         dividing          by   the  modulus
         
1172     rem       =    BN_mod_word(bnP,                 e);
         
1173     if(rem            ==     0)  //  evenly         divisible            so     add  two      keeping      the  number    odd  and
         
1174               //      making         sure     that   1     !=     p  mod     e
         
1175               BN_add_word(bnP,                  2);
         
1176     else          if(rem         ==  1)    //   leaves         a     remainder       of   1   so   subtract         two  keeping    the
         
1177               //      number         odd   and     making         (e-1)      =   p   mod  e
         
1178               BN_sub_word(bnP,                  2);
         
1179     
         
1180     //        Have    a      candidate,         check         for    primality
         
1181     if((retVal               =   (CRYPT_RESULT)BN_is_prime_ex(bnP,
         
1182                                  BN_prime_checks,                    NULL,      NULL))    <   0)
         
1183               FAIL(FATAL_ERROR_INTERNAL);
         
1184     
         
1185     if(retVal                !=  1)
         
1186               continue;
         
1187     
         
1188     //        Found       a  prime,        is   this       the       first      or   second.
         
1189     if(BN_is_zero(bnQ))

      Page 438                                                   TCG Published                                                        Family "2.0"

      October 30, 2014                               Copyright © TCG 2006-2014                                        Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                               Trusted Platform Module Library

1190     {
         
1191                   //    copy     p     to    q   and          compute           another           prime          in   p
         
1192                   BN_copy(bnQ,               bnP);
         
1193                   continue;
         
1194     }
         
1195     //Form              the   public             modulus
         
1196     BN_mul(bnN,                  bnP,        bnQ,          context);
         
1197     if(BN_num_bits(bnN)                              !=       keySizeInBits)
         
1198                   FAIL(FATAL_ERROR_INTERNAL);
         
1199     
         
1200     //            Save  the      public          modulus
         
1201     BnTo2B(n,                bnN,         n->size);                  //     Will         pad   the      buffer           to   the   correct      size
         
1202     pAssert((n->buffer[0]                                  &     0x80)         !=     0);
         
1203     
         
1204     //            And   one   prime
         
1205     BnTo2B(p,                bnP,         p->size);
         
1206     pAssert((p->buffer[0]                                  &     0x80)         !=     0);
         
1207     
         
1208     //            Finish     by     making           sure         that         we     can      form     the       modular         inverse    of  PHI
         
1209     //            with  respect              to  the          public           exponent
         
1210     //            Compute     PHI         =  (p      -     1)(q         -   1)     =     n  -  p  -     q     +   1
         
1211     //            Make  sure        that         we     can       form         the       modular        inverse
         
1212     BN_sub(bnT,                  bnN,        bnP);
         
1213     BN_sub(bnT,                  bnT,        bnQ);
         
1214     BN_add_word(bnT,                         1);
         
1215     
         
1216     //            find  d    such         that       (Phi         *     d)     mod       e  ==1
         
1217     //            If   there     isn't           then         we     are       broken          because           we   took     the     step
         
1218     //            of   making       sure         that         the       prime         !=    1  mod      e     so     the     modular   inverse
         
1219     //            must  exist
         
1220     if(BN_mod_inverse(bnT,                                    bnE,         bnT,       context)          ==       NULL     ||   BN_is_zero(bnT))
         
1221                   FAIL(FATAL_ERROR_INTERNAL);
         
1222     
         
1223     //            And,  finally,             do      a     trial           encryption             decryption
         
1224     {
         
1225                   TPM2B_TYPE(RSA_KEY,                            MAX_RSA_KEY_BYTES);
         
1226                   TPM2B_RSA_KEY                                   r;
         
1227                   r.t.size          =     sizeof(n->size);
         
1228     
         
1229                   //    If   we     are      using            a   seed,         then        results           must       be   reproducible       on    each
         
1230                   //    call.       Otherwise,                   just       get       a     random      number
         
1231                   if(seed        ==       NULL)
         
1232                         _cpri__GenerateRandom(n->size,                                            r.t.buffer);
         
1233                   else
         
1234                   {
         
1235                         //    this           this       version             does         not   have        a     deterministic         RNG,      XOR   the
         
1236                         //    public             key       and       private             exponent          to     get     a   deterministic      value
         
1237                         //    for         testing.
         
1238                         int                          i;
         
1239     
         
1240                         //    Generate               a     random-ish                 number      starting               with     the  public    modulus
         
1241                         //    XORed          with          the       MSO       of     the      seed
         
1242                         for(i          =     0;  i      <     n->size;             i++)
         
1243                                  r.t.buffer[i]                       =     n->buffer[i]              ^     seed->buffer[0];
         
1244                   }
         
1245                   //    Make     sure        that          the       number           is    smaller           than       the   public  modulus
         
1246                   r.t.buffer[0]                  &=     0x7F;
         
1247                              //     Convert
         
1248                   if(        BN_bin2bn(r.t.buffer,                                 r.t.size,            bnP)         ==   NULL
         
1249                              //     Encrypt             with         the       public          exponent
         
1250                         ||   BN_mod_exp(bnQ,                         bnP,       bnE,        bnN,     context)             !=   1
         
1251                              //     Decrypt             with         the       private         exponent
         
1252                         ||   BN_mod_exp(bnQ,                         bnQ,       bnT,        bnN,     context)             !=   1)
         
1253                         FAIL(FATAL_ERROR_INTERNAL);
         
1254                   //    If   the       starting               and       ending           values      are         not     the   same,   start     over  )-;
         
1255                   if(BN_ucmp(bnP,                    bnQ)         !=       0)

      Family "2.0"                                                           TCG Published                                                               Page 439

      Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                                         October 30, 2014
      Trusted Platform Module Library                                                      Part 4: Supporting Routines

1256                     {

1257                             BN_zero(bnQ);

1258                             continue;

1259                     }

1260             }

1261             retVal      =   CRYPT_SUCCESS;

1262             goto       Cleanup;

1263       }

1264       retVal     =     CRYPT_FAIL;

1265

1266  Cleanup:

1267       //  Close        out  the  hash  sessions

1268       _cpri__CompleteHash(&h2,             0,    NULL);

1269       _cpri__CompleteHash(&h1,             0,    NULL);

1270

1271       //  Free      up  allocated      BN  values

1272       BN_CTX_end(context);

1273       BN_CTX_free(context);

1274       if(counter        !=     NULL)

1275             *counter        =  outer;

1276       return     retVal;

1277  }

1278  #endif             //  RSA_KEY_SIEVE

1279  #endif   //   TPM_ALG_RSA

      B.12.2.  Alternative RSA Key Generation

      B.12.2.1.     Introduction

      The files in this clause implement an alternative RSA key generation method that is about an order of

      magnitude faster than the regular method in B.14.1 and is provided simply to speed testing of the test

      functions. The method implemented in this clause uses a sieve rather than choosing prime candidates at

      random and testing for primeness. In this alternative, the sieve filed starting address is chosen at random

      and  a   sieve  operation       is   performed  on  the  field  using  small  prime  values.  After  sieving,  the  bits

      representing values that are not divisible by the small primes tested, will be checked in a pseudo-random

      order until a prime is found.

      The size of the sieve field is tunable as is the value indicating the number of primes that should be

      checked. As the size of the prime increases, the density of primes is reduced so the size of the sieve field

      should be increased to improve the probability that the field will contain at least one prime. In addition, as

      the sieve field increases the number of small primes that should be checked increases. Eliminating a

      number from consideration by using division is considerably faster than eliminating the number with a

      Miller-Rabin test.

      B.12.2.2.     RSAKeySieve.h

      This header file is used to for parameterization of the Sieve and RNG used by the RSA module

1     #ifndef            RSA_H

2     #define            RSA_H

      This value is used to set the size of the table that is searched by the prime iterator. This is used during

      the generation of different primes. The smaller tables are used when generating smaller primes.

3     extern   const        UINT16        primeTableBytes;

      The following define determines how large the prime number difference table will be defined. The value of

      13 will allocate the maximum size table which allows generation of the first 6542 primes which is all the

      primes less than 2^16.

      Page 440                                            TCG Published                                    Family "2.0"

      October 30, 2014                           Copyright © TCG 2006-2014                 Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                 Trusted Platform Module Library

4   #define  PRIME_DIFF_TABLE_512_BYTE_PAGES                         13

    This set of macros used the value above to set the table size.

5   #ifndef  PRIME_DIFF_TABLE_512_BYTE_PAGES

6   #  define      PRIME_DIFF_TABLE_512_BYTE_PAGES                       4

7   #endif

8   #ifdef   PRIME_DIFF_TABLE_512_BYTE_PAGES

9   #  if    PRIME_DIFF_TABLE_512_BYTE_PAGES              >    12

10  #        define  PRIME_DIFF_TABLE_BYTES               6542

11  #  else

12  #        if     PRIME_DIFF_TABLE_512_BYTE_PAGES                  <=        0

13  #               define  PRIME_DIFF_TABLE_BYTES                512

14  #        else

15  #               define  PRIME_DIFF_TABLE_BYTES                (PRIME_DIFF_TABLE_512_BYTE_PAGES                     *   512)

16  #        endif

17  #  endif

18  #endif

19  extern   const   BYTE   primeDiffTable    [PRIME_DIFF_TABLE_BYTES];

    This determines the number of bits in the sieve field This must be a power of two.

20  #define  FIELD_POWER         14       //  This  is    the        only         value  in     this  group    that  should  be

21                                        //  changed

22  #define  FIELD_BITS          (1  <<       FIELD_POWER)

23  #define  MAX_FIELD_SIZE               ((FIELD_BITS         /     8)     +     1)

    This is the pre-sieved table. It already has the bits for multiples of 3, 5, and 7 cleared.

24  #define  SEED_VALUES_SIZE                 105

25  const   extern   BYTE                     seedValues[SEED_VALUES_SIZE];

    This allows determination    of  the  number of bits that are set                    in  a  byte  without  having  to  count  them

    individually.

26  const   extern   BYTE                     bitsInByte[256];

    This is the iterator structure for accessing the compressed prime number table. The                        expectation is that

    values will need to be accesses sequentially. This tries to save some data access.

27  typedef  struct  {

28     UINT32           lastPrime;

29     UINT32           index;

30     UINT32           final;

31  }  PRIME_ITERATOR;

32  #ifdef   RSA_INSTRUMENT

33  #  define      INSTRUMENT_SET(a,      b)  ((a)     =  (b))

34  #  define      INSTRUMENT_ADD(a,      b)  (a)   =     (a)     +  (b)

35  #  define      INSTRUMENT_INC(a)          (a)   =     (a)     +  1

36  extern   UINT32  failedAtIteration[10];

37  extern   UINT32  MillerRabinTrials;

38  extern   UINT32  totalFieldsSieved;

39  extern   UINT32  emptyFieldsSieved;

40  extern   UINT32  noPrimeFields;

41  extern   UINT32  primesChecked;

42  extern   UINT16     lastSievePrime;

43  #else

44  #  define      INSTRUMENT_SET(a,      b)

45  #  define      INSTRUMENT_ADD(a,      b)

46  #  define      INSTRUMENT_INC(a)

47  #endif

48  #ifdef   RSA_DEBUG

49  extern   UINT16     defaultFieldSize;

    Family "2.0"                                    TCG Published                                                          Page 441

    Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                        October 30, 2014
    Trusted Platform Module Library                             Part 4: Supporting Routines

50  #define  NUM_PRIMES              2047

51  extern   const  __int16          primes[NUM_PRIMES];

52  #else

53  #define  defaultFieldSize        MAX_FIELD_SIZE

54  #endif

55  #endif

    Page 442                               TCG Published        Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                     Trusted Platform Module Library

    B.12.2.3.    RSAKeySieve.c

    B.12.2.3.1.     Includes and defines

1   #include        "OsslCryptoEngine.h"

2   #ifdef         TPM_ALG_RSA

    This file produces no code unless the compile switch is set to cause it to generate code.

3   #ifdef          RSA_KEY_SIEVE                                 //%

4   #include        "RsaKeySieve.h"

    This next line  will show up          in  the  header   file  for  this  code.  It  will  make  the  local  functions  public  when

    debugging.

5   //%#ifdef       RSA_DEBUG

    B.12.2.3.2.     Bit Manipulation Functions

    B.12.2.3.2.1.       Introduction

    These functions operate on a bit array. A bit array is an array of bytes with the 0th byte being the byte

    with the lowest memory address. Within the byte, bit 0 is the least significant bit.

    B.12.2.3.2.2.       ClearBit()

    This function will CLEAR a bit in         a bit array.

6   void

7   ClearBit(

8         unsigned      char      *a,                       //    IN:  A     pointer    to    an  array  of     byte

9         int                       i                       //    IN:  the   number     of    the   bit  to     CLEAR

10        )

11  {

12        a[i  >>   3]  &=    0xff     ^  (1     <<  (i  &  7));

13  }

    B.12.2.3.2.3.       SetBit()

    Function to SET a bit in a bit array.

14  void

15  SetBit(

16        unsigned      char      *a,                       //    IN:  A     pointer    to    an  array  of     byte

17        int                       i                       //    IN:  the   number     of    the   bit  to     SET

18        )

19  {

20        a[i  >>   3]  |=    (1  <<      (i  &    7));

21  }

    B.12.2.3.2.4.       IsBitSet()

    Function to test if a bit in a bit array is SET.

    Family "2.0"                                            TCG Published                                                  Page 443

    Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                       October 30, 2014
    Trusted Platform Module Library                                                                                         Part 4: Supporting Routines

    Return Value                                          Meaning

    0                                                     bit is CLEAR

    1                                                     bit is SET

22  UINT32

23  IsBitSet(

24       unsigned          char          *a,                                //  IN:      A  pointer      to     an  array   of   byte

25       int                                 i                              //  IN:      the     number     of  the    bit  to   test

26       )

27  {

28       return        ((a[i        >>   3]        &  (1      <<   (i  &    7)))     !=     0);

29  }

    B.12.2.3.2.5.          BitsInArry()

    This function counts the number of bits                        set    in an array of bytes.

30  int

31  BitsInArray(

32       unsigned          char          *a,                                //  IN:      A  pointer      to     an  array   of   byte

33       int                                 i                              //  IN:      the     number     of  bytes  to   sum

34       )

35  {

36       int            j     =     0;

37       for(;      i   ;     i--)

38               j  +=     bitsInByte[*a++];

39       return        j;

40  }

    B.12.2.3.2.6.          FindNthSetBit()

    This function finds the nth SET bit in a bit array. The caller should check that the offset of the returned

    value is not out of range.               If called when the array does not have n bits set, it will return a fatal error

41  UINT32

42  FindNthSetBit(

43       const      UINT16                   aSize,                         //  IN:      the     size   of   the    array   to   check

44       const      BYTE                 *a,                                //  IN:      the     array   to     check

45       const      UINT32                   n                              //  IN,      the     number     of  the    SET  bit

46       )

47  {

48       UINT32                     i;

49       const      BYTE            *pA  =      a;

50       UINT32                     retValue;

51       BYTE                       sel;

52

53       (aSize);

54

55       //find        the       bit

56       for(i      =   0;       i  <    n;     i     +=  bitsInByte[*pA++]);

57

58       //   The      chosen           bit     is    in      the  byte     that     was      just     accessed

59       //   Compute            the     offset           to  the      start    of   that        byte

60       pA--;

61       retValue          =     (UINT32)(pA              -   a)   *   8;

62

63       //   Subtract              the  bits         in      the  last     byte     added.

64       i   -=     bitsInByte[*pA];

65

66       //   Now      process           the       byte,      one      bit  at    a  time.

    Page 444                                                                TCG Published                                               Family "2.0"

    October 30, 2014                                              Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
     Part  4: Supporting Routines                                                                          Trusted Platform Module Library

67         for(sel         =   *pA;        sel     !=  0   ;  sel    =  sel  >>    1)

68         {

69                if(sel           &  1)

70                {

71                         i   +=     1;

72                         if(i       ==      n)

73                                    return       retValue;

74                }

75                retValue            +=      1;

76         }

77         FAIL(FATAL_ERROR_INTERNAL);

78   }

     B.12.2.3.3.           Miscellaneous Functions

     B.12.2.3.3.1.             RandomForRsa()

     This function uses a special form of KDFa() to produces a pseudo random sequence. It's input is a

     structure that contains pointers to a pre-computed set of hash contexts that are set up for the HMAC

     computations using the seed.

     This function will test that ktx.outer will not wrap to zero if incremented. If so, the function returns FALSE.

     Otherwise, the ktx.outer is incremented before each number is generated.

79   void

80   RandomForRsa(

81         KDFa_CONTEXT                       *ktx,                     //   IN:   a   context  for   the    KDF

82         const        char                  *label,                   //   IN:   a   use  qualifying     label

83         TPM2B                              *p                        //   OUT:     the   pseudo   random  result

84         )

85   {

86         INT16                                              i;

87         UINT32                                             inner;

88         BYTE                                               swapped[4];

89         UINT16                                             fill;

90         BYTE                                               *pb;

91         UINT16                                             lLen   =  0;

92         UINT16                                             digestSize     =    _cpri__GetDigestSize(ktx->hashAlg);

93         CPRI_HASH_STATE                                    h;        //   the      working   hash  context

94

95         if(label            !=     NULL)

96                for(lLen            =    0;     label[lLen++];);

97         fill      =     digestSize;

98         pb  =     p->buffer;

99         inner        =  0;

100        *(ktx->outer)                  +=   1;

101        for(i        =  p->size;            i   >   0;  i  -=    digestSize)

102        {

103               inner++;

104

105               //       Initialize             the  HMAC       with  saved     state

106               _cpri__CopyHashState(&h,                          &(ktx->iPadCtx));

107

108               //       Hash       the     inner    counter       (the    one   that     changes   on  each    HMAC  iteration)

109               UINT32_TO_BYTE_ARRAY(inner,                           swapped);

110               _cpri__UpdateHash(&h,                       4,    swapped);

111               if(lLen             !=   0)

112                        _cpri__UpdateHash(&h,                     lLen,   (BYTE     *)label);

113

114               //       Is  there          any     party   1   data

115               if(ktx->extra                   !=   NULL)

116                        _cpri__UpdateHash(&h,                     ktx->extra->size,          ktx->extra->buffer);

117

     Family "2.0"                                                       TCG Published                                   Page 445

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                 October 30, 2014
     Trusted Platform Module Library                                                                 Part 4: Supporting  Routines

118             //  Include        the   outer     counter    (the    one  that  changes    on  each  prime

119             //  prime   candidate          generation

120             UINT32_TO_BYTE_ARRAY(*(ktx->outer),                   swapped);

121             _cpri__UpdateHash(&h,              4,    swapped);

122             _cpri__UpdateHash(&h,              2,    (BYTE  *)&ktx->keySizeInBits);

123             if(i     <  fill)

124                   fill  =      i;

125             _cpri__CompleteHash(&h,                fill,    pb);

126

127             //  Restart        the   oPad    hash

128             _cpri__CopyHashState(&h,                 &(ktx->oPadCtx));

129

130             //  Add     the    last  hashed    data

131             _cpri__UpdateHash(&h,              fill,    pb);

132

133             //  gives   a      completed       HMAC

134             _cpri__CompleteHash(&h,                fill,    pb);

135             pb  +=      fill;

136        }

137        return;

138  }

     B.12.2.3.3.2.       MillerRabinRounds()

     Function returns the number of Miller-Rabin rounds necessary to give an error probability                   equal   to  the

     security strength of the prime. These values are from FIPS 186-3.

139  UINT32

140  MillerRabinRounds(

141        UINT32                      bits                 //  IN:   Number     of  bits  in   the  RSA  prime

142        )

143  {

144        if(bits    <     511)   return    8;        //  don't    really    expect  this

145        if(bits    <     1536)  return      5;      //  for  512   and   1K   primes

146        return   4;                                 //  for  3K    public    modulus    and  greater

147  }

     B.12.2.3.3.3.       MillerRabin()

     This function performs a Miller-Rabin test from FIPS 186-3. It does iterations trials on the number. I all

     likelihood, if the number is not prime, the first test fails.

     If a KDFa(), PRNG context is provide (ktx), then it is used to provide the random values. Otherwise, the

     random numbers are retrieved from the random number generator.

     Return Value                            Meaning

     TRUE                                    probably prime

     FALSE                                   composite

148  BOOL

149  MillerRabin(

150        BIGNUM                  *bnW,

151        int                         iterations,

152        KDFa_CONTEXT            *ktx,

153        BN_CTX                  *context

154        )

155  {

156        BIGNUM           *bnWm1;

157        BIGNUM           *bnM;

158        BIGNUM           *bnB;

159        BIGNUM           *bnZ;

     Page 446                                               TCG Published                                        Family "2.0"

     October 30, 2014                              Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                           Trusted Platform    Module  Library

160      BOOL                                ret       =   FALSE;             //   Assumed      composite          for  easy  exit

161      TPM2B_TYPE(MAX_PRIME,                                    MAX_RSA_KEY_BYTES/2);

162      TPM2B_MAX_PRIME                                  b;

163      int                                 a;

164      int                                 j;

165      int                                 wLen;

166      int                                 i;

167

168      pAssert(BN_is_bit_set(bnW,                                          0));

169      INSTRUMENT_INC(MillerRabinTrials);                                                 //  Instrumentation

170

171      BN_CTX_start(context);

172      bnWm1            =     BN_CTX_get(context);

173      bnB        =     BN_CTX_get(context);

174      bnZ        =     BN_CTX_get(context);

175      bnM        =     BN_CTX_get(context);

176      if(bnM              ==       NULL)

177                 FAIL(FATAL_ERROR_ALLOCATION);

178

179  //  Let     a     be       the         largest           integer         such     that     2^a   divides      w1.

180      BN_copy(bnWm1,                            bnW);

181      BN_sub_word(bnWm1,                                1);

182      //      Since             w     is     odd       (w-1)       is     even     so  start      at  bit   number   1     rather  than  0

183      for(a            =     1;       !BN_is_bit_set(bnWm1,                         a);    a++);

184

185  //  2.   m     =     (w1)           /   2^a

186      BN_rshift(bnM,                            bnWm1,         a);

187

188  //  3.   wlen           =     len       (w).

189      wLen          =     BN_num_bits(bnW);

190      pAssert((wLen                          &   7)     ==     0);

191

192      //      Set         the         size       for       the     random       number

193      b.b.size                  =     (UINT16)(wLen                 +     7)/8;

194

195  //  4.   For         i     =     1     to     iterations             do

196      for(i            =     0;       i   <     iterations             ;   i++)

197      {

198

199  //  4.1     Obtain               a     string         b   of     wlen       bits     from  an    RBG.

200  step4point1:

201                 //       In       the       reference             implementation,            wLen    is    always   a     multiple  of  8

202                 if(ktx               !=     NULL)

203                             RandomForRsa(ktx,                         "Miller-Rabin          witness",         &b.b);

204                 else

205                             _cpri__GenerateRandom(b.t.size,                                  b.t.buffer);

206

207                 if(BN_bin2bn(b.t.buffer,                                     b.t.size,      bnB)     ==    NULL)

208                             FAIL(FATAL_ERROR_ALLOCATION);

209

210  //  4.2     If       ((b            1)     or     (b      w1)),         then     go  to    step     4.1.

211                 if(BN_is_zero(bnB))

212                             goto         step4point1;

213                 if(BN_is_one(bnB))

214                             goto         step4point1;

215                 if(BN_ucmp(bnB,                           bnWm1)         >=   0)

216                             goto         step4point1;

217

218  //  4.3     z     =     b^m         mod       w.

219                 if(BN_mod_exp(bnZ,                             bnB,       bnM,     bnW,     context)       !=  1)

220                             FAIL(FATAL_ERROR_ALLOCATION);

221

222  //  4.4     If       ((z         =     1)     or     (z   =   w      1)),     then     go  to    step     4.7.

223                 if(BN_is_one(bnZ)                             ||   BN_ucmp(bnZ,             bnWm1)   ==    0)

224                             goto         step4point7;

225

     Family "2.0"                                                                     TCG Published                                            Page 447

     Level 00 Revision 01.16                                              Copyright © TCG 2006-2014                                     October 30, 2014
     Trusted Platform Module Library                                                                                Part  4:  Supporting  Routines

226  //  4.5     For    j     =     1   to     a      1   do.

227              for(j           =     1;   j     <   a;   j++)

228              {

229  //  4.5.1      z   =     z^2       mod       w.

230                        if(BN_mod_mul(bnZ,                         bnZ,   bnZ,     bnW,  context)  !=  1)

231                                    FAIL(FATAL_ERROR_ALLOCATION);

232

233  //  4.5.2      If     (z       =   w1),         then     go   to     step  4.7.

234                        if(BN_ucmp(bnZ,                     bnWm1)       ==  0)

235                                    goto       step4point7;

236

237  //  4.5.3      If     (z       =   1),       then     go     to   step     4.6.

238                        if(BN_is_one(bnZ))

239                                    goto       step4point6;

240              }

241  //  4.6     Return          COMPOSITE.

242  step4point6:

243              if(i         >     9)

244                        INSTRUMENT_INC(failedAtIteration[9]);

245              else

246                        INSTRUMENT_INC(failedAtIteration[i]);

247              goto         end;

248

249  //  4.7     Continue.              Comment:           Increment         i  for   the   do-loop   in  step  4.

250  step4point7:

251              continue;

252        }

253  //  5.   Return          PROBABLY               PRIME

254        ret   =     TRUE;

255

256  end:

257        BN_CTX_end(context);

258        return       ret;

259  }

     B.12.2.3.3.4.            NextPrime()

     This function is used to access the next prime number in the sequence                                      of  primes.   It  requires  a  pre-

     initialized iterator.

260  UINT32

261  NextPrime(

262        PRIME_ITERATOR                      *iter

263        )

264  {

265        if(iter->index                   >=       iter->final)

266              return             (iter->lastPrime                   =  0);

267        return       (iter->lastPrime                       +=     primeDiffTable[iter->index++]);

268  }

     B.12.2.3.3.5.            AdjustNumberOfPrimes()

     Modifies the input parameter to be a valid value for the number of primes. The adjusted value is either the

     input value rounded up to the next 512 bytes boundary or the maximum value of the implementation. If

     the input is 0, the return is set to the maximum.

269  UINT32

270  AdjustNumberOfPrimes(

271        UINT32                                 p

272        )

273  {

274        p  =  ((p       +     511)       /     512)     *   512;

     Page 448                                                                TCG Published                                        Family "2.0"

     October 30, 2014                                              Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                          Trusted Platform Module Library

275        if(p     ==     0   ||     p  >      PRIME_DIFF_TABLE_BYTES)

276              p  =      PRIME_DIFF_TABLE_BYTES;

277        return       p;

278  }

     B.12.2.3.3.6.            PrimeInit()

     This function is used to initialize the prime sequence generator iterator. The iterator is initialized and

     returns the first prime that is equal to the requested starting value. If the starting value is no a prime, then

     the iterator is initialized to the next higher prime number.

279  UINT32

280  PrimeInit(

281        UINT32                               first,                //   IN:  the   initial      prime

282        PRIME_ITERATOR                    *iter,                   //   IN/OUT:    the  iterator       structure

283        UINT32                               primes                //   IN:  the   table    length

284        )

285  {

286

287        iter->lastPrime                   =     1;

288        iter->index             =     0;

289        iter->final             =     AdjustNumberOfPrimes(primes);

290        while(iter->lastPrime                          <   first)

291              NextPrime(iter);

292        return       iter->lastPrime;

293  }

     B.12.2.3.3.7.            SetDefaultNumberOfPrimes()

     This macro sets the default number of primes to the indicated value.

294  //%#define         SetDefaultNumberOfPrimes(p)                        (primeTableBytes        =  AdjustNumberOfPrimes(p))

     B.12.2.3.3.8.            IsPrimeWord()

     Checks to see if a UINT32 is prime

     Return Value                                         Meaning

     TRUE                                                 number is prime

     FAIL                                                 number is not prime

295  BOOL

296  IsPrimeWord(

297        UINT32                               p                     //   IN:  number     to  test

298        )

299  {

300  #if   defined         RSA_KEY_SIEVE                  &&  (PRIME_DIFF_TABLE_BYTES          >=  6542)

301

302        UINT32                  test;

303        UINT32                  index;

304        UINT32                  stop;

305

306        if((p    &      1)     ==     0)

307              return           FALSE;

308        if(p     ==     1   ||     p  ==        3)

309              return           TRUE;

310

311        //  Get      a     high       value         for    the  stopping    point

312        for(index           =   p,    stop          =  0;  index;  index     >>=   2)

     Family "2.0"                                                     TCG Published                                  Page 449

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                              October 30, 2014
     Trusted Platform Module Library                                                                                Part 4: Supporting  Routines

313            stop         =     (stop    <<   1)     +  1;

314      stop++;

315

316      //   If     the       full   prime      difference             value      table    is  present,       can  check  here

317

318      test     =     3;

319      for(index             =  1;  index      <     PRIME_DIFF_TABLE_BYTES;                  index      +=  1)

320      {

321            if((p           %  test)    ==    0)

322                     return        (p   ==    test);

323            if(test            >   stop)

324                     return        TRUE;

325            test         +=    primeDiffTable[index];

326      }

327      return         TRUE;

328

329  #else

330

331      BYTE                     b[4];

332      if(p     ==    RSA_DEFAULT_PUBLIC_EXPONENT                            ||  p  ==    1   ||  p  ==  3   )

333            return             TRUE;

334      if((p       &  1)        ==  0)

335            return             FALSE;

336      UINT32_TO_BYTE_ARRAY(p,b);

337      return         _math__IsPrime(p);

338  #endif

339  }

340  typedef   struct             {

341      UINT16                   prime;

342      UINT16                   count;

343  }   SIEVE_MARKS;

344  const   SIEVE_MARKS              sieveMarks[5]               =  {

345      {31,     7},       {73,      5},  {241,          4},     {1621,      3},  {UINT16_MAX,        2}};

     B.12.2.3.3.9.          PrimeSieve()

     This function does a prime sieve over the input field which has as its starting address the value in bnN.

     Since this initializes the Sieve using a pre-computed field with the bits associated with 3, 5 and 7 already

     turned off, the value of pnN may need to be adjusted by a few counts to allow the pre-computed field to

     be used without modification. The fieldSize parameter must be 2^N + 1 and is probably not useful if it is

     less than 129 bytes (1024 bits).

346  UINT32

347  PrimeSieve(

348      BIGNUM                   *bnN,                   //   IN/OUT:        number    to     sieve

349      UINT32                       fieldSize,          //   IN:      size   of  the    field     area   in     bytes

350      BYTE                     *field,                 //   IN:      field

351      UINT32                       primes              //   IN:      the   number    of     primes  to      use

352      )

353  {

354      UINT32                            i;

355      UINT32                            j;

356      UINT32                            fieldBits           =     fieldSize     *  8;

357      UINT32                            r;

358      const       BYTE                 *p1;

359      BYTE                             *p2;

360      PRIME_ITERATOR                    iter;

361      UINT32                            adjust;

362      UINT32                            mark     =     0;

363      UINT32                            count       =  sieveMarks[0].count;

364      UINT32                            stop     =     sieveMarks[0].prime;

365      UINT32                            composite;

366

367  //      UINT64                            test;                 //DEBUG

     Page 450                                                           TCG Published                                            Family "2.0"

     October 30, 2014                                         Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                           Trusted Platform Module Library

368

369  pAssert(field                      !=       NULL         &&     bnN     !=     NULL);

370  //     Need        to     have           a     field           that     has    a   size  of    2^n    +   1  bytes

371  pAssert(BitsInArray((BYTE                                          *)&fieldSize,         2)    ==   2);

372

373  primes          =     AdjustNumberOfPrimes(primes);

374

375  //     If    the       remainder                     is     odd,     then      subtracting         the    value

376  //     will        give         an       even         number,           but    we  want    an    odd     number,

377  //     so    subtract                 the         105+rem.           Otherwise,          just    subtract

378  //     the      even         remainder.

379  adjust          =     BN_mod_word(bnN,105);

380  if(adjust              &     1)

381            adjust          +=       105;

382

383  //     seed        the       field

384  //     This        starts             the         pointer          at    the      nearest    byte     to     the  input  value

385  p1     =     &seedValues[adjust/16];

386

387  //     Reduce          the         number             of       bytes     to    transfer      by    the    amount      skipped

388  j   =     sizeof(seedValues)                                -   adjust/16;

389  adjust          =     adjust             %     16;

390  BN_sub_word(bnN,                            adjust);

391  adjust          >>=       1;

392

393  //     This        offsets               the         field

394  p2     =     field;

395  for(i        =     fieldSize;                     i   >     0;     i--)

396  {

397            *p2++        =     *p1++;

398            if(--j          ==       0)

399            {

400                     j   =     sizeof(seedValues);

401                     p1     =     seedValues;

402            }

403  }

404  //     Mask        the       first             bits         in     the   field     and   the     last     byte    in  order    to  eliminate

405  //     bytes          not       in       the         field         from     consideration.

406  field[0]              &=     0xff           <<       adjust;

407  field[fieldSize-1]                                &=     0xff      >>    (8    -   adjust);

408

409  //     Cycle          through               the       primes,           clearing       bits

410  //     Have        already               done         3,       5,  and      7

411  PrimeInit(7,                    &iter,               primes);

412

413  //     Get      the       next           N     primes           where       N  is  determined         by     the  mark   in  the   sieveMarks

414  while((composite                            =     NextPrime(&iter))                !=    0)

415  {

416            UINT32             pList[8];

417            UINT32                next           =     0;

418            i  =     count;

419            pList[i--]                  =     composite;

420            for(;        i     >     0;       i--)

421            {

422                     next         =     NextPrime(&iter);

423                     pList[i]                 =     next;

424                     if(next               !=       0)

425                               composite                   *=     next;

426            }

427            composite                =     BN_mod_word(bnN,                      composite);

428            for(i        =     count;               i   >     0;     i--)

429            {

430                     next         =     pList[i];

431                     if(next               ==       0)

432                               goto           done;

433                     r   =     composite                   %     next;

     Family "2.0"                                                                   TCG Published                                       Page 451

     Level 00 Revision 01.16                                            Copyright © TCG 2006-2014                                       October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

434                         if(r     &     1)                    j     =  (next     -  r)/2;

435                         else     if(r      ==  0)            j     =  0;

436                         else                                 j     =  next   -     r/2;

437                         for(;       j  <   fieldBits;           j     +=  next)

438                                 ClearBit(field,              j);

439               }

440               if(next           >=     stop)

441               {

442                         mark++;

443                         count       =  sieveMarks[mark].count;

444                         stop     =     sieveMarks[mark].prime;

445               }

446        }

447  done:

448        INSTRUMENT_INC(totalFieldsSieved);

449        i   =  BitsInArray(field,                   fieldSize);

450        if(i      ==     0)  INSTRUMENT_INC(emptyFieldsSieved);

451        return        i;

452  }

     B.12.2.3.3.10. PrimeSelectWithSieve()

     This function will sieve the field around the input prime candidate. If the sieve field is not empty, one of

     the one bits in the field is chosen for testing with Miller-Rabin. If the value is prime, pnP is updated with

     this value and the function returns success. If this value is not prime, another pseudo-random candidate

     is chosen and tested. This process repeats until all values in the field have been checked. If all bits in the

     field have been checked and none is prime, the function returns FALSE and a new random value needs

     to be chosen.

453  BOOL

454  PrimeSelectWithSieve(

455        BIGNUM                          *bnP,                                //     IN/OUT:     The  candidate       to    filter

456        KDFa_CONTEXT                    *ktx,                                //     IN:   KDFa     iterator   structure

457        UINT32                              e,                               //     IN:   the   exponent

458        BN_CTX                          *context                             //     IN:   the   big  number     context     to   play   in

459  #ifdef       RSA_DEBUG                                                     //%

460     ,UINT16                                fieldSize,                       //     IN:   number     of  bytes   in    the  field,     as

461                                                                             //           determined     by   the    caller

462        UINT16                              primes                           //     IN:   number     of  primes    to    use.

463  #endif                                                                     //%

464  )

465  {

466        BYTE                                field[MAX_FIELD_SIZE];

467        UINT32                              first;

468        UINT32                              ones;

469        INT32                               chosen;

470        UINT32                              rounds    =  MillerRabinRounds(BN_num_bits(bnP));

471  #ifndef      RSA_DEBUG

472        UINT32                              primes;

473        UINT32                              fieldSize;

474        //     Adjust        the     field      size     and     prime     table    list       to  fit   the  size     of   the  prime

475        //     being      tested.

476        primes        =   BN_num_bits(bnP);

477        if(primes            <=   512)

478        {

479               primes        =    AdjustNumberOfPrimes(2048);

480               fieldSize             =  65;

481        }

482        else      if(primes             <=  1024)

483        {

484               primes        =    AdjustNumberOfPrimes(4096);

485               fieldSize             =  129;

486        }

     Page 452                                                             TCG Published                                                Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                 Trusted Platform Module   Library

487     else

488     {

489           primes         =   AdjustNumberOfPrimes(0);                           //     Set       to   the  maximum

490           fieldSize             =   MAX_FIELD_SIZE;

491     }

492     if(fieldSize             >     MAX_FIELD_SIZE)

493           fieldSize             =   MAX_FIELD_SIZE;

494  #endif

495

496     //   Save      the      low-order           word       to  use     as  a    search           generator   and     make  sure  that

497     //   it     has     some       interesting             range       to  it

498     first       =  bnP->d[0]            |   0x80000000;

499

500     //   Align       to     field       boundary

501     bnP->d[0]           &=   ~((UINT32)(fieldSize-3));

502     pAssert(BN_is_bit_set(bnP,                             0));

503     bnP->d[0]           &=   (UINT32_MAX               <<  (FIELD_POWER             +   1))       +   1;

504     ones     =     PrimeSieve(bnP,                 fieldSize,          field,       primes);

505  #ifdef   RSA_FILTER_DEBUG

506     pAssert(ones             ==     BitsInArray(field,                     defaultFieldSize));

507  #endif

508     for(;       ones     >   0;     ones--)

509     {

510  #ifdef   RSA_FILTER_DEBUG

511           if(ones           !=     BitsInArray(field,                  defaultFieldSize))

512                    FAIL(FATAL_ERROR_INTERNAL);

513  #endif

514           //       Decide       which       bit    to      look    at      and  find       its       offset

515           if(ones           ==     1)

516                    ones      =     ones;

517           chosen         =   FindNthSetBit(defaultFieldSize,                                  field,((first       %  ones)  +    1));

518           if(chosen             >=     ((defaultFieldSize)                 *    8))

519                    FAIL(FATAL_ERROR_INTERNAL);

520

521           //       Set   this       as     the     trial       prime

522           BN_add_word(bnP,                     chosen      *   2);

523

524           //       Use   MR     to     see     if  this        is  prime

525           if(MillerRabin(bnP,                      rounds,         ktx,    context))

526           {

527                    //    Final         check       is  to      make    sure     that       0     !=   (p-1)  mod  e

528                    //    This       is     the     same    as      -1  !=  p    mod     e     ;   or

529                    //    (e     -   1)     !=   p  mod     e

530                    if((e        <=     3)   ||     (BN_mod_word(bnP,                e)     !=     (e-1)))

531                             return         TRUE;

532           }

533           //       Back     out     the     bit    number

534           BN_sub_word(bnP,                     chosen      *   2);

535

536           //       Clear     the       bit     just    tested

537           ClearBit(field,                   chosen);

538  }

539     //   Ran       out   of     bits       and     couldn't        find    a    prime         in     this  field

540     INSTRUMENT_INC(noPrimeFields);

541     return         FALSE;

542  }

     B.12.2.3.3.11. AdjustPrimeCandiate()

     This function adjusts the candidate prime so that it is odd and > root(2)/2. This allows the product of these

     two numbers to be .5, which, in fixed point notation means that the most significant bit is 1. For this

     routine, the root(2)/2 is approximated with 0xB505 which is, in fixed point is 0.7071075439453125 or an

     error of 0.0001%. Just setting the upper two bits would give a value > 0.75 which is an error of > 6%.

     Family "2.0"                                                      TCG Published                                                       Page 453

     Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                            Part 4: Supporting Routines

     Given the amount of time all the other computations take, reducing              the error  is  not  much  of  a  cost,  but  it

     isn't totally required either.

     The function also puts the number on a field boundary.

543  void

544  AdjustPrimeCandidate(

545        BYTE                      *a,

546        UINT16                    len

547        )

548  {

549        UINT16     highBytes;

550

551        highBytes      =   BYTE_ARRAY_TO_UINT16(a);

552        //   This  is      fixed  point       arithmetic    on   16-bit  values

553        highBytes      =   ((UINT32)highBytes            *  (UINT32)0x4AFB)   >>  16;

554        highBytes      +=      0xB505;

555        UINT16_TO_BYTE_ARRAY(highBytes,                     a);

556        a[len-1]       |=  1;

557  }

     B.12.2.3.3.12. GeneratateRamdomPrime()

558  void

559  GenerateRandomPrime(

560        TPM2B      *p,

561        BN_CTX     *ctx

562  #ifdef      RSA_DEBUG                  //%

563     ,UINT16           field,

564        UINT16         primes

565  #endif                                 //%

566        )

567  {

568        BIGNUM     *bnP;

569        BN_CTX     *context;

570

571        if(ctx     ==  NULL)      context     =  BN_CTX_new();

572        else     context       =  ctx;

573        if(context         ==     NULL)

574              FAIL(FATAL_ERROR_ALLOCATION);

575        BN_CTX_start(context);

576        bnP   =  BN_CTX_get(context);

577

578        while(TRUE)

579        {

580              _cpri__GenerateRandom(p->size,                     p->buffer);

581              p->buffer[p->size-1]               |=  1;

582              p->buffer[0]        |=     0x80;

583              BN_bin2bn(p->buffer,               p->size,   bnP);

584  #ifdef      RSA_DEBUG

585              if(PrimeSelectWithSieve(bnP,                  NULL,  0,  context,   field,  primes))

586  #else

587              if(PrimeSelectWithSieve(bnP,                  NULL,  0,  context))

588  #endif

589                   break;

590        }

591        BnTo2B(p,      bnP,       (UINT16)BN_num_bytes(bnP));

592        BN_CTX_end(context);

593        if(ctx     ==  NULL)

594              BN_CTX_free(context);

595        return;

596  }

597  KDFa_CONTEXT         *

598  KDFaContextStart(

     Page 454                                                  TCG Published                                       Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                       Level  00  Revision 01.16
     Part 4: Supporting Routines                                                                Trusted Platform Module Library

599        KDFa_CONTEXT             *ktx,                //   IN/OUT:       the   context       structure        to  initialize

600        TPM2B                    *seed,               //   IN:   the     seed   for     the  digest  proce

601        TPM_ALG_ID               hashAlg,             //   IN:   the     hash   algorithm

602        TPM2B                    *extra,              //   IN:   the     extra  data

603        UINT32                   *outer,              //   IN:   the     outer  iteration       counter

604        UINT16                   keySizeInBit

605        )

606  {

607        UINT16                          digestSize    =   _cpri__GetDigestSize(hashAlg);

608        TPM2B_HASH_BLOCK                oPadKey;

609

610        if(seed   ==     NULL)

611           return        NULL;

612

613        pAssert(ktx      !=  NULL      &&  outer  !=  NULL  &&      digestSize       !=  0);

614

615     //    Start  the    hash    using     the  seed  and   get     the  intermediate         hash   value

616     _cpri__StartHMAC(hashAlg,                FALSE,  &(ktx->iPadCtx),          seed->size,          seed->buffer,

617                                 &oPadKey.b);

618     _cpri__StartHash(hashAlg,                FALSE,  &(ktx->oPadCtx));

619     _cpri__UpdateHash(&(ktx->oPadCtx),                   oPadKey.b.size,        oPadKey.b.buffer);

620     ktx->extra       =  extra;

621     ktx->hashAlg        =   hashAlg;

622     ktx->outer       =  outer;

623     ktx->keySizeInBits          =     keySizeInBits;

624     return     ktx;

625  }

626  void

627  KDFaContextEnd(

628        KDFa_CONTEXT             *ktx                 //   IN/OUT:       the   context       structure        to  close

629        )

630  {

631        if(ktx    !=  NULL)

632        {

633           //     Close     out  the    hash    sessions

634           _cpri__CompleteHash(&(ktx->iPadCtx),                     0,   NULL);

635           _cpri__CompleteHash(&(ktx->oPadCtx),                     0,   NULL);

636        }

637  }

638  //%#endif

     B.12.2.3.4.     Public Function

     B.12.2.3.4.1.       Introduction

     This is the external entry for this replacement function. All this file provides is the substitute function to

     generate an RSA key. If the compiler settings are set appropriately, this this function will be used instead

     of the similarly named function in CpriRSA.c.

     B.12.2.3.4.2.       _cpri__GenerateKeyRSA()

     Generate an RSA key from a provided seed

     Return Value                             Meaning

     CRYPT_FAIL                               exponent is not prime or is less than 3; or   could  not  find  a  prime using

                                              the provided parameters

     CRYPT_CANCEL                             operation was canceled

639  LIB_EXPORT      CRYPT_RESULT

640  _cpri__GenerateKeyRSA(

     Family "2.0"                                        TCG Published                                                        Page 455

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                         October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

641     TPM2B                         *n,                        //     OUT:     The  public           modulus

642     TPM2B                         *p,                        //     OUT:     One  of        the    prime     factors        of     n

643     UINT16                            keySizeInBits,         //     IN:   Size    of        the    public        modulus       in     bits

644     UINT32                            e,                     //     IN:   The     public           exponent

645     TPM_ALG_ID                        hashAlg,               //     IN:   hash    algorithm              to  use      in  the      key

646                                                              //           generation               process

647     TPM2B                         *seed,                     //     IN:   the     seed         to  use

648     const     char                *label,                    //     IN:   A  label          for    the   generation            process.

649     TPM2B                         *extra,                    //     IN:   Party       1     data    for      the     KDF

650     UINT32                        *counter                   //     IN/OUT:       Counter          value     to      allow     KDF

651                                                              //                   iteration          to      be   propagated           across

652                                                              //                   multiple          routines

653  #ifdef   RSA_DEBUG                                          //%

654     ,UINT16                           primes,                //     IN:   number         of    primes        to   test

655     UINT16                            fieldSize              //     IN:   the     field        size      to  use

656  #endif                                                      //%

657     )

658  {

659     CRYPT_RESULT                           retVal;

660     UINT32                                 myCounter     =   0;

661     UINT32                                *pCtr    =   (counter     ==       NULL)       ?     &myCounter         :   counter;

662

663     KDFa_CONTEXT                           ktx;

664     KDFa_CONTEXT                          *ktxPtr;

665     UINT32                                 i;

666     BIGNUM                                *bnP;

667     BIGNUM                                *bnQ;

668     BIGNUM                                *bnT;

669     BIGNUM                                *bnE;

670     BIGNUM                                *bnN;

671     BN_CTX                                *context;

672

673     //   Make       sure      that    the     required   pointers            are  provided

674     pAssert(n          !=     NULL    &&   p   !=  NULL);

675

676     //   If   the      seed       is  provided,        then  use    KDFa        for      generation          of      the  'random'

677     //   values

678     ktxPtr       =     KDFaContextStart(&ktx,                seed,       hashAlg,           extra,       pCtr,       keySizeInBits);

679

680     n->size         =  keySizeInBits/8;

681     p->size         =  n->size        /   2;

682

683     //   Validate          exponent

684     if(e     ==     0  ||     e   ==  RSA_DEFAULT_PUBLIC_EXPONENT)

685           e   =     RSA_DEFAULT_PUBLIC_EXPONENT;

686     else

687           if(!IsPrimeWord(e))

688                     return        CRYPT_FAIL;

689

690     //   Get     structures           for     the  big   number     representations

691     context         =  BN_CTX_new();

692     BN_CTX_start(context);

693     bnP   =   BN_CTX_get(context);

694     bnQ   =   BN_CTX_get(context);

695     bnT   =   BN_CTX_get(context);

696     bnE   =   BN_CTX_get(context);

697     bnN   =   BN_CTX_get(context);

698     if(bnN       ==    NULL)

699           FAIL(FATAL_ERROR_INTERNAL);

700

701     //   Set     Q     to  zero.      This     is  used  as      a  flag.       The      prime      is   computed         in      P.   When  a

702     //   new     prime        is  found,       Q   is  checked      to    see     if     it    is   zero.         If  so,      P   is   copied

703     //   to   Q     and    a     new  P   is   found.    When       both     P    and       Q  are   non-zero,            the     modulus    and

704     //   private           exponent       are     computed   and    a     trial       encryption/decryption                       is

705     //   performed.               If  the     encrypt/decrypt            fails,       assume        that     at      least     one     of   the

706     //   primes        is     composite.          Since  we  don't        know    which            one,  set      Q   to  zero        and   start

     Page 456                                                    TCG Published                                                                 Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                            Trusted Platform Module Library

707  //      over     and     find       a   new     pair         of   primes.

708  BN_zero(bnQ);

709  BN_set_word(bnE,                    e);

710

711  //      Each     call     to     generate             a   random        value        will         increment        ktx.outer

712  //      it   doesn't         matter         if     ktx.outer            wraps.          This      lets        the  caller

713  //      use     the   initial           value         of     the     counter         for       additional          entropy.

714  for(i        =   0;   i   <   UINT32_MAX;                 i++)

715  {

716          if(_plat__IsCanceled())

717          {

718                   retVal       =     CRYPT_CANCEL;

719                   goto     end;

720          }

721          //      Get   a   random           prime         candidate.

722          if(seed          ==   NULL)

723                   _cpri__GenerateRandom(p->size,                                    p->buffer);

724          else

725                   RandomForRsa(&ktx,                       label,        p);

726          AdjustPrimeCandidate(p->buffer,                                      p->size);

727

728          //      Convert       the       candidate            to      a  BN

729          if(BN_bin2bn(p->buffer,                              p->size,           bnP)     ==       NULL)

730                   FAIL(FATAL_ERROR_INTERNAL);

731          //      If   this     is       the     second        prime,          make       sure      that        it   differs     from  the

732          //      first     prime         by     at     least       2^100.        Since          BIGNUMS        use      words,  the   check

733          //      below     will         make     sure         they       are     different             by  at      least   128  bits

734          if(!BN_is_zero(bnQ))

735          {    //     bnQ   is     non-zero,               we  have       a    first       value

736                   UINT32                     *pP       =   (UINT32           *)(&bnP->d[4]);

737                   UINT32                     *pQ       =   (UINT32           *)(&bnQ->d[4]);

738                   INT32                      k   =     ((INT32)bnP->top)                     -     4;

739                   for(;k       >     0;     k--)

740                           if(*pP++           !=     *pQ++)

741                                   break;

742                   //   Didn't           find     any       difference            so      go     get    a   new      value

743                   if(k     ==     0)

744                           continue;

745          }

746          //      If   PrimeSelectWithSieve                               returns         success,          bnP      is  a  prime,

747  #ifdef  RSA_DEBUG

748          if(!PrimeSelectWithSieve(bnP,                                   ktxPtr,          e,       context,         fieldSize,      primes))

749  #else

750          if(!PrimeSelectWithSieve(bnP,                                   ktxPtr,          e,       context))

751  #endif

752                   continue;                 //   If       not,     get       another

753

754          //      Found     a   prime,           is     this       the    first        or     second.

755          if(BN_is_zero(bnQ))

756          {        //   copy       p     to   q   and       compute           another         prime         in  p

757                   BN_copy(bnQ,               bnP);

758                   continue;

759          }

760          //Form        the     public           modulus

761          if(         BN_mul(bnN,             bnP,         bnQ,     context)           !=     1

762               ||     BN_num_bits(bnN)                     !=  keySizeInBits)

763                   FAIL(FATAL_ERROR_INTERNAL);

764          //   Save     the     public           modulus

765          BnTo2B(n,         bnN,         n->size);

766          //   And     one     prime

767          BnTo2B(p,         bnP,         p->size);

768

769  #ifdef  EXTENDED_CHECKS

770          //      Finish       by     making         sure      that       we      can     form      the     modular         inverse    of  PHI

771          //      with     respect           to   the       public        exponent

772          //      Compute       PHI       =   (p     -     1)(q     -     1)   =  n    -   p     -  q   +   1

     Family "2.0"                                                         TCG Published                                                            Page 457

     Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                                   October 30, 2014
     Trusted Platform Module Library                                                                              Part 4: Supporting Routines

773              //   Make       sure    that  we      can   form       the     modular    inverse

774              if(         BN_sub(bnT,       bnN,    bnP)         !=   1

775                   ||     BN_sub(bnT,       bnT,    bnQ)         !=   1

776                   ||     BN_add_word(bnT,          1)       !=   1)

777                      FAIL(FATAL_ERROR_INTERNAL);

778

779              //   find       d  such     that   (Phi     *   d)     mod     e  ==1

780              //   If     there      isn't  then    we       are     broken        because   we    took   the  step

781              //   of     making      sure  that    the       prime       !=    1  mod  e    so  the     modular  inverse

782              //   must       exist

783              if(         BN_mod_inverse(bnT,                bnE,     bnT,      context)     ==    NULL

784                   ||     BN_is_zero(bnT))

785                      FAIL(FATAL_ERROR_INTERNAL);

786

787              //   And,       finally,      do   a  trial        encryption          decryption

788              {

789                      TPM2B_TYPE(RSA_KEY,                MAX_RSA_KEY_BYTES);

790                      TPM2B_RSA_KEY                       r;

791                      r.t.size        =   sizeof(r.t.buffer);

792                      //   If    we   are   using   a     seed,       then      results      must    be   reproducible   on  each

793                      //   call.      Otherwise,         just     get     a     random  number

794                      if(seed        ==   NULL)

795                              _cpri__GenerateRandom(keySizeInBits/8,                             r.t.buffer);

796                      else

797                              RandomForRsa(&ktx,              label,         &r.b);

798

799                      //   Make      sure   that    the      number       is    smaller      than    the  public  modulus

800                      r.t.buffer[0]         &=      0x7F;

801                                 //   Convert

802                      if(        BN_bin2bn(r.t.buffer,                   r.t.size,      bnP)     ==   NULL

803                                 //   Encrypt       with     the     public        exponent

804                           ||    BN_mod_exp(bnQ,             bnP,     bnE,      bnN,    context)      !=  1

805                                 //   Decrypt       with     the     private       exponent

806                           ||    BN_mod_exp(bnQ,             bnQ,     bnT,      bnN,    context)      !=  1)

807                              FAIL(FATAL_ERROR_INTERNAL);

808                      //   If    the     starting   and       ending         values     are  not     the  same,   start  over  )-;

809                      if(BN_ucmp(bnP,            bnQ)     !=     0)

810                      {

811                              BN_zero(bnQ);

812                              continue;

813                      }

814              }

815  #endif    //    EXTENDED_CHECKS

816              retVal       =     CRYPT_SUCCESS;

817              goto       end;

818        }

819        retVal     =     CRYPT_FAIL;

820

821  end:

822        KDFaContextEnd(&ktx);

823

824        //  Free      up   allocated        BN   values

825        BN_CTX_end(context);

826        BN_CTX_free(context);

827        return     retVal;

828  }

829  #else

830  static    void      noFuntion(

831        void

832        )

833  {

834        pAssert(1);

835  }

836  #endif                             //%

837  #endif    //    TPM_ALG_RSA

     Page 458                                                       TCG Published                                               Family "2.0"

     October 30, 2014                                  Copyright © TCG 2006-2014                                  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                Trusted Platform Module Library

    B.12.2.4.  RSAData.c

1   #include   "OsslCryptoEngine.h"

2   #ifdef     RSA_KEY_SIEVE

3   #include   "RsaKeySieve.h"

4   #ifdef  RSA_DEBUG

5   UINT16     defaultFieldSize  =      MAX_FIELD_SIZE;

6   #endif

    This table contains a pre-sieved table. It has the bits for 3, 5,  and  7  removed. Because of the factors, it

    needs to be aligned to 105 and has a repeat of 105.

7   const   BYTE  seedValues[SEED_VALUES_SIZE]           =  {

8       0x16,     0x29,  0xcb,   0xa4,     0x65,  0xda,  0x30,  0x6c,

9       0x99,     0x96,  0x4c,   0x53,     0xa2,  0x2d,  0x52,  0x96,

10      0x49,     0xcb,  0xb4,   0x61,     0xd8,  0x32,  0x2d,  0x99,

11      0xa6,     0x44,  0x5b,   0xa4,     0x2c,  0x93,  0x96,  0x69,

12      0xc3,     0xb0,  0x65,   0x5a,     0x32,  0x4d,  0x89,  0xb6,

13      0x48,     0x59,  0x26,   0x2d,     0xd3,  0x86,  0x61,  0xcb,

14      0xb4,     0x64,  0x9a,   0x12,     0x6d,  0x91,  0xb2,  0x4c,

15      0x5a,     0xa6,  0x0d,   0xc3,     0x96,  0x69,  0xc9,  0x34,

16      0x25,     0xda,  0x22,   0x65,     0x99,  0xb4,  0x4c,  0x1b,

17      0x86,     0x2d,  0xd3,   0x92,     0x69,  0x4a,  0xb4,  0x45,

18      0xca,     0x32,  0x69,   0x99,     0x36,  0x0c,  0x5b,  0xa6,

19      0x25,     0xd3,  0x94,   0x68,     0x8b,  0x94,  0x65,  0xd2,

20      0x32,     0x6d,  0x18,   0xb6,     0x4c,  0x4b,  0xa6,  0x29,

21      0xd1};

22  const   BYTE  bitsInByte[256]       =  {

23      0x00,     0x01,  0x01,   0x02,     0x01,  0x02,  0x02,  0x03,

24      0x01,     0x02,  0x02,   0x03,     0x02,  0x03,  0x03,  0x04,

25      0x01,     0x02,  0x02,   0x03,     0x02,  0x03,  0x03,  0x04,

26      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

27      0x01,     0x02,  0x02,   0x03,     0x02,  0x03,  0x03,  0x04,

28      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

29      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

30      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

31      0x01,     0x02,  0x02,   0x03,     0x02,  0x03,  0x03,  0x04,

32      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

33      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

34      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

35      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

36      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

37      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

38      0x04,     0x05,  0x05,   0x06,     0x05,  0x06,  0x06,  0x07,

39      0x01,     0x02,  0x02,   0x03,     0x02,  0x03,  0x03,  0x04,

40      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

41      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

42      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

43      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

44      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

45      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

46      0x04,     0x05,  0x05,   0x06,     0x05,  0x06,  0x06,  0x07,

47      0x02,     0x03,  0x03,   0x04,     0x03,  0x04,  0x04,  0x05,

48      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

49      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

50      0x04,     0x05,  0x05,   0x06,     0x05,  0x06,  0x06,  0x07,

51      0x03,     0x04,  0x04,   0x05,     0x04,  0x05,  0x05,  0x06,

52      0x04,     0x05,  0x05,   0x06,     0x05,  0x06,  0x06,  0x07,

53      0x04,     0x05,  0x05,   0x06,     0x05,  0x06,  0x06,  0x07,

54      0x05,     0x06,  0x06,   0x07,     0x06,  0x07,  0x07,  0x08

55  };

    Family "2.0"                                  TCG Published                Page 459

    Level 00 Revision 01.16                   Copyright © TCG 2006-2014        October 30, 2014
     Trusted Platform Module Library                                      Part 4: Supporting Routines

     Following table contains a byte that is the difference between two successive primes. This reduces the

     table size by a factor of two. It is optimized for sequential access to the prime table which is the most

     common case.

     When the table size is at its max, the table will have all primes less than 2^16. This is 6542 primes in

     6542 bytes.

56   const     UINT16  primeTableBytes        =  PRIME_DIFF_TABLE_BYTES;

57   #if  PRIME_DIFF_TABLE_BYTES      >  0

58   const     BYTE  primeDiffTable   [PRIME_DIFF_TABLE_BYTES]  =  {

59        0x02,0x02,0x02,0x04,0x02,0x04,0x02,0x04,0x06,0x02,0x06,0x04,0x02,0x04,0x06,0x06,

60        0x02,0x06,0x04,0x02,0x06,0x04,0x06,0x08,0x04,0x02,0x04,0x02,0x04,0x0E,0x04,0x06,

61        0x02,0x0A,0x02,0x06,0x06,0x04,0x06,0x06,0x02,0x0A,0x02,0x04,0x02,0x0C,0x0C,0x04,

62        0x02,0x04,0x06,0x02,0x0A,0x06,0x06,0x06,0x02,0x06,0x04,0x02,0x0A,0x0E,0x04,0x02,

63        0x04,0x0E,0x06,0x0A,0x02,0x04,0x06,0x08,0x06,0x06,0x04,0x06,0x08,0x04,0x08,0x0A,

64        0x02,0x0A,0x02,0x06,0x04,0x06,0x08,0x04,0x02,0x04,0x0C,0x08,0x04,0x08,0x04,0x06,

65        0x0C,0x02,0x12,0x06,0x0A,0x06,0x06,0x02,0x06,0x0A,0x06,0x06,0x02,0x06,0x06,0x04,

66        0x02,0x0C,0x0A,0x02,0x04,0x06,0x06,0x02,0x0C,0x04,0x06,0x08,0x0A,0x08,0x0A,0x08,

67        0x06,0x06,0x04,0x08,0x06,0x04,0x08,0x04,0x0E,0x0A,0x0C,0x02,0x0A,0x02,0x04,0x02,

68        0x0A,0x0E,0x04,0x02,0x04,0x0E,0x04,0x02,0x04,0x14,0x04,0x08,0x0A,0x08,0x04,0x06,

69        0x06,0x0E,0x04,0x06,0x06,0x08,0x06,0x0C,0x04,0x06,0x02,0x0A,0x02,0x06,0x0A,0x02,

70        0x0A,0x02,0x06,0x12,0x04,0x02,0x04,0x06,0x06,0x08,0x06,0x06,0x16,0x02,0x0A,0x08,

71        0x0A,0x06,0x06,0x08,0x0C,0x04,0x06,0x06,0x02,0x06,0x0C,0x0A,0x12,0x02,0x04,0x06,

72        0x02,0x06,0x04,0x02,0x04,0x0C,0x02,0x06,0x22,0x06,0x06,0x08,0x12,0x0A,0x0E,0x04,

73        0x02,0x04,0x06,0x08,0x04,0x02,0x06,0x0C,0x0A,0x02,0x04,0x02,0x04,0x06,0x0C,0x0C,

74        0x08,0x0C,0x06,0x04,0x06,0x08,0x04,0x08,0x04,0x0E,0x04,0x06,0x02,0x04,0x06,0x02

75   #endif

76   //   256

77   #if  PRIME_DIFF_TABLE_BYTES      >  256

78       ,0x06,0x0A,0x14,0x06,0x04,0x02,0x18,0x04,0x02,0x0A,0x0C,0x02,0x0A,0x08,0x06,0x06,

79        0x06,0x12,0x06,0x04,0x02,0x0C,0x0A,0x0C,0x08,0x10,0x0E,0x06,0x04,0x02,0x04,0x02,

80        0x0A,0x0C,0x06,0x06,0x12,0x02,0x10,0x02,0x16,0x06,0x08,0x06,0x04,0x02,0x04,0x08,

81        0x06,0x0A,0x02,0x0A,0x0E,0x0A,0x06,0x0C,0x02,0x04,0x02,0x0A,0x0C,0x02,0x10,0x02,

82        0x06,0x04,0x02,0x0A,0x08,0x12,0x18,0x04,0x06,0x08,0x10,0x02,0x04,0x08,0x10,0x02,

83        0x04,0x08,0x06,0x06,0x04,0x0C,0x02,0x16,0x06,0x02,0x06,0x04,0x06,0x0E,0x06,0x04,

84        0x02,0x06,0x04,0x06,0x0C,0x06,0x06,0x0E,0x04,0x06,0x0C,0x08,0x06,0x04,0x1A,0x12,

85        0x0A,0x08,0x04,0x06,0x02,0x06,0x16,0x0C,0x02,0x10,0x08,0x04,0x0C,0x0E,0x0A,0x02,

86        0x04,0x08,0x06,0x06,0x04,0x02,0x04,0x06,0x08,0x04,0x02,0x06,0x0A,0x02,0x0A,0x08,

87        0x04,0x0E,0x0A,0x0C,0x02,0x06,0x04,0x02,0x10,0x0E,0x04,0x06,0x08,0x06,0x04,0x12,

88        0x08,0x0A,0x06,0x06,0x08,0x0A,0x0C,0x0E,0x04,0x06,0x06,0x02,0x1C,0x02,0x0A,0x08,

89        0x04,0x0E,0x04,0x08,0x0C,0x06,0x0C,0x04,0x06,0x14,0x0A,0x02,0x10,0x1A,0x04,0x02,

90        0x0C,0x06,0x04,0x0C,0x06,0x08,0x04,0x08,0x16,0x02,0x04,0x02,0x0C,0x1C,0x02,0x06,

91        0x06,0x06,0x04,0x06,0x02,0x0C,0x04,0x0C,0x02,0x0A,0x02,0x10,0x02,0x10,0x06,0x14,

92        0x10,0x08,0x04,0x02,0x04,0x02,0x16,0x08,0x0C,0x06,0x0A,0x02,0x04,0x06,0x02,0x06,

93        0x0A,0x02,0x0C,0x0A,0x02,0x0A,0x0E,0x06,0x04,0x06,0x08,0x06,0x06,0x10,0x0C,0x02

94   #endif

95   //   512

96   #if  PRIME_DIFF_TABLE_BYTES      >  512

97       ,0x04,0x0E,0x06,0x04,0x08,0x0A,0x08,0x06,0x06,0x16,0x06,0x02,0x0A,0x0E,0x04,0x06,

98        0x12,0x02,0x0A,0x0E,0x04,0x02,0x0A,0x0E,0x04,0x08,0x12,0x04,0x06,0x02,0x04,0x06,

99        0x02,0x0C,0x04,0x14,0x16,0x0C,0x02,0x04,0x06,0x06,0x02,0x06,0x16,0x02,0x06,0x10,

100       0x06,0x0C,0x02,0x06,0x0C,0x10,0x02,0x04,0x06,0x0E,0x04,0x02,0x12,0x18,0x0A,0x06,

101       0x02,0x0A,0x02,0x0A,0x02,0x0A,0x06,0x02,0x0A,0x02,0x0A,0x06,0x08,0x1E,0x0A,0x02,

102       0x0A,0x08,0x06,0x0A,0x12,0x06,0x0C,0x0C,0x02,0x12,0x06,0x04,0x06,0x06,0x12,0x02,

103       0x0A,0x0E,0x06,0x04,0x02,0x04,0x18,0x02,0x0C,0x06,0x10,0x08,0x06,0x06,0x12,0x10,

104       0x02,0x04,0x06,0x02,0x06,0x06,0x0A,0x06,0x0C,0x0C,0x12,0x02,0x06,0x04,0x12,0x08,

105       0x18,0x04,0x02,0x04,0x06,0x02,0x0C,0x04,0x0E,0x1E,0x0A,0x06,0x0C,0x0E,0x06,0x0A,

106       0x0C,0x02,0x04,0x06,0x08,0x06,0x0A,0x02,0x04,0x0E,0x06,0x06,0x04,0x06,0x02,0x0A,

107       0x02,0x10,0x0C,0x08,0x12,0x04,0x06,0x0C,0x02,0x06,0x06,0x06,0x1C,0x06,0x0E,0x04,

108       0x08,0x0A,0x08,0x0C,0x12,0x04,0x02,0x04,0x18,0x0C,0x06,0x02,0x10,0x06,0x06,0x0E,

109       0x0A,0x0E,0x04,0x1E,0x06,0x06,0x06,0x08,0x06,0x04,0x02,0x0C,0x06,0x04,0x02,0x06,

110       0x16,0x06,0x02,0x04,0x12,0x02,0x04,0x0C,0x02,0x06,0x04,0x1A,0x06,0x06,0x04,0x08,

111       0x0A,0x20,0x10,0x02,0x06,0x04,0x02,0x04,0x02,0x0A,0x0E,0x06,0x04,0x08,0x0A,0x06,

112       0x14,0x04,0x02,0x06,0x1E,0x04,0x08,0x0A,0x06,0x06,0x08,0x06,0x0C,0x04,0x06,0x02

113  #endif

     Page 460                                    TCG Published            Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014     Level 00 Revision 01.16
     Part 4: Supporting Routines                                Trusted Platform Module Library

114  //   768

115  #if  PRIME_DIFF_TABLE_BYTES  >  768

116      ,0x06,0x04,0x06,0x02,0x0A,0x02,0x10,0x06,0x14,0x04,0x0C,0x0E,0x1C,0x06,0x14,0x04,

117       0x12,0x08,0x06,0x04,0x06,0x0E,0x06,0x06,0x0A,0x02,0x0A,0x0C,0x08,0x0A,0x02,0x0A,

118       0x08,0x0C,0x0A,0x18,0x02,0x04,0x08,0x06,0x04,0x08,0x12,0x0A,0x06,0x06,0x02,0x06,

119       0x0A,0x0C,0x02,0x0A,0x06,0x06,0x06,0x08,0x06,0x0A,0x06,0x02,0x06,0x06,0x06,0x0A,

120       0x08,0x18,0x06,0x16,0x02,0x12,0x04,0x08,0x0A,0x1E,0x08,0x12,0x04,0x02,0x0A,0x06,

121       0x02,0x06,0x04,0x12,0x08,0x0C,0x12,0x10,0x06,0x02,0x0C,0x06,0x0A,0x02,0x0A,0x02,

122       0x06,0x0A,0x0E,0x04,0x18,0x02,0x10,0x02,0x0A,0x02,0x0A,0x14,0x04,0x02,0x04,0x08,

123       0x10,0x06,0x06,0x02,0x0C,0x10,0x08,0x04,0x06,0x1E,0x02,0x0A,0x02,0x06,0x04,0x06,

124       0x06,0x08,0x06,0x04,0x0C,0x06,0x08,0x0C,0x04,0x0E,0x0C,0x0A,0x18,0x06,0x0C,0x06,

125       0x02,0x16,0x08,0x12,0x0A,0x06,0x0E,0x04,0x02,0x06,0x0A,0x08,0x06,0x04,0x06,0x1E,

126       0x0E,0x0A,0x02,0x0C,0x0A,0x02,0x10,0x02,0x12,0x18,0x12,0x06,0x10,0x12,0x06,0x02,

127       0x12,0x04,0x06,0x02,0x0A,0x08,0x0A,0x06,0x06,0x08,0x04,0x06,0x02,0x0A,0x02,0x0C,

128       0x04,0x06,0x06,0x02,0x0C,0x04,0x0E,0x12,0x04,0x06,0x14,0x04,0x08,0x06,0x04,0x08,

129       0x04,0x0E,0x06,0x04,0x0E,0x0C,0x04,0x02,0x1E,0x04,0x18,0x06,0x06,0x0C,0x0C,0x0E,

130       0x06,0x04,0x02,0x04,0x12,0x06,0x0C,0x08,0x06,0x04,0x0C,0x02,0x0C,0x1E,0x10,0x02,

131       0x06,0x16,0x0E,0x06,0x0A,0x0C,0x06,0x02,0x04,0x08,0x0A,0x06,0x06,0x18,0x0E,0x06

132  #endif

133  //   1024

134  #if  PRIME_DIFF_TABLE_BYTES  >  1024

135      ,0x04,0x08,0x0C,0x12,0x0A,0x02,0x0A,0x02,0x04,0x06,0x14,0x06,0x04,0x0E,0x04,0x02,

136       0x04,0x0E,0x06,0x0C,0x18,0x0A,0x06,0x08,0x0A,0x02,0x1E,0x04,0x06,0x02,0x0C,0x04,

137       0x0E,0x06,0x22,0x0C,0x08,0x06,0x0A,0x02,0x04,0x14,0x0A,0x08,0x10,0x02,0x0A,0x0E,

138       0x04,0x02,0x0C,0x06,0x10,0x06,0x08,0x04,0x08,0x04,0x06,0x08,0x06,0x06,0x0C,0x06,

139       0x04,0x06,0x06,0x08,0x12,0x04,0x14,0x04,0x0C,0x02,0x0A,0x06,0x02,0x0A,0x0C,0x02,

140       0x04,0x14,0x06,0x1E,0x06,0x04,0x08,0x0A,0x0C,0x06,0x02,0x1C,0x02,0x06,0x04,0x02,

141       0x10,0x0C,0x02,0x06,0x0A,0x08,0x18,0x0C,0x06,0x12,0x06,0x04,0x0E,0x06,0x04,0x0C,

142       0x08,0x06,0x0C,0x04,0x06,0x0C,0x06,0x0C,0x02,0x10,0x14,0x04,0x02,0x0A,0x12,0x08,

143       0x04,0x0E,0x04,0x02,0x06,0x16,0x06,0x0E,0x06,0x06,0x0A,0x06,0x02,0x0A,0x02,0x04,

144       0x02,0x16,0x02,0x04,0x06,0x06,0x0C,0x06,0x0E,0x0A,0x0C,0x06,0x08,0x04,0x24,0x0E,

145       0x0C,0x06,0x04,0x06,0x02,0x0C,0x06,0x0C,0x10,0x02,0x0A,0x08,0x16,0x02,0x0C,0x06,

146       0x04,0x06,0x12,0x02,0x0C,0x06,0x04,0x0C,0x08,0x06,0x0C,0x04,0x06,0x0C,0x06,0x02,

147       0x0C,0x0C,0x04,0x0E,0x06,0x10,0x06,0x02,0x0A,0x08,0x12,0x06,0x22,0x02,0x1C,0x02,

148       0x16,0x06,0x02,0x0A,0x0C,0x02,0x06,0x04,0x08,0x16,0x06,0x02,0x0A,0x08,0x04,0x06,

149       0x08,0x04,0x0C,0x12,0x0C,0x14,0x04,0x06,0x06,0x08,0x04,0x02,0x10,0x0C,0x02,0x0A,

150       0x08,0x0A,0x02,0x04,0x06,0x0E,0x0C,0x16,0x08,0x1C,0x02,0x04,0x14,0x04,0x02,0x04

151  #endif

152  //   1280

153  #if  PRIME_DIFF_TABLE_BYTES  >  1280

154      ,0x0E,0x0A,0x0C,0x02,0x0C,0x10,0x02,0x1C,0x08,0x16,0x08,0x04,0x06,0x06,0x0E,0x04,

155       0x08,0x0C,0x06,0x06,0x04,0x14,0x04,0x12,0x02,0x0C,0x06,0x04,0x06,0x0E,0x12,0x0A,

156       0x08,0x0A,0x20,0x06,0x0A,0x06,0x06,0x02,0x06,0x10,0x06,0x02,0x0C,0x06,0x1C,0x02,

157       0x0A,0x08,0x10,0x06,0x08,0x06,0x0A,0x18,0x14,0x0A,0x02,0x0A,0x02,0x0C,0x04,0x06,

158       0x14,0x04,0x02,0x0C,0x12,0x0A,0x02,0x0A,0x02,0x04,0x14,0x10,0x1A,0x04,0x08,0x06,

159       0x04,0x0C,0x06,0x08,0x0C,0x0C,0x06,0x04,0x08,0x16,0x02,0x10,0x0E,0x0A,0x06,0x0C,

160       0x0C,0x0E,0x06,0x04,0x14,0x04,0x0C,0x06,0x02,0x06,0x06,0x10,0x08,0x16,0x02,0x1C,

161       0x08,0x06,0x04,0x14,0x04,0x0C,0x18,0x14,0x04,0x08,0x0A,0x02,0x10,0x02,0x0C,0x0C,

162       0x22,0x02,0x04,0x06,0x0C,0x06,0x06,0x08,0x06,0x04,0x02,0x06,0x18,0x04,0x14,0x0A,

163       0x06,0x06,0x0E,0x04,0x06,0x06,0x02,0x0C,0x06,0x0A,0x02,0x0A,0x06,0x14,0x04,0x1A,

164       0x04,0x02,0x06,0x16,0x02,0x18,0x04,0x06,0x02,0x04,0x06,0x18,0x06,0x08,0x04,0x02,

165       0x22,0x06,0x08,0x10,0x0C,0x02,0x0A,0x02,0x0A,0x06,0x08,0x04,0x08,0x0C,0x16,0x06,

166       0x0E,0x04,0x1A,0x04,0x02,0x0C,0x0A,0x08,0x04,0x08,0x0C,0x04,0x0E,0x06,0x10,0x06,

167       0x08,0x04,0x06,0x06,0x08,0x06,0x0A,0x0C,0x02,0x06,0x06,0x10,0x08,0x06,0x06,0x0C,

168       0x0A,0x02,0x06,0x12,0x04,0x06,0x06,0x06,0x0C,0x12,0x08,0x06,0x0A,0x08,0x12,0x04,

169       0x0E,0x06,0x12,0x0A,0x08,0x0A,0x0C,0x02,0x06,0x0C,0x0C,0x24,0x04,0x06,0x08,0x04

170  #endif

171  //   1536

172  #if  PRIME_DIFF_TABLE_BYTES  >  1536

173      ,0x06,0x02,0x04,0x12,0x0C,0x06,0x08,0x06,0x06,0x04,0x12,0x02,0x04,0x02,0x18,0x04,

174       0x06,0x06,0x0E,0x1E,0x06,0x04,0x06,0x0C,0x06,0x14,0x04,0x08,0x04,0x08,0x06,0x06,

175       0x04,0x1E,0x02,0x0A,0x0C,0x08,0x0A,0x08,0x18,0x06,0x0C,0x04,0x0E,0x04,0x06,0x02,

176       0x1C,0x0E,0x10,0x02,0x0C,0x06,0x04,0x14,0x0A,0x06,0x06,0x06,0x08,0x0A,0x0C,0x0E,

177       0x0A,0x0E,0x10,0x0E,0x0A,0x0E,0x06,0x10,0x06,0x08,0x06,0x10,0x14,0x0A,0x02,0x06,

178       0x04,0x02,0x04,0x0C,0x02,0x0A,0x02,0x06,0x16,0x06,0x02,0x04,0x12,0x08,0x0A,0x08,

179       0x16,0x02,0x0A,0x12,0x0E,0x04,0x02,0x04,0x12,0x02,0x04,0x06,0x08,0x0A,0x02,0x1E,

     Family "2.0"                          TCG Published                                   Page 461

     Level 00 Revision 01.16         Copyright © TCG 2006-2014  October 30, 2014
     Trusted Platform Module Library                                Part 4: Supporting Routines

180       0x04,0x1E,0x02,0x0A,0x02,0x12,0x04,0x12,0x06,0x0E,0x0A,0x02,0x04,0x14,0x24,0x06,

181       0x04,0x06,0x0E,0x04,0x14,0x0A,0x0E,0x16,0x06,0x02,0x1E,0x0C,0x0A,0x12,0x02,0x04,

182       0x0E,0x06,0x16,0x12,0x02,0x0C,0x06,0x04,0x08,0x04,0x08,0x06,0x0A,0x02,0x0C,0x12,

183       0x0A,0x0E,0x10,0x0E,0x04,0x06,0x06,0x02,0x06,0x04,0x02,0x1C,0x02,0x1C,0x06,0x02,

184       0x04,0x06,0x0E,0x04,0x0C,0x0E,0x10,0x0E,0x04,0x06,0x08,0x06,0x04,0x06,0x06,0x06,

185       0x08,0x04,0x08,0x04,0x0E,0x10,0x08,0x06,0x04,0x0C,0x08,0x10,0x02,0x0A,0x08,0x04,

186       0x06,0x1A,0x06,0x0A,0x08,0x04,0x06,0x0C,0x0E,0x1E,0x04,0x0E,0x16,0x08,0x0C,0x04,

187       0x06,0x08,0x0A,0x06,0x0E,0x0A,0x06,0x02,0x0A,0x0C,0x0C,0x0E,0x06,0x06,0x12,0x0A,

188       0x06,0x08,0x12,0x04,0x06,0x02,0x06,0x0A,0x02,0x0A,0x08,0x06,0x06,0x0A,0x02,0x12

189  #endif

190  //   1792

191  #if  PRIME_DIFF_TABLE_BYTES      >  1792

192      ,0x0A,0x02,0x0C,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x0C,0x04,0x08,0x0A,0x06,0x06,0x14,

193       0x04,0x0E,0x10,0x0E,0x0A,0x08,0x0A,0x0C,0x02,0x12,0x06,0x0C,0x0A,0x0C,0x02,0x04,

194       0x02,0x0C,0x06,0x04,0x08,0x04,0x2C,0x04,0x02,0x04,0x02,0x0A,0x0C,0x06,0x06,0x0E,

195       0x04,0x06,0x06,0x06,0x08,0x06,0x24,0x12,0x04,0x06,0x02,0x0C,0x06,0x06,0x06,0x04,

196       0x0E,0x16,0x0C,0x02,0x12,0x0A,0x06,0x1A,0x18,0x04,0x02,0x04,0x02,0x04,0x0E,0x04,

197       0x06,0x06,0x08,0x10,0x0C,0x02,0x2A,0x04,0x02,0x04,0x18,0x06,0x06,0x02,0x12,0x04,

198       0x0E,0x06,0x1C,0x12,0x0E,0x06,0x0A,0x0C,0x02,0x06,0x0C,0x1E,0x06,0x04,0x06,0x06,

199       0x0E,0x04,0x02,0x18,0x04,0x06,0x06,0x1A,0x0A,0x12,0x06,0x08,0x06,0x06,0x1E,0x04,

200       0x0C,0x0C,0x02,0x10,0x02,0x06,0x04,0x0C,0x12,0x02,0x06,0x04,0x1A,0x0C,0x06,0x0C,

201       0x04,0x18,0x18,0x0C,0x06,0x02,0x0C,0x1C,0x08,0x04,0x06,0x0C,0x02,0x12,0x06,0x04,

202       0x06,0x06,0x14,0x10,0x02,0x06,0x06,0x12,0x0A,0x06,0x02,0x04,0x08,0x06,0x06,0x18,

203       0x10,0x06,0x08,0x0A,0x06,0x0E,0x16,0x08,0x10,0x06,0x02,0x0C,0x04,0x02,0x16,0x08,

204       0x12,0x22,0x02,0x06,0x12,0x04,0x06,0x06,0x08,0x0A,0x08,0x12,0x06,0x04,0x02,0x04,

205       0x08,0x10,0x02,0x0C,0x0C,0x06,0x12,0x04,0x06,0x06,0x06,0x02,0x06,0x0C,0x0A,0x14,

206       0x0C,0x12,0x04,0x06,0x02,0x10,0x02,0x0A,0x0E,0x04,0x1E,0x02,0x0A,0x0C,0x02,0x18,

207       0x06,0x10,0x08,0x0A,0x02,0x0C,0x16,0x06,0x02,0x10,0x14,0x0A,0x02,0x0C,0x0C,0x00

208  #endif

209  //   2048

210  #if  PRIME_DIFF_TABLE_BYTES      >  2048

211      ,0x12,0x0A,0x0C,0x06,0x02,0x0A,0x02,0x06,0x0A,0x12,0x02,0x0C,0x06,0x04,0x06,0x02,

212       0x18,0x1C,0x02,0x04,0x02,0x0A,0x02,0x10,0x0C,0x08,0x16,0x02,0x06,0x04,0x02,0x0A,

213       0x06,0x14,0x0C,0x0A,0x08,0x0C,0x06,0x06,0x06,0x04,0x12,0x02,0x04,0x0C,0x12,0x02,

214       0x0C,0x06,0x04,0x02,0x10,0x0C,0x0C,0x0E,0x04,0x08,0x12,0x04,0x0C,0x0E,0x06,0x06,

215       0x04,0x08,0x06,0x04,0x14,0x0C,0x0A,0x0E,0x04,0x02,0x10,0x02,0x0C,0x1E,0x04,0x06,

216       0x18,0x14,0x18,0x0A,0x08,0x0C,0x0A,0x0C,0x06,0x0C,0x0C,0x06,0x08,0x10,0x0E,0x06,

217       0x04,0x06,0x24,0x14,0x0A,0x1E,0x0C,0x02,0x04,0x02,0x1C,0x0C,0x0E,0x06,0x16,0x08,

218       0x04,0x12,0x06,0x0E,0x12,0x04,0x06,0x02,0x06,0x22,0x12,0x02,0x10,0x06,0x12,0x02,

219       0x18,0x04,0x02,0x06,0x0C,0x06,0x0C,0x0A,0x08,0x06,0x10,0x0C,0x08,0x0A,0x0E,0x28,

220       0x06,0x02,0x06,0x04,0x0C,0x0E,0x04,0x02,0x04,0x02,0x04,0x08,0x06,0x0A,0x06,0x06,

221       0x02,0x06,0x06,0x06,0x0C,0x06,0x18,0x0A,0x02,0x0A,0x06,0x0C,0x06,0x06,0x0E,0x06,

222       0x06,0x34,0x14,0x06,0x0A,0x02,0x0A,0x08,0x0A,0x0C,0x0C,0x02,0x06,0x04,0x0E,0x10,

223       0x08,0x0C,0x06,0x16,0x02,0x0A,0x08,0x06,0x16,0x02,0x16,0x06,0x08,0x0A,0x0C,0x0C,

224       0x02,0x0A,0x06,0x0C,0x02,0x04,0x0E,0x0A,0x02,0x06,0x12,0x04,0x0C,0x08,0x12,0x0C,

225       0x06,0x06,0x04,0x06,0x06,0x0E,0x04,0x02,0x0C,0x0C,0x04,0x06,0x12,0x12,0x0C,0x02,

226       0x10,0x0C,0x08,0x12,0x0A,0x1A,0x04,0x06,0x08,0x06,0x06,0x04,0x02,0x0A,0x14,0x04

227  #endif

228  //   2304

229  #if  PRIME_DIFF_TABLE_BYTES      >  2304

230      ,0x06,0x08,0x04,0x14,0x0A,0x02,0x22,0x02,0x04,0x18,0x02,0x0C,0x0C,0x0A,0x06,0x02,

231       0x0C,0x1E,0x06,0x0C,0x10,0x0C,0x02,0x16,0x12,0x0C,0x0E,0x0A,0x02,0x0C,0x0C,0x04,

232       0x02,0x04,0x06,0x0C,0x02,0x10,0x12,0x02,0x28,0x08,0x10,0x06,0x08,0x0A,0x02,0x04,

233       0x12,0x08,0x0A,0x08,0x0C,0x04,0x12,0x02,0x12,0x0A,0x02,0x04,0x02,0x04,0x08,0x1C,

234       0x02,0x06,0x16,0x0C,0x06,0x0E,0x12,0x04,0x06,0x08,0x06,0x06,0x0A,0x08,0x04,0x02,

235       0x12,0x0A,0x06,0x14,0x16,0x08,0x06,0x1E,0x04,0x02,0x04,0x12,0x06,0x1E,0x02,0x04,

236       0x08,0x06,0x04,0x06,0x0C,0x0E,0x22,0x0E,0x06,0x04,0x02,0x06,0x04,0x0E,0x04,0x02,

237       0x06,0x1C,0x02,0x04,0x06,0x08,0x0A,0x02,0x0A,0x02,0x0A,0x02,0x04,0x1E,0x02,0x0C,

238       0x0C,0x0A,0x12,0x0C,0x0E,0x0A,0x02,0x0C,0x06,0x0A,0x06,0x0E,0x0C,0x04,0x0E,0x04,

239       0x12,0x02,0x0A,0x08,0x04,0x08,0x0A,0x0C,0x12,0x12,0x08,0x06,0x12,0x10,0x0E,0x06,

240       0x06,0x0A,0x0E,0x04,0x06,0x02,0x0C,0x0C,0x04,0x06,0x06,0x0C,0x02,0x10,0x02,0x0C,

241       0x06,0x04,0x0E,0x06,0x04,0x02,0x0C,0x12,0x04,0x24,0x12,0x0C,0x0C,0x02,0x04,0x02,

242       0x04,0x08,0x0C,0x04,0x24,0x06,0x12,0x02,0x0C,0x0A,0x06,0x0C,0x18,0x08,0x06,0x06,

243       0x10,0x0C,0x02,0x12,0x0A,0x14,0x0A,0x02,0x06,0x12,0x04,0x02,0x28,0x06,0x02,0x10,

244       0x02,0x04,0x08,0x12,0x0A,0x0C,0x06,0x02,0x0A,0x08,0x04,0x06,0x0C,0x02,0x0A,0x12,

245       0x08,0x06,0x04,0x14,0x04,0x06,0x24,0x06,0x02,0x0A,0x06,0x18,0x06,0x0E,0x10,0x06

     Page 462                                  TCG Published        Family "2.0"

     October 30, 2014                    Copyright © TCG 2006-2014  Level 00 Revision 01.16
     Part 4: Supporting Routines                                Trusted Platform Module Library

246  #endif

247  //   2560

248  #if  PRIME_DIFF_TABLE_BYTES  >  2560

249      ,0x12,0x02,0x0A,0x14,0x0A,0x08,0x06,0x04,0x06,0x02,0x0A,0x02,0x0C,0x04,0x02,0x04,

250       0x08,0x0A,0x06,0x0C,0x12,0x0E,0x0C,0x10,0x08,0x06,0x10,0x08,0x04,0x02,0x06,0x12,

251       0x18,0x12,0x0A,0x0C,0x02,0x04,0x0E,0x0A,0x06,0x06,0x06,0x12,0x0C,0x02,0x1C,0x12,

252       0x0E,0x10,0x0C,0x0E,0x18,0x0C,0x16,0x06,0x02,0x0A,0x08,0x04,0x02,0x04,0x0E,0x0C,

253       0x06,0x04,0x06,0x0E,0x04,0x02,0x04,0x1E,0x06,0x02,0x06,0x0A,0x02,0x1E,0x16,0x02,

254       0x04,0x06,0x08,0x06,0x06,0x10,0x0C,0x0C,0x06,0x08,0x04,0x02,0x18,0x0C,0x04,0x06,

255       0x08,0x06,0x06,0x0A,0x02,0x06,0x0C,0x1C,0x0E,0x06,0x04,0x0C,0x08,0x06,0x0C,0x04,

256       0x06,0x0E,0x06,0x0C,0x0A,0x06,0x06,0x08,0x06,0x06,0x04,0x02,0x04,0x08,0x0C,0x04,

257       0x0E,0x12,0x0A,0x02,0x10,0x06,0x14,0x06,0x0A,0x08,0x04,0x1E,0x24,0x0C,0x08,0x16,

258       0x0C,0x02,0x06,0x0C,0x10,0x06,0x06,0x02,0x12,0x04,0x1A,0x04,0x08,0x12,0x0A,0x08,

259       0x0A,0x06,0x0E,0x04,0x14,0x16,0x12,0x0C,0x08,0x1C,0x0C,0x06,0x06,0x08,0x06,0x0C,

260       0x18,0x10,0x0E,0x04,0x0E,0x0C,0x06,0x0A,0x0C,0x14,0x06,0x04,0x08,0x12,0x0C,0x12,

261       0x0A,0x02,0x04,0x14,0x0A,0x0E,0x04,0x06,0x02,0x0A,0x18,0x12,0x02,0x04,0x14,0x10,

262       0x0E,0x0A,0x0E,0x06,0x04,0x06,0x14,0x06,0x0A,0x06,0x02,0x0C,0x06,0x1E,0x0A,0x08,

263       0x06,0x04,0x06,0x08,0x28,0x02,0x04,0x02,0x0C,0x12,0x04,0x06,0x08,0x0A,0x06,0x12,

264       0x12,0x02,0x0C,0x10,0x08,0x06,0x04,0x06,0x06,0x02,0x34,0x0E,0x04,0x14,0x10,0x02

265  #endif

266  //   2816

267  #if  PRIME_DIFF_TABLE_BYTES  >  2816

268      ,0x04,0x06,0x0C,0x02,0x06,0x0C,0x0C,0x06,0x04,0x0E,0x0A,0x06,0x06,0x0E,0x0A,0x0E,

269       0x10,0x08,0x06,0x0C,0x04,0x08,0x16,0x06,0x02,0x12,0x16,0x06,0x02,0x12,0x06,0x10,

270       0x0E,0x0A,0x06,0x0C,0x02,0x06,0x04,0x08,0x12,0x0C,0x10,0x02,0x04,0x0E,0x04,0x08,

271       0x0C,0x0C,0x1E,0x10,0x08,0x04,0x02,0x06,0x16,0x0C,0x08,0x0A,0x06,0x06,0x06,0x0E,

272       0x06,0x12,0x0A,0x0C,0x02,0x0A,0x02,0x04,0x1A,0x04,0x0C,0x08,0x04,0x12,0x08,0x0A,

273       0x0E,0x10,0x06,0x06,0x08,0x0A,0x06,0x08,0x06,0x0C,0x0A,0x14,0x0A,0x08,0x04,0x0C,

274       0x1A,0x12,0x04,0x0C,0x12,0x06,0x1E,0x06,0x08,0x06,0x16,0x0C,0x02,0x04,0x06,0x06,

275       0x02,0x0A,0x02,0x04,0x06,0x06,0x02,0x06,0x16,0x12,0x06,0x12,0x0C,0x08,0x0C,0x06,

276       0x0A,0x0C,0x02,0x10,0x02,0x0A,0x02,0x0A,0x12,0x06,0x14,0x04,0x02,0x06,0x16,0x06,

277       0x06,0x12,0x06,0x0E,0x0C,0x10,0x02,0x06,0x06,0x04,0x0E,0x0C,0x04,0x02,0x12,0x10,

278       0x24,0x0C,0x06,0x0E,0x1C,0x02,0x0C,0x06,0x0C,0x06,0x04,0x02,0x10,0x1E,0x08,0x18,

279       0x06,0x1E,0x0A,0x02,0x12,0x04,0x06,0x0C,0x08,0x16,0x02,0x06,0x16,0x12,0x02,0x0A,

280       0x02,0x0A,0x1E,0x02,0x1C,0x06,0x0E,0x10,0x06,0x14,0x10,0x02,0x06,0x04,0x20,0x04,

281       0x02,0x04,0x06,0x02,0x0C,0x04,0x06,0x06,0x0C,0x02,0x06,0x04,0x06,0x08,0x06,0x04,

282       0x14,0x04,0x20,0x0A,0x08,0x10,0x02,0x16,0x02,0x04,0x06,0x08,0x06,0x10,0x0E,0x04,

283       0x12,0x08,0x04,0x14,0x06,0x0C,0x0C,0x06,0x0A,0x02,0x0A,0x02,0x0C,0x1C,0x0C,0x12

284  #endif

285  //   3072

286  #if  PRIME_DIFF_TABLE_BYTES  >  3072

287      ,0x02,0x12,0x0A,0x08,0x0A,0x30,0x02,0x04,0x06,0x08,0x0A,0x02,0x0A,0x1E,0x02,0x24,

288       0x06,0x0A,0x06,0x02,0x12,0x04,0x06,0x08,0x10,0x0E,0x10,0x06,0x0E,0x04,0x14,0x04,

289       0x06,0x02,0x0A,0x0C,0x02,0x06,0x0C,0x06,0x06,0x04,0x0C,0x02,0x06,0x04,0x0C,0x06,

290       0x08,0x04,0x02,0x06,0x12,0x0A,0x06,0x08,0x0C,0x06,0x16,0x02,0x06,0x0C,0x12,0x04,

291       0x0E,0x06,0x04,0x14,0x06,0x10,0x08,0x04,0x08,0x16,0x08,0x0C,0x06,0x06,0x10,0x0C,

292       0x12,0x1E,0x08,0x04,0x02,0x04,0x06,0x1A,0x04,0x0E,0x18,0x16,0x06,0x02,0x06,0x0A,

293       0x06,0x0E,0x06,0x06,0x0C,0x0A,0x06,0x02,0x0C,0x0A,0x0C,0x08,0x12,0x12,0x0A,0x06,

294       0x08,0x10,0x06,0x06,0x08,0x10,0x14,0x04,0x02,0x0A,0x02,0x0A,0x0C,0x06,0x08,0x06,

295       0x0A,0x14,0x0A,0x12,0x1A,0x04,0x06,0x1E,0x02,0x04,0x08,0x06,0x0C,0x0C,0x12,0x04,

296       0x08,0x16,0x06,0x02,0x0C,0x22,0x06,0x12,0x0C,0x06,0x02,0x1C,0x0E,0x10,0x0E,0x04,

297       0x0E,0x0C,0x04,0x06,0x06,0x02,0x24,0x04,0x06,0x14,0x0C,0x18,0x06,0x16,0x02,0x10,

298       0x12,0x0C,0x0C,0x12,0x02,0x06,0x06,0x06,0x04,0x06,0x0E,0x04,0x02,0x16,0x08,0x0C,

299       0x06,0x0A,0x06,0x08,0x0C,0x12,0x0C,0x06,0x0A,0x02,0x16,0x0E,0x06,0x06,0x04,0x12,

300       0x06,0x14,0x16,0x02,0x0C,0x18,0x04,0x12,0x12,0x02,0x16,0x02,0x04,0x0C,0x08,0x0C,

301       0x0A,0x0E,0x04,0x02,0x12,0x10,0x26,0x06,0x06,0x06,0x0C,0x0A,0x06,0x0C,0x08,0x06,

302       0x04,0x06,0x0E,0x1E,0x06,0x0A,0x08,0x16,0x06,0x08,0x0C,0x0A,0x02,0x0A,0x02,0x06

303  #endif

304  //   3328

305  #if  PRIME_DIFF_TABLE_BYTES  >  3328

306      ,0x0A,0x02,0x0A,0x0C,0x12,0x14,0x06,0x04,0x08,0x16,0x06,0x06,0x1E,0x06,0x0E,0x06,

307       0x0C,0x0C,0x06,0x0A,0x02,0x0A,0x1E,0x02,0x10,0x08,0x04,0x02,0x06,0x12,0x04,0x02,

308       0x06,0x04,0x1A,0x04,0x08,0x06,0x0A,0x02,0x04,0x06,0x08,0x04,0x06,0x1E,0x0C,0x02,

309       0x06,0x06,0x04,0x14,0x16,0x08,0x04,0x02,0x04,0x48,0x08,0x04,0x08,0x16,0x02,0x04,

310       0x0E,0x0A,0x02,0x04,0x14,0x06,0x0A,0x12,0x06,0x14,0x10,0x06,0x08,0x06,0x04,0x14,

311       0x0C,0x16,0x02,0x04,0x02,0x0C,0x0A,0x12,0x02,0x16,0x06,0x12,0x1E,0x02,0x0A,0x0E,

     Family "2.0"                          TCG Published                                   Page 463

     Level 00 Revision 01.16         Copyright © TCG 2006-2014  October 30, 2014
     Trusted Platform Module Library                                Part 4: Supporting Routines

312       0x0A,0x08,0x10,0x32,0x06,0x0A,0x08,0x0A,0x0C,0x06,0x12,0x02,0x16,0x06,0x02,0x04,

313       0x06,0x08,0x06,0x06,0x0A,0x12,0x02,0x16,0x02,0x10,0x0E,0x0A,0x06,0x02,0x0C,0x0A,

314       0x14,0x04,0x0E,0x06,0x04,0x24,0x02,0x04,0x06,0x0C,0x02,0x04,0x0E,0x0C,0x06,0x04,

315       0x06,0x02,0x06,0x04,0x14,0x0A,0x02,0x0A,0x06,0x0C,0x02,0x18,0x0C,0x0C,0x06,0x06,

316       0x04,0x18,0x02,0x04,0x18,0x02,0x06,0x04,0x06,0x08,0x10,0x06,0x02,0x0A,0x0C,0x0E,

317       0x06,0x22,0x06,0x0E,0x06,0x04,0x02,0x1E,0x16,0x08,0x04,0x06,0x08,0x04,0x02,0x1C,

318       0x02,0x06,0x04,0x1A,0x12,0x16,0x02,0x06,0x10,0x06,0x02,0x10,0x0C,0x02,0x0C,0x04,

319       0x06,0x06,0x0E,0x0A,0x06,0x08,0x0C,0x04,0x12,0x02,0x0A,0x08,0x10,0x06,0x06,0x1E,

320       0x02,0x0A,0x12,0x02,0x0A,0x08,0x04,0x08,0x0C,0x18,0x28,0x02,0x0C,0x0A,0x06,0x0C,

321       0x02,0x0C,0x04,0x02,0x04,0x06,0x12,0x0E,0x0C,0x06,0x04,0x0E,0x1E,0x04,0x08,0x0A

322  #endif

323  //   3584

324  #if  PRIME_DIFF_TABLE_BYTES      >  3584

325      ,0x08,0x06,0x0A,0x12,0x08,0x04,0x0E,0x10,0x06,0x08,0x04,0x06,0x02,0x0A,0x02,0x0C,

326       0x04,0x02,0x04,0x06,0x08,0x04,0x06,0x20,0x18,0x0A,0x08,0x12,0x0A,0x02,0x06,0x0A,

327       0x02,0x04,0x12,0x06,0x0C,0x02,0x10,0x02,0x16,0x06,0x06,0x08,0x12,0x04,0x12,0x0C,

328       0x08,0x06,0x04,0x14,0x06,0x1E,0x16,0x0C,0x02,0x06,0x12,0x04,0x3E,0x04,0x02,0x0C,

329       0x06,0x0A,0x02,0x0C,0x0C,0x1C,0x02,0x04,0x0E,0x16,0x06,0x02,0x06,0x06,0x0A,0x0E,

330       0x04,0x02,0x0A,0x06,0x08,0x0A,0x0E,0x0A,0x06,0x02,0x0C,0x16,0x12,0x08,0x0A,0x12,

331       0x0C,0x02,0x0C,0x04,0x0C,0x02,0x0A,0x02,0x06,0x12,0x06,0x06,0x22,0x06,0x02,0x0C,

332       0x04,0x06,0x12,0x12,0x02,0x10,0x06,0x06,0x08,0x06,0x0A,0x12,0x08,0x0A,0x08,0x0A,

333       0x02,0x04,0x12,0x1A,0x0C,0x16,0x02,0x04,0x02,0x16,0x06,0x06,0x0E,0x10,0x06,0x14,

334       0x0A,0x0C,0x02,0x12,0x2A,0x04,0x18,0x02,0x06,0x0A,0x0C,0x02,0x06,0x0A,0x08,0x04,

335       0x06,0x0C,0x0C,0x08,0x04,0x06,0x0C,0x1E,0x14,0x06,0x18,0x06,0x0A,0x0C,0x02,0x0A,

336       0x14,0x06,0x06,0x04,0x0C,0x0E,0x0A,0x12,0x0C,0x08,0x06,0x0C,0x04,0x0E,0x0A,0x02,

337       0x0C,0x1E,0x10,0x02,0x0C,0x06,0x04,0x02,0x04,0x06,0x1A,0x04,0x12,0x02,0x04,0x06,

338       0x0E,0x36,0x06,0x34,0x02,0x10,0x06,0x06,0x0C,0x1A,0x04,0x02,0x06,0x16,0x06,0x02,

339       0x0C,0x0C,0x06,0x0A,0x12,0x02,0x0C,0x0C,0x0A,0x12,0x0C,0x06,0x08,0x06,0x0A,0x06,

340       0x08,0x04,0x02,0x04,0x14,0x18,0x06,0x06,0x0A,0x0E,0x0A,0x02,0x16,0x06,0x0E,0x0A

341  #endif

342  //   3840

343  #if  PRIME_DIFF_TABLE_BYTES      >  3840

344      ,0x1A,0x04,0x12,0x08,0x0C,0x0C,0x0A,0x0C,0x06,0x08,0x10,0x06,0x08,0x06,0x06,0x16,

345       0x02,0x0A,0x14,0x0A,0x06,0x2C,0x12,0x06,0x0A,0x02,0x04,0x06,0x0E,0x04,0x1A,0x04,

346       0x02,0x0C,0x0A,0x08,0x04,0x08,0x0C,0x04,0x0C,0x08,0x16,0x08,0x06,0x0A,0x12,0x06,

347       0x06,0x08,0x06,0x0C,0x04,0x08,0x12,0x0A,0x0C,0x06,0x0C,0x02,0x06,0x04,0x02,0x10,

348       0x0C,0x0C,0x0E,0x0A,0x0E,0x06,0x0A,0x0C,0x02,0x0C,0x06,0x04,0x06,0x02,0x0C,0x04,

349       0x1A,0x06,0x12,0x06,0x0A,0x06,0x02,0x12,0x0A,0x08,0x04,0x1A,0x0A,0x14,0x06,0x10,

350       0x14,0x0C,0x0A,0x08,0x0A,0x02,0x10,0x06,0x14,0x0A,0x14,0x04,0x1E,0x02,0x04,0x08,

351       0x10,0x02,0x12,0x04,0x02,0x06,0x0A,0x12,0x0C,0x0E,0x12,0x06,0x10,0x14,0x06,0x04,

352       0x08,0x06,0x04,0x06,0x0C,0x08,0x0A,0x02,0x0C,0x06,0x04,0x02,0x06,0x0A,0x02,0x10,

353       0x0C,0x0E,0x0A,0x06,0x08,0x06,0x1C,0x02,0x06,0x12,0x1E,0x22,0x02,0x10,0x0C,0x02,

354       0x12,0x10,0x06,0x08,0x0A,0x08,0x0A,0x08,0x0A,0x2C,0x06,0x06,0x04,0x14,0x04,0x02,

355       0x04,0x0E,0x1C,0x08,0x06,0x10,0x0E,0x1E,0x06,0x1E,0x04,0x0E,0x0A,0x06,0x06,0x08,

356       0x04,0x12,0x0C,0x06,0x02,0x16,0x0C,0x08,0x06,0x0C,0x04,0x0E,0x04,0x06,0x02,0x04,

357       0x12,0x14,0x06,0x10,0x26,0x10,0x02,0x04,0x06,0x02,0x28,0x2A,0x0E,0x04,0x06,0x02,

358       0x18,0x0A,0x06,0x02,0x12,0x0A,0x0C,0x02,0x10,0x02,0x06,0x10,0x06,0x08,0x04,0x02,

359       0x0A,0x06,0x08,0x0A,0x02,0x12,0x10,0x08,0x0C,0x12,0x0C,0x06,0x0C,0x0A,0x06,0x06

360  #endif

361  //   4096

362  #if  PRIME_DIFF_TABLE_BYTES      >  4096

363      ,0x12,0x0C,0x0E,0x04,0x02,0x0A,0x14,0x06,0x0C,0x06,0x10,0x1A,0x04,0x12,0x02,0x04,

364       0x20,0x0A,0x08,0x06,0x04,0x06,0x06,0x0E,0x06,0x12,0x04,0x02,0x12,0x0A,0x08,0x0A,

365       0x08,0x0A,0x02,0x04,0x06,0x02,0x0A,0x2A,0x08,0x0C,0x04,0x06,0x12,0x02,0x10,0x08,

366       0x04,0x02,0x0A,0x0E,0x0C,0x0A,0x14,0x04,0x08,0x0A,0x26,0x04,0x06,0x02,0x0A,0x14,

367       0x0A,0x0C,0x06,0x0C,0x1A,0x0C,0x04,0x08,0x1C,0x08,0x04,0x08,0x18,0x06,0x0A,0x08,

368       0x06,0x10,0x0C,0x08,0x0A,0x0C,0x08,0x16,0x06,0x02,0x0A,0x02,0x06,0x0A,0x06,0x06,

369       0x08,0x06,0x04,0x0E,0x1C,0x08,0x10,0x12,0x08,0x04,0x06,0x14,0x04,0x12,0x06,0x02,

370       0x18,0x18,0x06,0x06,0x0C,0x0C,0x04,0x02,0x16,0x02,0x0A,0x06,0x08,0x0C,0x04,0x14,

371       0x12,0x06,0x04,0x0C,0x18,0x06,0x06,0x36,0x08,0x06,0x04,0x1A,0x24,0x04,0x02,0x04,

372       0x1A,0x0C,0x0C,0x04,0x06,0x06,0x08,0x0C,0x0A,0x02,0x0C,0x10,0x12,0x06,0x08,0x06,

373       0x0C,0x12,0x0A,0x02,0x36,0x04,0x02,0x0A,0x1E,0x0C,0x08,0x04,0x08,0x10,0x0E,0x0C,

374       0x06,0x04,0x06,0x0C,0x06,0x02,0x04,0x0E,0x0C,0x04,0x0E,0x06,0x18,0x06,0x06,0x0A,

375       0x0C,0x0C,0x14,0x12,0x06,0x06,0x10,0x08,0x04,0x06,0x14,0x04,0x20,0x04,0x0E,0x0A,

376       0x02,0x06,0x0C,0x10,0x02,0x04,0x06,0x0C,0x02,0x0A,0x08,0x06,0x04,0x02,0x0A,0x0E,

377       0x06,0x06,0x0C,0x12,0x22,0x08,0x0A,0x06,0x18,0x06,0x02,0x0A,0x0C,0x02,0x1E,0x0A,

     Page 464                                  TCG Published        Family "2.0"

     October 30, 2014                    Copyright © TCG 2006-2014  Level 00 Revision 01.16
     Part 4: Supporting Routines                                Trusted Platform Module Library

378       0x0E,0x0C,0x0C,0x10,0x06,0x06,0x02,0x12,0x04,0x06,0x1E,0x0E,0x04,0x06,0x06,0x02

379  #endif

380  //   4352

381  #if  PRIME_DIFF_TABLE_BYTES  >  4352

382      ,0x06,0x04,0x06,0x0E,0x06,0x04,0x08,0x0A,0x0C,0x06,0x20,0x0A,0x08,0x16,0x02,0x0A,

383       0x06,0x18,0x08,0x04,0x1E,0x06,0x02,0x0C,0x10,0x08,0x06,0x04,0x06,0x08,0x10,0x0E,

384       0x06,0x06,0x04,0x02,0x0A,0x0C,0x02,0x10,0x0E,0x04,0x02,0x04,0x14,0x12,0x0A,0x02,

385       0x0A,0x06,0x0C,0x1E,0x08,0x12,0x0C,0x0A,0x02,0x06,0x06,0x04,0x0C,0x0C,0x02,0x04,

386       0x0C,0x12,0x18,0x02,0x0A,0x06,0x08,0x10,0x08,0x06,0x0C,0x0A,0x0E,0x06,0x0C,0x06,

387       0x06,0x04,0x02,0x18,0x04,0x06,0x08,0x06,0x04,0x02,0x04,0x06,0x0E,0x04,0x08,0x0A,

388       0x18,0x18,0x0C,0x02,0x06,0x0C,0x16,0x1E,0x02,0x06,0x12,0x0A,0x06,0x06,0x08,0x04,

389       0x02,0x06,0x0A,0x08,0x0A,0x06,0x08,0x10,0x06,0x0E,0x06,0x04,0x18,0x08,0x0A,0x02,

390       0x0C,0x06,0x04,0x24,0x02,0x16,0x06,0x08,0x06,0x0A,0x08,0x06,0x0C,0x0A,0x0E,0x0A,

391       0x06,0x12,0x0C,0x02,0x0C,0x04,0x1A,0x0A,0x0E,0x10,0x12,0x08,0x12,0x0C,0x0C,0x06,

392       0x10,0x0E,0x18,0x0A,0x0C,0x08,0x16,0x06,0x02,0x0A,0x3C,0x06,0x02,0x04,0x08,0x10,

393       0x0E,0x0A,0x06,0x18,0x06,0x0C,0x12,0x18,0x02,0x1E,0x04,0x02,0x0C,0x06,0x0A,0x02,

394       0x04,0x0E,0x06,0x10,0x02,0x0A,0x08,0x16,0x14,0x06,0x04,0x20,0x06,0x12,0x04,0x02,

395       0x04,0x02,0x04,0x08,0x34,0x0E,0x16,0x02,0x16,0x14,0x0A,0x08,0x0A,0x02,0x06,0x04,

396       0x0E,0x04,0x06,0x14,0x04,0x06,0x02,0x0C,0x0C,0x06,0x0C,0x10,0x02,0x0C,0x0A,0x08,

397       0x04,0x06,0x02,0x1C,0x0C,0x08,0x0A,0x0C,0x02,0x04,0x0E,0x1C,0x08,0x06,0x04,0x02

398  #endif

399  //   4608

400  #if  PRIME_DIFF_TABLE_BYTES  >  4608

401      ,0x04,0x06,0x02,0x0C,0x3A,0x06,0x0E,0x0A,0x02,0x06,0x1C,0x20,0x04,0x1E,0x08,0x06,

402       0x04,0x06,0x0C,0x0C,0x02,0x04,0x06,0x06,0x0E,0x10,0x08,0x1E,0x04,0x02,0x0A,0x08,

403       0x06,0x04,0x06,0x1A,0x04,0x0C,0x02,0x0A,0x12,0x0C,0x0C,0x12,0x02,0x04,0x0C,0x08,

404       0x0C,0x0A,0x14,0x04,0x08,0x10,0x0C,0x08,0x06,0x10,0x08,0x0A,0x0C,0x0E,0x06,0x04,

405       0x08,0x0C,0x04,0x14,0x06,0x28,0x08,0x10,0x06,0x24,0x02,0x06,0x04,0x06,0x02,0x16,

406       0x12,0x02,0x0A,0x06,0x24,0x0E,0x0C,0x04,0x12,0x08,0x04,0x0E,0x0A,0x02,0x0A,0x08,

407       0x04,0x02,0x12,0x10,0x0C,0x0E,0x0A,0x0E,0x06,0x06,0x2A,0x0A,0x06,0x06,0x14,0x0A,

408       0x08,0x0C,0x04,0x0C,0x12,0x02,0x0A,0x0E,0x12,0x0A,0x12,0x08,0x06,0x04,0x0E,0x06,

409       0x0A,0x1E,0x0E,0x06,0x06,0x04,0x0C,0x26,0x04,0x02,0x04,0x06,0x08,0x0C,0x0A,0x06,

410       0x12,0x06,0x32,0x06,0x04,0x06,0x0C,0x08,0x0A,0x20,0x06,0x16,0x02,0x0A,0x0C,0x12,

411       0x02,0x06,0x04,0x1E,0x08,0x06,0x06,0x12,0x0A,0x02,0x04,0x0C,0x14,0x0A,0x08,0x18,

412       0x0A,0x02,0x06,0x16,0x06,0x02,0x12,0x0A,0x0C,0x02,0x1E,0x12,0x0C,0x1C,0x02,0x06,

413       0x04,0x06,0x0E,0x06,0x0C,0x0A,0x08,0x04,0x0C,0x1A,0x0A,0x08,0x06,0x10,0x02,0x0A,

414       0x12,0x0E,0x06,0x04,0x06,0x0E,0x10,0x02,0x06,0x04,0x0C,0x14,0x04,0x14,0x04,0x06,

415       0x0C,0x02,0x24,0x04,0x06,0x02,0x0A,0x02,0x16,0x08,0x06,0x0A,0x0C,0x0C,0x12,0x0E,

416       0x18,0x24,0x04,0x14,0x18,0x0A,0x06,0x02,0x1C,0x06,0x12,0x08,0x04,0x06,0x08,0x06

417  #endif

418  //   4864

419  #if  PRIME_DIFF_TABLE_BYTES  >  4864

420      ,0x04,0x02,0x0C,0x1C,0x12,0x0E,0x10,0x0E,0x12,0x0A,0x08,0x06,0x04,0x06,0x06,0x08,

421       0x16,0x0C,0x02,0x0A,0x12,0x06,0x02,0x12,0x0A,0x02,0x0C,0x0A,0x12,0x20,0x06,0x04,

422       0x06,0x06,0x08,0x06,0x06,0x0A,0x14,0x06,0x0C,0x0A,0x08,0x0A,0x0E,0x06,0x0A,0x0E,

423       0x04,0x02,0x16,0x12,0x02,0x0A,0x02,0x04,0x14,0x04,0x02,0x22,0x02,0x0C,0x06,0x0A,

424       0x02,0x0A,0x12,0x06,0x0E,0x0C,0x0C,0x16,0x08,0x06,0x10,0x06,0x08,0x04,0x0C,0x06,

425       0x08,0x04,0x24,0x06,0x06,0x14,0x18,0x06,0x0C,0x12,0x0A,0x02,0x0A,0x1A,0x06,0x10,

426       0x08,0x06,0x04,0x18,0x12,0x08,0x0C,0x0C,0x0A,0x12,0x0C,0x02,0x18,0x04,0x0C,0x12,

427       0x0C,0x0E,0x0A,0x02,0x04,0x18,0x0C,0x0E,0x0A,0x06,0x02,0x06,0x04,0x06,0x1A,0x04,

428       0x06,0x06,0x02,0x16,0x08,0x12,0x04,0x12,0x08,0x04,0x18,0x02,0x0C,0x0C,0x04,0x02,

429       0x34,0x02,0x12,0x06,0x04,0x06,0x0C,0x02,0x06,0x0C,0x0A,0x08,0x04,0x02,0x18,0x0A,

430       0x02,0x0A,0x02,0x0C,0x06,0x12,0x28,0x06,0x14,0x10,0x02,0x0C,0x06,0x0A,0x0C,0x02,

431       0x04,0x06,0x0E,0x0C,0x0C,0x16,0x06,0x08,0x04,0x02,0x10,0x12,0x0C,0x02,0x06,0x10,

432       0x06,0x02,0x06,0x04,0x0C,0x1E,0x08,0x10,0x02,0x12,0x0A,0x18,0x02,0x06,0x18,0x04,

433       0x02,0x16,0x02,0x10,0x02,0x06,0x0C,0x04,0x12,0x08,0x04,0x0E,0x04,0x12,0x18,0x06,

434       0x02,0x06,0x0A,0x02,0x0A,0x26,0x06,0x0A,0x0E,0x06,0x06,0x18,0x04,0x02,0x0C,0x10,

435       0x0E,0x10,0x0C,0x02,0x06,0x0A,0x1A,0x04,0x02,0x0C,0x06,0x04,0x0C,0x08,0x0C,0x0A

436  #endif

437  //   5120

438  #if  PRIME_DIFF_TABLE_BYTES  >  5120

439      ,0x12,0x06,0x0E,0x1C,0x02,0x06,0x0A,0x02,0x04,0x0E,0x22,0x02,0x06,0x16,0x02,0x0A,

440       0x0E,0x04,0x02,0x10,0x08,0x0A,0x06,0x08,0x0A,0x08,0x04,0x06,0x02,0x10,0x06,0x06,

441       0x12,0x1E,0x0E,0x06,0x04,0x1E,0x02,0x0A,0x0E,0x04,0x14,0x0A,0x08,0x04,0x08,0x12,

442       0x04,0x0E,0x06,0x04,0x18,0x06,0x06,0x12,0x12,0x02,0x24,0x06,0x0A,0x0E,0x0C,0x04,

443       0x06,0x02,0x1E,0x06,0x04,0x02,0x06,0x1C,0x14,0x04,0x14,0x0C,0x18,0x10,0x12,0x0C,

     Family "2.0"                          TCG Published                                   Page 465

     Level 00 Revision 01.16         Copyright © TCG 2006-2014  October 30, 2014
     Trusted Platform Module Library                                Part 4: Supporting Routines

444       0x0E,0x06,0x04,0x0C,0x20,0x0C,0x06,0x0A,0x08,0x0A,0x06,0x12,0x02,0x10,0x0E,0x06,

445       0x16,0x06,0x0C,0x02,0x12,0x04,0x08,0x1E,0x0C,0x04,0x0C,0x02,0x0A,0x26,0x16,0x02,

446       0x04,0x0E,0x06,0x0C,0x18,0x04,0x02,0x04,0x0E,0x0C,0x0A,0x02,0x10,0x06,0x14,0x04,

447       0x14,0x16,0x0C,0x02,0x04,0x02,0x0C,0x16,0x18,0x06,0x06,0x02,0x06,0x04,0x06,0x02,

448       0x0A,0x0C,0x0C,0x06,0x02,0x06,0x10,0x08,0x06,0x04,0x12,0x0C,0x0C,0x0E,0x04,0x0C,

449       0x06,0x08,0x06,0x12,0x06,0x0A,0x0C,0x0E,0x06,0x04,0x08,0x16,0x06,0x02,0x1C,0x12,

450       0x02,0x12,0x0A,0x06,0x0E,0x0A,0x02,0x0A,0x0E,0x06,0x0A,0x02,0x16,0x06,0x08,0x06,

451       0x10,0x0C,0x08,0x16,0x02,0x04,0x0E,0x12,0x0C,0x06,0x18,0x06,0x0A,0x02,0x0C,0x16,

452       0x12,0x06,0x14,0x06,0x0A,0x0E,0x04,0x02,0x06,0x0C,0x16,0x0E,0x0C,0x04,0x06,0x08,

453       0x16,0x02,0x0A,0x0C,0x08,0x28,0x02,0x06,0x0A,0x08,0x04,0x2A,0x14,0x04,0x20,0x0C,

454       0x0A,0x06,0x0C,0x0C,0x02,0x0A,0x08,0x06,0x04,0x08,0x04,0x1A,0x12,0x04,0x08,0x1C

455  #endif

456  //   5376

457  #if  PRIME_DIFF_TABLE_BYTES      >  5376

458      ,0x06,0x12,0x06,0x0C,0x02,0x0A,0x06,0x06,0x0E,0x0A,0x0C,0x0E,0x18,0x06,0x04,0x14,

459       0x16,0x02,0x12,0x04,0x06,0x0C,0x02,0x10,0x12,0x0E,0x06,0x06,0x04,0x06,0x08,0x12,

460       0x04,0x0E,0x1E,0x04,0x12,0x08,0x0A,0x02,0x04,0x08,0x0C,0x04,0x0C,0x12,0x02,0x0C,

461       0x0A,0x02,0x10,0x08,0x04,0x1E,0x02,0x06,0x1C,0x02,0x0A,0x02,0x12,0x0A,0x0E,0x04,

462       0x1A,0x06,0x12,0x04,0x14,0x06,0x04,0x08,0x12,0x04,0x0C,0x1A,0x18,0x04,0x14,0x16,

463       0x02,0x12,0x16,0x02,0x04,0x0C,0x02,0x06,0x06,0x06,0x04,0x06,0x0E,0x04,0x18,0x0C,

464       0x06,0x12,0x02,0x0C,0x1C,0x0E,0x04,0x06,0x08,0x16,0x06,0x0C,0x12,0x08,0x04,0x14,

465       0x06,0x04,0x06,0x02,0x12,0x06,0x04,0x0C,0x0C,0x08,0x1C,0x06,0x08,0x0A,0x02,0x18,

466       0x0C,0x0A,0x18,0x08,0x0A,0x14,0x0C,0x06,0x0C,0x0C,0x04,0x0E,0x0C,0x18,0x22,0x12,

467       0x08,0x0A,0x06,0x12,0x08,0x04,0x08,0x10,0x0E,0x06,0x04,0x06,0x18,0x02,0x06,0x04,

468       0x06,0x02,0x10,0x06,0x06,0x14,0x18,0x04,0x02,0x04,0x0E,0x04,0x12,0x02,0x06,0x0C,

469       0x04,0x0E,0x04,0x02,0x12,0x10,0x06,0x06,0x02,0x10,0x14,0x06,0x06,0x1E,0x04,0x08,

470       0x06,0x18,0x10,0x06,0x06,0x08,0x0C,0x1E,0x04,0x12,0x12,0x08,0x04,0x1A,0x0A,0x02,

471       0x16,0x08,0x0A,0x0E,0x06,0x04,0x12,0x08,0x0C,0x1C,0x02,0x06,0x04,0x0C,0x06,0x18,

472       0x06,0x08,0x0A,0x14,0x10,0x08,0x1E,0x06,0x06,0x04,0x02,0x0A,0x0E,0x06,0x0A,0x20,

473       0x16,0x12,0x02,0x04,0x02,0x04,0x08,0x16,0x08,0x12,0x0C,0x1C,0x02,0x10,0x0C,0x12

474  #endif

475  //   5632

476  #if  PRIME_DIFF_TABLE_BYTES      >  5632

477      ,0x0E,0x0A,0x12,0x0C,0x06,0x20,0x0A,0x0E,0x06,0x0A,0x02,0x0A,0x02,0x06,0x16,0x02,

478       0x04,0x06,0x08,0x0A,0x06,0x0E,0x06,0x04,0x0C,0x1E,0x18,0x06,0x06,0x08,0x06,0x04,

479       0x02,0x04,0x06,0x08,0x06,0x06,0x16,0x12,0x08,0x04,0x02,0x12,0x06,0x04,0x02,0x10,

480       0x12,0x14,0x0A,0x06,0x06,0x1E,0x02,0x0C,0x1C,0x06,0x06,0x06,0x02,0x0C,0x0A,0x08,

481       0x12,0x12,0x04,0x08,0x12,0x0A,0x02,0x1C,0x02,0x0A,0x0E,0x04,0x02,0x1E,0x0C,0x16,

482       0x1A,0x0A,0x08,0x06,0x0A,0x08,0x10,0x0E,0x06,0x06,0x0A,0x0E,0x06,0x04,0x02,0x0A,

483       0x0C,0x02,0x06,0x0A,0x08,0x04,0x02,0x0A,0x1A,0x16,0x06,0x02,0x0C,0x12,0x04,0x1A,

484       0x04,0x08,0x0A,0x06,0x0E,0x0A,0x02,0x12,0x06,0x0A,0x14,0x06,0x06,0x04,0x18,0x02,

485       0x04,0x08,0x06,0x10,0x0E,0x10,0x12,0x02,0x04,0x0C,0x02,0x0A,0x02,0x06,0x0C,0x0A,

486       0x06,0x06,0x14,0x06,0x04,0x06,0x26,0x04,0x06,0x0C,0x0E,0x04,0x0C,0x08,0x0A,0x0C,

487       0x0C,0x08,0x04,0x06,0x0E,0x0A,0x06,0x0C,0x02,0x0A,0x12,0x02,0x12,0x0A,0x08,0x0A,

488       0x02,0x0C,0x04,0x0E,0x1C,0x02,0x10,0x02,0x12,0x06,0x0A,0x06,0x08,0x10,0x0E,0x1E,

489       0x0A,0x14,0x06,0x0A,0x18,0x02,0x1C,0x02,0x0C,0x10,0x06,0x08,0x24,0x04,0x08,0x04,

490       0x0E,0x0C,0x0A,0x08,0x0C,0x04,0x06,0x08,0x04,0x06,0x0E,0x16,0x08,0x06,0x04,0x02,

491       0x0A,0x06,0x14,0x0A,0x08,0x06,0x06,0x16,0x12,0x02,0x10,0x06,0x14,0x04,0x1A,0x04,

492       0x0E,0x16,0x0E,0x04,0x0C,0x06,0x08,0x04,0x06,0x06,0x1A,0x0A,0x02,0x12,0x12,0x04

493  #endif

494  //   5888

495  #if  PRIME_DIFF_TABLE_BYTES      >  5888

496      ,0x02,0x10,0x02,0x12,0x04,0x06,0x08,0x04,0x06,0x0C,0x02,0x06,0x06,0x1C,0x26,0x04,

497       0x08,0x10,0x1A,0x04,0x02,0x0A,0x0C,0x02,0x0A,0x08,0x06,0x0A,0x0C,0x02,0x0A,0x02,

498       0x18,0x04,0x1E,0x1A,0x06,0x06,0x12,0x06,0x06,0x16,0x02,0x0A,0x12,0x1A,0x04,0x12,

499       0x08,0x06,0x06,0x0C,0x10,0x06,0x08,0x10,0x06,0x08,0x10,0x02,0x2A,0x3A,0x08,0x04,

500       0x06,0x02,0x04,0x08,0x10,0x06,0x14,0x04,0x0C,0x0C,0x06,0x0C,0x02,0x0A,0x02,0x06,

501       0x16,0x02,0x0A,0x06,0x08,0x06,0x0A,0x0E,0x06,0x06,0x04,0x12,0x08,0x0A,0x08,0x10,

502       0x0E,0x0A,0x02,0x0A,0x02,0x0C,0x06,0x04,0x14,0x0A,0x08,0x34,0x08,0x0A,0x06,0x02,

503       0x0A,0x08,0x0A,0x06,0x06,0x08,0x0A,0x02,0x16,0x02,0x04,0x06,0x0E,0x04,0x02,0x18,

504       0x0C,0x04,0x1A,0x12,0x04,0x06,0x0E,0x1E,0x06,0x04,0x06,0x02,0x16,0x08,0x04,0x06,

505       0x02,0x16,0x06,0x08,0x10,0x06,0x0E,0x04,0x06,0x12,0x08,0x0C,0x06,0x0C,0x18,0x1E,

506       0x10,0x08,0x22,0x08,0x16,0x06,0x0E,0x0A,0x12,0x0E,0x04,0x0C,0x08,0x04,0x24,0x06,

507       0x06,0x02,0x0A,0x02,0x04,0x14,0x06,0x06,0x0A,0x0C,0x06,0x02,0x28,0x08,0x06,0x1C,

508       0x06,0x02,0x0C,0x12,0x04,0x18,0x0E,0x06,0x06,0x0A,0x14,0x0A,0x0E,0x10,0x0E,0x10,

509       0x06,0x08,0x24,0x04,0x0C,0x0C,0x06,0x0C,0x32,0x0C,0x06,0x04,0x06,0x06,0x08,0x06,

     Page 466                                  TCG Published        Family "2.0"

     October 30, 2014                    Copyright © TCG 2006-2014  Level 00 Revision 01.16
     Part 4: Supporting Routines                                                   Trusted Platform Module Library

510       0x0A,0x02,0x0A,0x02,0x12,0x0A,0x0E,0x10,0x08,0x06,0x04,0x14,0x04,0x02,0x0A,0x06,

511       0x0E,0x12,0x0A,0x26,0x0A,0x12,0x02,0x0A,0x02,0x0C,0x04,0x02,0x04,0x0E,0x06,0x0A

512  #endif

513  //   6144

514  #if  PRIME_DIFF_TABLE_BYTES         >  6144

515      ,0x08,0x28,0x06,0x14,0x04,0x0C,0x08,0x06,0x22,0x08,0x16,0x08,0x0C,0x0A,0x02,0x10,

516       0x2A,0x0C,0x08,0x16,0x08,0x16,0x08,0x06,0x22,0x02,0x06,0x04,0x0E,0x06,0x10,0x02,

517       0x16,0x06,0x08,0x18,0x16,0x06,0x02,0x0C,0x04,0x06,0x0E,0x04,0x08,0x18,0x04,0x06,

518       0x06,0x02,0x16,0x14,0x06,0x04,0x0E,0x04,0x06,0x06,0x08,0x06,0x0A,0x06,0x08,0x06,

519       0x10,0x0E,0x06,0x06,0x16,0x06,0x18,0x20,0x06,0x12,0x06,0x12,0x0A,0x08,0x1E,0x12,

520       0x06,0x10,0x0C,0x06,0x0C,0x02,0x06,0x04,0x0C,0x08,0x06,0x16,0x08,0x06,0x04,0x0E,

521       0x0A,0x12,0x14,0x0A,0x02,0x06,0x04,0x02,0x1C,0x12,0x02,0x0A,0x06,0x06,0x06,0x0E,

522       0x28,0x18,0x02,0x04,0x08,0x0C,0x04,0x14,0x04,0x20,0x12,0x10,0x06,0x24,0x08,0x06,

523       0x04,0x06,0x0E,0x04,0x06,0x1A,0x06,0x0A,0x0E,0x12,0x0A,0x06,0x06,0x0E,0x0A,0x06,

524       0x06,0x0E,0x06,0x18,0x04,0x0E,0x16,0x08,0x0C,0x0A,0x08,0x0C,0x12,0x0A,0x12,0x08,

525       0x18,0x0A,0x08,0x04,0x18,0x06,0x12,0x06,0x02,0x0A,0x1E,0x02,0x0A,0x02,0x04,0x02,

526       0x28,0x02,0x1C,0x08,0x06,0x06,0x12,0x06,0x0A,0x0E,0x04,0x12,0x1E,0x12,0x02,0x0C,

527       0x1E,0x06,0x1E,0x04,0x12,0x0C,0x02,0x04,0x0E,0x06,0x0A,0x06,0x08,0x06,0x0A,0x0C,

528       0x02,0x06,0x0C,0x0A,0x02,0x12,0x04,0x14,0x04,0x06,0x0E,0x06,0x06,0x16,0x06,0x06,

529       0x08,0x12,0x12,0x0A,0x02,0x0A,0x02,0x06,0x04,0x06,0x0C,0x12,0x02,0x0A,0x08,0x04,

530       0x12,0x02,0x06,0x06,0x06,0x0A,0x08,0x0A,0x06,0x12,0x0C,0x08,0x0C,0x06,0x04,0x06

531  #endif

532  //   6400

533  #if  PRIME_DIFF_TABLE_BYTES         >  6400

534      ,0x0E,0x10,0x02,0x0C,0x04,0x06,0x26,0x06,0x06,0x10,0x14,0x1C,0x14,0x0A,0x06,0x06,

535       0x0E,0x04,0x1A,0x04,0x0E,0x0A,0x12,0x0E,0x1C,0x02,0x04,0x0E,0x10,0x02,0x1C,0x06,

536       0x08,0x06,0x22,0x08,0x04,0x12,0x02,0x10,0x08,0x06,0x28,0x08,0x12,0x04,0x1E,0x06,

537       0x0C,0x02,0x1E,0x06,0x0A,0x0E,0x28,0x0E,0x0A,0x02,0x0C,0x0A,0x08,0x04,0x08,0x06,

538       0x06,0x1C,0x02,0x04,0x0C,0x0E,0x10,0x08,0x1E,0x10,0x12,0x02,0x0A,0x12,0x06,0x20,

539       0x04,0x12,0x06,0x02,0x0C,0x0A,0x12,0x02,0x06,0x0A,0x0E,0x12,0x1C,0x06,0x08,0x10,

540       0x02,0x04,0x14,0x0A,0x08,0x12,0x0A,0x02,0x0A,0x08,0x04,0x06,0x0C,0x06,0x14,0x04,

541       0x02,0x06,0x04,0x14,0x0A,0x1A,0x12,0x0A,0x02,0x12,0x06,0x10,0x0E,0x04,0x1A,0x04,

542       0x0E,0x0A,0x0C,0x0E,0x06,0x06,0x04,0x0E,0x0A,0x02,0x1E,0x12,0x16,0x02

543  #endif

544  //   6542

545  #if  PRIME_DIFF_TABLE_BYTES         >  0

546       };

547  #endif

548  #if  defined        RSA_INSTRUMENT     ||  defined    RSA_DEBUG

549  UINT32        failedAtIteration[10];

550  UINT32        MillerRabinTrials;

551  UINT32        totalFields;

552  UINT32        emptyFields;

553  UINT32        noPrimeFields;

554  UINT16        lastSievePrime;

555  UINT32        primesChecked;

556  #endif

     Only want this table when doing debug of the          prime number stuff This is a table of the first 2048 primes

     and takes 4096 bytes

557  #ifdef        RSA_DEBUG

558  const    __int16    primes[NUM_PRIMES]=

559       {

560                3,    5,      7,   11,       13,  17,   19,   23,   29,   31,   37,   41,   43,   47,   53,

561           59,  61,   67,     71,  73,       79,  83,   89,   97,   101,  103,  107,  109,  113,  127,  131,

562       137,     139,  149,  151,   157,  163,     167,  173,  179,  181,  191,  193,  197,  199,  211,  223,

563       227,     229,  233,  239,   241,  251,     257,  263,  269,  271,  277,  281,  283,  293,  307,  311,

564       313,     317,  331,  337,   347,  349,     353,  359,  367,  373,  379,  383,  389,  397,  401,  409,

565       419,     421,  431,  433,   439,  443,     449,  457,  461,  463,  467,  479,  487,  491,  499,  503,

566       509,     521,  523,  541,   547,  557,     563,  569,  571,  577,  587,  593,  599,  601,  607,  613,

567       617,     619,  631,  641,   643,  647,     653,  659,  661,  673,  677,  683,  691,  701,  709,  719,

568       727,     733,  739,  743,   751,  757,     761,  769,  773,  787,  797,  809,  811,  821,  823,  827,

569       829,     839,  853,  857,   859,  863,     877,  881,  883,  887,  907,  911,  919,  929,  937,  941,

570       947,     953,  967,  971,   977,  983,     991,  997,1009,1013,1019,1021,1031,1033,1039,1049,

     Family "2.0"                                    TCG Published                                         Page 467

     Level 00 Revision 01.16                    Copyright © TCG 2006-2014                      October 30, 2014
     Trusted Platform Module Library                              Part 4: Supporting Routines

571  1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,

572  1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,

573  1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,

574  1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,

575  1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,

576  1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,

577  1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,

578  1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,

579  2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,

580  2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,

581  2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,

582  2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,

583  2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,

584  2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,

585  2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,

586  2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,

587  3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,

588  3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,

589  3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,

590  3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,

591  3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,

592  3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,

593  3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,

594  3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,

595  4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,

596  4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,

597  4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,

598  4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,

599  4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,

600  4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,

601  4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,

602  5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,

603  5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,

604  5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,

605  5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,

606  5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,

607  5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,

608  5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,

609  6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,

610  6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,

611  6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,

612  6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,

613  6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,

614  6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,

615  6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,

616  6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,

617  7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,

618  7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,

619  7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,

620  7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,

621  7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,

622  7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,

623  8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,

624  8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,

625  8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,

626  8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,

627  8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,

628  8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,

629  8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,

630  9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,

631  9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,

632  9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,

633  9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,

634  9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,

635  9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,

636  9859,     9871,   9883,  9887,   9901,  9907,  9923,  9929,

     Page 468                                TCG Published        Family "2.0"

     October 30, 2014                 Copyright © TCG 2006-2014   Level 00 Revision 01.16
     Part 4: Supporting Routines                                Trusted  Platform Module Library

637  9931,  9941,  9949,      9967,  9973,10007,10009,10037,

638  10039,10061,10067,10069,10079,10091,10093,10099,

639  10103,10111,10133,10139,10141,10151,10159,10163,

640  10169,10177,10181,10193,10211,10223,10243,10247,

641  10253,10259,10267,10271,10273,10289,10301,10303,

642  10313,10321,10331,10333,10337,10343,10357,10369,

643  10391,10399,10427,10429,10433,10453,10457,10459,

644  10463,10477,10487,10499,10501,10513,10529,10531,

645  10559,10567,10589,10597,10601,10607,10613,10627,

646  10631,10639,10651,10657,10663,10667,10687,10691,

647  10709,10711,10723,10729,10733,10739,10753,10771,

648  10781,10789,10799,10831,10837,10847,10853,10859,

649  10861,10867,10883,10889,10891,10903,10909,10937,

650  10939,10949,10957,10973,10979,10987,10993,11003,

651  11027,11047,11057,11059,11069,11071,11083,11087,

652  11093,11113,11117,11119,11131,11149,11159,11161,

653  11171,11173,11177,11197,11213,11239,11243,11251,

654  11257,11261,11273,11279,11287,11299,11311,11317,

655  11321,11329,11351,11353,11369,11383,11393,11399,

656  11411,11423,11437,11443,11447,11467,11471,11483,

657  11489,11491,11497,11503,11519,11527,11549,11551,

658  11579,11587,11593,11597,11617,11621,11633,11657,

659  11677,11681,11689,11699,11701,11717,11719,11731,

660  11743,11777,11779,11783,11789,11801,11807,11813,

661  11821,11827,11831,11833,11839,11863,11867,11887,

662  11897,11903,11909,11923,11927,11933,11939,11941,

663  11953,11959,11969,11971,11981,11987,12007,12011,

664  12037,12041,12043,12049,12071,12073,12097,12101,

665  12107,12109,12113,12119,12143,12149,12157,12161,

666  12163,12197,12203,12211,12227,12239,12241,12251,

667  12253,12263,12269,12277,12281,12289,12301,12323,

668  12329,12343,12347,12373,12377,12379,12391,12401,

669  12409,12413,12421,12433,12437,12451,12457,12473,

670  12479,12487,12491,12497,12503,12511,12517,12527,

671  12539,12541,12547,12553,12569,12577,12583,12589,

672  12601,12611,12613,12619,12637,12641,12647,12653,

673  12659,12671,12689,12697,12703,12713,12721,12739,

674  12743,12757,12763,12781,12791,12799,12809,12821,

675  12823,12829,12841,12853,12889,12893,12899,12907,

676  12911,12917,12919,12923,12941,12953,12959,12967,

677  12973,12979,12983,13001,13003,13007,13009,13033,

678  13037,13043,13049,13063,13093,13099,13103,13109,

679  13121,13127,13147,13151,13159,13163,13171,13177,

680  13183,13187,13217,13219,13229,13241,13249,13259,

681  13267,13291,13297,13309,13313,13327,13331,13337,

682  13339,13367,13381,13397,13399,13411,13417,13421,

683  13441,13451,13457,13463,13469,13477,13487,13499,

684  13513,13523,13537,13553,13567,13577,13591,13597,

685  13613,13619,13627,13633,13649,13669,13679,13681,

686  13687,13691,13693,13697,13709,13711,13721,13723,

687  13729,13751,13757,13759,13763,13781,13789,13799,

688  13807,13829,13831,13841,13859,13873,13877,13879,

689  13883,13901,13903,13907,13913,13921,13931,13933,

690  13963,13967,13997,13999,14009,14011,14029,14033,

691  14051,14057,14071,14081,14083,14087,14107,14143,

692  14149,14153,14159,14173,14177,14197,14207,14221,

693  14243,14249,14251,14281,14293,14303,14321,14323,

694  14327,14341,14347,14369,14387,14389,14401,14407,

695  14411,14419,14423,14431,14437,14447,14449,14461,

696  14479,14489,14503,14519,14533,14537,14543,14549,

697  14551,14557,14561,14563,14591,14593,14621,14627,

698  14629,14633,14639,14653,14657,14669,14683,14699,

699  14713,14717,14723,14731,14737,14741,14747,14753,

700  14759,14767,14771,14779,14783,14797,14813,14821,

701  14827,14831,14843,14851,14867,14869,14879,14887,

702  14891,14897,14923,14929,14939,14947,14951,14957,

     Family "2.0"                    TCG Published                       Page 469

     Level 00 Revision 01.16         Copyright © TCG 2006-2014           October 30, 2014
     Trusted Platform Module Library                             Part 4: Supporting Routines

703      14969,14983,15013,15017,15031,15053,15061,15073,

704      15077,15083,15091,15101,15107,15121,15131,15137,

705      15139,15149,15161,15173,15187,15193,15199,15217,

706      15227,15233,15241,15259,15263,15269,15271,15277,

707      15287,15289,15299,15307,15313,15319,15329,15331,

708      15349,15359,15361,15373,15377,15383,15391,15401,

709      15413,15427,15439,15443,15451,15461,15467,15473,

710      15493,15497,15511,15527,15541,15551,15559,15569,

711      15581,15583,15601,15607,15619,15629,15641,15643,

712      15647,15649,15661,15667,15671,15679,15683,15727,

713      15731,15733,15737,15739,15749,15761,15767,15773,

714      15787,15791,15797,15803,15809,15817,15823,15859,

715      15877,15881,15887,15889,15901,15907,15913,15919,

716      15923,15937,15959,15971,15973,15991,16001,16007,

717      16033,16057,16061,16063,16067,16069,16073,16087,

718      16091,16097,16103,16111,16127,16139,16141,16183,

719      16187,16189,16193,16217,16223,16229,16231,16249,

720      16253,16267,16273,16301,16319,16333,16339,16349,

721      16361,16363,16369,16381,16411,16417,16421,16427,

722      16433,16447,16451,16453,16477,16481,16487,16493,

723      16519,16529,16547,16553,16561,16567,16573,16603,

724      16607,16619,16631,16633,16649,16651,16657,16661,

725      16673,16691,16693,16699,16703,16729,16741,16747,

726      16759,16763,16787,16811,16823,16829,16831,16843,

727      16871,16879,16883,16889,16901,16903,16921,16927,

728      16931,16937,16943,16963,16979,16981,16987,16993,

729      17011,17021,17027,17029,17033,17041,17047,17053,

730      17077,17093,17099,17107,17117,17123,17137,17159,

731      17167,17183,17189,17191,17203,17207,17209,17231,

732      17239,17257,17291,17293,17299,17317,17321,17327,

733      17333,17341,17351,17359,17377,17383,17387,17389,

734      17393,17401,17417,17419,17431,17443,17449,17467,

735      17471,17477,17483,17489,17491,17497,17509,17519,

736      17539,17551,17569,17573,17579,17581,17597,17599,

737      17609,17623,17627,17657,17659,17669,17681,17683,

738      17707,17713,17729,17737,17747,17749,17761,17783,

739      17789,17791,17807,17827,17837,17839,17851,17863

740  };

741  #endif

742  #endif

     Page 470                         TCG Published              Family "2.0"

     October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
    Part 4: Supporting Routines                                              Trusted Platform Module  Library

    B.13  Elliptic Curve Files

    B.13.1.  CpriDataEcc.h

1   #ifndef         _CRYPTDATAECC_H_

2   #define         _CRYPTDATAECC_H_

    Structure for the curve parameters. This is an analog to the TPMS_ALGORITHM_DETAIL_ECC

3   typedef  struct      {

4         const   TPM2B     *p;       //       a  prime  number

5         const   TPM2B     *a;       //       linear    coefficient

6         const   TPM2B     *b;       //       constant    term

7         const   TPM2B     *x;       //       generator   x   coordinate

8         const   TPM2B     *y;       //       generator   y   coordinate

9         const   TPM2B     *n;       //       the  order  of    the  curve

10        const   TPM2B     *h;       //       cofactor

11  }  ECC_CURVE_DATA;

12  typedef  struct

13  {

14        TPM_ECC_CURVE               curveId;

15        UINT16                      keySizeBits;

16        TPMT_KDF_SCHEME             kdf;

17        TPMT_ECC_SCHEME             sign;

18        const   ECC_CURVE_DATA      *curveData;   //   the   address  of   the  curve  data

19  }  ECC_CURVE;

20  extern   const  ECC_CURVE_DATA    SM2_P256;

21  extern   const  ECC_CURVE_DATA    NIST_P256;

22  extern   const  ECC_CURVE_DATA    BN_P256;

23  extern   const  ECC_CURVE    eccCurves[];

24  extern   const  UINT16  ECC_CURVE_COUNT;

25  #endif

    Family "2.0"                                  TCG Published                                Page 471

    Level 00 Revision 01.16           Copyright © TCG 2006-2014                          October 30, 2014
    Trusted Platform Module Library                                                  Part 4: Supporting Routines

    B.13.2.  CpriDataEcc.c

    Defines for the sizes of ECC parameters

1   #include      "TPMB.h"

2   TPM2B_BYTE_VALUE(1);

3   TPM2B_BYTE_VALUE(16);

4   TPM2B_BYTE_VALUE(2);

5   TPM2B_BYTE_VALUE(24);

6   TPM2B_BYTE_VALUE(28);

7   TPM2B_BYTE_VALUE(32);

8   TPM2B_BYTE_VALUE(4);

9   TPM2B_BYTE_VALUE(48);

10  TPM2B_BYTE_VALUE(64);

11  TPM2B_BYTE_VALUE(66);

12  TPM2B_BYTE_VALUE(8);

13  TPM2B_BYTE_VALUE(80);

14  #if  defined  ECC_NIST_P192       &&  ECC_NIST_P192       ==     YES

15  const   TPM2B_24_BYTE_VALUE       NIST_P192_p       =     {24,

16            {0xFF,    0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

17               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFE,

18               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF}};

19  const   TPM2B_24_BYTE_VALUE       NIST_P192_a       =     {24,

20            {0xFF,    0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

21               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFE,

22               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFC}};

23  const   TPM2B_24_BYTE_VALUE       NIST_P192_b       =     {24,

24            {0x64,    0x21,  0x05,   0x19,     0xE5,     0x9C,     0x80,  0xE7,

25               0x0F,  0xA7,  0xE9,   0xAB,     0x72,     0x24,     0x30,  0x49,

26               0xFE,  0xB8,  0xDE,   0xEC,     0xC1,     0x46,     0xB9,  0xB1}};

27  const   TPM2B_24_BYTE_VALUE       NIST_P192_gX         =  {24,

28            {0x18,    0x8D,  0xA8,   0x0E,     0xB0,     0x30,     0x90,  0xF6,

29               0x7C,  0xBF,  0x20,   0xEB,     0x43,     0xA1,     0x88,  0x00,

30               0xF4,  0xFF,  0x0A,   0xFD,     0x82,     0xFF,     0x10,  0x12}};

31  const   TPM2B_24_BYTE_VALUE       NIST_P192_gY         =  {24,

32            {0x07,    0x19,  0x2B,   0x95,     0xFFC,       0x8D,  0xA7,    0x86,

33               0x31,  0x01,  0x1ED,     0x6B,  0x24,        0xCD,  0xD5,    0x73,

34               0xF9,  0x77,  0xA1,   0x1E,     0x79,     0x48,     0x11}};

35  const   TPM2B_24_BYTE_VALUE       NIST_P192_n       =     {24,

36            {0xFF,    0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

37               0xFF,  0xFF,  0xFF,   0xFF,     0x99,     0xDE,     0xF8,  0x36,

38               0x14,  0x6B,  0xC9,   0xB1,     0xB4,     0xD2,     0x28,  0x31}};

39  const   TPM2B_1_BYTE_VALUE   NIST_P192_h       =       {1,{1}};

40  const   ECC_CURVE_DATA     NIST_P192  =      {&NIST_P192_p.b,           &NIST_P192_a.b,  &NIST_P192_b.b,

41                                               &NIST_P192_gX.b,           &NIST_P192_gY.b,  &NIST_P192_n.b,

42                                               &NIST_P192_h.b};

43  #endif   //  ECC_NIST_P192

44  #if  defined  ECC_NIST_P224       &&  ECC_NIST_P224       ==     YES

45  const   TPM2B_28_BYTE_VALUE       NIST_P224_p       =     {28,

46            {0xFF,    0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

47               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

48               0x00,  0x00,  0x00,   0x00,     0x00,     0x00,     0x00,  0x00,

49               0x00,  0x00,  0x00,   0x01}};

50  const   TPM2B_28_BYTE_VALUE       NIST_P224_a       =     {28,

51            {0xFF,    0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

52               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFE,

53               0xFF,  0xFF,  0xFF,   0xFF,     0xFF,     0xFF,     0xFF,  0xFF,

54               0xFF,  0xFF,  0xFF,   0xFE}};

55  const   TPM2B_28_BYTE_VALUE       NIST_P224_b       =     {28,

56            {0xB4,    0x05,  0x0A,   0x85,     0x0C,     0x04,     0xB3,  0xAB,

57               0xF5,  0x41,  0x32,   0x56,     0x50,     0x44,     0xB0,  0xB7,

58               0xD7,  0xBF,  0xD8,   0xBA,     0x27,     0x0B,     0x39,  0x43,

59               0x23,  0x55,  0xFF,   0xB4}};

60  const   TPM2B_28_BYTE_VALUE       NIST_P224_gX         =  {28,

61            {0xB7,    0x0E,  0x0C,   0xBD,     0x6B,     0xB4,     0xBF,  0x7F,

    Page 472                                       TCG Published                              Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                  Trusted Platform Module Library

62               0x32,  0x13,  0x90,  0xB9,  0x4A,       0x03,    0xC1,  0xD3,

63               0x56,  0xC2,  0x11,  0x22,  0x34,       0x32,    0x80,  0xD6,

64               0x11,  0x5C,  0x1D,  0x21}};

65   const   TPM2B_28_BYTE_VALUE      NIST_P224_gY       =  {28,

66           {0xBD,     0x37,  0x63,  0x88,  0xB5,       0xF7,    0x23,  0xFB,

67               0x4C,  0x22,  0xDF,  0xE6,  0xCD,       0x43,    0x75,  0xA0,

68               0x5A,  0x07,  0x47,  0x64,  0x44,       0xD5,    0x81,  0x99,

69               0x85,  0x00,  0x7E,  0x34}};

70   const   TPM2B_28_BYTE_VALUE      NIST_P224_n     =     {28,

71           {0xFF,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

72               0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0x16,  0xA2,

73               0xE0,  0xB8,  0xF0,  0x3E,  0x13,       0xDD,    0x29,  0x45,

74               0x5C,  0x5C,  0x2A,  0x3D}};

75   const   TPM2B_1_BYTE_VALUE   NIST_P224_h      =     {1,{1}};

76   const   ECC_CURVE_DATA    NIST_P224  =  {&NIST_P224_p.b,            &NIST_P224_a.b,  &NIST_P224_b.b,

77                                             &NIST_P224_gX.b,          &NIST_P224_gY.b,  &NIST_P224_n.b,

78                                             &NIST_P224_h.b};

79   #endif  //  ECC_NIST_P224

80   #if  defined  ECC_NIST_P256      &&  ECC_NIST_P256     ==    YES

81   const   TPM2B_32_BYTE_VALUE      NIST_P256_p     =     {32,

82           {0xFF,     0xFF,  0xFF,  0xFF,  0x00,       0x00,    0x00,  0x01,

83               0x00,  0x00,  0x00,  0x00,  0x00,       0x00,    0x00,  0x00,

84               0x00,  0x00,  0x00,  0x00,  0xFF,       0xFF,    0xFF,  0xFF,

85               0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF}};

86   const   TPM2B_32_BYTE_VALUE      NIST_P256_a     =     {32,

87           {0xFF,     0xFF,  0xFF,  0xFF,  0x00,       0x00,    0x00,  0x01,

88               0x00,  0x00,  0x00,  0x00,  0x00,       0x00,    0x00,  0x00,

89               0x00,  0x00,  0x00,  0x00,  0xFF,       0xFF,    0xFF,  0xFF,

90               0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFC}};

91   const   TPM2B_32_BYTE_VALUE      NIST_P256_b     =     {32,

92           {0x5A,     0xC6,  0x35,  0xD8,  0xAA,       0x3A,    0x93,  0xE7,

93               0xB3,  0xEB,  0xBD,  0x55,  0x76,       0x98,    0x86,  0xBC,

94               0x65,  0x1D,  0x06,  0xB0,  0xCC,       0x53,    0xB0,  0xF6,

95               0x3B,  0xCE,  0x3C,  0x3E,  0x27,       0xD2,    0x60,  0x4B}};

96   const   TPM2B_32_BYTE_VALUE      NIST_P256_gX       =  {32,

97           {0x6B,     0x17,  0xD1,  0xF2,  0xE1,       0x2C,    0x42,  0x47,

98               0xF8,  0xBC,  0xE6,  0xE5,  0x63,       0xA4,    0x40,  0xF2,

99               0x77,  0x03,  0x7D,  0x81,  0x2D,       0xEB,    0x33,  0xA0,

100              0xF4,  0xA1,  0x39,  0x45,  0xD8,       0x98,    0xC2,  0x96}};

101  const   TPM2B_32_BYTE_VALUE      NIST_P256_gY       =  {32,

102          {0x4F,     0xE3,  0x42,  0xE2,  0xFE,       0x1A,    0x7F,  0x9B,

103              0x8E,  0xE7,  0xEB,  0x4A,  0x7C,       0x0F,    0x9E,  0x16,

104              0x2B,  0xCE,  0x33,  0x57,  0x6B,       0x31,    0x5E,  0xCE,

105              0xCB,  0xB6,  0x40,  0x68,  0x37,       0xBF,    0x51,  0xF5}};

106  const   TPM2B_32_BYTE_VALUE      NIST_P256_n     =     {32,

107          {0xFF,     0xFF,  0xFF,  0xFF,  0x00,       0x00,    0x00,  0x00,

108              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

109              0xBC,  0xE6,  0xFA,  0xAD,  0xA7,       0x17,    0x9E,  0x84,

110              0xF3,  0xB9,  0xCA,  0xC2,  0xFC,       0x63,    0x25,  0x51}};

111  const   TPM2B_1_BYTE_VALUE   NIST_P256_h      =     {1,{1}};

112  const   ECC_CURVE_DATA    NIST_P256  =  {&NIST_P256_p.b,            &NIST_P256_a.b,  &NIST_P256_b.b,

113                                            &NIST_P256_gX.b,          &NIST_P256_gY.b,  &NIST_P256_n.b,

114                                            &NIST_P256_h.b};

115  #endif  //  ECC_NIST_P256

116  #if  defined  ECC_NIST_P384      &&  ECC_NIST_P384     ==    YES

117  const   TPM2B_48_BYTE_VALUE      NIST_P384_p     =     {48,

118          {0xFF,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

119              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

120              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

121              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFE,

122              0xFF,  0xFF,  0xFF,  0xFF,  0x00,       0x00,    0x00,  0x00,

123              0x00,  0x00,  0x00,  0x00,  0xFF,       0xFF,    0xFF,  0xFF}};

124  const   TPM2B_48_BYTE_VALUE      NIST_P384_a     =     {48,

125          {0xFF,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

126              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

127              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

     Family "2.0"                              TCG Published                               Page 473

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                        October 30, 2014
     Trusted Platform Module Library                                              Part 4: Supporting Routines

128              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFE,

129              0xFF,  0xFF,  0xFF,  0xFF,  0x00,       0x00,    0x00,  0x00,

130              0x00,  0x00,  0x00,  0x00,  0xFF,       0xFF,    0xFF,  0xFC}};

131  const   TPM2B_48_BYTE_VALUE      NIST_P384_b     =     {48,

132          {0xB3,     0x31,  0x2F,  0xA7,  0xE2,       0x3E,    0xE7,  0xE4,

133              0x98,  0x8E,  0x05,  0x6B,  0xE3,       0xF8,    0x2D,  0x19,

134              0x18,  0x1D,  0x9C,  0x6E,  0xFE,       0x81,    0x41,  0x12,

135              0x03,  0x14,  0x08,  0x8F,  0x50,       0x13,    0x87,  0x5A,

136              0xC6,  0x56,  0x39,  0x8D,  0x8A,       0x2E,    0xD1,  0x9D,

137              0x2A,  0x85,  0xC8,  0xED,  0xD3,       0xEC,    0x2A,  0xEF}};

138  const   TPM2B_48_BYTE_VALUE      NIST_P384_gX       =  {48,

139          {0xAA,     0x87,  0xCA,  0x22,  0xBE,       0x8B,    0x05,  0x37,

140              0x8E,  0xB1,  0xC7,  0x1E,  0xF3,       0x20,    0xAD,  0x74,

141              0x6E,  0x1D,  0x3B,  0x62,  0x8B,       0xA7,    0x9B,  0x98,

142              0x59,  0xF7,  0x41,  0xE0,  0x82,       0x54,    0x2A,  0x38,

143              0x55,  0x02,  0xF2,  0x5D,  0xBF,       0x55,    0x29,  0x6C,

144              0x3A,  0x54,  0x5E,  0x38,  0x72,       0x76,    0x0A,  0xB7}};

145  const   TPM2B_48_BYTE_VALUE      NIST_P384_gY       =  {48,

146          {0x36,     0x17,  0xDE,  0x4A,  0x96,       0x26,    0x2C,  0x6F,

147              0x5D,  0x9E,  0x98,  0xBF,  0x92,       0x92,    0xDC,  0x29,

148              0xF8,  0xF4,  0x1D,  0xBD,  0x28,       0x9A,    0x14,  0x7C,

149              0xE9,  0xDA,  0x31,  0x13,  0xB5,       0xF0,    0xB8,  0xC0,

150              0x0A,  0x60,  0xB1,  0xCE,  0x1D,       0x7E,    0x81,  0x9D,

151              0x7A,  0x43,  0x1D,  0x7C,  0x90,       0xEA,    0x0E,  0x5F}};

152  const   TPM2B_48_BYTE_VALUE      NIST_P384_n     =     {48,

153          {0xFF,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

154              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

155              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

156              0xC7,  0x63,  0x4D,  0x81,  0xF4,       0x37,    0x2D,  0xDF,

157              0x58,  0x1A,  0x0D,  0xB2,  0x48,       0xB0,    0xA7,  0x7A,

158              0xEC,  0xEC,  0x19,  0x6A,  0xCC,       0xC5,    0x29,  0x73}};

159  const   TPM2B_1_BYTE_VALUE   NIST_P384_h      =     {1,{1}};

160  const   ECC_CURVE_DATA    NIST_P384  =  {&NIST_P384_p.b,            &NIST_P384_a.b,  &NIST_P384_b.b,

161                                          &NIST_P384_gX.b,            &NIST_P384_gY.b,  &NIST_P384_n.b,

162                                          &NIST_P384_h.b};

163  #endif  //  ECC_NIST_P384

164  #if  defined  ECC_NIST_P521      &&  ECC_NIST_P521     ==    YES

165  const   TPM2B_66_BYTE_VALUE      NIST_P521_p     =     {66,

166          {0x01,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

167              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

168              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

169              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

170              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

171              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

172              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

173              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

174              0xFF,  0xFF}};

175  const   TPM2B_66_BYTE_VALUE      NIST_P521_a     =     {66,

176          {0x01,     0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

177              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

178              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

179              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

180              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

181              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

182              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

183              0xFF,  0xFF,  0xFF,  0xFF,  0xFF,       0xFF,    0xFF,  0xFF,

184              0xFF,  0xFC}};

185  const   TPM2B_66_BYTE_VALUE      NIST_P521_b     =     {66,

186          {0x00,     0x51,  0x95,  0x3E,  0xB9,       0x61,    0x8E,  0x1C,

187              0x9A,  0x1F,  0x92,  0x9A,  0x21,       0xA0,    0xB6,  0x85,

188              0x40,  0xEE,  0xA2,  0xDA,  0x72,       0x5B,    0x99,  0xB3,

189              0x15,  0xF3,  0xB8,  0xB4,  0x89,       0x91,    0x8E,  0xF1,

190              0x09,  0xE1,  0x56,  0x19,  0x39,       0x51,    0xEC,  0x7E,

191              0x93,  0x7B,  0x16,  0x52,  0xC0,       0xBD,    0x3B,  0xB1,

192              0xBF,  0x07,  0x35,  0x73,  0xDF,       0x88,    0x3D,  0x2C,

193              0x34,  0xF1,  0xEF,  0x45,  0x1F,       0xD4,    0x6B,  0x50,

     Page 474                                      TCG Published                           Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                                       Trusted Platform Module Library

194              0x3F,  0x00}};

195  const   TPM2B_66_BYTE_VALUE      NIST_P521_gX           =   {66,

196          {0x00,     0xC6,  0x85,  0x8E,   0x06,          0xB7,     0x04,  0x04,

197              0xE9,  0xCD,  0x9E,  0x3E,   0xCB,          0x66,     0x23,  0x95,

198              0xB4,  0x42,  0x9C,  0x64,   0x81,          0x39,     0x05,  0x3F,

199              0xB5,  0x21,  0xF8,  0x28,   0xAF,          0x60,     0x6B,  0x4D,

200              0x3D,  0xBA,  0xA1,  0x4B,   0x5E,          0x77,     0xEF,  0xE7,

201              0x59,  0x28,  0xFE,  0x1D,   0xC1,          0x27,     0xA2,  0xFF,

202              0xA8,  0xDE,  0x33,  0x48,   0xB3,          0xC1,     0x85,  0x6A,

203              0x42,  0x9B,  0xF9,  0x7E,   0x7E,          0x31,     0xC2,  0xE5,

204              0xBD,  0x66}};

205  const   TPM2B_66_BYTE_VALUE      NIST_P521_gY           =   {66,

206          {0x01,     0x18,  0x39,  0x29,   0x6A,          0x78,     0x9A,  0x3B,

207              0xC0,  0x04,  0x5C,  0x8A,   0x5F,          0xB4,     0x2C,  0x7D,

208              0x1B,  0xD9,  0x98,  0xF5,   0x44,          0x49,     0x57,  0x9B,

209              0x44,  0x68,  0x17,  0xAF,   0xBD,          0x17,     0x27,  0x3E,

210              0x66,  0x2C,  0x97,  0xEE,   0x72,          0x99,     0x5E,  0xF4,

211              0x26,  0x40,  0xC5,  0x50,   0xB9,          0x01,     0x3F,  0xAD,

212              0x07,  0x61,  0x35,  0x3C,   0x70,          0x86,     0xA2,  0x72,

213              0xC2,  0x40,  0x88,  0xBE,   0x94,          0x76,     0x9F,  0xD1,

214              0x66,  0x50}};

215  const   TPM2B_66_BYTE_VALUE      NIST_P521_n         =     {66,

216          {0x01,     0xFF,  0xFF,  0xFF,   0xFF,          0xFF,     0xFF,  0xFF,

217              0xFF,  0xFF,  0xFF,  0xFF,   0xFF,          0xFF,     0xFF,  0xFF,

218              0xFF,  0xFF,  0xFF,  0xFF,   0xFF,          0xFF,     0xFF,  0xFF,

219              0xFF,  0xFF,  0xFF,  0xFF,   0xFF,          0xFF,     0xFF,  0xFF,

220              0xFF,  0xFA,  0x51,  0x86,   0x87,          0x83,     0xBF,  0x2F,

221              0x96,  0x6B,  0x7F,  0xCC,   0x01,          0x48,     0xF7,  0x09,

222              0xA5,  0xD0,  0x3B,  0xB5,   0xC9,          0xB8,     0x89,  0x9C,

223              0x47,  0xAE,  0xBB,  0x6F,   0xB7,          0x1E,     0x91,  0x38,

224              0x64,  0x09}};

225  const   TPM2B_1_BYTE_VALUE   NIST_P521_h          =     {1,{1}};

226  const   ECC_CURVE_DATA    NIST_P521   =  {&NIST_P521_p.b,                &NIST_P521_a.b,  &NIST_P521_b.b,

227                                           &NIST_P521_gX.b,                &NIST_P521_gY.b,  &NIST_P521_n.b,

228                                           &NIST_P521_h.b};

229  #endif  //  ECC_NIST_P521

230  #if  defined  ECC_BN_P256    &&  ECC_BN_P256            ==  YES

231  const   TPM2B_32_BYTE_VALUE      BN_P256_p     =     {32,

232          {0xFF,     0XFF,  0XFF,  0XFF,   0XFF,          0XFC,     0XF0,  0XCD,

233              0X46,  0XE5,  0XF2,  0X5E,   0XEE,          0X71,     0XA4,  0X9F,

234              0X0C,  0XDC,  0X65,  0XFB,   0X12,          0X98,     0X0A,  0X82,

235              0XD3,  0X29,  0X2D,  0XDB,   0XAE,          0XD3,     0X30,  0X13}};

236  const   TPM2B_1_BYTE_VALUE   BN_P256_a      =     {1,{0}};

237  const   TPM2B_1_BYTE_VALUE   BN_P256_b      =     {1,{3}};

238  const   TPM2B_1_BYTE_VALUE   BN_P256_gX        =     {1,{1}};

239  const   TPM2B_1_BYTE_VALUE   BN_P256_gY        =     {1,{2}};;

240  const   TPM2B_32_BYTE_VALUE      BN_P256_n     =     {32,

241          {0xFF,     0XFF,  0XFF,  0XFF,   0XFF,          0XFC,     0XF0,  0XCD,

242              0X46,  0XE5,  0XF2,  0X5E,   0XEE,          0X71,     0XA4,  0X9E,

243              0X0C,  0XDC,  0X65,  0XFB,   0X12,          0X99,     0X92,  0X1A,

244              0XF6,  0X2D,  0X53,  0X6C,   0XD1,          0X0B,     0X50,  0X0D}};

245  const   TPM2B_1_BYTE_VALUE   BN_P256_h      =     {1,{1}};

246  const   ECC_CURVE_DATA    BN_P256  =  {&BN_P256_p.b,              &BN_P256_a.b,   &BN_P256_b.b,

247                                           &BN_P256_gX.b,           &BN_P256_gY.b,  &BN_P256_n.b,

248                                           &BN_P256_h.b};

249  #endif  //  ECC_BN_P256

250  #if  defined  ECC_BN_P638    &&  ECC_BN_P638            ==  YES

251  const   TPM2B_80_BYTE_VALUE      BN_P638_p     =     {80,

252          {0x23,     0xFF,  0xFF,  0xFD,   0xC0,          0x00,     0x00,  0x0D,

253              0x7F,  0xFF,  0xFF,  0xB8,   0x00,          0x00,     0x01,  0xD3,

254              0xFF,  0xFF,  0xF9,  0x42,   0xD0,          0x00,     0x16,  0x5E,

255              0x3F,  0xFF,  0x94,  0x87,   0x00,          0x00,     0xD5,  0x2F,

256              0xFF,  0xFD,  0xD0,  0xE0,   0x00,          0x08,     0xDE,  0x55,

257              0xC0,  0x00,  0x86,  0x52,   0x00,          0x21,     0xE5,  0x5B,

258              0xFF,  0xFF,  0xF5,  0x1F,   0xFF,          0xF4,     0xEB,  0x80,

259              0x00,  0x00,  0x00,  0x4C,   0x80,          0x01,     0x5A,  0xCD,

     Family "2.0"                                   TCG Published                                     Page 475

     Level 00 Revision 01.16               Copyright © TCG 2006-2014                            October 30, 2014
     Trusted Platform Module Library                                                     Part 4: Supporting Routines

260              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xEC,  0xE0,

261              0x00,  0x00,  0x00,  0x00,    0x00,         0x00,  0x00,  0x67}};

262  const   TPM2B_1_BYTE_VALUE   BN_P638_a      =     {1,{0}};

263  const   TPM2B_2_BYTE_VALUE   BN_P638_b      =     {2,{0x01,0x01}};

264  const   TPM2B_80_BYTE_VALUE      BN_P638_gX       =     {80,

265          {0x23,     0xFF,  0xFF,  0xFD,    0xC0,         0x00,  0x00,  0x0D,

266              0x7F,  0xFF,  0xFF,  0xB8,    0x00,         0x00,  0x01,  0xD3,

267              0xFF,  0xFF,  0xF9,  0x42,    0xD0,         0x00,  0x16,  0x5E,

268              0x3F,  0xFF,  0x94,  0x87,    0x00,         0x00,  0xD5,  0x2F,

269              0xFF,  0xFD,  0xD0,  0xE0,    0x00,         0x08,  0xDE,  0x55,

270              0xC0,  0x00,  0x86,  0x52,    0x00,         0x21,  0xE5,  0x5B,

271              0xFF,  0xFF,  0xF5,  0x1F,    0xFF,         0xF4,  0xEB,  0x80,

272              0x00,  0x00,  0x00,  0x4C,    0x80,         0x01,  0x5A,  0xCD,

273              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xEC,  0xE0,

274              0x00,  0x00,  0x00,  0x00,    0x00,         0x00,  0x00,  0x66}};

275  const   TPM2B_1_BYTE_VALUE   BN_P638_gY        =     {1,{0x10}};

276  const   TPM2B_80_BYTE_VALUE      BN_P638_n     =     {80,

277          {0x23,     0xFF,  0xFF,  0xFD,    0xC0,         0x00,  0x00,  0x0D,

278              0x7F,  0xFF,  0xFF,  0xB8,    0x00,         0x00,  0x01,  0xD3,

279              0xFF,  0xFF,  0xF9,  0x42,    0xD0,         0x00,  0x16,  0x5E,

280              0x3F,  0xFF,  0x94,  0x87,    0x00,         0x00,  0xD5,  0x2F,

281              0xFF,  0xFD,  0xD0,  0xE0,    0x00,         0x08,  0xDE,  0x55,

282              0x60,  0x00,  0x86,  0x55,    0x00,         0x21,  0xE5,  0x55,

283              0xFF,  0xFF,  0xF5,  0x4F,    0xFF,         0xF4,  0xEA,  0xC0,

284              0x00,  0x00,  0x00,  0x49,    0x80,         0x01,  0x54,  0xD9,

285              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xED,  0xA0,

286              0x00,  0x00,  0x00,  0x00,    0x00,         0x00,  0x00,  0x61}};

287  const   TPM2B_1_BYTE_VALUE   BN_P638_h      =     {1,{1}};

288  const   ECC_CURVE_DATA    BN_P638   =     {&BN_P638_p.b,       &BN_P638_a.b,   &BN_P638_b.b,

289                                            &BN_P638_gX.b,            &BN_P638_gY.b,  &BN_P638_n.b,

290                                            &BN_P638_h.b};

291  #endif  //  ECC_BN_P638

292  #if  defined  ECC_SM2_P256   &&    ECC_SM2_P256         ==     YES

293  const   TPM2B_32_BYTE_VALUE      SM2_P256_p       =     {32,

294          {0xFF,     0xFF,  0xFF,  0xFE,    0xFF,         0xFF,  0xFF,  0xFF,

295              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xFF,  0xFF,

296              0xFF,  0xFF,  0xFF,  0xFF,    0x00,         0x00,  0x00,  0x00,

297              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xFF,  0xFF}};

298  const   TPM2B_32_BYTE_VALUE      SM2_P256_a       =     {32,

299          {0xFF,     0xFF,  0xFF,  0xFE,    0xFF,         0xFF,  0xFF,  0xFF,

300              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xFF,  0xFF,

301              0xFF,  0xFF,  0xFF,  0xFF,    0x00,         0x00,  0x00,  0x00,

302              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xFF,  0xFC}};

303  const   TPM2B_32_BYTE_VALUE      SM2_P256_b       =     {32,

304          {0x28,     0xE9,  0xFA,  0x9E,    0x9D,         0x9F,  0x5E,  0x34,

305              0x4D,  0x5A,  0x9E,  0x4B,    0xCF,         0x65,  0x09,  0xA7,

306              0xF3,  0x97,  0x89,  0xF5,    0x15,         0xAB,  0x8F,  0x92,

307              0xDD,  0xBC,  0xBD,  0x41,    0x4D,         0x94,  0x0E,  0x93}};

308  const   TPM2B_32_BYTE_VALUE      SM2_P256_gX         =  {32,

309          {0x32,     0xC4,  0xAE,  0x2C,    0x1F,         0x19,  0x81,  0x19,

310              0x5F,  0x99,  0x04,  0x46,    0x6A,         0x39,  0xC9,  0x94,

311              0x8F,  0xE3,  0x0B,  0xBF,    0xF2,         0x66,  0x0B,  0xE1,

312              0x71,  0x5A,  0x45,  0x89,    0x33,         0x4C,  0x74,  0xC7}};

313  const   TPM2B_32_BYTE_VALUE      SM2_P256_gY         =  {32,

314          {0xBC,     0x37,  0x36,  0xA2,    0xF4,         0xF6,  0x77,  0x9C,

315              0x59,  0xBD,  0xCE,  0xE3,    0x6B,         0x69,  0x21,  0x53,

316              0xD0,  0xA9,  0x87,  0x7C,    0xC6,         0x2A,  0x47,  0x40,

317              0x02,  0xDF,  0x32,  0xE5,    0x21,         0x39,  0xF0,  0xA0}};

318  const   TPM2B_32_BYTE_VALUE      SM2_P256_n       =     {32,

319          {0xFF,     0xFF,  0xFF,  0xFE,    0xFF,         0xFF,  0xFF,  0xFF,

320              0xFF,  0xFF,  0xFF,  0xFF,    0xFF,         0xFF,  0xFF,  0xFF,

321              0x72,  0x03,  0xDF,  0x6B,    0x21,         0xC6,  0x05,  0x2B,

322              0x53,  0xBB,  0xF4,  0x09,    0x39,         0xD5,  0x41,  0x23}};

323  const   TPM2B_1_BYTE_VALUE   SM2_P256_h        =     {1,{1}};

324  const   ECC_CURVE_DATA    SM2_P256     =  {&SM2_P256_p.b,           &SM2_P256_a.b,  &SM2_P256_b.b,

325                                            &SM2_P256_gX.b,             &SM2_P256_gY.b,  &SM2_P256_n.b,

     Page 476                                       TCG Published                                  Family "2.0"

     October 30, 2014                       Copyright © TCG 2006-2014                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                     Trusted  Platform Module Library

326                                             &SM2_P256_h.b};

327  #endif   //  ECC_SM2_P256

328  #define    comma

329  const   ECC_CURVE       eccCurves[]  =  {

330  #if  defined  ECC_NIST_P192      &&  ECC_NIST_P192  ==   YES

331       comma

332       {TPM_ECC_NIST_P192,

333       192,

334       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SHA256},

335       {TPM_ALG_NULL,TPM_ALG_NULL},

336       &NIST_P192}

337  #    undef   comma

338  #    define   comma  ,

339  #endif   //  ECC_NIST_P192

340  #if  defined  ECC_NIST_P224      &&  ECC_NIST_P224  ==   YES

341       comma

342       {TPM_ECC_NIST_P224,

343       224,

344       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SHA256},

345       {TPM_ALG_NULL,TPM_ALG_NULL},

346       &NIST_P224}

347  #    undef   comma

348  #    define   comma  ,

349  #endif   //  ECC_NIST_P224

350  #if  defined  ECC_NIST_P256      &&  ECC_NIST_P256  ==   YES

351       comma

352       {TPM_ECC_NIST_P256,

353       256,

354       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SHA256},

355       {TPM_ALG_NULL,TPM_ALG_NULL},

356       &NIST_P256}

357  #    undef   comma

358  #    define   comma  ,

359  #endif   //  ECC_NIST_P256

360  #if  defined  ECC_NIST_P384      &&  ECC_NIST_P384  ==   YES

361       comma

362       {TPM_ECC_NIST_P384,

363       384,

364       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SHA384},

365       {TPM_ALG_NULL,TPM_ALG_NULL},

366       &NIST_P384}

367  #    undef   comma

368  #    define   comma  ,

369  #endif   //  ECC_NIST_P384

370  #if  defined  ECC_NIST_P521      &&  ECC_NIST_P521  ==   YES

371       comma

372       {TPM_ECC_NIST_P521,

373       521,

374       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SHA512},

375       {TPM_ALG_NULL,TPM_ALG_NULL},

376       &NIST_P521}

377  #    undef   comma

378  #    define   comma  ,

379  #endif   //  ECC_NIST_P521

380  #if  defined  ECC_BN_P256    &&  ECC_BN_P256  ==    YES

381       comma

382       {TPM_ECC_BN_P256,

383       256,

384       {TPM_ALG_NULL,TPM_ALG_NULL},

385       {TPM_ALG_NULL,TPM_ALG_NULL},

386       &BN_P256}

387  #    undef   comma

388  #    define   comma  ,

389  #endif   //  ECC_BN_P256

390  #if  defined  ECC_BN_P638    &&  ECC_BN_P638  ==    YES

391       comma

     Family "2.0"                               TCG Published                 Page 477

     Level 00 Revision 01.16              Copyright © TCG 2006-2014           October 30, 2014
     Trusted Platform Module Library                                  Part 4: Supporting  Routines

392       {TPM_ECC_BN_P638,

393       638,

394       {TPM_ALG_NULL,TPM_ALG_NULL},

395       {TPM_ALG_NULL,TPM_ALG_NULL},

396       &BN_P638}

397  #    undef   comma

398  #    define   comma  ,

399  #endif  //   ECC_BN_P638

400  #if  defined    ECC_SM2_P256  &&  ECC_SM2_P256  ==  YES

401       comma

402       {TPM_ECC_SM2_P256,

403       256,

404       {TPM_ALG_KDF1_SP800_56A,TPM_ALG_SM3_256},

405       {TPM_ALG_NULL,TPM_ALG_NULL},

406       &SM2_P256}

407  #    undef   comma

408  #    define   comma  ,

409  #endif  //   ECC_SM2_P256

410  };

411  const   UINT16       ECC_CURVE_COUNT  =  sizeof(eccCurves)  /  sizeof(ECC_CURVE);

     Page 478                                 TCG Published                             Family "2.0"

     October 30, 2014                      Copyright © TCG 2006-2014  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                  Trusted Platform Module Library

    B.13.3.  CpriECC.c

    B.13.3.1.    Includes and Defines

    Need to include OsslCryptEngine.h to determine if ECC is defined for this Implementation

1   #include       "OsslCryptoEngine.h"

2   #ifdef     TPM_ALG_ECC

3   #include       "CpriDataEcc.h"

4   #include       "CpriDataEcc.c"

    B.13.3.2.    Functions

    B.13.3.2.1.    _cpri__EccStartup()

    This function is called at TPM Startup to initialize the  crypto units.

    In this implementation, no initialization is performed    at startup but  a  future  version  may  initialize  the  self -

    test functions here.

5   LIB_EXPORT     BOOL

6   _cpri__EccStartup(

7      void

8      )

9   {

10     return      TRUE;

11  }

    B.13.3.2.2.    _cpri__GetCurveIdByIndex()

    This function returns the number of the i-th implemented      curve. The normal use           would be to call this

    function with i starting at 0. When the i is greater than or  equal to the number of          implemented curves,

    TPM_ECC_NONE is returned.

12  LIB_EXPORT     TPM_ECC_CURVE

13  _cpri__GetCurveIdByIndex(

14     UINT16                i

15     )

16  {

17     if(i    >=  ECC_CURVE_COUNT)

18             return     TPM_ECC_NONE;

19     return      eccCurves[i].curveId;

20  }

21  LIB_EXPORT     UINT32

22  _cpri__EccGetCurveCount(

23     void

24     )

25  {

26     return      ECC_CURVE_COUNT;

27  }

    B.13.3.2.3.    _cpri__EccGetParametersByCurveId()

    This function returns a pointer to the curve data that is associated with the indicated curveId. If there is no

    curve with the indicated ID, the function returns NULL.

    Family "2.0"                          TCG Published                                                Page 479

    Level 00 Revision 01.16              Copyright © TCG 2006-2014                                October 30, 2014
    Trusted Platform Module Library                                                                Part 4: Supporting Routines

    Return Value                             Meaning

    NULL                                     curve     with  the   indicated      TPM_ECC_CURVE      value  is  not

                                             implemented

    non-NULL                                 pointer to the curve data

28  LIB_EXPORT       const       ECC_CURVE    *

29  _cpri__EccGetParametersByCurveId(

30     TPM_ECC_CURVE                curveId                  //  IN:   the   curveID

31     )

32  {

33     int                   i;

34     for(i      =  0;   i  <      ECC_CURVE_COUNT;         i++)

35     {

36            if(eccCurves[i].curveId                  ==  curveId)

37                   return         &eccCurves[i];

38     }

39     FAIL(FATAL_ERROR_INTERNAL);

40  }

41  static    const  ECC_CURVE_DATA              *

42  GetCurveData(

43     TPM_ECC_CURVE                curveId                  //  IN:   the   curveID

44     )

45  {

46     const      ECC_CURVE               *curve    =  _cpri__EccGetParametersByCurveId(curveId);

47     return        curve->curveData;

48  }

    B.13.3.2.4.      Point2B()

    This function makes a TPMS_ECC_POINT from a BIGNUM EC_POINT.

49  static    BOOL

50  Point2B(

51     EC_GROUP                     *group,                  //  IN:   group  for   the  point

52     TPMS_ECC_POINT               *p,                      //  OUT:   receives    the  converted   point

53     EC_POINT                     *ecP,                    //  IN:   the   point  to   convert

54     INT16                        size,                    //  IN:   size   of  the   coordinates

55     BN_CTX                       *context                 //  IN:   working    context

56     )

57  {

58     BIGNUM                       *bnX;

59     BIGNUM                       *bnY;

60

61     BN_CTX_start(context);

62     bnX    =   BN_CTX_get(context);

63     bnY    =   BN_CTX_get(context);

64

65     if(           bnY     ==     NULL

66

67            //     Get  the       coordinate    values

68           ||      EC_POINT_get_affine_coordinates_GFp(group,                        ecP,  bnX,  bnY,  context)    !=  1

69

70           //   Convert        x

71           ||      (!BnTo2B(&p->x.b,          bnX,       size))

72

73           //   Convert        y

74           ||      (!BnTo2B(&p->y.b,          bnY,       size))

75        )

76                   FAIL(FATAL_ERROR_INTERNAL);

77

78     BN_CTX_end(context);

79     return        TRUE;

    Page 480                                                 TCG Published                                      Family "2.0"

    October 30, 2014                                Copyright © TCG 2006-2014                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                             Trusted Platform Module Library

80   }

     B.13.3.2.5.   EccCurveInit()

     This function initializes the OpenSSL() group definition structure

     This function is only used within this file.

     It is a fatal error if groupContext is not provided.

     Return Value                       Meaning

     NULL                               the TPM_ECC_CURVE is not valid

     non-NULL                           points to a structure in groupContext static EC_GROUP *

81   static    EC_GROUP  *

82   EccCurveInit(

83      TPM_ECC_CURVE             curveId,                   //  IN:  the  ID   of  the   curve

84      BN_CTX                  *groupContext                //  IN:  the  context    in     which  the  group  is  to  be

85                                                           //       created

86      )

87   {

88      const     ECC_CURVE_DATA           *curveData            =  GetCurveData(curveId);

89      EC_GROUP                           *group         =  NULL;

90      EC_POINT                           *P   =     NULL;

91      BN_CTX                             *context;

92      BIGNUM                             *bnP;

93      BIGNUM                             *bnA;

94      BIGNUM                             *bnB;

95      BIGNUM                             *bnX;

96      BIGNUM                             *bnY;

97      BIGNUM                             *bnN;

98      BIGNUM                             *bnH;

99      int                                 ok     =  FALSE;

100

101     //   Context     must   be   provided      and       curve    selector  must     be  valid

102     pAssert(groupContext           !=  NULL       &&     curveData     !=   NULL);

103

104     context      =   BN_CTX_new();

105     if(context       ==   NULL)

106            FAIL(FATAL_ERROR_ALLOCATION);

107

108     BN_CTX_start(context);

109     bnP    =  BN_CTX_get(context);

110     bnA    =  BN_CTX_get(context);

111     bnB    =  BN_CTX_get(context);

112     bnX    =  BN_CTX_get(context);

113     bnY    =  BN_CTX_get(context);

114     bnN    =  BN_CTX_get(context);

115     bnH    =  BN_CTX_get(context);

116

117     if   (bnH    ==  NULL)

118            goto     Cleanup;

119

120     //   Convert     the   number  formats

121

122     BnFrom2B(bnP,         curveData->p);

123     BnFrom2B(bnA,         curveData->a);

124     BnFrom2B(bnB,         curveData->b);

125     BnFrom2B(bnX,         curveData->x);

126     BnFrom2B(bnY,         curveData->y);

127     BnFrom2B(bnN,         curveData->n);

128     BnFrom2B(bnH,         curveData->h);

129

     Family "2.0"                                            TCG Published                                          Page 481

     Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                 October 30, 2014
     Trusted Platform Module Library                                                                                Part 4: Supporting Routines

130        //   initialize               EC     group,     associate    a  generator        point    and      initialize      the   point

131        //   from         the     parameter           data

132        ok   =     (       (group         =   EC_GROUP_new_curve_GFp(bnP,                bnA,     bnB,     groupContext))        !=  NULL

133                      &&   (P     =   EC_POINT_new(group))              !=   NULL

134                      &&   EC_POINT_set_affine_coordinates_GFp(group,                             P,    bnX,     bnY,  groupContext)

135                      &&   EC_GROUP_set_generator(group,                     P,    bnN,  bnH)

136                   );

137  Cleanup:

138        if   (!ok         &&     group       !=  NULL)

139        {

140                EC_GROUP_free(group);

141                group         =   NULL;

142        }

143        if(P       !=     NULL)

144                EC_POINT_free(P);

145        BN_CTX_end(context);

146        BN_CTX_free(context);

147        return         group;

148  }

     B.13.3.2.6.          PointFrom2B()

     This function sets the coordinates of an existing BN Point from a TPMS_ECC_POINT.

149  static     EC_POINT             *

150  PointFrom2B(

151        EC_GROUP                          *group,                //     IN:  the   group    for       the  point

152        EC_POINT                          *ecP,                  //     IN:  an    existing       BN  point      in  the   group

153        TPMS_ECC_POINT                    *p,                    //     IN:  the   2B    coordinates         of  the   point

154        BN_CTX                            *context               //     IN:  the   BIGNUM      context

155        )

156  {

157        BIGNUM                            *bnX;

158        BIGNUM                            *bnY;

159

160        //   If       the     point       is     not  allocated      then    just  return      a  NULL

161        if(ecP         ==     NULL)

162                return           NULL;

163

164        BN_CTX_start(context);

165        bnX     =     BN_CTX_get(context);

166        bnY     =     BN_CTX_get(context);

167        if(     //     Set       the  coordinates           of  the  point

168                      bnY     ==     NULL

169             ||       BN_bin2bn(p->x.t.buffer,                   p->x.t.size,       bnX)    ==    NULL

170             ||       BN_bin2bn(p->y.t.buffer,                   p->y.t.size,       bnY)    ==    NULL

171             ||       !EC_POINT_set_affine_coordinates_GFp(group,                              ecP,     bnX,     bnY,  context)

172             )

173             FAIL(FATAL_ERROR_INTERNAL);

174

175        BN_CTX_end(context);

176        return         ecP;

177  }

     B.13.3.2.7.          EccInitPoint2B()

     This     function        allocates         a   point  in  the  provided        group   and      initializes    it  with   the   values   in  a

     TPMS_ECC_POINT.

178  static     EC_POINT             *

179  EccInitPoint2B(

180        EC_GROUP                          *group,                //     IN:  group     for  the       point

181        TPMS_ECC_POINT                    *p,                    //     IN:  the   coordinates          for    the   point

     Page 482                                                         TCG Published                                                  Family "2.0"

     October 30, 2014                                          Copyright © TCG 2006-2014                            Level 00   Revision 01.16
     Part  4: Supporting Routines                                                               Trusted Platform Module Library

182        BN_CTX                 *context                //       IN:   the  BIGNUM      context

183        )

184  {

185        EC_POINT               *ecP;

186

187        BN_CTX_start(context);

188        ecP   =   EC_POINT_new(group);

189

190        if(PointFrom2B(group,             ecP,  p,  context)          ==   NULL)

191              FAIL(FATAL_ERROR_INTERNAL);

192

193        BN_CTX_end(context);

194        return    ecP;

195  }

     B.13.3.2.8.     PointMul()

     This function does a point multiply and checks for the result being the point at                  infinity.  Q  =  ([A]G  +  [B]P)

     Return Value                            Meaning

     CRYPT_NO_RESULT                         point is at infinity

     CRYPT_SUCCESS                           point not at infinity

196  static     CRYPT_RESULT

197  PointMul(

198        EC_GROUP               *group,                 //       IN:   group   curve

199        EC_POINT               *ecpQ,                  //       OUT:  result

200        BIGNUM                 *bnA,                   //       IN:   scalar    for    [A]G

201        EC_POINT               *ecpP,                  //       IN:   point   for    [B]P

202        BIGNUM                 *bnB,                   //       IN:   scalar    for    [B]P

203        BN_CTX                 *context                //       IN:   working     context

204        )

205  {

206             if(EC_POINT_mul(group,             ecpQ,  bnA,      ecpP,     bnB,    context)     !=  1)

207                   FAIL(FATAL_ERROR_INTERNAL);

208              if(EC_POINT_is_at_infinity(group,                      ecpQ))

209                   return      CRYPT_NO_RESULT;

210              return     CRYPT_SUCCESS;

211  }

     B.13.3.2.9.     GetRandomPrivate()

     This function gets a random value (d) to use as a private ECC key and then qualifies the key so that it is

     between 0 < d < n.

     It is a fatal error if dOut or pIn is not provided or if the size of pIn is larger than MAX_ECC_KEY_BYTES

     (the largest buffer size of a TPM2B_ECC_PARAMETER)

212  static     void

213  GetRandomPrivate(

214        TPM2B_ECC_PARAMETER               *dOut,                      //   OUT:    the   qualified      random    value

215        const     TPM2B                   *pIn                        //   IN:    the    maximum    value  for    the  key

216        )

217  {

218        int              i;

219        BYTE             *pb;

220

221        pAssert(pIn      !=    NULL  &&   dOut  !=     NULL      &&   pIn->size      <=  MAX_ECC_KEY_BYTES);

222

223        //   Set  the    size  of    the  output

224        dOut->t.size     =     pIn->size;

     Family "2.0"                                         TCG Published                                                        Page 483

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                      October 30, 2014
     Trusted Platform Module Library                                                                           Part  4:  Supporting  Routines

225     //   Get  some       random             bits

226     while(TRUE)

227     {

228          _cpri__GenerateRandom(dOut->t.size,                                  dOut->t.buffer);

229          //   See     if     the         d  <   n

230          if(memcmp(dOut->t.buffer,                             pIn->buffer,        pIn->size)       <  0)

231          {

232               //      dOut         <     n  so      make    sure  that     0  <    dOut

233               for(pb            =     dOut->t.buffer,             i   =  dOut->t.size;        i  >     0;  i--)

234               {

235                          if(*pb++               !=  0)

236                                    return;

237               }

238          }

239     }

240  }

     B.13.3.2.10. Mod2B()

     Function does modular reduction of TPM2B values.

241  static  CRYPT_RESULT

242  Mod2B(

243     TPM2B                          *x,                            //  IN/OUT:      value  to     reduce

244     const     TPM2B                *n                             //  IN:     mod

245     )

246  {

247     int                  compare;

248     compare   =    _math__uComp(x->size,                          x->buffer,       n->size,      n->buffer);

249     if(compare        <     0)

250          //   if   x     <   n,       then      mod     is  x

251          return       CRYPT_SUCCESS;

252     if(compare        ==     0)

253     {

254          //   if   x     ==     n     then      mod     is  0

255          x->size         =   0;

256          x->buffer[0]                 =     0;

257          return       CRYPT_SUCCESS;

258     }

259     return    _math__Div(x,                 n,      NULL,   x);

260  }

     B.13.3.2.11. _cpri__EccPointMultiply

     This function computes 'R := [dIn]G + [uIn]QIn. Where dIn and uIn are scalars, G and QIn are points on

     the specified curve and G is the default generator of the curve.

     The xOut and yOut parameters are optional and may be set to NULL if not used.

     It is not necessary to provide uIn if QIn is specified but one of uIn and dIn must be provided. If dIn and

     QIn are specified but uIn is not provided, then R = [dIn]QIn.

     If the multiply produces the point at infinity, the CRYPT_NO_RESULT is returned.

     The sizes of xOut and yOut' will be set to be the size of the degree of the curve

     It is a fatal error if dIn and uIn are both unspecified (NULL) or if Qin or Rout is unspecified.

     Page 484                                                         TCG Published                                      Family "2.0"

     October 30, 2014                                       Copyright © TCG 2006-2014                          Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                          Trusted Platform Module Library

     Return Value                               Meaning

     CRYPT_SUCCESS                              point multiplication succeeded

     CRYPT_POINT                                the point Qin is not on the curve

     CRYPT_NO_RESULT                            the product point is at infinity

261  LIB_EXPORT     CRYPT_RESULT

262  _cpri__EccPointMultiply(

263     TPMS_ECC_POINT                              *Rout,                     //   OUT:   the    product       point      R

264     TPM_ECC_CURVE                               curveId,                   //   IN:   the     curve   to    use

265     TPM2B_ECC_PARAMETER                         *dIn,                      //   IN:   value       to  multiply       against      the

266                                                                            //         curve       generator

267     TPMS_ECC_POINT                              *Qin,                      //   IN:   point       Q

268     TPM2B_ECC_PARAMETER                         *uIn                       //   IN:   scalar         value  for     the   multiplier

269                                                                            //         of   Q

270     )

271  {

272     BN_CTX                              *context;

273     BIGNUM                              *bnD;

274     BIGNUM                              *bnU;

275     EC_GROUP                            *group;

276     EC_POINT                            *R   =  NULL;

277     EC_POINT                            *Q   =  NULL;

278     CRYPT_RESULT                         retVal       =   CRYPT_SUCCESS;

279

280     //   Validate          that    the   required         parameters       are   provided.

281     pAssert((dIn           !=    NULL    ||     uIn   !=  NULL)    &&      (Qin  !=    NULL       ||  dIn   !=    NULL));

282

283     //   If  a   point       is    provided       for     the     multiply,      make     sure       that   it  is   on   the  curve

284     if(Qin      !=     NULL    &&    !_cpri__EccIsPointOnCurve(curveId,                           Qin))

285          return        CRYPT_POINT;

286

287     context      =     BN_CTX_new();

288     if(context         ==    NULL)

289          FAIL(FATAL_ERROR_ALLOCATION);

290

291     BN_CTX_start(context);

292     bnU  =   BN_CTX_get(context);

293     bnD  =   BN_CTX_get(context);

294     group    =   EccCurveInit(curveId,                    context);

295

296     //   There      should       be  no     path     for  getting       a  bad   curve        ID     into   this    function.

297     pAssert(group            !=    NULL);

298

299     //   check      allocations          should       have     worked      and   allocate         R

300     if(      bnD       ==  NULL

301          ||  (R     =  EC_POINT_new(group))                   ==   NULL)

302          FAIL(FATAL_ERROR_ALLOCATION);

303

304     //   If  Qin       is  present,         create       the   point

305     if(Qin      !=     NULL)

306     {

307          //     Assume       the     size    variables         do  not     overflow.       This       should    not    happen     in

308          //     the    contexts         in   which       this     function      will   be     called.

309          assert2Bsize(Qin->x.t);

310          assert2Bsize(Qin->x.t);

311          Q   =   EccInitPoint2B(group,                    Qin,     context);

312

313     }

314     if(dIn      !=     NULL)

315     {

316          //     Assume       the     size    variables         do  not     overflow,       which      should      not     happen  in

317          //     the    contexts         that    this      function      will     be   called.

318          assert2Bsize(dIn->t);

     Family "2.0"                                                 TCG Published                                                       Page 485

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                               October 30, 2014
     Trusted Platform Module Library                                                                        Part 4: Supporting Routines

319             BnFrom2B(bnD,              &dIn->b);

320       }

321       else

322             bnD    =    NULL;

323

324       //  If    uIn     is  specified,            initialize       its    BIGNUM

325       if(uIn       !=   NULL)

326       {

327             //     Assume       the    size       variables    do    not   overflow,         which  should  not  happen  in

328             //     the  contexts           that   this      function      will     be  called.

329             assert2Bsize(uIn->t);

330             BnFrom2B(bnU,              &uIn->b);

331       }

332       //  If    uIn     is  not       specified        but  Q  is,   then      we  are  going       to

333       //  do    R  =    [d]Q

334       else    if(Qin        !=     NULL)

335       {

336             bnU    =    bnD;

337             bnD    =    NULL;

338       }

339       //  If    neither         Q  nor     u  is  specified,         then  null        this  pointer

340       else

341             bnU    =    NULL;

342

343       //  Use      the  generator             of  the  curve

344       if((retVal        =   PointMul(group,             R,     bnD,  Q,    bnU,    context))        ==  CRYPT_SUCCESS)

345             Point2B(group,              Rout,     R,   (INT16)       BN_num_bytes(&group->field),           context);

346

347       if  (Q)

348             EC_POINT_free(Q);

349       if(R)

350             EC_POINT_free(R);

351       if(group)

352             EC_GROUP_free(group);

353       BN_CTX_end(context);

354       BN_CTX_free(context);

355       return       retVal;

356  }

     B.13.3.2.12. ClearPoint2B()

     Initialize the size values of a point

357  static   void

358  ClearPoint2B(

359       TPMS_ECC_POINT               *p                          //  IN:    the   point

360       )

361  {

362       if(p    !=   NULL)        {

363             p->x.t.size            =   0;

364             p->y.t.size            =   0;

365       }

366  }

367  #if  defined      TPM_ALG_ECDAA              ||  defined      TPM_ALG_SM2         //%

     B.13.3.2.13. _cpri__EccCommitCompute()

     This function performs the point multiply operations required by TPM2_Commit().

     If B or M is provided, they must be on the curve defined by curveId. This routine does not check that they

     are on the curve and results are unpredictable if they are not.

     Page 486                                                      TCG Published                                            Family "2.0"

     October 30, 2014                                 Copyright © TCG 2006-2014                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                           Trusted Platform Module Library

     It is a fatal error if r or d is NULL. If B is not NULL, then it is a fatal error if K and L are both NULL. If                                              M  is

     not NULL, then it is a fatal error if E is NULL.

     Return Value                                       Meaning

     CRYPT_SUCCESS                                      computations completed normally

     CRYPT_NO_RESULT                                    if K, L or E was computed to be the point at infinity

     CRYPT_CANCEL                                       a cancel indication was asserted during this function

368  LIB_EXPORT        CRYPT_RESULT

369  _cpri__EccCommitCompute(

370     TPMS_ECC_POINT                                      *K,                               //  OUT:       [d]B    or    [r]Q

371     TPMS_ECC_POINT                                      *L,                               //  OUT:       [r]B

372     TPMS_ECC_POINT                                      *E,                               //  OUT:       [r]M

373     TPM_ECC_CURVE                                          curveId,                       //  IN:     the       curve     for     the  computations

374     TPMS_ECC_POINT                                      *M,                               //  IN:     M     (optional)

375     TPMS_ECC_POINT                                      *B,                               //  IN:     B     (optional)

376     TPM2B_ECC_PARAMETER                                 *d,                               //  IN:     d     (required)

377     TPM2B_ECC_PARAMETER                                 *r                                //  IN:     the       computed       r  value     (required)

378     )

379  {

380     BN_CTX                                      *context;

381     BIGNUM                                      *bnX,         *bnY,       *bnR,     *bnD;

382     EC_GROUP                                    *group;

383     EC_POINT                                    *pK     =     NULL,       *pL  =    NULL,        *pE     =  NULL,      *pM     =  NULL,     *pB   =   NULL;

384     UINT16                                       keySizeInBytes;

385     CRYPT_RESULT                                 retVal           =   CRYPT_SUCCESS;

386

387     //   Validate               that       the   required             parameters          are     provided.

388     //   Note:         E     has     to    be    provided             if  computing           E   :=     [r]Q    or    E  :=      [r]M.     Will  do

389     //   E     :=  [r]Q          if     both     M     and     B     are  NULL.

390     pAssert(                 r   !=     NULL     &&     (K     !=     NULL     ||   B     ==  NULL)         &&   (L  !=   NULL    ||     B  ==    NULL)

391                    ||        (E   !=       NULL     ||     (M     ==  NULL     &&      B  !=     NULL)));

392

393     context        =      BN_CTX_new();

394     if(context               ==   NULL)

395             FAIL(FATAL_ERROR_ALLOCATION);

396     BN_CTX_start(context);

397     bnR     =  BN_CTX_get(context);

398     bnD     =  BN_CTX_get(context);

399     bnX     =  BN_CTX_get(context);

400     bnY     =  BN_CTX_get(context);

401     if(bnY         ==     NULL)

402             FAIL(FATAL_ERROR_ALLOCATION);

403

404     //   Initialize               the      output          points         in   case       they    are       not  computed

405     ClearPoint2B(K);

406     ClearPoint2B(L);

407     ClearPoint2B(E);

408

409     if((group             =     EccCurveInit(curveId,                         context))          ==   NULL)

410     {

411             retVal           =   CRYPT_PARAMETER;

412             goto       Cleanup2;

413     }

414     keySizeInBytes                   =     (UINT16)           BN_num_bytes(&group->field);

415

416     //   Sizes         of       the     r  and      d   parameters             may     not    be     zero

417     pAssert(((int)                   r->t.size             >   0)     &&  ((int)          d->t.size         >    0));

418

419     //   Convert             scalars       to       BIGNUM

420     BnFrom2B(bnR,                 &r->b);

421     BnFrom2B(bnD,                 &d->b);

422

     Family "2.0"                                                             TCG Published                                                               Page 487

     Level 00 Revision 01.16                                      Copyright © TCG 2006-2014                                                     October 30, 2014
     Trusted Platform Module Library                                                                                      Part 4: Supporting Routines

423     //  If        B     is   provided,               compute         K=[d]B       and    L=[r]B

424     if(B         !=     NULL)

425     {

426            //     Allocate           the         points      to      receive      the      value

427            if(            (pK     =     EC_POINT_new(group))                      ==    NULL

428                      ||   (pL     =     EC_POINT_new(group))                      ==    NULL)

429            FAIL(FATAL_ERROR_ALLOCATION);

430            //     need       to   compute             K   =  [d]B

431            //     Allocate           and         initialize           BIGNUM      version         of  B

432            pB     =   EccInitPoint2B(group,                           B,  context);

433

434            //     do     the     math         for     K   =  [d]B

435            if((retVal             =     PointMul(group,                   pK,     NULL,    pB,    bnD,      context))        !=  CRYPT_SUCCESS)

436                      goto     Cleanup;

437

438            //     Convert         BN       K     to   TPM2B       K

439            Point2B(group,                     K,     pK,     (INT16)keySizeInBytes,                   context);

440

441            //        compute         L=       [r]B       after       checking       for    cancel

442            if(_plat__IsCanceled())

443            {

444                      retVal       =     CRYPT_CANCEL;

445                      goto     Cleanup;

446            }

447            //     compute         L     =     [r]B

448            if((retVal             =     PointMul(group,                   pL,     NULL,    pB,    bnR,      context))        !=  CRYPT_SUCCESS)

449                      goto     Cleanup;

450

451            //     Convert         BN       L     to   TPM2B       L

452            Point2B(group,                     L,     pL,     (INT16)keySizeInBytes,                   context);

453     }

454     if(M         !=     NULL     ||     B     ==     NULL)

455     {

456            //     if     this     is       the       third   point        multiply,        check         for  cancel      first

457            if(B       !=     NULL       &&       _plat__IsCanceled())

458            {

459                      retVal       =     CRYPT_CANCEL;

460                      goto     Cleanup;

461            }

462

463            //     Allocate           E

464            if((pE         =   EC_POINT_new(group))                        ==      NULL)

465                      FAIL(FATAL_ERROR_ALLOCATION);

466

467            //     Create         BIGNUM           version         of  M   unless        M  is     NULL

468            if(M       !=     NULL)

469            {

470                      //   M   provided               so   initialize           a  BIGNUM       M  and       compute  E    =  [r]M

471                      pM   =   EccInitPoint2B(group,                       M,      context);

472                      retVal       =     PointMul(group,                   pE,     NULL,    pM,    bnR,      context);

473            }

474            else

475                      //   compute             E   =   [r]G   (this        is      only     done   if     M  and  B   are     both  NULL

476                      retVal       =     PointMul(group,                   pE,     bnR,     NULL,      NULL,   context);

477

478            if(retVal             ==     CRYPT_SUCCESS)

479                      //   Convert             E   to     2B  format

480                      Point2B(group,                   E,     pE,     (INT16)keySizeInBytes,                   context);

481     }

482  Cleanup:

483     EC_GROUP_free(group);

484     if(pK         !=     NULL)       EC_POINT_free(pK);

485     if(pL         !=     NULL)       EC_POINT_free(pL);

486     if(pE         !=     NULL)       EC_POINT_free(pE);

487     if(pM         !=     NULL)       EC_POINT_free(pM);

488     if(pB         !=     NULL)       EC_POINT_free(pB);

     Page 488                                                             TCG Published                                                      Family "2.0"

     October 30, 2014                                            Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                 Trusted Platform Module Library

489  Cleanup2:

490     BN_CTX_end(context);

491     BN_CTX_free(context);

492     return       retVal;

493  }

494  #endif     //%

     B.13.3.2.14. _cpri__EccIsPointOnCurve()

     This function is used to test if a point is on a defined curve. It does this by checking               that  y^2 mod p  =  x^3

     + a*x + b mod p

     It is a fatal error if Q is not specified (is NULL).

     Return Value                             Meaning

     TRUE                                     point is on curve

     FALSE                                    point is not on curve or curve is not supported

495  LIB_EXPORT      BOOL

496  _cpri__EccIsPointOnCurve(

497     TPM_ECC_CURVE                 curveId,              //     IN:  the  curve    selector

498     TPMS_ECC_POINT             *Q                       //     IN:  the  point.

499     )

500  {

501     BN_CTX                                   *context;

502     BIGNUM                                   *bnX;

503     BIGNUM                                   *bnY;

504     BIGNUM                                   *bnA;

505     BIGNUM                                   *bnB;

506     BIGNUM                                   *bnP;

507     BIGNUM                                   *bn3;

508     const        ECC_CURVE_DATA              *curveData        =  GetCurveData(curveId);

509     BOOL                                     retVal;

510

511     pAssert(Q        !=     NULL   &&  curveData       !=   NULL);

512

513     if((context          =  BN_CTX_new())         ==   NULL)

514             FAIL(FATAL_ERROR_ALLOCATION);

515     BN_CTX_start(context);

516     bnX     =   BN_CTX_get(context);

517     bnY     =   BN_CTX_get(context);

518     bnA     =   BN_CTX_get(context);

519     bnB     =   BN_CTX_get(context);

520     bn3     =   BN_CTX_get(context);

521     bnP     =   BN_CTX_get(context);

522     if(bnP       ==  NULL)

523             FAIL(FATAL_ERROR_ALLOCATION);

524

525     //   Convert     values

526     if   (       !BN_bin2bn(Q->x.t.buffer,                  Q->x.t.size,      bnX)

527             ||   !BN_bin2bn(Q->y.t.buffer,                  Q->y.t.size,      bnY)

528             ||   !BN_bin2bn(curveData->p->buffer,                   curveData->p->size,      bnP)

529             ||   !BN_bin2bn(curveData->a->buffer,                   curveData->a->size,      bnA)

530             ||   !BN_set_word(bn3,           3)

531             ||   !BN_bin2bn(curveData->b->buffer,                   curveData->b->size,      bnB)

532          )

533             FAIL(FATAL_ERROR_INTERNAL);

534

535     //   The     following        sequence   is     probably        not  optimal    but  it  seems  to  be    correct.

536     //   compute     x^3    +     a*x  +  b  mod    p

537                  //  first,        compute   a*x       mod  p

538     if(         !BN_mod_mul(bnA,          bnA,    bnX,      bnP,    context)

     Family "2.0"                                           TCG Published                                         Page 489

     Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                  October 30, 2014
     Trusted Platform Module Library                                                                           Part 4: Supporting Routines

539                   //  next,  compute   a*x    +     b     mod     p

540            ||  !BN_mod_add(bnA,       bnA,  bnB,          bnP,       context)

541                   //  next,  compute   X^3    mod         p

542            ||  !BN_mod_exp(bnX,       bnX,  bn3,          bnP,       context)

543                   //  finally,  compute     x^3        +     a*x     +  b   mod     p

544            ||  !BN_mod_add(bnX,       bnX,  bnA,          bnP,       context)

545                   //  then   compute  y^2

546            ||  !BN_mod_mul(bnY,       bnY,  bnY,          bnP,       context)

547         )

548            FAIL(FATAL_ERROR_INTERNAL);

549

550     retVal     =  BN_cmp(bnX,   bnY)   ==     0;

551     BN_CTX_end(context);

552     BN_CTX_free(context);

553     return     retVal;

554  }

     B.13.3.2.15. _cpri__GenerateKeyEcc()

     This function generates an ECC key pair based on the input parameters. This routine uses KDFa() to

     produce   candidate  numbers.    The  method             is  according          to    FIPS      186-3,    section  B.4.1     "GKey()    Pair

     Generation Using Extra Random Bits." According to the method in FIPS 186-3, the resulting private value

     d should be 1 <= d < n where n is the order of the base point. In this implementation, the range of the

     private value is further restricted to be 2^(nLen/2) <= d < n where nLen is the order of n.

     EXAMPLE:         If the curve is NIST-P256, then nLen is 256 bits and d will need to be between 2^128 <= d < n

     It is a fatal error if Qout, dOut, or seed is not provided (is NULL).

     Return Value                         Meaning

     CRYPT_PARAMETER                      the hash algorithm is not supported

555  LIB_EXPORT    CRYPT_RESULT

556  _cpri__GenerateKeyEcc(

557     TPMS_ECC_POINT                    *Qout,                            //     OUT:       the  public      point

558     TPM2B_ECC_PARAMETER               *dOut,                            //     OUT:       the  private     scalar

559     TPM_ECC_CURVE                      curveId,                         //     IN:     the     curve  identifier

560     TPM_ALG_ID                         hashAlg,                         //     IN:     hash    algorithm        to  use  in    the  key

561                                                                         //             generation         process

562     TPM2B                             *seed,                            //     IN:     the     seed   to   use

563     const      char                   *label,                           //     IN:     A  label      for   the  generation

564                                                                         //             process.

565     TPM2B                             *extra,                           //     IN:     Party     1   data  for      the  KDF

566     UINT32                            *counter                          //     IN/OUT:         Counter     value    to   allow  KDF

567                                                                         //             iteration      to   be   propagated      across

568                                                                         //             multiple       functions

569     )

570  {

571     const      ECC_CURVE_DATA         *curveData              =   GetCurveData(curveId);

572     INT16                              keySizeInBytes;

573     UINT32                             count        =     0;

574     CRYPT_RESULT                       retVal;

575     UINT16                             hLen      =     _cpri__GetDigestSize(hashAlg);

576     BIGNUM                            *bnNm1;                           //     Order      of   the    curve     minus    one

577     BIGNUM                            *bnD;                             //     the     private       scalar

578     BN_CTX                            *context;                         //     the     context       for   the  BIGNUM   values

579     BYTE                               withExtra[MAX_ECC_KEY_BYTES                               +   8];   //   trial    key    with

580                                                                                                            //extra       bits

581     TPM2B_4_BYTE_VALUE                 marshaledCounter                     =  {4,        {0}};

582     UINT32                             totalBits;

583

584     //     Validate   parameters      (these     are         fatal)

     Page 490                                              TCG Published                                                           Family "2.0"

     October 30, 2014                      Copyright © TCG 2006-2014                                             Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                          Trusted Platform Module Library

585     pAssert(                seed   !=   NULL     &&     dOut       !=     NULL  &&    Qout    !=  NULL   &&  curveData        !=     NULL);
        
586     
        
587     //   Non-fatal              parameter       checks.
        
588     if(hLen          <=     0)
        
589          return             CRYPT_PARAMETER;
        
590     
        
591     //   allocate            the   local     BN     values
        
592     context          =   BN_CTX_new();
        
593     if(context              ==   NULL)
        
594          FAIL(FATAL_ERROR_ALLOCATION);
        
595     BN_CTX_start(context);
        
596     bnNm1     =      BN_CTX_get(context);
        
597     bnD  =    BN_CTX_get(context);
        
598     
        
599     //   The      size       of   the   input       scalars           is   limited       by  the  size   of  the   size     of    a
        
600     //   TPM2B_ECC_PARAMETER.                    Make       sure       that     it   is  not     irrational.
        
601     pAssert((int)                curveData->n->size                   <=   MAX_ECC_KEY_BYTES);
        
602     
        
603     if(       bnD        ==     NULL
        
604          ||   BN_bin2bn(curveData->n->buffer,                                curveData->n->size,             bnNm1)     ==  NULL
        
605          ||   (keySizeInBytes                =   (INT16)           BN_num_bytes(bnNm1))           >      MAX_ECC_KEY_BYTES)
        
606          FAIL(FATAL_ERROR_INTERNAL);
        
607     
        
608     //   get      the       total     number     of     bits
        
609     totalBits            =   BN_num_bits(bnNm1)                 +     64;
        
610     
        
611     //   Reduce          bnNm1     from     'n'     to  'n'        -   1
        
612     BN_sub_word(bnNm1,                  1);
        
613     
        
614     //   Initialize              the   count     value
        
615     if(counter              !=   NULL)
        
616          count           =   *counter;
        
617     if(count            ==   0)
        
618          count           =   1;
        
619     
        
620     //   Start          search     for     key   (should           be     quick)
        
621     for(;     count          !=   0;   count++)
        
622     {
        
623     
        
624          UINT32_TO_BYTE_ARRAY(count,                               marshaledCounter.t.buffer);
        
625          _cpri__KDFa(hashAlg,                       seed,       label,       extra,      &marshaledCounter.b,
        
626                                    totalBits,           withExtra,           NULL,       FALSE);
        
627     
        
628          //       Convert         the   result       and    modular          reduce
        
629          //       Assume         the   size     variables             do   not  overflow,         which  should    not      happen   in
        
630          //       the       contexts       that     this    function            will     be  called.
        
631          pAssert(keySizeInBytes                         <=  MAX_ECC_KEY_BYTES);
        
632          if       (         BN_bin2bn(withExtra,                   keySizeInBytes+8,              bnD)   ==  NULL
        
633                      ||     BN_mod(bnD,         bnD,    bnNm1,            context)       !=  1)
        
634                      FAIL(FATAL_ERROR_INTERNAL);
        
635     
        
636          //       Add       one   to   get   0   <   d  <   n
        
637          BN_add_word(bnD,                   1);
        
638          if(BnTo2B(&dOut->b,                     bnD,       keySizeInBytes)              !=   1)
        
639                              FAIL(FATAL_ERROR_INTERNAL);
        
640     
        
641          //       Do     the     point     multiply         to     create       the   public      portion    of  the    key.    If
        
642          //       the       multiply       generates        the        point    at    infinity    (unlikely),         do    another
        
643          //       iteration.
        
644          if(                (retVal     =   _cpri__EccPointMultiply(Qout,                         curveId,       dOut,    NULL,      NULL))
        
645                      !=     CRYPT_NO_RESULT)
        
646                      break;
        
647     }
        
648     
        
649     if(count            ==   0)   //   if   counter         wrapped,         then     the    TPM  should     go  into     failure    mode
        
650          FAIL(FATAL_ERROR_INTERNAL);

     Family "2.0"                                                   TCG Published                                                     Page 491

     Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                              October 30, 2014
     Trusted Platform Module Library                                                                Part 4: Supporting Routines

651

652     //   Free  up   allocated        BN    values

653     BN_CTX_end(context);

654     BN_CTX_free(context);

655     if(counter      !=     NULL)

656          *counter       =  count;

657     return     retVal;

658  }

     B.13.3.2.16. _cpri__GetEphemeralEcc()

     This function creates an ephemeral ECC. It is ephemeral in that is expected that the private part of                        the

     key will be discarded

659  LIB_EXPORT    CRYPT_RESULT

660  _cpri__GetEphemeralEcc(

661     TPMS_ECC_POINT                         *Qout,                  //   OUT:   the  public     point

662     TPM2B_ECC_PARAMETER                    *dOut,                  //   OUT:   the  private     scalar

663     TPM_ECC_CURVE                            curveId               //   IN:   the   curve  for   the    key

664     )

665  {

666     CRYPT_RESULT                             retVal;

667     const    ECC_CURVE_DATA                *curveData      =  GetCurveData(curveId);

668

669     pAssert(curveData           !=   NULL);

670

671     //   Keep  getting         random    values    until      one  is   found     that  doesn't     create   a   point

672     //   at  infinity.         This  will    never,    ever,       ever,    ever,   ever,  happen       but  if  it  does

673     //   we  have   to     get  a    next    random   value.

674     while(TRUE)

675     {

676          GetRandomPrivate(dOut,              curveData->p);

677

678          //    _cpri__EccPointMultiply               does     not  return     CRYPT_ECC_POINT       if   no  point       is

679          //    provided.        CRYPT_PARAMTER        should       not  be   returned   because     the      curve   ID

680          //    has  to     be   supported.   Thus      the    only      possible    error  is   CRYPT_NO_RESULT.

681          retVal     =      _cpri__EccPointMultiply(Qout,                  curveId,      dOut,   NULL,    NULL);

682          if(retVal         !=   CRYPT_NO_RESULT)

683                return      retVal;       //  Will    return   CRYPT_SUCCESS

684     }

685  }

686  #ifdef  TPM_ALG_ECDSA          //%

     B.13.3.2.17. SignEcdsa()

     This function implements the ECDSA signing algorithm. The method is described in the comments below.

     It is a fatal error if rOut, sOut, dIn, or digest are not provided.

687  LIB_EXPORT    CRYPT_RESULT

688  SignEcdsa(

689     TPM2B_ECC_PARAMETER                    *rOut,                  //   OUT:   r   component    of  the      signature

690     TPM2B_ECC_PARAMETER                    *sOut,                  //   OUT:   s   component    of  the      signature

691     TPM_ECC_CURVE                            curveId,              //   IN:   the   curve  used     in  the  signature

692                                                                    //         process

693     TPM2B_ECC_PARAMETER                    *dIn,                   //   IN:   the   private    key

694     TPM2B                                  *digest                 //   IN:   the   value  to   sign

695     )

696  {

697     BIGNUM                                 *bnK;

698     BIGNUM                                 *bnIk;

699     BIGNUM                                 *bnN;

700     BIGNUM                                 *bnR;

     Page 492                                             TCG Published                                                 Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                           Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                                          Trusted Platform Module Library

701      BIGNUM                                            *bnD;

702      BIGNUM                                            *bnZ;

703      TPM2B_ECC_PARAMETER                                   k;

704      TPMS_ECC_POINT                                        R;

705      BN_CTX                                            *context;

706      CRYPT_RESULT                                          retVal             =   CRYPT_SUCCESS;

707      const        ECC_CURVE_DATA                       *curveData                    =     GetCurveData(curveId);

708

709      pAssert(rOut                  !=   NULL       &&  sOut            !=     NULL         &&   dIn       !=     NULL         &&     digest     !=     NULL);

710

711      context      =       BN_CTX_new();

712      if(context              ==     NULL)

713            FAIL(FATAL_ERROR_ALLOCATION);

714      BN_CTX_start(context);

715      bnN   =      BN_CTX_get(context);

716      bnZ   =      BN_CTX_get(context);

717      bnR   =      BN_CTX_get(context);

718      bnD   =      BN_CTX_get(context);

719      bnIk      =  BN_CTX_get(context);

720      bnK   =      BN_CTX_get(context);

721      //   Assume          the       size     variables                 do     not       overflow,             which           should       not     happen      in

722      //   the     contexts              that       this       function               will       be       called.

723      pAssert(curveData->n->size                                  <=       MAX_ECC_PARAMETER_BYTES);

724      if(          bnK     ==       NULL

725           ||      BN_bin2bn(curveData->n->buffer,                                             curveData->n->size,                         bnN)     ==     NULL)

726            FAIL(FATAL_ERROR_INTERNAL);

727

728  //  The  algorithm                as   described             in       "Suite           B     Implementer's                   Guide       to  FIPS        186-3(ECDSA)"

729  //  1.   Use     one     of       the     routines           in       Appendix               A.2     to     generate             (k,     k^-1),       a  per-message

730  //       secret       number           and     its    inverse                modulo           n.     Since         n     is  prime,          the

731  //       output       will         be     invalid         only           if     there         is     a   failure             in     the   RBG.

732  //  2.   Compute         the       elliptic           curve           point         R     =   [k]G       =   (xR,        yR)        using    EC    scalar

733  //       multiplication                   (see    [Routines]),                      where         G     is   the         base       point    included         in

734  //       the     set     of       domain       parameters.

735  //  3.   Compute         r     =   xR     mod     n.  If        r     =     0,   then         return         to       Step       1.   1.

736  //  4.   Use     the     selected           hash      function                  to     compute           H   =     Hash(M).

737  //  5.   Convert         the       bit     string         H     to       an     integer           e     as   described               in   Appendix       B.2.

738  //  6.   Compute         s     =   (k^-1       *      (e     +     d     *      r))       mod     n.     If     s     =  0,      return      to    Step      1.2.

739  //  7.   Return       (r,         s).

740

741      //   Generate              a   random         value         k     in     the       range         1   <=     k     <  n

742      //   Want    a       K     value       that       is     the         same       size       as       the     curve        order

743      k.t.size          =     curveData->n->size;

744

745      while(TRUE)                //     This     implements                   the     loop       at       step       6.    If      s   is   zero,       start     over.

746      {

747            while(TRUE)

748            {

749                   //         Step       1   and    2   --        generate               an     ephemeral               key    and      the    modular         inverse

750                   //         of     the     private           key.

751                   while(TRUE)

752                   {

753                                 GetRandomPrivate(&k,                             curveData->n);

754

755                                 //     Do   the    point            multiply               to   generate               a  point        and    check       to   see  if

756                                 //     the   point         it       at       infinity

757                                 if(          _cpri__EccPointMultiply(&R,                                         curveId,             &k,     NULL,       NULL)

758                                         !=   CRYPT_NO_RESULT)

759                                         break;         //        can         only       be     CRYPT_SUCCESS

760                   }

761

762                   //         x     coordinate          is        mod         p.      Make       it       mod     n

763                   //         Assume         the    size          variables                 do   not       overflow,               which       should      not    happen

764                   //         in     the     contexts             that         this         function           will        be      called.

765                   assert2Bsize(R.x.t);

766                   BN_bin2bn(R.x.t.buffer,                                     R.x.t.size,                 bnR);

     Family "2.0"                                                                 TCG Published                                                                         Page 493

     Level 00 Revision 01.16                                      Copyright © TCG 2006-2014                                                                   October 30, 2014
     Trusted Platform Module Library                                                                                            Part 4: Supporting Routines

767            BN_mod(bnR,                      bnR,        bnN,          context);

768

769            //      Make           sure         that         it    is    not     zero;

770            if(BN_is_zero(bnR))

771                       continue;

772

773            //      Make           sure         that         a     modular       inverse       exists

774            //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen

775            //      in       the         contexts               that     this     function         will    be     called.

776            assert2Bsize(k.t);

777            BN_bin2bn(k.t.buffer,                                      k.t.size,         bnK);

778            if(        BN_mod_inverse(bnIk,                              bnK,        bnN,     context)        !=    NULL)

779                       break;

780            }
               
781            
               
782            //        Set     z     =     leftmost                 bits      of    the     digest
               
783            //        NOTE:         This           is     implemented              such        that     the     key  size       needs   to  be
               
784            //                      an       even         number             of  bytes      in     length.
               
785            if(digest->size                            >     curveData->n->size)
               
786            {
               
787                      //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
               
788                      //      in       the         contexts               that     this     function         will    be     called.
               
789                      pAssert(curveData->n->size                                        <=     MAX_ECC_KEY_BYTES);
               
790                      //      digest               is     larger             than  n    so     truncate
               
791                      BN_bin2bn(digest->buffer,                                        curveData->n->size,                  bnZ);
               
792            }
               
793            else
               
794            {
               
795                      //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
               
796                      //      in       the         contexts               that     this     function         will    be     called.
               
797                      pAssert(digest->size                                   <=    MAX_DIGEST_SIZE);
               
798                      //      digest               is     same         or    smaller        than     n   so     use  it     all
               
799                      BN_bin2bn(digest->buffer,                                        digest->size,            bnZ);
               
800            }
               
801            
               
802            //        Assume           the         size         variables          do      not     overflow,         which      should    not    happen  in
               
803            //        the     contexts                 that        this          function       will     be     called.
               
804            assert2Bsize(dIn->t);
               
805            if(            bnZ         ==       NULL
               
806            
               
807                      //   need           the         private             scalar       of   the    signing      key
               
808                      ||   BN_bin2bn(dIn->t.buffer,                                     dIn->t.size,            bnD)      ==    NULL)
               
809                      FAIL(FATAL_ERROR_INTERNAL);
               
810            
               
811            //        NOTE:         When           the       result          of    an   operation         is    going       to     be  reduced   mod  x
               
812            //        any     modular                 multiplication                   is   done     so   that       the    intermediate         values
               
813            //        don't         get         too       large.
               
814            //
               
815            //        now     have           inverse               of     K  (bnIk),        z   (bnZ),       r  (bnR),          d  (bnD)    and  n    (bnN)
               
816            //        Compute             s     =     k^-1         (z     +  r*d)(mod          n)
               
817                      //         first             do     d     =  r*d       mod   n
               
818            if(           !BN_mod_mul(bnD,                             bnR,      bnD,      bnN,    context)

819

820                      //   d     =     z     +     r   *     d
                         
821                      ||   !BN_add(bnD,                         bnZ,         bnD)
                         
822                      
                         
823                      //   d     =     k^(-1)(z                 +  r      *  d)(mod        n)
                         
824                      ||   !BN_mod_mul(bnD,                               bnIk,    bnD,        bnN,     context)
                         
825                      
                         
826                      //   convert                 to     TPM2B           format
                         
827                      ||   !BnTo2B(&sOut->b,                                 bnD,  curveData->n->size)
                         
828                      
                         
829                      //   and         write           the         modular         reduced         version      of   r
                         
830                      //   NOTE:             this         was      deferred            to   reduce       the    number        of
                         
831                      //   error             checks.
                         
832                      ||   !BnTo2B(&rOut->b,                                 bnR,  curveData->n->size))

     Page 494                                                               TCG Published                                                      Family "2.0"

     October 30, 2014                                           Copyright © TCG 2006-2014                                       Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                          Trusted Platform Module Library

833                      FAIL(FATAL_ERROR_INTERNAL);

834

835              if(!BN_is_zero(bnD))

836                      break;         //  signature         not  zero    so     done

837

838              //      if  the     signature       value    was      zero,    start      over

839       }

840

841       //     Free    up      allocated       BN  values

842       BN_CTX_end(context);

843       BN_CTX_free(context);

844       return         retVal;

845  }

846  #endif      //%

847  #if  defined        TPM_ALG_ECDAA           ||  defined       TPM_ALG_ECSCHNORR               //%

     B.13.3.2.18. EcDaa()

     This function is used to perform a modified Schnorr signature for ECDAA.

     This function performs s = k + T * d mod n where

     a)   'k is a random, or pseudo-random value used in the commit phase

     b)   T is the digest to be signed, and

     c)   d is a private key.

     If tIn is NULL then use tOut as T

     Return Value                                Meaning

     CRYPT_SUCCESS                               signature created

848  static      CRYPT_RESULT

849  EcDaa(

850       TPM2B_ECC_PARAMETER                        *tOut,                     //    OUT:     T   component      of    the    signature

851       TPM2B_ECC_PARAMETER                        *sOut,                     //    OUT:     s   component      of    the    signature

852       TPM_ECC_CURVE                              curveId,                   //    IN:   the    curve  used         in  signing

853       TPM2B_ECC_PARAMETER                        *dIn,                      //    IN:   the    private        key

854       TPM2B                                      *tIn,                      //    IN:   the    value  to      sign

855       TPM2B_ECC_PARAMETER                        *kIn                       //    IN:   a     random  value        from    commit

856       )

857  {

858       BIGNUM                                     *bnN,    *bnK,        *bnT,    *bnD;

859       BN_CTX                                     *context;

860       const       TPM2B                          *n;

861       const       ECC_CURVE_DATA                 *curveData         =  GetCurveData(curveId);

862       BOOL                                       OK    =  TRUE;

863

864       //     Parameter        checks

865          pAssert(            sOut   !=  NULL     &&    dIn     !=   NULL    &&    tOut     !=  NULL

866                          &&  kIn    !=  NULL     &&   curveData        !=   NULL);

867

868       //     this    just     saves     key      strokes

869       n   =  curveData->n;

870

871       if(tIn         !=  NULL)

872              Copy2B(&tOut->b,                tIn);

873

874       //     The     size    of   dIn   and      kIn  input    scalars        is  limited      by     the     size     of  the  size

875       //     of   a  TPM2B_ECC_PARAMETER               and     tIn     can  be    no   larger  than        a  digest.

876       //     Make    sure     they      are  within       range.

877       pAssert(               (int)  dIn->t.size           <=   MAX_ECC_KEY_BYTES

878                      &&      (int)  kIn->t.size           <=   MAX_ECC_KEY_BYTES

     Family "2.0"                                                  TCG Published                                                       Page 495

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                            October 30, 2014
     Trusted Platform Module Library                                                                                  Part 4: Supporting Routines

879                     &&  (int)            tOut->t.size                    <=  MAX_DIGEST_SIZE

880                     );

881

882      context        =   BN_CTX_new();

883      if(context         ==      NULL)

884              FAIL(FATAL_ERROR_ALLOCATION);

885      BN_CTX_start(context);

886      bnN     =  BN_CTX_get(context);

887      bnK     =  BN_CTX_get(context);

888      bnT     =  BN_CTX_get(context);

889      bnD     =  BN_CTX_get(context);

890

891      //   Check         for  allocation                       problems

892      if(bnD         ==  NULL)

893              FAIL(FATAL_ERROR_ALLOCATION);

894

895      //   Convert       values

896      if(        BN_bin2bn(n->buffer,                                n->size,       bnN)  ==  NULL

897           ||    BN_bin2bn(kIn->t.buffer,                                  kIn->t.size,       bnK)  ==      NULL

898           ||    BN_bin2bn(dIn->t.buffer,                                  dIn->t.size,       bnD)  ==  NULL

899           ||    BN_bin2bn(tOut->t.buffer,                                    tOut->t.size,   bnT)      ==  NULL)

900

901              FAIL(FATAL_ERROR_INTERNAL);

902      //   Compute       T    =     T     mod         n

903      OK   =     OK  &&  BN_mod(bnT,                        bnT,        bnN,  context);

904

905      //   compute       (s      =     k     +     T     *     d     mod  n)

906                     //       d     =     T     *     d     mod      n

907      OK   =     OK  &&  BN_mod_mul(bnD,                             bnT,     bnD,  bnN,  context)      ==  1;

908                     //       d     =     k     +     T     *     d  mod   n

909      OK   =     OK  &&  BN_mod_add(bnD,                             bnK,     bnD,  bnN,  context)      ==  1;

910                     //       s     =     d

911      OK   =     OK  &&  BnTo2B(&sOut->b,                               bnD,  n->size);

912                     //       r     =     T

913      OK   =     OK  &&  BnTo2B(&tOut->b,                               bnT,  n->size);

914      if(!OK)

915              FAIL(FATAL_ERROR_INTERNAL);

916

917      //   Cleanup

918      BN_CTX_end(context);

919      BN_CTX_free(context);

920

921      return         CRYPT_SUCCESS;

922  }

923  #endif      //%

924  #ifdef   TPM_ALG_ECSCHNORR                          //%

     B.13.3.2.19. SchnorrEcc()

     This function is used to perform a modified Schnorr signature.

     This function will generate a random value k and compute

     a)  (xR, yR) = [k]G

     b)  r = hash(P || xR)(mod n)

     c)  s= k + r * ds

     d)  return the tuple T, s

     Page 496                                                                    TCG Published                        Family "2.0"

     October 30, 2014                                                   Copyright © TCG 2006-2014                     Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                Trusted Platform Module Library

     Return Value                                Meaning

     CRYPT_SUCCESS                               signature created

     CRYPT_SCHEME                                hashAlg can't produce zero-length digest

925  static    CRYPT_RESULT

926  SchnorrEcc(

927     TPM2B_ECC_PARAMETER                           *rOut,                            //  OUT:    r   component     of  the    signature

928     TPM2B_ECC_PARAMETER                           *sOut,                            //  OUT:    s   component     of  the    signature

929     TPM_ALG_ID                                     hashAlg,                         //  IN:    hash  algorithm        used

930     TPM_ECC_CURVE                                  curveId,                         //  IN:    the   curve   used     in  signing

931     TPM2B_ECC_PARAMETER                           *dIn,                             //  IN:    the   private   key

932     TPM2B                                         *digest,                          //  IN:    the   digest   to   sign

933     TPM2B_ECC_PARAMETER                           *kIn                              //  IN:    for   testing

934     )

935  {

936     TPM2B_ECC_PARAMETER                            k;

937     BIGNUM                                        *bnR,      *bnN,          *bnK,       *bnT,   *bnD;

938     BN_CTX                                        *context;

939     const        TPM2B                            *n;

940     EC_POINT                                      *pR     =  NULL;

941     EC_GROUP                                      *group     =    NULL;

942     CPRI_HASH_STATE                                hashState;

943     UINT16                                         digestSize               =  _cpri__GetDigestSize(hashAlg);

944     const        ECC_CURVE_DATA                   *curveData             =     GetCurveData(curveId);

945     TPM2B_TYPE(T,                MAX(MAX_DIGEST_SIZE,                    MAX_ECC_PARAMETER_BYTES));

946     TPM2B_T                                        T2b;

947     BOOL                                           OK     =  TRUE;

948

949     //     Parameter          checks

950

951     //     Must  have         a  place       for   the       'r'  and          's'  parts      of   the   signature,      a  private

952     //     key   ('d')

953     pAssert(              rOut       !=  NULL     &&   sOut       !=     NULL       &&  dIn    !=   NULL

954                  &&       digest         !=  NULL     &&     curveData         !=       NULL);

955

956     //     to    save     key    strokes

957     n   =     curveData->n;

958

959     //     If    the   digest        does    not      produce         a     hash,       then   null  the    signature        and  return

960     //     a     failure.

961     if(digestSize                ==  0)

962     {

963               rOut->t.size           =   0;

964               sOut->t.size           =   0;

965               return      CRYPT_SCHEME;

966     }

967

968     //     Allocate        big       number    values

969     context      =     BN_CTX_new();

970     if(context            ==     NULL)

971               FAIL(FATAL_ERROR_ALLOCATION);

972     BN_CTX_start(context);

973     bnR       =  BN_CTX_get(context);

974     bnN       =  BN_CTX_get(context);

975     bnK       =  BN_CTX_get(context);

976     bnT       =  BN_CTX_get(context);

977     bnD       =  BN_CTX_get(context);

978     if(          bnD   ==     NULL

979                  //       initialize         the      group       parameters

980            ||    (group       =  EccCurveInit(curveId,                         context))       ==   NULL

981                  //    allocate          a   local     point

982            ||    (pR   =   EC_POINT_new(group))                   ==        NULL

983         )

     Family "2.0"                                                     TCG Published                                                       Page 497

     Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                              October 30, 2014
      Trusted Platform Module Library                                                                                        Part 4: Supporting Routines

984               FAIL(FATAL_ERROR_ALLOCATION);

985

986       if(BN_bin2bn(curveData->n->buffer,                                     curveData->n->size,                   bnN)  ==  NULL)

987               FAIL(FATAL_ERROR_INTERNAL);

988

989       while(OK)

990       {

991   //  a)  set       k     to     a   random         value     such     that     1      k      n-1

992               if(kIn             !=   NULL)

993               {

994                           Copy2B(&k.b,               &kIn->b);          //   copy         input    k  if   testing

995                           OK     =   FALSE;                             //   not       OK     to   loop

996               }

997               else

998               //       If     get     a     random       value     in   the     correct           range

999                           GetRandomPrivate(&k,                     n);

1000

1001              //       Convert           'k'     and     generate       pR   =     ['k']G

1002              BnFrom2B(bnK,                     &k.b);

1003

1004  //  b)  compute             E      (xE,       yE)      [k]G

1005              if(PointMul(group,                         pR,   bnK,     NULL,       NULL,         context)     ==  CRYPT_NO_RESULT)

1006  //  c)  if     E     is     the     point         at   infinity,       go     to     a)

1007                          continue;

1008

1009  //  d)  compute             e      xE     (mod     n)

1010              //       Get       the     x   coordinate         of     the   point

1011              EC_POINT_get_affine_coordinates_GFp(group,                                              pR,  bnR,    NULL,     context);

1012

1013              //       make         (mod     n)

1014              BN_mod(bnR,                   bnR,     bnN,     context);

1015

1016  //  e)  if     e     is     zero,         go   to     a)

1017              if(BN_is_zero(bnR))

1018                          continue;

1019

1020              //       Convert           xR     to   a   string     (use     T     as     a   temp)

1021              BnTo2B(&T2b.b,                     bnR,       (UINT16)(BN_num_bits(bnR)+7)/8);

1022

1023  //  f)  compute             r      HschemeHash(P             ||   e)   (mod       n)

1024              _cpri__StartHash(hashAlg,                             FALSE,         &hashState);

1025              _cpri__UpdateHash(&hashState,                                 digest->size,             digest->buffer);

1026              _cpri__UpdateHash(&hashState,                                 T2b.t.size,            T2b.t.buffer);

1027              if(_cpri__CompleteHash(&hashState,                                       digestSize,         T2b.b.buffer)     !=     digestSize)

1028                          FAIL(FATAL_ERROR_INTERNAL);

1029              T2b.t.size                 =   digestSize;

1030              BnFrom2B(bnT,                     &T2b.b);

1031              BN_div(NULL,                   bnT,       bnT,   bnN,     context);

1032              BnTo2B(&rOut->b,                       bnT,     (UINT16)BN_num_bytes(bnT));

1033

1034              //       We     have       a   value       and   we   are     going         to  exit    the   loop   successfully

1035              OK       =   TRUE;

1036              break;

1037      }

1038      //  Cleanup

1039      EC_POINT_free(pR);

1040      EC_GROUP_free(group);

1041      BN_CTX_end(context);

1042      BN_CTX_free(context);

1043

1044      //  If        we     have       a     value,       finish     the     signature

1045      if(OK)

1046              return             EcDaa(rOut,             sOut,     curveId,         dIn,      NULL,      &k);

1047      else

1048              return             CRYPT_NO_RESULT;

1049  }

      Page 498                                                              TCG Published                                                   Family "2.0"

      October 30, 2014                                            Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                 Trusted  Platform  Module  Library

1050  #endif  //%

1051  #ifdef  TPM_ALG_SM2         //%

1052  #ifdef  _SM2_SIGN_DEBUG                  //%

1053  static  int

1054  cmp_bn2hex(

1055     BIGNUM                      *bn,                         //  IN:   big  number  value

1056     const     char              *c                           //  IN:   character    string   number

1057     )

1058  {

1059     int                  result;

1060     BIGNUM               *bnC   =      BN_new();

1061     pAssert(bnC          !=  NULL);

1062

1063     BN_hex2bn(&bnC,             c);

1064     result     =     BN_ucmp(bn,             bnC);

1065     BN_free(bnC);

1066     return     result;

1067  }

1068  static  int

1069  cmp_2B2hex(

1070     TPM2B                       *a,                          //  IN:   TPM2B   number    to  compare

1071     const     char              *c                           //  IN:   character    string

1072     )

1073  {

1074     int                  result;

1075     int                  sl  =  strlen(c);

1076     BIGNUM               *bnA;

1077

1078     result     =     (a->size       *     2)     -  sl;

1079     if(result        !=  0)

1080          return      result;

1081     pAssert((bnA         =   BN_bin2bn(a->buffer,                a->size,      NULL))    !=  NULL);

1082     result     =     cmp_bn2hex(bnA,                c);

1083     BN_free(bnA);

1084     return     result;

1085  }

1086  static  void

1087  cpy_hexTo2B(

1088     TPM2B                       *b,                          //  OUT:  receives     value

1089     const     char              *c                           //  IN:   source  string

1090     )

1091  {

1092     BIGNUM               *bnB   =      BN_new();

1093     pAssert((strlen(c)                 &     1)     ==  0);  //  must  have    an  even  number  of   digits

1094     b->size       =  strlen(c)            /   2;

1095     BN_hex2bn(&bnB,             c);

1096     pAssert(bnB          !=  NULL);

1097     BnTo2B(b,        bnB,    b->size);

1098     BN_free(bnB);

1099

1100  }

1101  #endif  //%   _SM2_SIGN_DEBUG

      B.13.3.2.20. SignSM2()

      This function signs a digest using the method defined in SM2 Part 2. The method in the standard will add

      a header to the message to be signed that is a hash of the values that define the key. This then hashed

      with the message to produce a digest (e) that is signed. This function signs e.

      Family "2.0"                                                TCG Published                                      Page 499

      Level 00 Revision 01.16                                Copyright © TCG 2006-2014                     October 30, 2014
      Trusted Platform Module Library                                                                 Part 4: Supporting Routines

      Return Value                            Meaning

      CRYPT_SUCCESS                           sign worked

1102  static   CRYPT_RESULT

1103  SignSM2(

1104      TPM2B_ECC_PARAMETER                     *rOut,                //  OUT:  r    component      of     the  signature

1105      TPM2B_ECC_PARAMETER                     *sOut,                //  OUT:  s    component      of     the  signature

1106      TPM_ECC_CURVE                            curveId,             //  IN:   the  curve   used       in  signing

1107      TPM2B_ECC_PARAMETER                     *dIn,                 //  IN:   the  private    key

1108      TPM2B                                   *digest               //  IN:   the  digest     to  sign

1109      )

1110  {

1111      BIGNUM                                  *bnR;

1112      BIGNUM                                  *bnS;

1113      BIGNUM                                  *bnN;

1114      BIGNUM                                  *bnK;

1115      BIGNUM                                  *bnX1;

1116      BIGNUM                                  *bnD;

1117      BIGNUM                                  *bnT;    //  temp

1118      BIGNUM                                  *bnE;

1119

1120      BN_CTX                                  *context;

1121      TPM2B_TYPE(DIGEST,              MAX_DIGEST_SIZE);

1122      TPM2B_ECC_PARAMETER                      k;

1123      TPMS_ECC_POINT                           p2Br;

1124      const        ECC_CURVE_DATA             *curveData   =  GetCurveData(curveId);

1125

1126      pAssert(curveData             !=   NULL);

1127      context        =     BN_CTX_new();

1128      BN_CTX_start(context);

1129      bnK    =     BN_CTX_get(context);

1130      bnR    =     BN_CTX_get(context);

1131      bnS    =     BN_CTX_get(context);

1132      bnX1      =  BN_CTX_get(context);

1133      bnN    =     BN_CTX_get(context);

1134      bnD    =     BN_CTX_get(context);

1135      bnT    =     BN_CTX_get(context);

1136      bnE    =     BN_CTX_get(context);

1137      if(bnE       ==      NULL)

1138             FAIL(FATAL_ERROR_ALLOCATION);

1139

1140      BnFrom2B(bnE,           digest);

1141      BnFrom2B(bnN,           curveData->n);

1142      BnFrom2B(bnD,           &dIn->b);

1143

1144  #ifdef   _SM2_SIGN_DEBUG

1145  BN_hex2bn(&bnE,             "B524F552CD82B8B028476E005C377FB19A87E6FC682D48BB5D42E3D9B9EFFE76");

1146  BN_hex2bn(&bnD,             "128B2FA8BD433C6C068C8D803DFF79792A519A55171B1B650C23661D15897263");

1147  #endif

1148  //  A3:  Use     random     number     generator     to  generate     random     number  1  <=      k   <=  n-1;

1149  //  NOTE:     Ax:     numbers     are  from    the  SM2  standard

1150      k.t.size          =  curveData->n->size;

1151  loop:

1152      {

1153             //    Get     a  random     number

1154             _cpri__GenerateRandom(k.t.size,                  k.t.buffer);

1155

1156  #ifdef   _SM2_SIGN_DEBUG

1157  BN_hex2bn(&bnK,             "6CB28D99385C175C94F94E934817663FC176D925DD72B727260DBAAE1FB2F96F");

1158  BnTo2B(&k.b,bnK,            32);

1159  k.t.size      =  32;

1160  #endif

1161             //make        sure   that   the   number  is  0  <  k  <   n

1162             BnFrom2B(bnK,          &k.b);

      Page 500                                               TCG Published                                              Family "2.0"

      October 30, 2014                               Copyright © TCG 2006-2014                        Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                     Trusted Platform Module Library

1163            if(           BN_ucmp(bnK,                  bnN)      >=  0

1164                     ||   BN_is_zero(bnK))

1165                     goto     loop;

1166

1167  //  A4:   Figure       out     the         point      of     elliptic        curve    (x1,   y1)=[k]G,             and       according

1168  //  to   details       specified               in     4.2.7     in  Part     1    of  this   document,             transform               the

1169  //  data  type      of     x1     into         an     integer;

1170            if(          _cpri__EccPointMultiply(&p2Br,                                 curveId,     &k,      NULL,         NULL)

1171                  ==     CRYPT_NO_RESULT)

1172                     goto     loop;

1173

1174            BnFrom2B(bnX1,                    &p2Br.x.b);

1175

1176  //  A5:   Figure        out       r     =   (e     +  x1)    mod    n,

1177            if(!BN_mod_add(bnR,                         bnE,      bnX1,     bnN,     context))

1178                     FAIL(FATAL_ERROR_INTERNAL);

1179  #ifdef    _SM2_SIGN_DEBUG

1180  pAssert(cmp_bn2hex(bnR,

1181                             "40F1EC59F793D9F49E09DCEF49130D4194F79FB1EED2CAA55BACDB49C4E755D1")

1182            ==    0);

1183  #endif

1184

1185                  //     if   r=0         or     r+k=n,        return     to   A3;

1186            if(!BN_add(bnT,                       bnK,      bnR))

1187                     FAIL(FATAL_ERROR_INTERNAL);

1188

1189            if(BN_is_zero(bnR)                          ||  BN_ucmp(bnT,            bnN)   ==  0)

1190                     goto     loop;

1191

1192  //  A6:   Figure       out     s     =     ((1     +  dA)^-1        (k    -  r     dA))     mod  n,     if     s=0,       return           to     A3;

1193            //    compute           t     =   (1+d)-1

1194            BN_copy(bnT,                  bnD);

1195            if(          !BN_add_word(bnT,                     1)

1196                  ||     !BN_mod_inverse(bnT,                         bnT,     bnN,     context)     //    (1     +     dA)^-1           mod     n

1197                  )

1198                     FAIL(FATAL_ERROR_INTERNAL);

1199  #ifdef    _SM2_SIGN_DEBUG

1200  pAssert(cmp_bn2hex(bnT,

1201                             "79BFCF3052C80DA7B939E0C6914A18CBB2D96D8555256E83122743A7D4F5F956")

1202            ==    0);

1203  #endif

1204            //    compute           s     =   t   *     (k  -  r   *  dA)      mod   n

1205            if(          !BN_mod_mul(bnS,                      bnD,   bnR,     bnN,     context)       //     (r     *  dA)          mod     n

1206                  ||     !BN_mod_sub(bnS,                      bnK,   bnS,     bnN,     context)       //     (k     -  (r        *   dA)       mod   n

1207                  ||     !BN_mod_mul(bnS,                      bnT,   bnS,     bnN,     context))//           t   *     (k     -     (r   *     dA)   mod  n

1208                  FAIL(FATAL_ERROR_INTERNAL);

1209  #ifdef    _SM2_SIGN_DEBUG

1210  pAssert(cmp_bn2hex(bnS,

1211                             "6FC6DAC32C5D5CF10C77DFB20F7C2EB667A457872FB09EC56327A67EC7DEEBE7")

1212            ==    0);

1213  #endif

1214

1215            if(BN_is_zero(bnS))

1216                     goto     loop;

1217      }

1218

1219  //  A7:   According         to       details          specified         in   4.2.1      in   Part    1   of     this         document,             transform

1220  //  the   data     type     of       r,     s   into      bit    strings,         signature      of     message           M     is     (r,     s).

1221

1222      BnTo2B(&rOut->b,                    bnR,       curveData->n->size);

1223      BnTo2B(&sOut->b,                    bnS,       curveData->n->size);

1224  #ifdef    _SM2_SIGN_DEBUG

1225  pAssert(cmp_2B2hex(&rOut->b,

1226                             "40F1EC59F793D9F49E09DCEF49130D4194F79FB1EED2CAA55BACDB49C4E755D1")

1227            ==    0);

1228  pAssert(cmp_2B2hex(&sOut->b,

      Family "2.0"                                                        TCG Published                                                                      Page 501

      Level 00 Revision 01.16                                   Copyright © TCG 2006-2014                                                        October 30, 2014
      Trusted Platform Module Library                                                           Part 4: Supporting Routines

1229                      "6FC6DAC32C5D5CF10C77DFB20F7C2EB667A457872FB09EC56327A67EC7DEEBE7")

1230          ==    0);

1231  #endif

1232     BN_CTX_end(context);

1233     BN_CTX_free(context);

1234     return     CRYPT_SUCCESS;

1235  }

1236  #endif  //%   TPM_ALG_SM2

      B.13.3.2.21. _cpri__SignEcc()

      This function is the dispatch function for the various ECC-based signing schemes.

      Return Value                     Meaning

      CRYPT_SCHEME                     scheme is not supported

1237  LIB_EXPORT    CRYPT_RESULT

1238  _cpri__SignEcc(

1239     TPM2B_ECC_PARAMETER             *rOut,                 //  OUT:     r  component       of  the  signature

1240     TPM2B_ECC_PARAMETER             *sOut,                 //  OUT:     s  component       of  the  signature

1241     TPM_ALG_ID                      scheme,                //  IN:   the   scheme      selector

1242     TPM_ALG_ID                      hashAlg,               //  IN:   the   hash   algorithm         if  need

1243     TPM_ECC_CURVE                   curveId,               //  IN:   the   curve     used      in  the  signature

1244                                                            //        process

1245     TPM2B_ECC_PARAMETER             *dIn,                  //  IN:   the   private     key

1246     TPM2B                           *digest,               //  IN:   the   digest      to  sign

1247     TPM2B_ECC_PARAMETER             *kIn                   //  IN:   k     for  input

1248     )

1249  {

1250     switch     (scheme)

1251     {

1252          case  TPM_ALG_ECDSA:

1253                //    SignEcdsa  always    works

1254                return   SignEcdsa(rOut,     sOut,     curveId,       dIn,  digest);

1255                break;

1256  #ifdef  TPM_ALG_ECDAA

1257          case  TPM_ALG_ECDAA:

1258                if(rOut   !=  NULL)

1259                      rOut->b.size   =   0;

1260                return   EcDaa(rOut,     sOut,    curveId,      dIn,  digest,     kIn);

1261                break;

1262  #endif

1263  #ifdef  TPM_ALG_ECSCHNORR

1264          case  TPM_ALG_ECSCHNORR:

1265                return   SchnorrEcc(rOut,       sOut,  hashAlg,       curveId,     dIn,     digest,      kIn);

1266                break;

1267  #endif

1268  #ifdef  TPM_ALG_SM2

1269          case  TPM_ALG_SM2:

1270                return   SignSM2(rOut,       sOut,  curveId,    dIn,        digest);

1271                break;

1272  #endif

1273          default:

1274                return   CRYPT_SCHEME;

1275     }

1276  }

1277  #ifdef  TPM_ALG_ECDSA   //%

      B.13.3.2.22. ValidateSignatureEcdsa()

      This function validates an ECDSA signature. rIn and sIn shoudl have             been      checked to make sure that

      they are not zero.

      Page 502                                      TCG Published                                            Family "2.0"

      October 30, 2014                      Copyright © TCG 2006-2014                           Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                    Trusted Platform Module Library

      Return Value                             Meaning

      CRYPT_SUCCESS                            signature valid

      CRYPT_FAIL                               signature not valid

1278  static     CRYPT_RESULT

1279  ValidateSignatureEcdsa(

1280      TPM2B_ECC_PARAMETER                      *rIn,                     //  IN:  r  component      of    the     signature

1281      TPM2B_ECC_PARAMETER                      *sIn,                     //  IN:  s  component      of    the     signature

1282      TPM_ECC_CURVE                              curveId,                //  IN:  the    curve   used     in   the  signature

1283                                                                         //       process

1284      TPMS_ECC_POINT                           *Qin,                     //  IN:  the    public     point     of  the   key

1285      TPM2B                                    *digest                   //  IN:  the    digest     that   was    signed

1286      )

1287  {

1288      TPM2B_ECC_PARAMETER                        U1;

1289      TPM2B_ECC_PARAMETER                        U2;

1290      TPMS_ECC_POINT                             R;

1291      const         TPM2B                      *n;

1292      BN_CTX                                   *context;

1293      EC_POINT                                 *pQ    =  NULL;

1294      EC_GROUP                                 *group    =     NULL;

1295      BIGNUM                                   *bnU1;

1296      BIGNUM                                   *bnU2;

1297      BIGNUM                                   *bnR;

1298      BIGNUM                                   *bnS;

1299      BIGNUM                                   *bnW;

1300      BIGNUM                                   *bnV;

1301      BIGNUM                                   *bnN;

1302      BIGNUM                                   *bnE;

1303      BIGNUM                                   *bnGx;

1304      BIGNUM                                   *bnGy;

1305      BIGNUM                                   *bnQx;

1306      BIGNUM                                   *bnQy;

1307      CRYPT_RESULT                               retVal     =  CRYPT_FAIL;

1308      int                                        t;

1309

1310      const         ECC_CURVE_DATA             *curveData       =   GetCurveData(curveId);

1311

1312      //     The    curve      selector    should        have  been   filtered       by  the  unmarshaling          process

1313      pAssert       (curveData        !=   NULL);

1314      n   =   curveData->n;

1315

1316  //  1.  If     r  and    s   are  not    both  integers       in    the    interval    [1,  n  -  1],    output

1317  //      INVALID.

1318  //  rIn     and   sIn       are   known  to    be   greater      than    zero   (was   checked    by    the     caller).

1319      if(           _math__uComp(rIn->t.size,                  rIn->t.buffer,        n->size,       n->buffer)      >=  0

1320              ||    _math__uComp(sIn->t.size,                  sIn->t.buffer,        n->size,       n->buffer)      >=  0

1321          )

1322             return      CRYPT_FAIL;

1323

1324      context       =    BN_CTX_new();

1325      if(context           ==  NULL)

1326              FAIL(FATAL_ERROR_ALLOCATION);

1327      BN_CTX_start(context);

1328      bnR     =     BN_CTX_get(context);

1329      bnS     =     BN_CTX_get(context);

1330      bnN     =     BN_CTX_get(context);

1331      bnE     =     BN_CTX_get(context);

1332      bnV     =     BN_CTX_get(context);

1333      bnW     =     BN_CTX_get(context);

1334      bnGx       =  BN_CTX_get(context);

1335      bnGy       =  BN_CTX_get(context);

1336      bnQx       =  BN_CTX_get(context);

      Family "2.0"                                              TCG Published                                                    Page 503

      Level 00 Revision 01.16                        Copyright © TCG 2006-2014                                        October 30, 2014
      Trusted Platform Module Library                                                                                                 Part 4: Supporting Routines

1337      bnQy       =  BN_CTX_get(context);

1338      bnU1       =  BN_CTX_get(context);

1339      bnU2       =  BN_CTX_get(context);

1340

1341      //     Assume       the       size         variables           do     not     overflow,        which         should         not     happen    in

1342      //     the    contexts              that         this     function         will     be     called.

1343      assert2Bsize(Qin->x.t);

1344      assert2Bsize(rIn->t);

1345      assert2Bsize(sIn->t);

1346

1347      //     BN_CTX_get()                 is     sticky         so   only       need    to    check         the    last       value       to  know   that

1348      //     all    worked.

1349      if(           bnU2     ==     NULL

1350

1351             //     initialize                the      group        parameters

1352             ||     (group       =     EccCurveInit(curveId,                        context))            ==     NULL

1353

1354             //     allocate           a  local          point

1355             ||     (pQ   =   EC_POINT_new(group))                           ==     NULL

1356

1357             //     use   the       public             key   values         (QxIn      and    QyIn)         to     initialize          Q

1358             ||     BN_bin2bn(Qin->x.t.buffer,                               Qin->x.t.size,                 bnQx)      ==     NULL

1359             ||     BN_bin2bn(Qin->x.t.buffer,                               Qin->x.t.size,                 bnQy)      ==     NULL

1360             ||     !EC_POINT_set_affine_coordinates_GFp(group,                                                 pQ,    bnQx,      bnQy,       context)

1361

1362             //     convert         the       signature             values

1363             ||     BN_bin2bn(rIn->t.buffer,                             rIn->t.size,            bnR)          ==  NULL

1364             ||     BN_bin2bn(sIn->t.buffer,                             sIn->t.size,            bnS)          ==  NULL

1365

1366             //     convert         the       curve         order

1367             ||     BN_bin2bn(curveData->n->buffer,                                    curveData->n->size,                    bnN)        ==  NULL)

1368             FAIL(FATAL_ERROR_INTERNAL);

1369

1370  //  2.  Use       the   selected               hash       function         to     compute      H0      =     Hash(M0).

1371      //     This   is       an     input           parameter

1372

1373  //  3.  Convert         the       bit       string         H0     to   an     integer       e  as      described            in  Appendix        B.2.

1374      t   =  (digest->size                    >     rIn->t.size)             ?   rIn->t.size             :     digest->size;

1375      if(BN_bin2bn(digest->buffer,                                   t,     bnE)    ==    NULL)

1376             FAIL(FATAL_ERROR_INTERNAL);

1377

1378  //  4.  Compute         w   =     (s')^-1            mod      n,   using       the    routine          in     Appendix          B.1.

1379      if     (BN_mod_inverse(bnW,                           bnS,     bnN,       context)         ==  NULL)

1380             FAIL(FATAL_ERROR_INTERNAL);

1381

1382  //  5.  Compute         u1     =     (e'       *       w)     mod     n,   and    compute          u2     =   (r'    *      w)  mod     n.

1383      if(           !BN_mod_mul(bnU1,                       bnE,     bnW,       bnN,    context)

1384             ||     !BN_mod_mul(bnU2,                       bnR,     bnW,       bnN,    context))

1385             FAIL(FATAL_ERROR_INTERNAL);

1386

1387      BnTo2B(&U1.b,                 bnU1,           (INT16)         BN_num_bytes(bnU1));

1388      BnTo2B(&U2.b,                 bnU2,           (INT16)         BN_num_bytes(bnU2));

1389

1390  //  6.  Compute         the       elliptic             curve       point       R  =   (xR,     yR)        =   u1G+u2Q,          using       EC

1391  //      scalar         multiplication                     and     EC   addition         (see       [Routines]).             If    R     is  equal     to

1392  //      the       point     at       infinity             O,   output         INVALID.

1393      if(_cpri__EccPointMultiply(&R,                                     curveId,         &U1,       Qin,       &U2)      ==  CRYPT_SUCCESS)

1394      {

1395             //     7.    Compute             v     =  Rx    mod     n.

1396             if(          BN_bin2bn(R.x.t.buffer,                               R.x.t.size,          bnV)          ==  NULL

1397                    ||    !BN_mod(bnV,                   bnV,       bnN,     context))

1398                    FAIL(FATAL_ERROR_INTERNAL);

1399

1400      //     8.     Compare         v     and       r0.     If   v   =   r0,     output       VALID;           otherwise,         output          INVALID

1401             if(BN_cmp(bnV,                      bnR)       ==   0)

1402                    retVal             =  CRYPT_SUCCESS;

      Page 504                                                                  TCG Published                                                               Family "2.0"

      October 30, 2014                                              Copyright © TCG 2006-2014                                           Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                       Trusted Platform Module Library

1403     }

1404

1405     if(pQ        !=   NULL)    EC_POINT_free(pQ);

1406     if(group          !=  NULL)    EC_GROUP_free(group);

1407     BN_CTX_end(context);

1408     BN_CTX_free(context);

1409

1410     return       retVal;

1411  }

1412  #endif              //%  TPM_ALG_ECDSA

1413  #ifdef     TPM_ALG_ECSCHNORR           //%

      B.13.3.2.23. ValidateSignatureEcSchnorr()

      This function is used to validate an EC Schnorr signature.                        rIn  and  sIn   are  required    to  be  greater  than

      zero. This is checked in _cpri__ValidateSignatureEcc().

      Return Value                               Meaning

      CRYPT_SUCCESS                              signature valid

      CRYPT_FAIL                                 signature not valid

      CRYPT_SCHEME                               hashAlg is not supported

1414  static     CRYPT_RESULT

1415  ValidateSignatureEcSchnorr(

1416     TPM2B_ECC_PARAMETER                      *rIn,                    //    IN:    r    component       of  the     signature

1417     TPM2B_ECC_PARAMETER                      *sIn,                    //    IN:    s    component       of  the     signature

1418     TPM_ALG_ID                               hashAlg,                 //    IN:    hash     algorithm       of   the    signature

1419     TPM_ECC_CURVE                            curveId,                 //    IN:    the      curve   used    in   the    signature

1420                                                                       //           process

1421     TPMS_ECC_POINT                           *Qin,                    //    IN:    the      public  point       of  the     key

1422     TPM2B                                    *digest                  //    IN:    the      digest  that    was     signed

1423     )

1424  {

1425     TPMS_ECC_POINT                           pE;

1426     const        TPM2B                       *n;

1427     CPRI_HASH_STATE                          hashState;

1428     TPM2B_DIGEST                             rPrime;

1429     TPM2B_ECC_PARAMETER                      minusR;

1430     UINT16                                   digestSize            =  _cpri__GetDigestSize(hashAlg);

1431     const        ECC_CURVE_DATA              *curveData         =     GetCurveData(curveId);

1432

1433     //      The  curve    parameter         should    have      been  filtered          by  unmarshaling         code

1434     pAssert(curveData              !=   NULL);

1435

1436     if(digestSize              ==  0)

1437             return        CRYPT_SCHEME;

1438

1439     //      Input     parameter        validation

1440     pAssert(rIn           !=   NULL     &&  sIn   !=  NULL      &&    Qin  !=  NULL     &&   digest     !=  NULL);

1441

1442     n    =  curveData->n;

1443

1444     //      if   sIn  or  rIn      are  not  between         1  and   N-1,     signature     check      fails

1445     //      sIn  and      rIn  were     verified      to  be    non-zero       by  the      caller

1446     if(          _math__uComp(sIn->b.size,                sIn->b.buffer,           n->size,        n->buffer)       >=   0

1447             ||   _math__uComp(rIn->b.size,                rIn->b.buffer,           n->size,        n->buffer)       >=   0

1448          )

1449             return        CRYPT_FAIL;

1450

1451     //E     =    [s]InG   -    [r]InQ

1452     _math__sub(n->size,                 n->buffer,

1453                           rIn->t.size,       rIn->t.buffer,

      Family "2.0"                                             TCG Published                                                          Page 505

      Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                          October 30, 2014
      Trusted Platform Module Library                                                                 Part 4: Supporting Routines

1454                        &minusR.t.size,           minusR.t.buffer);

1455     if(_cpri__EccPointMultiply(&pE,                          curveId,  sIn,     Qin,   &minusR)  !=   CRYPT_SUCCESS)

1456           return       CRYPT_FAIL;

1457

1458     //   Ex  =  Ex     mod     N

1459     if(Mod2B(&pE.x.b,             n)   !=    CRYPT_SUCCESS)

1460           FAIL(FATAL_ERROR_INTERNAL);

1461

1462     _math__Normalize2B(&pE.x.b);

1463

1464     //   rPrime     =  h(digest        ||    pE.x)     mod   n;

1465     _cpri__StartHash(hashAlg,                    FALSE,      &hashState);

1466     _cpri__UpdateHash(&hashState,                      digest->size,       digest->buffer);

1467     _cpri__UpdateHash(&hashState,                      pE.x.t.size,        pE.x.t.buffer);

1468     if(_cpri__CompleteHash(&hashState,                       digestSize,        rPrime.t.buffer)         !=  digestSize)

1469           FAIL(FATAL_ERROR_INTERNAL);

1470

1471     rPrime.t.size           =     digestSize;

1472

1473     //   rPrime     =  rPrime          (mod  n)

1474     if(Mod2B(&rPrime.b,                n)    !=  CRYPT_SUCCESS)

1475           FAIL(FATAL_ERROR_INTERNAL);

1476

1477     //   if  the    values        don't      match,    then  the     signature     is  bad

1478     if(_math__uComp(rIn->t.size,                       rIn->t.buffer,

1479                                   rPrime.t.size,          rPrime.t.buffer)         !=  0)

1480           return       CRYPT_FAIL;

1481     else

1482           return       CRYPT_SUCCESS;

1483  }

1484  #endif   //%   TPM_ALG_ECSCHNORR

1485  #ifdef  TPM_ALG_SM2              //%

      B.13.3.2.24. ValidateSignatueSM2Dsa()

      This function is used to validate an SM2 signature.

      Return Value                              Meaning

      CRYPT_SUCCESS                             signature valid

      CRYPT_FAIL                                signature not valid

1486  static  CRYPT_RESULT

1487  ValidateSignatureSM2Dsa(

1488     TPM2B_ECC_PARAMETER                      *rIn,                     //  IN:  r  component     of  the     signature

1489     TPM2B_ECC_PARAMETER                      *sIn,                     //  IN:  s  component     of  the     signature

1490     TPM_ECC_CURVE                                curveId,              //  IN:  the    curve   used  in   the  signature

1491                                                                        //       process

1492     TPMS_ECC_POINT                           *Qin,                     //  IN:  the    public  point     of  the  key

1493     TPM2B                                    *digest                   //  IN:  the    digest  that   was    signed

1494     )

1495  {

1496     BIGNUM                                   *bnR;

1497     BIGNUM                                   *bnRp;

1498     BIGNUM                                   *bnT;

1499     BIGNUM                                   *bnS;

1500     BIGNUM                                   *bnE;

1501     EC_POINT                                 *pQ;

1502     BN_CTX                                   *context;

1503     EC_GROUP                                 *group       =  NULL;

1504     const    ECC_CURVE_DATA                  *curveData      =   GetCurveData(curveId);

1505     BOOL                                         fail  =     FALSE;

1506

      Page 506                                                    TCG Published                                        Family "2.0"

      October 30, 2014                                Copyright © TCG 2006-2014                           Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                      Trusted Platform Module Library

1507      if((context                =     BN_CTX_new())             ==    NULL   ||  curveData           ==   NULL)

1508               FAIL(FATAL_ERROR_INTERNAL);

1509      bnR      =     BN_CTX_get(context);

1510      bnRp=          BN_CTX_get(context);

1511      bnE      =     BN_CTX_get(context);

1512      bnT      =     BN_CTX_get(context);

1513      bnS      =     BN_CTX_get(context);

1514      if(            bnS     ==     NULL

1515            ||       (group         =     EccCurveInit(curveId,               context))           ==  NULL)

1516               FAIL(FATAL_ERROR_INTERNAL);

1517

1518  #ifdef       _SM2_SIGN_DEBUG

1519      cpy_hexTo2B(&Qin->x.b,

1520                     "0AE4C7798AA0F119471BEE11825BE46202BB79E2A5844495E97C04FF4DF2548A");

1521      cpy_hexTo2B(&Qin->y.b,

1522                     "7C0240F88F1CD4E16352A73C17B7F16F07353E53A176D684A9FE0C6BB798E857");

1523      cpy_hexTo2B(digest,

1524                     "B524F552CD82B8B028476E005C377FB19A87E6FC682D48BB5D42E3D9B9EFFE76");

1525  #endif

1526      pQ    =     EccInitPoint2B(group,                          Qin,    context);

1527

1528  #ifdef    _SM2_SIGN_DEBUG

1529      pAssert(EC_POINT_get_affine_coordinates_GFp(group,                                                  pQ,  bnT,    bnS,  context));

1530      pAssert(cmp_bn2hex(bnT,

1531                                 "0AE4C7798AA0F119471BEE11825BE46202BB79E2A5844495E97C04FF4DF2548A")

1532                     ==         0);

1533      pAssert(cmp_bn2hex(bnS,

1534                                 "7C0240F88F1CD4E16352A73C17B7F16F07353E53A176D684A9FE0C6BB798E857")

1535                     ==         0);

1536  #endif

1537

1538      BnFrom2B(bnR,                    &rIn->b);

1539      BnFrom2B(bnS,                    &sIn->b);

1540      BnFrom2B(bnE,                    digest);

1541

1542  #ifdef    _SM2_SIGN_DEBUG

1543  //  Make     sure       that         the    input         signature    is   the     test     signature

1544  pAssert(cmp_2B2hex(&rIn->b,

1545               "40F1EC59F793D9F49E09DCEF49130D4194F79FB1EED2CAA55BACDB49C4E755D1")                                                     ==  0);

1546  pAssert(cmp_2B2hex(&sIn->b,

1547               "6FC6DAC32C5D5CF10C77DFB20F7C2EB667A457872FB09EC56327A67EC7DEEBE7")                                                     ==  0);

1548  #endif

1549

1550  //  a)  verify          that         r  and       s  are   in     the  inclusive        interval         1   to  (n  1)

1551      fail        =  (BN_ucmp(bnR,                     &group->order)         >=  0);

1552

1553      fail        =  (BN_ucmp(bnS,                     &group->order)         >=  0)     ||  fail;

1554      if(fail)

1555      //    There         is     no       reason       to   continue.        Since    r   and     s   are     inputs   from  the  caller,

1556      //    they     can         know        that      the   values      are  not     in     the     proper    range.  So,   exiting       here

1557      //    does     not         disclose              any  information.

1558               goto       Cleanup;

1559

1560  //  b)  compute            t      :=    (r     +     s)   mod  n

1561      if(!BN_mod_add(bnT,                           bnR,    bnS,     &group->order,          context))

1562               FAIL(FATAL_ERROR_INTERNAL);

1563  #ifdef    _SM2_SIGN_DEBUG

1564      pAssert(cmp_bn2hex(bnT,

1565                                 "2B75F07ED7ECE7CCC1C8986B991F441AD324D6D619FE06DD63ED32E0C997C801")

1566                     ==         0);

1567  #endif

1568

1569  //  c)  verify          that         t  >   0

1570      if(BN_is_zero(bnT))                           {

1571               fail       =     TRUE;

1572               //    set        to     a  value        that      should  allow      rest     of      the   computations      to   run  without

      Family "2.0"                                                           TCG Published                                                     Page 507

      Level 00 Revision 01.16                                    Copyright © TCG 2006-2014                                           October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines

1573            //  trouble

1574            BN_copy(bnT,         bnS);

1575      }

1576  //  d)  compute    (x,     y)  :=      [s]G   +   [t]Q

1577      if(!EC_POINT_mul(group,                  pQ,     bnS,      pQ,     bnT,     context))

1578            FAIL(FATAL_ERROR_INTERNAL);

1579      //  Get   the  x    coordinate           of   the      point

1580      if(!EC_POINT_get_affine_coordinates_GFp(group,                                   pQ,    bnT,   NULL,     context))

1581            FAIL(FATAL_ERROR_INTERNAL);

1582

1583  #ifdef    _SM2_SIGN_DEBUG

1584      pAssert(cmp_bn2hex(bnT,

1585                         "110FCDA57615705D5E7B9324AC4B856D23E6D9188B2AE47759514657CE25D112")

1586                         ==   0);

1587  #endif

1588

1589  //  e)  compute    r'   :=     (e  +   x)    mod     n     (the     x  coordinate       is  in   bnT)

1590      if(!BN_mod_add(bnRp,               bnE,      bnT,      &group->order,            context))

1591            FAIL(FATAL_ERROR_INTERNAL);

1592

1593  //  f)  verify   that      r'  =   r

1594      fail   =  BN_ucmp(bnR,             bnRp)     !=     0  ||    fail;

1595

1596  Cleanup:

1597      if(pQ)    EC_POINT_free(pQ);

1598      if(group)      EC_GROUP_free(group);

1599      BN_CTX_end(context);

1600      BN_CTX_free(context);

1601

1602      if(fail)

1603            return   CRYPT_FAIL;

1604      else

1605            return   CRYPT_SUCCESS;

1606  }

1607  #endif  //%   TPM_ALG_SM2

      B.13.3.2.25. _cpri__ValidateSignatureEcc()

      This function validates

      Return Value                           Meaning

      CRYPT_SUCCESS                          signature is valid

      CRYPT_FAIL                             not a valid signature

      CRYPT_SCHEME                           unsupported scheme

1608  LIB_EXPORT    CRYPT_RESULT

1609  _cpri__ValidateSignatureEcc(

1610      TPM2B_ECC_PARAMETER                      *rIn,                          //  IN:  r   component     of    the     signature

1611      TPM2B_ECC_PARAMETER                      *sIn,                          //  IN:  s   component     of    the     signature

1612      TPM_ALG_ID                                scheme,                       //  IN:  the    scheme     selector

1613      TPM_ALG_ID                                hashAlg,                      //  IN:  the    hash   algorithm         used  (not  used

1614                                                                              //       in     all  schemes)

1615      TPM_ECC_CURVE                             curveId,                      //  IN:  the    curve      used  in   the    signature

1616                                                                              //       process

1617      TPMS_ECC_POINT                           *Qin,                          //  IN:  the    public     point     of  the   key

1618      TPM2B                                    *digest                        //  IN:  the    digest     that   was    signed

1619      )

1620  {

1621      CRYPT_RESULT                             retVal;

1622

1623      //  return     failure         if  either        part      of      the  signature       is   zero

1624      if(_math__Normalize2B(&rIn->b)                         ==    0     ||   _math__Normalize2B(&sIn->b)              ==    0)

      Page 508                                                   TCG Published                                                       Family "2.0"

      October 30, 2014                                 Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                      Trusted Platform Module       Library

1625              return        CRYPT_FAIL;

1626

1627       switch      (scheme)

1628       {

1629              case       TPM_ALG_ECDSA:

1630                      retVal    =      ValidateSignatureEcdsa(rIn,           sIn,     curveId,      Qin,      digest);

1631                      break;

1632

1633  #ifdef      TPM_ALG_ECSCHNORR

1634              case       TPM_ALG_ECSCHNORR:

1635                      retVal    =      ValidateSignatureEcSchnorr(rIn,                sIn,     hashAlg,   curveId,        Qin,

1636                                                                           digest);

1637                      break;

1638  #endif

1639

1640  #ifdef      TPM_ALG_SM2

1641              case       TPM_ALG_SM2:

1642                      retVal    =      ValidateSignatureSM2Dsa(rIn,             sIn,      curveId,      Qin,  digest);

1643  #endif

1644              default:

1645                      retVal    =      CRYPT_SCHEME;

1646                      break;

1647       }

1648       return      retVal;

1649  }

1650  #if  CC_ZGen_2Phase           ==     YES   //%

1651  #ifdef      TPM_ALG_ECMQV

      B.13.3.2.26. avf1()

      This function does the associated value computation required by MQV key exchange. Process:

      a)   Convert xQ to an integer xqi using the convention specified in Appendix C.3.

      b)   Calculate xqm = xqi mod 2^ceil(f/2) (where f = ceil(log2(n)).

      c)   Calculate the associate value function avf(Q) = xqm + 2ceil(f / 2)

1652  static      BOOL

1653  avf1(

1654       BIGNUM                        *bnX,                  //   IN/OUT:   the    reduced      value

1655       BIGNUM                        *bnN                   //   IN:  the  order      of  the      curve

1656       )

1657  {

1658  //   compute     f     =  2^(ceil(ceil(log2(n))           /    2))

1659       int                                        f  =  (BN_num_bits(bnN)         +   1)  /    2;

1660  //   x'  =  2^f     +     (x  mod    2^f)

1661       BN_mask_bits(bnX,               f);   //      This   is   mod  2*2^f  but      it  doesn't       matter  because

1662                                             //      the   next  operation      will      SET  the  extra     bit   anyway

1663       BN_set_bit(bnX,               f);

1664       return      TRUE;

1665  }

      B.13.3.2.27. C_2_2_MQV()

      This function performs the key exchange defined in SP800-56A 6.1.1.4 Full MQV, C(2, 2, ECC MQV).

      CAUTION: Implementation of this function may require use of essential claims in patents not owned by

      TCG members.

      Points   QsB()      and       QeB()  are   required   to  be   on   the  curve  of  inQsA.       The    function  will  fail,  possibly

      catastrophically, if this is not the case.

      Family "2.0"                                              TCG Published                                                 Page 509

      Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                      October 30, 2014
      Trusted Platform Module Library                                                                                     Part 4: Supporting Routines

      Return Value                                    Meaning

      CRYPT_SUCCESS                                   results is valid

      CRYPT_NO_RESULT                                 the value for dsA does not give a valid point on the curve

1666  static   CRYPT_RESULT

1667  C_2_2_MQV(

1668      TPMS_ECC_POINT                                  *outZ,                      //     OUT:       the  computed     point

1669      TPM_ECC_CURVE                                      curveId,                 //     IN:    the      curve  for   the    computations

1670      TPM2B_ECC_PARAMETER                             *dsA,                       //     IN:    static   private        TPM  key

1671      TPM2B_ECC_PARAMETER                             *deA,                       //     IN:    ephemeral       private      TPM  key

1672      TPMS_ECC_POINT                                  *QsB,                       //     IN:    static   public       party  B    key

1673      TPMS_ECC_POINT                                  *QeB                        //     IN:    ephemeral       public     party  B    key

1674      )

1675  {

1676      BN_CTX                                          *context;

1677      EC_POINT                                        *pQeA    =     NULL;

1678      EC_POINT                                        *pQeB    =     NULL;

1679      EC_POINT                                        *pQsB    =     NULL;

1680      EC_GROUP                                        *group      =  NULL;

1681      BIGNUM                                          *bnTa;

1682      BIGNUM                                          *bnDeA;

1683      BIGNUM                                          *bnDsA;

1684      BIGNUM                                          *bnXeA;                     //     x  coordinate          of  ephemeral     party     A  key

1685      BIGNUM                                          *bnH;

1686      BIGNUM                                          *bnN;

1687      BIGNUM                                          *bnXeB;

1688      const         ECC_CURVE_DATA                    *curveData         =    GetCurveData(curveId);

1689      CRYPT_RESULT                                    retVal;

1690

1691      pAssert(                   curveData        !=     NULL  &&    outZ     !=     NULL       &&  dsA  !=     NULL

1692                       &&                 deA     !=     NULL  &&        QsB  !=     NULL       &&  QeB  !=     NULL);

1693

1694      context          =     BN_CTX_new();

1695      if(context                ==  NULL    ||    curveData          ==  NULL)

1696              FAIL(FATAL_ERROR_ALLOCATION);

1697      BN_CTX_start(context);

1698      bnTa       =     BN_CTX_get(context);

1699      bnDeA         =  BN_CTX_get(context);

1700      bnDsA         =  BN_CTX_get(context);

1701      bnXeA         =  BN_CTX_get(context);

1702      bnH     =     BN_CTX_get(context);

1703      bnN     =     BN_CTX_get(context);

1704      bnXeB         =  BN_CTX_get(context);

1705      if(bnXeB            ==     NULL)

1706              FAIL(FATAL_ERROR_ALLOCATION);

1707

1708  //  Process:

1709  //  1.   implicitsigA             =     (de,A       +  avf(Qe,A)ds,A            )   mod       n.

1710  //  2.   P     =     h(implicitsigA)(Qe,B                 +  avf(Qe,B)Qs,B).

1711  //  3.   If       P  =     O,     output    an  error        indicator.

1712  //  4.   Z=xP,          where     xP    is    the      x-coordinate         of     P.

1713

1714      //   Initialize               group     parameters          and    local       values         of   input

1715      if((group              =   EccCurveInit(curveId,                   context))          ==  NULL)

1716              FAIL(FATAL_ERROR_INTERNAL);

1717

1718      if((pQeA            =     EC_POINT_new(group))                 ==  NULL)

1719              FAIL(FATAL_ERROR_ALLOCATION);

1720

1721      BnFrom2B(bnDeA,               &deA->b);

1722      BnFrom2B(bnDsA,               &dsA->b);

1723      BnFrom2B(bnH,                 curveData->h);

1724      BnFrom2B(bnN,                 curveData->n);

      Page 510                                                           TCG Published                                                     Family "2.0"

      October 30, 2014                                       Copyright © TCG 2006-2014                                    Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                                   Trusted Platform Module Library

1725      BnFrom2B(bnXeB,                       &QeB->x.b);

1726      pQeB        =     EccInitPoint2B(group,                             QeB,       context);

1727      pQsB        =     EccInitPoint2B(group,                             QsB,       context);

1728

1729      //      Compute           the      public           ephemeral             key      pQeA       =  [de,A]G

1730      if(               (retVal          =     PointMul(group,                    pQeA,         bnDeA,         NULL,       NULL,    context))

1731              !=        CRYPT_SUCCESS)

1732                 goto       Cleanup;

1733

1734      if(EC_POINT_get_affine_coordinates_GFp(group,                                                            pQeA,       bnXeA,      NULL,  context)  !=  1)

1735                         FAIL(FATAL_ERROR_INTERNAL);

1736

1737  //  1.      implicitsigA                  =   (de,A           +   avf(Qe,A)ds,A               )      mod     n.

1738  //  tA   :=     (ds,A         +     de,A         avf(Xe,A))                mod     n   (3)

1739  //  Compute           'tA'       =     ('deA'       +         'dsA'           avf('XeA'))            mod      n

1740      //      Ta     =   avf(XeA);

1741      BN_copy(bnTa,                      bnXeA);

1742      avf1(bnTa,                bnN);

1743      if(//          do     Ta     =     ds,A      *  Ta        mod    n     =  dsA      *     avf(XeA)         mod   n

1744                     !BN_mod_mul(bnTa,                          bnDsA,          bnTa,       bnN,       context)

1745

1746              //     now     Ta       =  deA       +  Ta        mod    n     =    deA       +   dsA    *    avf(XeA)           mod  n

1747              ||     !BN_mod_add(bnTa,                          bnDeA,          bnTa,       bnN,       context)

1748           )

1749                         FAIL(FATAL_ERROR_INTERNAL);

1750

1751  //  2.      P   =     h(implicitsigA)(Qe,B                           +     avf(Qe,B)Qs,B).

1752  //  Put     this       in     because            almost           every       case        of  h      is   ==     1  so   skip     the  call    when

1753      //      not       necessary.

1754      if(!BN_is_one(bnH))

1755      {

1756                 //     Cofactor            is     not       1     so  compute           Ta     :=     Ta   *   h     mod  n

1757                 if(!BN_mul(bnTa,                     bnTa,            bnH,     context))

1758                         FAIL(FATAL_ERROR_INTERNAL);

1759      }

1760

1761      //      Now       that       'tA'        is     (h     *     'tA'      mod     n)

1762      //      'outZ'         =     (tA)(Qe,B              +     avf(Qe,B)Qs,B).

1763

1764      //      first,         compute            XeB       =     avf(XeB)

1765      avf1(bnXeB,                  bnN);

1766

1767      //      QsB       :=   [XeB]QsB

1768      if(                !EC_POINT_mul(group,                             pQsB,         NULL,       pQsB,       bnXeB,         context)

1769

1770                 //     QeB     :=       QsB    +     QeB

1771                 ||      !EC_POINT_add(group,                             pQeB,         pQeB,       pQsB,       context)

1772              )

1773                 FAIL(FATAL_ERROR_INTERNAL);

1774

1775      //      QeB       :=   [tA]QeB            =     [tA](QsB            +     [Xe,B]QeB)             and     check       for  at     infinity

1776      if(PointMul(group,                           pQeB,           NULL,        pQeB,       bnTa,      context)            ==   CRYPT_SUCCESS)

1777                 //     Convert          BIGNUM           E     to     TPM2B      E

1778                 Point2B(group,                    outZ,           pQeB,        (INT16)BN_num_bytes(bnN),                           context);

1779

1780  Cleanup:

1781      if(pQeA            !=     NULL)          EC_POINT_free(pQeA);

1782      if(pQeB            !=     NULL)          EC_POINT_free(pQeB);

1783      if(pQsB            !=     NULL)          EC_POINT_free(pQsB);

1784      if(group              !=     NULL)        EC_GROUP_free(group);

1785      BN_CTX_end(context);

1786      BN_CTX_free(context);

1787

1788      return            retVal;

1789

1790  }

      Family "2.0"                                                                  TCG Published                                                           Page 511

      Level 00 Revision 01.16                                           Copyright © TCG 2006-2014                                                    October 30, 2014
      Trusted Platform Module Library                                                                                   Part 4: Supporting Routines

1791  #endif      //  TPM_ALG_ECMQV

1792  #ifdef      TPM_ALG_SM2        //%

      B.13.3.2.28. avfSm2()

      This function does the associated value computation required by SM2 key exchange. This is different

      form the avf() in the international standards because it returns a value that is half the size of the value

      returned by the standard avf. For example, if n is 15, Ws (w in the standard) is 2 but the W here is 1. This

      means that an input value of 14 (1110b) would return a value of 110b with the standard but 10b with the

      scheme in SM2.

1793  static      BOOL

1794  avfSm2(

1795         BIGNUM                   *bnX,                            //  IN/OUT:       the     reduced       value

1796         BIGNUM                   *bnN                             //  IN:   the     order       of   the   curve

1797         )

1798  {

1799  //  a)    set   w   :=   ceil(ceil(log2(n))                /     2)  -  1

1800         int                                      w   =   ((BN_num_bits(bnN)                  +   1)  /    2)   -   1;

1801

1802  //  b)    set   x'  :=    2^w   +   (   x  &    (2^w    -     1))

1803  //  This    is     just   like     the     avf  for     MQV      where     x'   =     2^w   +   (x  mod      2^w)

1804         BN_mask_bits(bnX,            w);         //  as     wiht      avf1,     this     is     too  big      by   a   factor       of   2  but

1805                                                  //  it     doesn't         matter     becasue       we    SET     the     extra    bit     anyway

1806         BN_set_bit(bnX,          w);

1807         return      TRUE;

1808  }

      SM2KeyExchange() This function performs the key exchange defined in SM2. The first step is to compute

      tA  =  (dsA     +  deA    avf(Xe,A))       mod  n   Then,        compute       the    Z    value    from     outZ    =    (h  tA   mod     n)   (QsA  +

      [avf(QeB().x)](QeB())). The function will compute the ephemeral public key from the ephemeral private

      key. All points are required to be on the curve of inQsA. The function will fail catastrophically if this is not

      the case

      Return Value                               Meaning

      CRYPT_SUCCESS                              results is valid

      CRYPT_NO_RESULT                            the value for dsA does not give a valid point on the curve

1809  static      CRYPT_RESULT

1810  SM2KeyExchange(

1811         TPMS_ECC_POINT                           *outZ,                      //     OUT:     the     computed         point

1812         TPM_ECC_CURVE                            curveId,                    //     IN:     the     curve     for     the   computations

1813         TPM2B_ECC_PARAMETER                      *dsA,                       //     IN:     static      private        TPM     key

1814         TPM2B_ECC_PARAMETER                      *deA,                       //     IN:     ephemeral         private       TPM     key

1815         TPMS_ECC_POINT                           *QsB,                       //     IN:     static      public        party    B    key

1816         TPMS_ECC_POINT                           *QeB                        //     IN:     ephemeral         public       party    B    key

1817         )

1818  {

1819         BN_CTX                                   *context;

1820         EC_POINT                                 *pQeA      =     NULL;

1821         EC_POINT                                 *pQeB      =     NULL;

1822         EC_POINT                                 *pQsB      =     NULL;

1823         EC_GROUP                                 *group        =  NULL;

1824         BIGNUM                                   *bnTa;

1825         BIGNUM                                   *bnDeA;

1826         BIGNUM                                   *bnDsA;

1827         BIGNUM                                   *bnXeA;                     //     x  coordinate          of     ephemeral         party     A  key

1828         BIGNUM                                   *bnH;

1829         BIGNUM                                   *bnN;

1830         BIGNUM                                   *bnXeB;

      Page 512                                                         TCG Published                                                          Family "2.0"

      October 30, 2014                                    Copyright © TCG 2006-2014                                        Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                                  Trusted Platform Module    Library

1831      const         ECC_CURVE_DATA                           *curveData         =     GetCurveData(curveId);

1832      CRYPT_RESULT                                           retVal;

1833

1834      pAssert(                      curveData            !=  NULL    &&    outZ          !=  NULL         &&  dsA       !=     NULL

1835                        &&                       deA     !=  NULL    &&      QsB         !=  NULL         &&  QeB       !=     NULL);

1836

1837      context           =     BN_CTX_new();

1838      if(context                 ==       NULL   ||      curveData       ==     NULL)

1839              FAIL(FATAL_ERROR_ALLOCATION);

1840      BN_CTX_start(context);

1841      bnTa       =     BN_CTX_get(context);

1842      bnDeA         =   BN_CTX_get(context);

1843      bnDsA         =   BN_CTX_get(context);

1844      bnXeA         =   BN_CTX_get(context);

1845      bnH     =     BN_CTX_get(context);

1846      bnN     =     BN_CTX_get(context);

1847      bnXeB         =   BN_CTX_get(context);

1848      if(bnXeB             ==       NULL)

1849              FAIL(FATAL_ERROR_ALLOCATION);

1850

1851      //     Initialize                   group     parameters          and     local        values           of  input

1852      if((group               =     EccCurveInit(curveId,                    context))              ==    NULL)

1853              FAIL(FATAL_ERROR_INTERNAL);

1854

1855      if((pQeA             =     EC_POINT_new(group))                    ==     NULL)

1856              FAIL(FATAL_ERROR_ALLOCATION);

1857

1858      BnFrom2B(bnDeA,                        &deA->b);

1859      BnFrom2B(bnDsA,                        &dsA->b);

1860      BnFrom2B(bnH,                       curveData->h);

1861      BnFrom2B(bnN,                       curveData->n);

1862      BnFrom2B(bnXeB,                        &QeB->x.b);

1863      pQeB       =     EccInitPoint2B(group,                         QeB,    context);

1864      pQsB       =     EccInitPoint2B(group,                         QsB,    context);

1865

1866      //     Compute             the      public         ephemeral       key       pQeA      =   [de,A]G

1867      if(              (retVal            =  PointMul(group,               pQeA,         bnDeA,           NULL,      NULL,      context))

1868             !=        CRYPT_SUCCESS)

1869              goto         Cleanup;

1870

1871      if(EC_POINT_get_affine_coordinates_GFp(group,                                                       pQeA,      bnXeA,        NULL,    context)  !=  1)

1872                        FAIL(FATAL_ERROR_INTERNAL);

1873

1874  //  tA  :=     (ds,A           +     de,A      avf(Xe,A))          mod     n     (3)

1875  //  Compute          'tA'         =     ('dsA'      +      'deA'      avf('XeA'))              mod      n

1876      //     Ta     =   avf(XeA);

1877      BN_copy(bnTa,                       bnXeA);

1878      avfSm2(bnTa,                     bnN);

1879      if(//         do     Ta       =     de,A   *    Ta     mod  n  =   deA       *     avf(XeA)         mod     n

1880                    !BN_mod_mul(bnTa,                        bnDeA,     bnTa,         bnN,      context)

1881

1882             //     now       Ta       =  dsA    +    Ta     mod  n  =     dsA        +  deA     *     avf(XeA)            mod  n

1883             ||     !BN_mod_add(bnTa,                        bnDsA,     bnTa,         bnN,      context)

1884          )

1885                        FAIL(FATAL_ERROR_INTERNAL);

1886

1887  //  outZ    ?     [h        tA       mod   n]     (Qs,B    +    [avf(Xe,B)](Qe,B))                      (4)

1888      //     Put       this         in    because         almost     every         case      of     h     is  ==     1     so   skip   the  call  when

1889      //     not       necessary.

1890      if(!BN_is_one(bnH))

1891      {

1892              //       Cofactor              is  not      1  so   compute          Ta    :=     Ta     *  h   mod       n

1893              if(!BN_mul(bnTa,                        bnTa,       bnH,   context))

1894                        FAIL(FATAL_ERROR_INTERNAL);

1895      }

1896

      Family "2.0"                                                           TCG Published                                                                Page 513

      Level 00 Revision 01.16                                    Copyright © TCG 2006-2014                                                      October 30, 2014
      Trusted Platform Module Library                                                                       Part 4: Supporting     Routines

1897     //   Now    that    'tA'     is  (h     *  'tA'        mod     n)

1898     //   'outZ'      =  ['tA'](QsB          +  [avf(QeB.x)](QeB)).

1899

1900     //   first,      compute      XeB    =     avf(XeB)

1901     avfSm2(bnXeB,           bnN);

1902

1903     //   QeB    :=   [XeB]QeB

1904     if(          !EC_POINT_mul(group,                   pQeB,      NULL,  pQeB,     bnXeB,     context)

1905

1906             //  QeB     :=  QsB   +  QeB

1907             ||   !EC_POINT_add(group,                   pQeB,      pQeB,  pQsB,     context)

1908          )

1909             FAIL(FATAL_ERROR_INTERNAL);

1910

1911     //   QeB    :=   [tA]QeB      =  [tA](QsB           +  [Xe,B]QeB)         and  check   for   at  infinity

1912     if(PointMul(group,               pQeB,     NULL,       pQeB,       bnTa,  context)     ==   CRYPT_SUCCESS)

1913             //  Convert     BIGNUM       E     to   TPM2B       E

1914             Point2B(group,           outZ,     pQeB,       (INT16)BN_num_bytes(bnN),             context);

1915

1916  Cleanup:

1917     if(pQeA      !=     NULL)    EC_POINT_free(pQeA);

1918     if(pQeB      !=     NULL)    EC_POINT_free(pQeB);

1919     if(pQsB      !=     NULL)    EC_POINT_free(pQsB);

1920     if(group        !=  NULL)     EC_GROUP_free(group);

1921     BN_CTX_end(context);

1922     BN_CTX_free(context);

1923

1924     return      retVal;

1925

1926  }

1927  #endif     //%     TPM_ALG_SM2

      B.13.3.2.29. C_2_2_ECDH()

      This function performs the two phase key exchange defined in SP800-56A, 6.1.1.2 Full Unified Model,

      C(2, 2, ECC CDH).

1928  static  CRYPT_RESULT

1929  C_2_2_ECDH(

1930     TPMS_ECC_POINT                             *outZ1,                    //  OUT:  Zs

1931     TPMS_ECC_POINT                             *outZ2,                    //  OUT:  Ze

1932     TPM_ECC_CURVE                              curveId,                   //  IN:   the   curve  for    the   computations

1933     TPM2B_ECC_PARAMETER                        *dsA,                      //  IN:   static     private   TPM   key

1934     TPM2B_ECC_PARAMETER                        *deA,                      //  IN:   ephemeral    private      TPM   key

1935     TPMS_ECC_POINT                             *QsB,                      //  IN:   static     public   party  B    key

1936     TPMS_ECC_POINT                             *QeB                       //  IN:   ephemeral    public      party  B    key

1937     )

1938  {

1939     BN_CTX                                     *context;

1940     EC_POINT                                   *pQ   =     NULL;

1941     EC_GROUP                                   *group      =    NULL;

1942     BIGNUM                                     *bnD;

1943     INT16                                      size;

1944     const       ECC_CURVE_DATA                 *curveData          =   GetCurveData(curveId);

1945

1946     context      =   BN_CTX_new();

1947     if(context          ==  NULL     ||  curveData            ==   NULL)

1948             FAIL(FATAL_ERROR_ALLOCATION);

1949     BN_CTX_start(context);

1950     if((bnD      =   BN_CTX_get(context))                  ==      NULL)

1951             FAIL(FATAL_ERROR_INTERNAL);

1952

1953     //   Initialize         group    parameters            and     local  values    of    input

1954     if((group        =  EccCurveInit(curveId,                      context))  ==    NULL)

      Page 514                                                     TCG Published                                              Family "2.0"

      October 30, 2014                                  Copyright © TCG 2006-2014                            Level 00 Revision 01.16
      Part  4: Supporting Routines                                                                      Trusted Platform     Module    Library

1955               FAIL(FATAL_ERROR_INTERNAL);

1956        size    =  (INT16)BN_num_bytes(&group->order);

1957

1958        //  Get    the      static     private     key     of   A

1959        BnFrom2B(bnD,            &dsA->b);

1960

1961        //  Initialize           the   static      public      point     from   B

1962        pQ  =   EccInitPoint2B(group,                 QsB,     context);

1963

1964        //  Do     the     point   multiply        for    the   Zs  value

1965        if(PointMul(group,                pQ,  NULL,      pQ,   bnD,     context)       !=   CRYPT_NO_RESULT)

1966               //  Convert        the     Zs   value

1967               Point2B(group,             outZ1,   pQ,     size,    context);

1968

1969        //  Get    the      ephemeral         private     key   of  A

1970        BnFrom2B(bnD,            &deA->b);

1971

1972        //  Initalize       the       ephemeral       public       point  from     B

1973        PointFrom2B(group,                pQ,  QeB,      context);

1974

1975        //  Do     the     point   multiply        for    the   Ze  value

1976        if(PointMul(group,                pQ,  NULL,      pQ,   bnD,     context)       !=   CRYPT_NO_RESULT)

1977               //  Convert        the     Ze   value.

1978               Point2B(group,             outZ2,   pQ,     size,    context);

1979

1980        if(pQ      !=   NULL)     EC_POINT_free(pQ);

1981        if(group        !=  NULL)      EC_GROUP_free(group);

1982        BN_CTX_end(context);

1983        BN_CTX_free(context);

1984        return     CRYPT_SUCCESS;

1985  }

      B.13.3.2.30. _cpri__C_2_2_KeyExchange()

      This function is the dispatch routine for the EC key exchange function that use two ephemeral and two

      static keys.

      Return Value                                 Meaning

      CRYPT_SCHEME                                 scheme is not defined

1986  LIB_EXPORT       CRYPT_RESULT

1987  _cpri__C_2_2_KeyExchange(

1988        TPMS_ECC_POINT                             *outZ1,                //    OUT:    a    computed    point

1989        TPMS_ECC_POINT                             *outZ2,                //    OUT:    and  optional      second      point

1990        TPM_ECC_CURVE                              curveId,               //    IN:     the  curve  for    the  computations

1991        TPM_ALG_ID                                 scheme,                //    IN:     the  key  exchange      scheme

1992        TPM2B_ECC_PARAMETER                        *dsA,                  //    IN:     static    private  TPM      key

1993        TPM2B_ECC_PARAMETER                        *deA,                  //    IN:     ephemeral   private     TPM      key

1994        TPMS_ECC_POINT                             *QsB,                  //    IN:     static    public   party    B    key

1995        TPMS_ECC_POINT                             *QeB                   //    IN:     ephemeral   public      party    B    key

1996        )

1997  {

1998        pAssert(            outZ1     !=   NULL

1999                       &&   dsA   !=   NULL    &&  deA     !=   NULL

2000                       &&   QsB   !=   NULL    &&  QeB     !=   NULL);

2001

2002        //  Initalize       the       output       points   so     that   they     are  empty     until   one   of  the

2003        //  functions       decides           otherwise

2004        outZ1->x.b.size            =   0;

2005        outZ1->y.b.size            =   0;

2006        if(outZ2        !=  NULL)

2007        {

2008               outZ2->x.b.size             =   0;

      Family "2.0"                                                 TCG Published                                                  Page 515

      Level 00 Revision 01.16                          Copyright © TCG 2006-2014                                        October 30, 2014
      Trusted Platform Module Library                                                             Part 4: Supporting Routines

2009           outZ2->y.b.size          =  0;

2010     }

2011

2012     switch    (scheme)

2013     {

2014           case  TPM_ALG_ECDH:

2015                 return  C_2_2_ECDH(outZ1,           outZ2,    curveId,    dsA,       deA,    QsB,  QeB);

2016                 break;

2017  #ifdef   TPM_ALG_ECMQV

2018           case  TPM_ALG_ECMQV:

2019                 return  C_2_2_MQV(outZ1,            curveId,  dsA,    deA,      QsB,  QeB);

2020                 break;

2021  #endif

2022  #ifdef   TPM_ALG_SM2

2023           case  TPM_ALG_SM2:

2024                 return  SM2KeyExchange(outZ1,           curveId,      dsA,      deA,  QsB,   QeB);

2025                 break;

2026  #endif

2027           default:

2028                 return  CRYPT_SCHEME;

2029     }

2030  }

2031  #else          //%

      Stub used when the 2-phase key           exchange  is  not  defined  so  that  the  linker  has   something  to  associate

      with the value in the .def file.

2032  LIB_EXPORT   CRYPT_RESULT

2033  _cpri__C_2_2_KeyExchange(

2034     void

2035     )

2036  {

2037     return    CRYPT_FAIL;

2038  }

2039  #endif  //%  CC_ZGen_2Phase

2040  #endif  //   TPM_ALG_ECC

      Page 516                                           TCG Published                                             Family "2.0"

      October 30, 2014                         Copyright © TCG 2006-2014                          Level 00 Revision 01.16
    Part 4: Supporting Routines                                     Trusted Platform Module Library

                                                         Annex C

                                                     (informative)

                                     Simulation Environment

    C.1     Introduction

    These files are used to simulate some of the implementation-dependent hardware of a TPM. These files

    are provided to allow creation of a simulation environment for the TPM. These files are not expected to be

    part of a hardware TPM implementation.

    C.2     Cancel.c

    C.2.1.    Introduction

    This module simulates the cancel pins on the TPM.

    C.2.2.    Includes, Typedefs, Structures, and Defines

1   #include   "PlatformData.h"

    C.2.3.    Functions

    C.2.3.1.   _plat__IsCanceled()

    Check if the cancel flag is set

    Return Value                     Meaning

    TRUE                             if cancel flag  is  set

    FALSE                            if cancel flag  is  not  set

2   LIB_EXPORT    BOOL

3   _plat__IsCanceled(

4        void

5        )

6   {

7        //   return  cancel  flag

8        return   s_isCanceled;

9   }

    C.2.3.2.   _plat__SetCancel()

    Set cancel flag.

10  LIB_EXPORT    void

11  _plat__SetCancel(

12       void

13       )

14  {

15       s_isCanceled     =  TRUE;

16       return;

17  }

    Family "2.0"                                     TCG Published  Page 517

    Level 00 Revision 01.16          Copyright © TCG 2006-2014      October 30, 2014
    Trusted Platform Module Library                             Part 4: Supporting Routines

    C.2.3.3.  _plat__ClearCancel()

    Clear cancel flag

18  LIB_EXPORT  void

19  _plat__ClearCancel(

20     void

21     )

22  {

23     s_isCanceled    =  FALSE;

24     return;

25  }

    Page 518                         TCG Published              Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                           Trusted Platform Module Library

    C.3     Clock.c

    C.3.1.    Introduction

    This file contains the routines that are used by the simulator to mimic a hardware clock on a TPM. In this

    implementation, all the time values are measured in millisecond. However, the precision of the clock

    functions may be implementation dependent.

    C.3.2.    Includes and Data Definitions

1   #include      <time.h>

2   #include      "PlatformData.h"

3   #include      "Platform.h"

    C.3.3.    Functions

    C.3.3.1.      _plat__ClockReset()

    Set the current clock time as initial time.        This function is called at a power on event   to reset the  clock

4   LIB_EXPORT        void

5   _plat__ClockReset(

6        void

7        )

8   {

9        //   Implementation            specific:  Microsoft       C   set  CLOCKS_PER_SEC  to  be   1/1000,

10       //   so  here  the       measurement      of  clock()     is  in   millisecond.

11       s_initClock        =     clock();

12       s_adjustRate          =  CLOCK_NOMINAL;

13

14       return;

15  }

    C.3.3.2.      _plat__ClockTimeFromStart()

    Function      returns         the   compensated    time           from  the  start      of  the  command       when

    _plat__ClockTimeFromStart() was called.

16  unsigned      long  long

17  _plat__ClockTimeFromStart(

18       void

19       )

20  {

21       unsigned     long        long  currentClock   =  clock();

22       return   ((currentClock             -  s_initClock)    *     CLOCK_NOMINAL)  /   s_adjustRate;

23  }

    C.3.3.3.      _plat__ClockTimeElapsed()

    Get the time elapsed from current to the last time the _plat__ClockTimeElapsed() is called.               For the first

    _plat__ClockTimeElapsed() call after a power on event, this call report the elapsed time from power on to

    the current call

24  LIB_EXPORT        unsigned         long  long

25  _plat__ClockTimeElapsed(

26       void

    Family "2.0"                                       TCG Published                                               Page 519

    Level 00 Revision 01.16                     Copyright © TCG 2006-2014                            October 30, 2014
    Trusted Platform Module Library                                                                    Part 4: Supporting Routines

27     )

28  {

29     unsigned           long  long       elapsed;

30     unsigned           long  long       currentClock          =     clock();

31     elapsed         =   ((currentClock               -  s_initClock)     *    CLOCK_NOMINAL)     /  s_adjustRate;

32     s_initClock         +=     (elapsed           *     s_adjustRate)    /    CLOCK_NOMINAL;

33

34  #ifdef       DEBUGGING_TIME

35     //     Put  this    in     so       that     TPM    time  will  pass      much   faster   than  real  time    when

36     //     doing       debug.

37     //     A   value    of   1000       for      DEBUG_TIME_MULTIPLER         will    make    each  ms  into   a  second

38     //     A   good     value     might       be     100

39     elapsed         *=  DEBUG_TIME_MULTIPLIER

40  #endif

41                         return          elapsed;

42  }

    C.3.3.4.      _plat__ClockAdjustRate()

    Adjust the clock rate

43  LIB_EXPORT     void

44  _plat__ClockAdjustRate(

45     int                              adjust                   //    IN:  the  adjust    number.     It  could     be  positive

46                                                               //         or   negative

47     )

48  {

49     //     We   expect       the     caller       should      only  use  a    fixed  set  of  constant    values      to

50     //     adjust       the  rate

51     switch(adjust)

52     {

53               case     CLOCK_ADJUST_COARSE:

54                     s_adjustRate             +=   CLOCK_ADJUST_COARSE;

55                     break;

56               case     -CLOCK_ADJUST_COARSE:

57                     s_adjustRate             -=   CLOCK_ADJUST_COARSE;

58                     break;

59               case     CLOCK_ADJUST_MEDIUM:

60                     s_adjustRate             +=   CLOCK_ADJUST_MEDIUM;

61                     break;

62               case     -CLOCK_ADJUST_MEDIUM:

63                     s_adjustRate             -=   CLOCK_ADJUST_MEDIUM;

64                     break;

65               case     CLOCK_ADJUST_FINE:

66                     s_adjustRate             +=   CLOCK_ADJUST_FINE;

67                     break;

68               case     -CLOCK_ADJUST_FINE:

69                     s_adjustRate             -=   CLOCK_ADJUST_FINE;

70                     break;

71               default:

72                     //  ignore          any   other       values;

73                     break;

74     }

75

76     if(s_adjustRate               >     (CLOCK_NOMINAL        +     CLOCK_ADJUST_LIMIT))

77               s_adjustRate           =  CLOCK_NOMINAL         +     CLOCK_ADJUST_LIMIT;

78     if(s_adjustRate               <     (CLOCK_NOMINAL        -     CLOCK_ADJUST_LIMIT))

79               s_adjustRate           =  CLOCK_NOMINAL-CLOCK_ADJUST_LIMIT;

80

81     return;

82  }

    Page 520                                                     TCG Published                                           Family "2.0"

    October 30, 2014                                       Copyright © TCG 2006-2014                       Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                  Trusted Platform Module Library

    C.4      Entropy.c

    C.4.1.     Includes

1   #define       _CRT_RAND_S

2   #include       <stdlib.h>

3   #include       <stdint.h>

4   #include       <memory.h>

5   #include       "TpmBuildSwitches.h"

    C.4.2.     Local values

    This is the last 32-bits of hardware entropy produced. We have to check to see that two consecutive 32-

    bit values are not the same because (according to FIPS 140-2, annex C

          "If each call to a RNG produces blocks of n bits (where n > 15), the first n-bit block generated after

          power-up, initialization, or reset shall not be used, but shall be saved for comparison with the next n-

          bit block to be generated. Each subsequent generation of an n-bit block shall be compared with the

          previously generated block. The test shall fail if any two compared n-bit blocks are equal."

6   extern     uint32_t                    lastEntropy;

7   extern     int                         firstValue;

    C.4.3.     _plat__GetEntropy()

    This function is used to get available hardware entropy. In a hardware implementation of this function,

    there would be no call to the system to get entropy. If the caller does not ask for any entropy, then this is

    a startup indication and firstValue should be reset.

    Return Value                                 Meaning

    <0                                           hardware failure of the entropy generator, this is sticky

    >= 0                                         the returned amount of entropy (bytes)

8   LIB_EXPORT       int32_t

9   _plat__GetEntropy(

10        unsigned       char                 *entropy,              //    output        buffer

11        uint32_t                            amount                 //    amount        requested

12  )

13  {

14        uint32_t                            rndNum;

15        int                          OK     =   1;

16

17        if(amount         ==  0)

18        {

19                firstValue        =  1;

20                return    0;

21        }

22

23        //   Only     provide        entropy      32  bits  at  a  time  to  test      the  ability

24        //   of   the     caller     to     deal    with  partial  results.

25        OK   =   rand_s(&rndNum)            ==    0;

26        if(OK)

27        {

28                if(firstValue)

29                      firstValue         =  0;

30                else

31                      OK  =   (rndNum       !=    lastEntropy);

32        }

    Family "2.0"                                              TCG Published                                 Page 521

    Level 00 Revision 01.16                             Copyright © TCG 2006-2014                           October 30, 2014
    Trusted Platform Module Library                                   Part 4: Supporting Routines

33     if(OK)

34     {

35        lastEntropy          =  rndNum;

36        if(amount      >     sizeof(rndNum))

37             amount       =     sizeof(rndNum);

38        memcpy(entropy,         &rndNum,  amount);

39     }

40     return  (OK)   ?  (int32_t)amount    :      -1;

41  }

    Page 522                                       TCG Published      Family "2.0"

    October 30, 2014                       Copyright © TCG 2006-2014  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                           Trusted Platform Module Library

    C.5     LocalityPlat.c

    C.5.1.    Includes

1   #include   "PlatformData.h"

2   #include   "TpmError.h"

    C.5.2.    Functions

    C.5.2.1.   _plat__LocalityGet()

    Get the most recent command locality in locality value form. This is an               integer value for locality and not a

    locality structure The locality can be 0-4 or 32-255. 5-31 is not allowed.

3   LIB_EXPORT    unsigned              char

4   _plat__LocalityGet(

5        void

6        )

7   {

8        return   s_locality;

9   }

    C.5.2.2.   _plat__LocalitySet()

    Set the most recent command locality          in  locality  value  form

10  LIB_EXPORT    void

11  _plat__LocalitySet(

12       unsigned  char                 locality

13       )

14  {

15       if(locality       >     4  &&  locality  <   32)

16             locality       =     0;

17       s_locality     =     locality;

18       return;

19  }

    C.5.2.3.   _plat__IsRsaKeyCacheEnabled()

    This function is used to check if the RSA key cache         is     enabled  or  not.

20  LIB_EXPORT    int

21  _plat__IsRsaKeyCacheEnabled(

22       void

23       )

24  {

25       return   s_RsaKeyCacheEnabled;

26  }

    Family "2.0"                                      TCG Published                       Page 523

    Level 00 Revision 01.16                       Copyright © TCG 2006-2014               October 30, 2014
    Trusted Platform Module Library                                                Part 4: Supporting Routines

    C.6     NVMem.c

    C.6.1.    Introduction

    This file contains the NV read and write access methods.         This implementation uses RAM/file and does

    not manage the RAM/file as NV blocks. The implementation may become more sophisticated over time.

    C.6.2.    Includes

1   #include   <memory.h>

2   #include   <string.h>

3   #include   "PlatformData.h"

4   #include   "TpmError.h"

5   #include   "assert.h"

    C.6.3.    Functions

    C.6.3.1.   _plat__NvErrors()

    This function is used by the simulator to set the error   flags  in  the  NV  subsystem  to  simulate  an  error  in  the

    NV loading process

6   LIB_EXPORT    void

7   _plat__NvErrors(

8        BOOL                  recoverable,

9        BOOL                  unrecoverable

10       )

11  {

12       s_NV_unrecoverable       =  unrecoverable;

13       s_NV_recoverable      =  recoverable;

14  }

    C.6.3.2.   _plat__NVEnable()

    Enable NV memory.

    This version just pulls in data from a file. In a real TPM, with NV on chip, this function would verify the

    integrity of the saved context. If the NV memory was not on chip but was in something like RPMB, the NV

    state would be read in, decrypted and integrity checked.

    The recovery from an integrity failure depends on where the error occurred. It it was in the state that is

    discarded by TPM Reset, then the error is recoverable if the TPM is reset. Otherwise, the TPM must go

    into failure mode.

    Return Value                     Meaning

    0                                if success

    >0                               if receive recoverable error

    <0                               if unrecoverable error

15  LIB_EXPORT    int

16  _plat__NVEnable(

17       void               *platParameter        //  IN:    platform    specific  parameter

18       )

19  {

20       (platParameter);                             //     to    keep  compiler  quiet

21       //   Start  assuming     everything  is  OK

    Page 524                                      TCG Published                                            Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014                               Level  00  Revision 01.16
    Part 4: Supporting Routines                                                                           Trusted Platform Module Library

22     s_NV_unrecoverable                     =   FALSE;

23     s_NV_recoverable                   =   FALSE;

24

25  #ifdef    FILE_BACKED_NV

26

27     if(s_NVFile            !=      NULL)       return      0;

28

29     //     Try     to   open       an     exist     NVChip       file   for   read/write

30     if(0       !=   fopen_s(&s_NVFile,                     "NVChip",         "r+b"))

31            s_NVFile            =   NULL;

32

33     if(NULL         !=     s_NVFile)

34     {

35            //      See     if     the     NVChip       file     is   empty

36            fseek(s_NVFile,                    0,  SEEK_END);

37            if(0        ==  ftell(s_NVFile))

38                     s_NVFile           =   NULL;

39     }

40

41     if(s_NVFile            ==      NULL)

42     {

43            //      Initialize             all     the   byte     in     the  new  file    to  0

44            memset(s_NV,                0,     NV_MEMORY_SIZE);

45

46            //      If   NVChip         file       does     not   exist,      try  to  create     it    for  read/write

47            fopen_s(&s_NVFile,                     "NVChip",          "w+b");

48            //      Start       initialize           at     the   end    of   new  file

49            fseek(s_NVFile,                    0,  SEEK_END);

50            //      Write       0s  to      NVChip       file

51            fwrite(s_NV,                1,     NV_MEMORY_SIZE,           s_NVFile);

52     }

53     else

54     {

55            //      If   NVChip         file       exist,       assume   the   size    is  correct

56            fseek(s_NVFile,                    0,  SEEK_END);

57            assert(ftell(s_NVFile)                          ==   NV_MEMORY_SIZE);

58            //      read    NV      file       data     to  memory

59            fseek(s_NVFile,                    0,  SEEK_SET);

60            fread(s_NV,             NV_MEMORY_SIZE,                  1,  s_NVFile);

61     }

62  #endif

63     //     NV   contents           have       been     read     and     the  error    checks     have  been  performed.  For

64     //     simulation             purposes,         use    the      signaling     interface      to    indicate  if  an  error  is

65     //     to   be     simulated           and    the      type     of  the  error.

66     if(s_NV_unrecoverable)

67            return          -1;

68     return         s_NV_recoverable;

69  }

    C.6.3.3.      _plat__NVDisable()

    Disable NV memory

70  LIB_EXPORT        void

71  _plat__NVDisable(

72     void

73     )

74  {

75  #ifdef    FILE_BACKED_NV

76

77     assert(s_NVFile                !=      NULL);

78     //     Close       NV  file

79     fclose(s_NVFile);

80     //     Set     file    handle          to     NULL

    Family "2.0"                                                       TCG Published                                        Page 525

    Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                                                  Part 4: Supporting Routines

81      s_NVFile         =  NULL;

82

83   #endif

84

85      return;

86   }

     C.6.3.4.      _plat__IsNvAvailable()

     Check if NV is available

     Return Value                            Meaning

     0                                       NV is available

     1                                       NV is not available  due  to write failure

     2                                       NV is not available  due  to rate limit

87   LIB_EXPORT      int

88   _plat__IsNvAvailable(

89      void

90      )

91   {

92      //     NV  is    not    available    if  the  TPM     is  in   failure        mode

93      if(!s_NvIsAvailable)

94             return       1;

95

96   #ifdef    FILE_BACKED_NV

97      if(s_NVFile           ==  NULL)

98             return       1;

99   #endif

100

101     return       0;

102

103  }

     C.6.3.5.      _plat__NvMemoryRead()

     Function: Read a chunk of NV memory

104  LIB_EXPORT      void

105  _plat__NvMemoryRead(

106     unsigned         int          startOffset,    //      IN:     read   start

107     unsigned         int          size,           //      IN:     size   of  bytes      to  read

108     void                       *data              //      OUT:     data  buffer

109     )

110  {

111     assert(startOffset            +    size  <=   NV_MEMORY_SIZE);

112

113     //     Copy    data     from  RAM

114     memcpy(data,            &s_NV[startOffset],        size);

115     return;

116  }

     C.6.3.6.      _plat__NvIsDifferent()

     This function checks to see if the NV is different from the test value. This               is so that NV will not be written if

     it has not changed.

     Page 526                                         TCG Published                                   Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                            Level 00 Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

     Return Value                           Meaning

     TRUE                                   the NV location is different from the test value

     FALSE                                  the NV location is the same as the test value

117  LIB_EXPORT      BOOL

118  _plat__NvIsDifferent(

119     unsigned     int         startOffset,                //  IN:   read   start

120     unsigned     int         size,                       //  IN:   size   of  bytes    to  read

121     void                     *data                       //  IN:   data   buffer

122     )

123  {

124     return       (memcmp(&s_NV[startOffset],                 data,  size)     !=  0);

125  }

     C.6.3.7.  _plat__NvMemoryWrite()

     This function is used to update NV memory. The write is to a memory copy                         of   NV.  At  the  end  of the

     current command, any changes are written to the actual NV memory.

126  LIB_EXPORT      void

127  _plat__NvMemoryWrite(

128     unsigned     int         startOffset,                //  IN:   write   start

129     unsigned     int         size,                       //  IN:   size   of  bytes    to  write

130     void                     *data                       //  OUT:   data   buffer

131     )

132  {

133     assert(startOffset            +     size   <=     NV_MEMORY_SIZE);

134

135     //     Copy  the   data  to      the   NV     image

136     memcpy(&s_NV[startOffset],                    data,  size);

137  }

     C.6.3.8.  _plat__NvMemoryMove()

     Function: Move a chunk of NV memory from source to destination This                         function  should   ensure    that if

     there overlap, the original data is copied before it is written

138  LIB_EXPORT      void

139  _plat__NvMemoryMove(

140     unsigned     int         sourceOffset,               //  IN:   source     offset

141     unsigned     int         destOffset,                 //  IN:   destination      offset

142     unsigned     int         size                        //  IN:   size   of  data    being  moved

143     )

144  {

145     assert(sourceOffset              +  size      <=  NV_MEMORY_SIZE);

146     assert(destOffset         +      size     <=   NV_MEMORY_SIZE);

147

148     //     Move  data  in    RAM

149     memmove(&s_NV[destOffset],                    &s_NV[sourceOffset],        size);

150

151     return;

152  }

     C.6.3.9.  _plat__NvCommit()

     Update NV chip

     Family "2.0"                                            TCG Published                                               Page 527

     Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                    October 30, 2014
     Trusted Platform Module Library                                        Part 4:                 Supporting Routines

     Return Value                           Meaning

     0                                      NV write success

     non-0                                  NV write fail

153  LIB_EXPORT    int

154  _plat__NvCommit(

155     void

156     )

157  {

158  #ifdef  FILE_BACKED_NV

159     //   If  NV    file     is     not  available,     return  failure

160     if(s_NVFile         ==   NULL)

161             return  1;

162

163     //   Write     RAM   data       to  NV

164     fseek(s_NVFile,             0,  SEEK_SET);

165     fwrite(s_NV,         1,     NV_MEMORY_SIZE,        s_NVFile);

166     return     0;

167  #else

168     return     0;

169  #endif

170

171  }

     C.6.3.10.   _plat__SetNvAvail()

     Set the current NV state           to available.  This function is for testing purpose only.   It is  not  part  of  the

     platform NV logic

172  LIB_EXPORT    void

173  _plat__SetNvAvail(

174     void

175     )

176  {

177     s_NvIsAvailable             =   TRUE;

178     return;

179  }

     C.6.3.11.   _plat__ClearNvAvail()

     Set the current NV state to unavailable.           This function is for testing purpose only.  It is  not  part  of  the

     platform NV logic

180  LIB_EXPORT    void

181  _plat__ClearNvAvail(

182     void

183     )

184  {

185     s_NvIsAvailable             =   FALSE;

186     return;

187  }

     Page 528                                              TCG Published                                   Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014   Level 00 Revision 01.16
    Part 4: Supporting Routines                                              Trusted  Platform Module Library

    C.7     PowerPlat.c

    C.7.1.    Includes and Function Prototypes

1   #include         "PlatformData.h"

2   #include         "Platform.h"

    C.7.2.    Functions

    C.7.2.1.   _plat__Signal_PowerOn()

    Signal platform power on

3   LIB_EXPORT      int

4   _plat__Signal_PowerOn(

5        void

6        )

7   {

8        //   Start     clock

9        _plat__ClockReset();

10

11       //   Initialize       locality

12       s_locality      =     0;

13

14       //   Command    cancel

15          s_isCanceled       =   FALSE;

16

17       //   Need   to  indicate          that  we  lost  power

18       s_powerLost        =  TRUE;

19

20       return     0;

21  }

    C.7.2.2.   _plat__WasPowerLost()

    Test whether power was lost before a _TPM_Init()

22  LIB_EXPORT      BOOL

23  _plat__WasPowerLost(

24       BOOL                         clear

25       )

26  {

27       BOOL               retVal    =    s_powerLost;

28       if(clear)

29             s_powerLost         =  FALSE;

30       return     retVal;

31  }

    C.7.2.3.   _plat_Signal_Reset()

    This a TPM reset without a power loss.

32  LIB_EXPORT      int

33  _plat__Signal_Reset(

34       void

35       )

36  {

37       //   Need   to  reset        the  clock

38       _plat__ClockReset();

    Family "2.0"                                           TCG Published              Page 529

    Level 00 Revision 01.16                       Copyright © TCG 2006-2014           October 30, 2014
    Trusted Platform Module Library                                                   Part 4: Supporting Routines

39

40     //     if   we  are   doing  reset    but  did  not  have  a  power  failure,  then  we  should

41     //     not  need     to  reload  NV   ...

42     return      0;

43  }

    C.7.2.4.      _plat__Signal_PowerOff()

    Signal platform power off

44  LIB_EXPORT     void

45  _plat__Signal_PowerOff(

46     void

47     )

48  {

49     //     Prepare    NV     memory  for  power  off

50     _plat__NVDisable();

51

52     return;

53  }

    Page 530                                           TCG Published                            Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                Level 00 Revision 01.16
    Part 4: Supporting Routines                                        Trusted  Platform Module Library

    C.8     Platform.h

1   #ifndef       PLATFORM_H

2   #define       PLATFORM_H

    C.8.1.    Includes and Defines

3   #include  "bool.h"

4   #include  "stdint.h"

5   #include  "TpmError.h"

6   #include  "TpmBuildSwitches.h"

7   #define   UNREFERENCED(a)    ((void)(a))

    C.8.2.    Power Functions

    C.8.2.1.  _plat__Signal_PowerOn

    Signal power on This signal is simulate by a RPC call

8   LIB_EXPORT    int

9   _plat__Signal_PowerOn(void);

    C.8.2.2.  _plat__Signal_Reset

    Signal reset This signal is simulate by a RPC call

10  LIB_EXPORT    int

11  _plat__Signal_Reset(void);

    C.8.2.3.  _plat__WasPowerLost()

    Indicates if the power was lost before a _TPM__Init().

12  LIB_EXPORT    BOOL

13  _plat__WasPowerLost(BOOL     clear);

    C.8.2.4.  _plat__Signal_PowerOff()

    Signal power off This signal is simulate by a RPC call

14  LIB_EXPORT    void

15  _plat__Signal_PowerOff(void);

    C.8.3.    Physical Presence Functions

    C.8.3.1.  _plat__PhysicalPresenceAsserted()

    Check if physical presence is signaled

    Family "2.0"                              TCG Published                     Page 531

    Level 00 Revision 01.16                 Copyright © TCG 2006-2014           October 30, 2014
    Trusted Platform Module Library                                        Part 4: Supporting Routines

    Return Value                     Meaning

    TRUE                             if physical presence is signaled

    FALSE                            if physical presence is not signaled

16  LIB_EXPORT    BOOL

17  _plat__PhysicalPresenceAsserted(void);

    C.8.3.2.  _plat__Signal_PhysicalPresenceOn

    Signal physical presence on This signal is simulate by a RPC call

18  LIB_EXPORT    void

19  _plat__Signal_PhysicalPresenceOn(void);

    C.8.3.3.  _plat__Signal_PhysicalPresenceOff()

    Signal physical presence off This signal is simulate by a RPC call

20  LIB_EXPORT    void

21  _plat__Signal_PhysicalPresenceOff(void);

    C.8.4.    Command Canceling Functions

    C.8.4.1.  _plat__IsCanceled()

    Check if the cancel flag is set

    Return Value                     Meaning

    TRUE                             if cancel flag  is  set

    FALSE                            if cancel flag  is  not  set

22  LIB_EXPORT    BOOL

23  _plat__IsCanceled(void);

    C.8.4.2.  _plat__SetCancel()

    Set cancel flag.

24  LIB_EXPORT    void

25  _plat__SetCancel(void);

    C.8.4.3.  _plat__ClearCancel()

    Clear cancel flag

26  LIB_EXPORT    void

27  _plat__ClearCancel(  void);

    Page 532                                         TCG Published         Family "2.0"

    October 30, 2014                 Copyright © TCG 2006-2014             Level 00 Revision 01.16
    Part 4: Supporting Routines                                                       Trusted Platform Module Library

    C.8.5.    NV memory functions

    C.8.5.1.  _plat__NvErrors()

    This function is used by the simulator  to  set  the  error  flags  in  the   NV  subsystem  to  simulate  an  error  in  the

    NV loading process

28  LIB_EXPORT    void

29  _plat__NvErrors(

30      BOOL            recoverable,

31      BOOL            unrecoverable

32      );

    C.8.5.2.  _plat__NVEnable()

    Enable platform NV memory NV memory is automatically enabled at power on                         event.  This  function   is

    mostly for TPM_Manufacture() to access NV memory without a power on event

    Return Value                  Meaning

    0                             if success

    non-0                         if fail

33  LIB_EXPORT    int

34  _plat__NVEnable(

35      void      *platParameter                          //     IN:  platform        specific   parameters

36  );

    C.8.5.3.  _plat__NVDisable()

    Disable platform NV memory NV memory is automatically disabled at power off                      event.  This function is

    mostly for TPM_Manufacture() to disable NV memory without a power off event

37  LIB_EXPORT    void

38  _plat__NVDisable(void);

    C.8.5.4.  _plat__IsNvAvailable()

    Check if NV is available

    Return Value                  Meaning

    0                             NV is available

    1                             NV is not available     due    to   write failure

    2                             NV is not available     due    to   rate limit

39  LIB_EXPORT    int

40  _plat__IsNvAvailable(void);

    C.8.5.5.  _plat__NvCommit()

    Update NV chip

    Family "2.0"                                     TCG Published                                                 Page 533

    Level 00 Revision 01.16                 Copyright © TCG 2006-2014                                October 30, 2014
    Trusted Platform Module Library                                                         Part 4: Supporting Routines

    Return Value                     Meaning

    0                                NV write success

    non-0                            NV write fail

41  LIB_EXPORT    int

42  _plat__NvCommit(void);

    C.8.5.6.  _plat__NvMemoryRead()

    Read a chunk of NV memory

43  LIB_EXPORT    void

44  _plat__NvMemoryRead(

45      unsigned  int           startOffset,           //  IN:       read  start

46      unsigned  int           size,                  //  IN:       size  of           bytes   to  read

47      void                    *data                  //  OUT:      data           buffer

48  );

    C.8.5.7.  _plat__NvIsDifferent()

    This function checks to see if the NV is different from the test value. This is so that NV will not be    written    if

    it has not changed.

    Return Value                     Meaning

    TRUE                             the NV location is different from the test value

    FALSE                            the NV location is the same as the test value

49  LIB_EXPORT    BOOL

50  _plat__NvIsDifferent(

51      unsigned  int           startOffset,           //  IN:       read           start

52      unsigned  int           size,                  //  IN:       size           of  bytes   to  compare

53      void                    *data                  //  IN:       data           buffer

54      );

    C.8.5.8.  _plat__NvMemoryWrite()

    Write a chunk of NV memory

55  LIB_EXPORT    void

56  _plat__NvMemoryWrite(

57      unsigned  int           startOffset,           //  IN:       read  start

58      unsigned  int           size,                  //  IN:       size  of           bytes   to  read

59      void                    *data                  //  OUT:      data           buffer

60  );

    C.8.5.9.  _plat__NvMemoryMove()

    Move a chunk of NV memory from source to destination This function should ensure that if there overlap,

    the original data is copied before it is written

61  LIB_EXPORT    void

62  _plat__NvMemoryMove(

63      unsigned  int           sourceOffset,          //  IN:       source             offset

64      unsigned  int           destOffset,            //  IN:       destination               offset

65      unsigned  int           size                   //  IN:       size           of  data    being  moved

    Page 534                                          TCG Published                                         Family "2.0"

    October 30, 2014                   Copyright © TCG 2006-2014                               Level 00 Revision 01.16
    Part 4: Supporting Routines                                             Trusted Platform Module Library

66  );

    C.8.5.10.  _plat__SetNvAvail()

    Set the current NV state to available.    This function is for testing purposes only.  It is not part of the

    platform NV logic

67  LIB_EXPORT    void

68  _plat__SetNvAvail(void);

    C.8.5.11.  _plat__ClearNvAvail()

    Set the current NV state to unavailable.  This function is for testing purposes only.  It is not part of the

    platform NV logic

69  LIB_EXPORT    void

70  _plat__ClearNvAvail(void);

    C.8.6.    Locality Functions

    C.8.6.1.   _plat__LocalityGet()

    Get the most recent command locality in locality value form

71  LIB_EXPORT    unsigned   char

72  _plat__LocalityGet(void);

    C.8.6.2.   _plat__LocalitySet()

    Set the most recent command locality in locality value form

73  LIB_EXPORT    void

74  _plat__LocalitySet(

75      unsigned  char      locality

76  );

    C.8.6.3.   _plat__IsRsaKeyCacheEnabled()

    This function is used to check if the RSA key cache is enabled or not.

77  LIB_EXPORT    int

78  _plat__IsRsaKeyCacheEnabled(

79      void

80      );

    C.8.7.    Clock Constants and Functions

    Assume that the nominal divisor is 30000

81  #define       CLOCK_NOMINAL               30000

    A 1% change in rate is 300 counts

82  #define       CLOCK_ADJUST_COARSE         300

    Family "2.0"                              TCG Published                                Page 535

    Level 00 Revision 01.16            Copyright © TCG 2006-2014                           October 30, 2014
    Trusted Platform Module Library                                                         Part 4: Supporting Routines

    A .1 change in rate is 30 counts

83  #define           CLOCK_ADJUST_MEDIUM        30

    A minimum change in rate is 1 count

84  #define           CLOCK_ADJUST_FINE          1

    The clock tolerance is +/-15% (4500 counts) Allow some guard band (16.7%)

85  #define           CLOCK_ADJUST_LIMIT         5000

    C.8.7.1.   _plat__ClockReset()

    This function sets the current clock time as initial time.  This function is called at a power on event to reset

    the clock

86  LIB_EXPORT        void

87  _plat__ClockReset(void);

    C.8.7.2.   _plat__ClockTimeFromStart()

    Function   returns      the     compensated     time        from      the  start    of  the    command  when

    _plat__ClockTimeFromStart() was called.

88  LIB_EXPORT        unsigned   long  long

89  _plat__ClockTimeFromStart(

90  void

91  );

    C.8.7.3.   _plat__ClockTimeElapsed()

    Get the time elapsed from current to the last time the _plat__ClockTimeElapsed() is called.        For the first

    _plat__ClockTimeElapsed() call after a power on event, this call report the elapsed time from power on to

    the current call

92  LIB_EXPORT        unsigned   long  long

93  _plat__ClockTimeElapsed(void);

    C.8.7.4.   _plat__ClockAdjustRate()

    Adjust the clock rate

94  LIB_EXPORT        void

95  _plat__ClockAdjustRate(

96  int                     adjust               //  IN:        the  adjust    number.  It  could  be

97                                               //  positive         or  negative

98  );

    Page 536                                     TCG Published                                         Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

     C.8.8.    Single Function Files

     C.8.8.1.  _plat__GetEntropy()

     This function is used to get available hardware entropy. In a hardware implementation of this function,

     there would be no call to the system to get entropy. If the caller does not ask for any entropy, then this is

     a startup indication and firstValue should be reset.

     Return Value                     Meaning

     <0                               hardware failure of the entropy generator, this is sticky

     >= 0                             the returned amount of entropy (bytes)

99   LIB_EXPORT    int32_t

100  _plat__GetEntropy(

101        unsigned  char         *entropy,                //  output         buffer

102        uint32_t               amount                   //  amount         requested

103  );

104  #endif

     Family "2.0"                              TCG Published                                     Page 537

     Level 00 Revision 01.16          Copyright © TCG 2006-2014                                  October 30, 2014
    Trusted Platform Module Library                                                          Part 4: Supporting Routines

    C.9   PlatformData.h

    This file contains the instance data for  the  Platform  module.  It  is  collected  in  this  file  so  that  the  state  of

    the module is easier to manage.

1   #ifndef   _PLATFORM_DATA_H_

2   #define   _PLATFORM_DATA_H_

3   #include        "TpmBuildSwitches.h"

4   #include        "Implementation.h"

5   #include        "bool.h"

    From Cancel.c Cancel flag.    It is initialized as FALSE, which indicate the command is not being canceled

6   extern   BOOL      s_isCanceled;

    From Clock.c This variable records the time when _plat__ClockReset() is called.                This mechanism allow

    us to subtract the time when TPM is power off from the total time reported by clock() function

7   extern   unsigned  long     long  s_initClock;

8   extern   unsigned  int            s_adjustRate;

    From LocalityPlat.c Locality of current command

9   extern   unsigned  char     s_locality;

    From NVMem.c Choose if the NV memory should be backed by RAM or by file. If this macro is defined,

    then a file is used as NV.  If it is not defined, then RAM is used to back NV memory. Comment out to use

    RAM.

10  #define   FILE_BACKED_NV

11  #if  defined    FILE_BACKED_NV

12  #include     <stdio.h>

    A file to emulate NV storage

13  extern   FILE*                    s_NVFile;

14  #endif

15  extern   unsigned  char           s_NV[NV_MEMORY_SIZE];

16  extern   BOOL                     s_NvIsAvailable;

17  extern   BOOL                     s_NV_unrecoverable;

18  extern   BOOL                     s_NV_recoverable;

    From PPPlat.c Physical presence.  It is initialized to FALSE

19  extern   BOOL      s_physicalPresence;

    From Power

20  extern   BOOL           s_powerLost;

    From Entropy.c

21  extern   uint32_t             lastEntropy;

22  extern   int                  firstValue;

23  #endif   //   _PLATFORM_DATA_H_

    Page 538                                       TCG Published                                             Family "2.0"

    October 30, 2014                          Copyright © TCG 2006-2014                      Level 00 Revision 01.16
    Part 4: Supporting Routines                                                   Trusted Platform Module Library

    C.10  PlatformData.c

    C.10.1.  Description

    This file will instance the TPM variables that are not stack allocated. The descriptions for these variables

    is in Global.h for this project.

    C.10.2.  Includes

    This include is required to set the NV memory size consistently  across  all  parts  of  the  implementation.

1   #include          "Implementation.h"

2   #include          "Platform.h"

3   #include          "PlatformData.h"

    From Cancel.c

4   BOOL                     s_isCanceled;

    From Clock.c

5   unsigned     long  long  s_initClock;

6   unsigned     int         s_adjustRate;

    From LocalityPlat.c

7   unsigned     char        s_locality;

    From Power.c

8   BOOL                     s_powerLost;

    From Entropy.c

9   uint32_t                 lastEntropy;

10  int                      firstValue;

    From NVMem.c

11  #ifdef    VTPM

12  #     undef  FILE_BACKED_NV

13  #endif

14  #ifdef   FILE_BACKED_NV

15  FILE                     *s_NVFile    =  NULL;

16  #endif

17  unsigned     char        s_NV[NV_MEMORY_SIZE];

18  BOOL                     s_NvIsAvailable;

19  BOOL                     s_NV_unrecoverable;

20  BOOL                     s_NV_recoverable;

    From PPPlat.c

21  BOOL    s_physicalPresence;

    Family "2.0"                               TCG Published                                      Page 539

    Level 00 Revision 01.16               Copyright © TCG 2006-2014                               October 30, 2014
    Trusted Platform Module Library                                                    Part 4: Supporting Routines

    C.11     PPPlat.c

    C.11.1.   Description

    This module simulates the physical present interface pins on the TPM.

    C.11.2.   Includes

1   #include      "PlatformData.h"

    C.11.3.   Functions

    C.11.3.1.     _plat__PhysicalPresenceAsserted()

    Check if physical presence is signaled

    Return Value                      Meaning

    TRUE                              if physical presence is signaled

    FALSE                             if physical presence is not signaled

2   LIB_EXPORT     BOOL

3   _plat__PhysicalPresenceAsserted(

4         void

5         )

6   {

7         //  Do  not  know  how  to  check   physical  presence        without  real  hardware.

8         //  so  always  return     TRUE;

9         return   s_physicalPresence;

10  }

    C.11.3.2.     _plat__Signal_PhysicalPresenceOn()

    Signal physical presence on

11  LIB_EXPORT     void

12  _plat__Signal_PhysicalPresenceOn(

13        void

14        )

15  {

16        s_physicalPresence      =   TRUE;

17        return;

18  }

    C.11.3.3.     _plat__Signal_PhysicalPresenceOff()

    Signal physical presence off

19  LIB_EXPORT     void

20  _plat__Signal_PhysicalPresenceOff(

21        void

22        )

23  {

24        s_physicalPresence      =   FALSE;

25        return;

26  }

    Page 540                                   TCG Published                                      Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                 Level 00   Revision 01.16
    Part 4: Supporting Routines                                                                       Trusted Platform Module Library

    C.12     Unique.c

    C.12.1.      Introduction

    In some implementations of the TPM, the hardware can provide a secret value to the TPM. This secret

    value    is  statistically  unique        to  the     instance     of     the  TPM.     Typical  uses  of  this  value  are   to   provide

    personalization to the random number generation and as a shared secret between the TPM and the

    manufacturer.

    C.12.2.      Includes

1   #include        "stdint.h"

2   #include        "TpmBuildSwitches.h"

3   const    char      notReallyUnique[]               =

4                "This    is    not    really     a       unique       value.      A  real  unique    value    should"

5                "  be  generated          by     the     platform.";

    C.12.3.      _plat__GetUnique()

    This function is used to access the platform-specific unique value. This function places the unique value

    in the provided buffer (b) and returns the number of bytes transferred. The function will not copy more

    data than bSize.

    NOTE:               If a platform unique value has unequal distribution of uniqueness and bSize is smaller              than  the  size  of  the

                        unique value, the bSize portion with the most uniqueness should be returned.

6   LIB_EXPORT         uint32_t

7   _plat__GetUnique(

8         uint32_t                             which,                     //   authorities       (0)  or   details

9         uint32_t                             bSize,                     //   size    of   the  buffer

10        unsigned      char                  *b                          //   output       buffer

11  )

12  {

13        const     char                      *from       =  notReallyUnique;

14        uint32_t                             retVal        =     0;

15

16        if(which      ==    0)   //     the     authorities          value

17        {

18               for(retVal        =   0;

19                      *from      !=  0   &&     retVal           <   bSize;

20                      retVal++)

21               {

22                      *b++    =  *from++;

23               }

24        }

25        else

26        {

27  #define      uSize      sizeof(notReallyUnique)

28               b  =   &b[((bSize         <   uSize)        ?     bSize  :    uSize)  -    1];

29               for(retVal        =   0;

30                      *from      !=  0   &&     retVal        <     bSize;

31                      retVal++)

32               {

33                      *b--    =  *from++;

34               }

35        }

36        return       retVal;

37  }

    Family "2.0"                                                       TCG Published                                              Page 541

    Level 00 Revision 01.16                               Copyright © TCG 2006-2014                                     October 30, 2014
Trusted Platform Module Library                                                     Part 4: Supporting Routines

                                               Annex D

                                               (informative)

                                 Remote Procedure Interface

D.1   Introduction

These files provide an RPC interface for a TPM simulation.

The simulation uses two ports: a command port and a hardware simulation port. Only TPM commands

defined in TPM 2.0 Part 3 are sent to the TPM on the command port. The hardware simulation port is

used  to  simulate  hardware     events  such  as  power    on/off  and  locality;  and  indications  such  as

_TPM_HashStart.

Page 542                                       TCG Published                             Family "2.0"

October 30, 2014                         Copyright © TCG 2006-2014                  Level 00 Revision 01.16
    Part 4: Supporting Routines                                                    Trusted Platform Module Library

    D.2     TpmTcpProtocol.h

    D.2.1.    Introduction

    TPM    commands      are  communicated       as  BYTE  streams  on   a  TCP  connection.  The  TPM   command

    protocol is enveloped with the interface protocol described in this file. The command is indicated by a

    UINT32 with one of the values below.           Most commands take no parameters return no TPM errors.    In

    these cases the TPM interface protocol acknowledges that command processing is complete by returning

    a   UINT32=0.  The    command          TPM_SIGNAL_HASH_DATA     takes    a   UINT32-prepended  variable  length

    BYTE array and the interface protocol acknowledges command completion with a UINT32=0. Most TPM

    commands are enveloped using the TPM_SEND_COMMAND interface command. The parameters are

    as indicated below.    The interface layer also appends a UIN32=0 to the TPM response for regularity.

    D.2.2.    Typedefs and Defines

1   #ifndef        TCP_TPM_PROTOCOL_H

2   #define        TCP_TPM_PROTOCOL_H

    TPM Commands. All commands acknowledge processing by returning a UINT32 == 0 except where

    noted

3   #define   TPM_SIGNAL_POWER_ON                    1

4   #define   TPM_SIGNAL_POWER_OFF                   2

5   #define   TPM_SIGNAL_PHYS_PRES_ON                3

6   #define   TPM_SIGNAL_PHYS_PRES_OFF               4

7   #define   TPM_SIGNAL_HASH_START                  5

8   #define   TPM_SIGNAL_HASH_DATA                   6

9             //   {UINT32       BufferSize,     BYTE[BufferSize]   Buffer}

10  #define   TPM_SIGNAL_HASH_END                    7

11  #define   TPM_SEND_COMMAND                       8

12            //   {BYTE     Locality,     UINT32    InBufferSize,  BYTE[InBufferSize]        InBuffer}  ->

13            //         {UINT32     OutBufferSize,      BYTE[OutBufferSize]     OutBuffer}

14  #define   TPM_SIGNAL_CANCEL_ON                   9

15  #define   TPM_SIGNAL_CANCEL_OFF                  10

16  #define   TPM_SIGNAL_NV_ON                       11

17  #define   TPM_SIGNAL_NV_OFF                      12

18  #define   TPM_SIGNAL_KEY_CACHE_ON                13

19  #define   TPM_SIGNAL_KEY_CACHE_OFF               14

20  #define   TPM_REMOTE_HANDSHAKE                   15

21  #define   TPM_SET_ALTERNATIVE_RESULT             16

22  #define   TPM_SIGNAL_RESET                       17

23  #define   TPM_SESSION_END                        20

24  #define   TPM_STOP                               21

25  #define   TPM_GET_COMMAND_RESPONSE_SIZES               25

26  #define   TPM_TEST_FAILURE_MODE                  30

27  enum    TpmEndPointInfo

28  {

29        tpmPlatformAvailable             =  0x01,

30        tpmUsesTbs      =   0x02,

31        tpmInRawMode        =     0x04,

32        tpmSupportsPP          =  0x08

33  };

34

35  //   Existing  RPC    interface        type  definitions   retained  so  that  the  implementation

36  //   can  be  re-used

37  typedef   struct

38  {

39        unsigned   long        BufferSize;

40        unsigned   char        *Buffer;

41  }   _IN_BUFFER;

    Family "2.0"                                     TCG Published                                       Page 543

    Level 00 Revision 01.16                      Copyright © TCG 2006-2014                    October 30, 2014
    Trusted Platform Module Library                                                    Part 4: Supporting Routines

42

43  typedef    unsigned   char   *_OUTPUT_BUFFER;

44

45  typedef    struct

46  {

47        uint32_t               BufferSize;

48        _OUTPUT_BUFFER         Buffer;

49  }   _OUT_BUFFER;

50

51  //**  TPM    Command  Function   Prototypes

52  void  _rpc__Signal_PowerOn(BOOL       isReset);

53  void  _rpc__Signal_PowerOff();

54  void  _rpc__ForceFailureMode();

55  void  _rpc__Signal_PhysicalPresenceOn();

56  void  _rpc__Signal_PhysicalPresenceOff();

57  void  _rpc__Signal_Hash_Start();

58  void  _rpc__Signal_Hash_Data(

59        _IN_BUFFER    input

60  );

61  void  _rpc__Signal_HashEnd();

62  void  _rpc__Send_Command(

63        unsigned  char       locality,

64        _IN_BUFFER           request,

65        _OUT_BUFFER          *response

66  );

67  void  _rpc__Signal_CancelOn();

68  void  _rpc__Signal_CancelOff();

69  void  _rpc__Signal_NvOn();

70  void  _rpc__Signal_NvOff();

71  BOOL  _rpc__InjectEPS(

72        const  char*    seed,

73        int  seedSize

74  );

    start the TPM server on the indicated socket. The TPM is single-threaded and       will  accept  connections

    first-come-first-served. Once a connection is dropped another client can connect.

75  BOOL  TpmServer(SOCKET       ServerSocket);

76  #endif

    Page 544                                     TCG Published                                       Family "2.0"

    October 30, 2014                      Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part 4: Supporting Routines                                                               Trusted Platform Module Library

    D.3      TcpServer.c

    D.3.1.     Description

    This file contains the socket interface to a TPM simulator.

    D.3.2.     Includes, Locals, Defines and Function Prototypes

1   #include         <stdio.h>

2   #include         <windows.h>

3   #include         <winsock.h>

4   #include         "string.h"

5   #include         <stdlib.h>

6   #include         <stdint.h>

7   #include         "TpmTcpProtocol.h"

8   BOOL     ReadBytes(SOCKET       s,     char*     buffer,      int  NumBytes);

9   BOOL     ReadVarBytes(SOCKET           s,     char*    buffer,     UINT32*  BytesReceived,     int  MaxLen);

10  BOOL     WriteVarBytes(SOCKET             s,     char  *buffer,    int    BytesToSend);

11  BOOL     WriteBytes(SOCKET         s,     char*      buffer,  int  NumBytes);

12  BOOL     WriteUINT32(SOCKET           s,   UINT32      val);

13  #ifndef       __IGNORE_STATE__

14  static     UINT32       ServerVersion         =  1;

15  #define       MAX_BUFFER        1048576

16  char     InputBuffer[MAX_BUFFER];                      //The       input   data   buffer  for  the  simulator.

17  char     OutputBuffer[MAX_BUFFER];                     //The       output   data  buffer  for  the  simulator.

18  struct     {

19        UINT32            largestCommandSize;

20        UINT32            largestCommand;

21        UINT32            largestResponseSize;

22        UINT32            largestResponse;

23  }  CommandResponseSizes            =   {0};

24  #endif     //    __IGNORE_STATE___

    D.3.3.     Functions

    D.3.3.1.         CreateSocket()

    This function creates a socket listening on PortNumber.

25  static     int

26  CreateSocket(

27        int                              PortNumber,

28        SOCKET                          *listenSocket

29        )

30  {

31        WSADATA                          wsaData;

32        struct                           sockaddr_in     MyAddress;

33

34        int     res;

35

36        //   Initialize        Winsock

37        res     =  WSAStartup(MAKEWORD(2,2),             &wsaData);

38        if   (res     !=  0)

39        {

40                printf("WSAStartup           failed      with   error:    %d\n",    res);

41                return    -1;

42        }

43

44        //   create       listening     socket

45        *listenSocket          =  socket(PF_INET,        SOCK_STREAM,         0);

    Family "2.0"                                           TCG Published                                            Page 545

    Level 00 Revision 01.16                          Copyright © TCG 2006-2014                          October 30, 2014
     Trusted Platform Module Library                                                            Part 4: Supporting  Routines

46         if(INVALID_SOCKET            ==  *listenSocket)

47         {

48               printf("Cannot         create      server      listen   socket.    Error   is  0x%x\n",

49                            WSAGetLastError());

50               return      -1;

51         }

52

53         //  bind     the   listening     socket     to      the  specified  port

54         ZeroMemory(&MyAddress,               sizeof(MyAddress));

55         MyAddress.sin_port=htons((short)                     PortNumber);

56         MyAddress.sin_family=AF_INET;

57

58         res=     bind(*listenSocket,(struct                 sockaddr*)     &MyAddress,sizeof(MyAddress));

59         if(res==SOCKET_ERROR)

60         {

61               printf("Bind        error.         Error   is  0x%x\n",      WSAGetLastError());

62               return      -1;

63         };

64

65         //  listen/wait        for   server      connections

66         res=     listen(*listenSocket,3);

67         if(res==SOCKET_ERROR)

68         {

69               printf("Listen         error.      Error       is  0x%x\n",   WSAGetLastError());

70               return      -1;

71         };

72

73         return    0;

74   }

     D.3.3.2.       PlatformServer()

     This function processes incoming platform requests.

75   BOOL

76   PlatformServer(

77         SOCKET                    s

78         )

79   {

80         BOOL                             ok   =  TRUE;

81         UINT32                           length  =      0;

82         UINT32                           Command;

83

84         for(;;)

85         {

86               ok  =   ReadBytes(s,       (char*)        &Command,     4);

87               //  client       disconnected      (or     other   error).    We   stop   processing   this   client

88               //  and     return     to  our     caller     who  can  stop  the  server  or  listen    for  another

89               //  connection.

90               if(!ok)      return    TRUE;

91               Command      =   ntohl(Command);

92               switch(Command)

93               {

94                      case     TPM_SIGNAL_POWER_ON:

95                            _rpc__Signal_PowerOn(FALSE);

96                            break;

97

98                      case     TPM_SIGNAL_POWER_OFF:

99                            _rpc__Signal_PowerOff();

100                           break;

101

102                     case     TPM_SIGNAL_RESET:

103                           _rpc__Signal_PowerOn(TRUE);

104                           break;

     Page 546                                                  TCG Published                                   Family "2.0"

     October 30, 2014                               Copyright © TCG 2006-2014                      Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

105

106                case    TPM_SIGNAL_PHYS_PRES_ON:

107                      _rpc__Signal_PhysicalPresenceOn();

108                      break;

109

110                case    TPM_SIGNAL_PHYS_PRES_OFF:

111                      _rpc__Signal_PhysicalPresenceOff();

112                      break;

113

114                case    TPM_SIGNAL_CANCEL_ON:

115                      _rpc__Signal_CancelOn();

116                      break;

117

118                case    TPM_SIGNAL_CANCEL_OFF:

119                      _rpc__Signal_CancelOff();

120                      break;

121

122                case    TPM_SIGNAL_NV_ON:

123                      _rpc__Signal_NvOn();

124                      break;

125

126                case    TPM_SIGNAL_NV_OFF:

127                      _rpc__Signal_NvOff();

128                      break;

129

130                case    TPM_SESSION_END:

131                      //  Client     signaled   end-of-session

132                      return   TRUE;

133

134                case    TPM_STOP:

135                      //  Client     requested  the  simulator  to  exit

136                      return   FALSE;

137

138                case    TPM_TEST_FAILURE_MODE:

139                      _rpc__ForceFailureMode();

140                      break;

141

142                case    TPM_GET_COMMAND_RESPONSE_SIZES:

143                      ok  =  WriteVarBytes(s,   (char  *)&CommandResponseSizes,

144                                                sizeof(CommandResponseSizes));

145                      memset(&CommandResponseSizes,       0,    sizeof(CommandResponseSizes));

146                      if(!ok)

147                             return  TRUE;

148                      break;

149

150                default:

151                      printf("Unrecognized      platform  interface  command       %d\n",  Command);

152                      WriteUINT32(s,   1);

153                      return   TRUE;

154            }

155            WriteUINT32(s,0);

156     }

157     return     FALSE;

158  }

     D.3.3.3.     PlatformSvcRoutine()

     This function is called to set up the socket interfaces to listen for commands.

159  DWORD  WINAPI

160  PlatformSvcRoutine(

161     LPVOID                  port

162     )

163  {

     Family "2.0"                                  TCG Published                                   Page 547

     Level 00 Revision 01.16              Copyright © TCG 2006-2014                           October 30, 2014
     Trusted Platform Module Library                                                           Part 4: Supporting Routines

164       int                             PortNumber     =  (int)(INT_PTR)      port;

165       SOCKET                          listenSocket,       serverSocket;

166       struct                          sockaddr_in       HerAddress;

167       int                             res;

168       int                             length;

169       BOOL                            continueServing;

170

171       res   =   CreateSocket(PortNumber,             &listenSocket);

172       if(res     !=  0)

173       {

174             printf("Create         platform      service    socket  fail\n");

175             return    res;

176       }

177

178       //   Loop  accepting       connections     one-by-one     until   we    are  killed     or  asked     to  stop

179       //   Note  the     platform     service    is  single-threaded      so  we   don't   listen      for  a   new

180       //   connection       until  the    prior  connection     drops.

181       do

182       {

183             printf("Platform          server     listening  on  port   %d\n",      PortNumber);

184

185             //   blocking   accept

186             length    =  sizeof(HerAddress);

187             serverSocket      =    accept(listenSocket,

188                                             (struct     sockaddr*)    &HerAddress,

189                                             &length);

190             if(serverSocket        ==   SOCKET_ERROR)

191             {

192                  printf("Accept         error.       Error  is  0x%x\n",    WSAGetLastError());

193                  return     -1;

194             };

195             printf("Client         accepted\n");

196

197             //   normal     behavior    on  client      disconnection   is    to   wait  for  a   new  client

198             //   to  connect

199             continueServing        =   PlatformServer(serverSocket);

200             closesocket(serverSocket);

201       }

202       while(continueServing);

203

204       return     0;

205  }

     D.3.3.4.      PlatformSignalService()

     This function starts a new thread waiting for platform signals. Platform signals are processed one                   at  a

     time in the order in which they are received.

206  int

207  PlatformSignalService(

208       int                     PortNumber

209       )

210  {

211       HANDLE                          hPlatformSvc;

212       int                             ThreadId;

213       int                             port  =    PortNumber;

214

215       //   Create    service     thread     for  platform   signals

216       hPlatformSvc       =  CreateThread(NULL,          0,

217                                                  (LPTHREAD_START_ROUTINE)PlatformSvcRoutine,

218                                                  (LPVOID)   (INT_PTR)   port,      0,  (LPDWORD)&ThreadId);

219       if(hPlatformSvc       ==     NULL)

220       {

221             printf("Thread         Creation      failed\n");

     Page 548                                            TCG Published                                              Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                           Trusted Platform Module Library

222               return       -1;

223       }

224

225       return      0;

226  }

     D.3.3.5.        RegularCommandService()

     This funciton services regular commands.

227  int

228  RegularCommandService(

229       int                          PortNumber

230       )

231  {

232       SOCKET                               listenSocket;

233       SOCKET                               serverSocket;

234       struct                               sockaddr_in   HerAddress;

235

236       int     res,    length;

237       BOOL       continueServing;

238

239       res     =   CreateSocket(PortNumber,           &listenSocket);

240       if(res      !=  0)

241       {

242               printf("Create            platform  service   socket   fail\n");

243               return       res;

244       }

245

246       //   Loop       accepting         connections  one-by-one  until  we    are  killed     or   asked   to   stop

247       //   Note       the     TPM  command  service     is  single-threaded   so   we    don't     listen  for

248       //   a     new  connection        until   the  prior  connection  drops.

249       do

250       {

251               printf("TPM          command  server   listening   on     port  %d\n",   PortNumber);

252

253               //  blocking         accept

254               length       =  sizeof(HerAddress);

255               serverSocket         =    accept(listenSocket,

256                                                 (struct     sockaddr*)  &HerAddress,

257                                                 &length);

258               if(serverSocket           ==SOCKET_ERROR)

259               {

260                       printf("Accept        error.   Error  is   0x%x\n",     WSAGetLastError());

261                       return       -1;

262               };

263               printf("Client            accepted\n");

264

265               //  normal        behavior    on  client   disconnection  is    to   wait  for    a  new  client

266               //  to  connect

267               continueServing           =  TpmServer(serverSocket);

268               closesocket(serverSocket);

269       }

270       while(continueServing);

271

272       return      0;

273  }

     D.3.3.6.        StartTcpServer()

     Main entry-point to the TCP server.              The server listens on port specified. Note that there is no way to

     specify the network interface in this implementation.

     Family "2.0"                                           TCG Published                                           Page 549

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                               October 30, 2014
     Trusted Platform Module Library                                              Part 4: Supporting Routines

274  int

275  StartTcpServer(

276        int                      PortNumber

277        )

278  {

279        int                           res;

280

281        //   Start     Platform  Signal     Processing  Service

282        res   =  PlatformSignalService(PortNumber+1);

283        if   (res   !=  0)

284        {

285              printf("PlatformSignalService          failed\n");

286              return    res;

287        }

288

289        //   Start     Regular/DRTM   TPM   command  service

290        res   =  RegularCommandService(PortNumber);

291        if   (res   !=  0)

292        {

293              printf("RegularCommandService          failed\n");

294              return    res;

295        }

296

297        return     0;

298  }

     D.3.3.7.       ReadBytes()

     This function reads the indicated number of bytes (NumBytes) into buffer from the indicated    socket.

299  BOOL

300  ReadBytes(

301        SOCKET                   s,

302        char                  *buffer,

303        int                      NumBytes

304        )

305  {

306        int                           res;

307        int                           numGot  =  0;

308

309        while(numGot<NumBytes)

310        {

311              res   =   recv(s,  buffer+numGot,      NumBytes-numGot,     0);

312              if(res    ==  -1)

313              {

314                    printf("Receive      error.      Error  is  0x%x\n",  WSAGetLastError());

315                    return    FALSE;

316              }

317              if(res==0)

318              {

319                    return    FALSE;

320              }

321              numGot+=res;

322        }

323        return     TRUE;

324  }

     D.3.3.8.       WriteBytes()

     This function will send the    indicated  number of bytes (NumBytes) to the  indicated socket

325  BOOL

326  WriteBytes(

     Page 550                                           TCG Published                               Family "2.0"

     October 30, 2014                           Copyright © TCG 2006-2014         Level 00          Revision 01.16
     Part  4: Supporting Routines                                                         Trusted Platform  Module  Library

327        SOCKET                      s,

328        char                        *buffer,

329        int                         NumBytes

330        )

331  {

332        int                               res;

333        int                               numSent  =    0;

334        while(numSent<NumBytes)

335        {

336              res     =  send(s,    buffer+numSent,         NumBytes-numSent,     0);

337              if(res     ==   -1)

338              {

339                      if(WSAGetLastError()         ==   0x2745)

340                      {

341                            printf("Client       disconnected\n");

342                      }

343                      else

344                      {

345                            printf("Send        error.      Error  is   0x%x\n",  WSAGetLastError());

346                      }

347                      return     FALSE;

348              }

349              numSent+=res;

350        }

351        return     TRUE;

352  }

     D.3.3.9.       WriteUINT32()

     Send 4 bytes containing hton(1)

353  BOOL

354  WriteUINT32(

355        SOCKET                      s,

356        UINT32                      val

357        )

358  {

359        UINT32     netVal     =     htonl(val);

360        return     WriteBytes(s,          (char*)  &netVal,        4);

361  }

     D.3.3.10.      ReadVarBytes()

     Get a UINT32-length-prepended binary array.               Note that the 4-byte  length  is  in  network byte order (big-

     endian).

362  BOOL

363  ReadVarBytes(

364        SOCKET                      s,

365        char                        *buffer,

366        UINT32                      *BytesReceived,

367        int                         MaxLen

368        )

369  {

370        int                               length;

371        BOOL                              res;

372

373        res   =  ReadBytes(s,           (char*)  &length,   4);

374        if(!res)         return     res;

375        length     =     ntohl(length);

376        *BytesReceived           =  length;

377        if(length>MaxLen)

378        {

     Family "2.0"                                          TCG Published                                    Page 551

     Level 00 Revision 01.16                        Copyright © TCG 2006-2014                        October 30, 2014
     Trusted Platform Module Library                                                           Part 4: Supporting Routines

379              printf("Buffer       too  big.     Client      says  %d\n",     length);

380              return   FALSE;

381        }

382        if(length==0)         return   TRUE;

383        res   =   ReadBytes(s,     buffer,      length);

384        if(!res)       return  res;

385        return    TRUE;

386  }

     D.3.3.11.      WriteVarBytes()

     Send a UINT32-length-prepended binary array.               Note that the 4-byte   length  is  in  network  byte  order  (big-

     endian).

387  BOOL

388  WriteVarBytes(

389        SOCKET                 s,

390        char                   *buffer,

391        int                    BytesToSend

392        )

393  {

394        UINT32                         netLength     =  htonl(BytesToSend);

395        BOOL     res;

396

397        res   =   WriteBytes(s,        (char*)  &netLength,        4);

398        if(!res)       return  res;

399        res   =   WriteBytes(s,        buffer,  BytesToSend);

400        if(!res)       return  res;

401        return    TRUE;

402  }

     D.3.3.12.      TpmServer()

     Processing incoming TPM command requests using the protocol / interface defined above.

403  BOOL

404  TpmServer(

405        SOCKET                 s

406        )

407  {

408        UINT32                         length;

409        UINT32                         Command;

410        BYTE                           locality;

411        BOOL                           ok;

412        int                            result;

413        int                            clientVersion;

414        _IN_BUFFER                     InBuffer;

415        _OUT_BUFFER                    OutBuffer;

416

417        for(;;)

418        {

419              ok  =    ReadBytes(s,     (char*)      &Command,     4);

420              //  client      disconnected      (or  other   error).     We   stop  processing      this     client

421              //  and  return      to  our  caller      who  can   stop  the  server    or  listen  for      another

422              //  connection.

423              if(!ok)

424                     return    TRUE;

425              Command      =  ntohl(Command);

426              switch(Command)

427              {

428                     case     TPM_SIGNAL_HASH_START:

429                           _rpc__Signal_Hash_Start();

430                           break;

     Page 552                                              TCG Published                                        Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                               Trusted Platform Module Library

431

432                case     TPM_SIGNAL_HASH_END:

433                      _rpc__Signal_HashEnd();

434                      break;

435

436                case     TPM_SIGNAL_HASH_DATA:

437                      ok   =   ReadVarBytes(s,            InputBuffer,       &length,  MAX_BUFFER);

438                      if(!ok)  return       TRUE;

439                      InBuffer.Buffer        =     (BYTE*)          InputBuffer;

440                      InBuffer.BufferSize              =     length;

441                      _rpc__Signal_Hash_Data(InBuffer);

442                      break;

443

444                case     TPM_SEND_COMMAND:

445                      ok   =   ReadBytes(s,        (char*)          &locality,    1);

446                      if(!ok)

447                              return  TRUE;

448

449                      ok   =   ReadVarBytes(s,            InputBuffer,       &length,  MAX_BUFFER);

450                      if(!ok)

451                              return  TRUE;

452                      InBuffer.Buffer        =     (BYTE*)          InputBuffer;

453                      InBuffer.BufferSize              =     length;

454                      OutBuffer.BufferSize                =   MAX_BUFFER;

455                      OutBuffer.Buffer          =  (_OUTPUT_BUFFER)               OutputBuffer;

456                      //   record     the  number         of     bytes   in  the  command      if  it  is     the  largest

457                      //   we  have   seen   so    far.

458                      if(InBuffer.BufferSize                  >     CommandResponseSizes.largestCommandSize)

459                      {

460                              CommandResponseSizes.largestCommandSize                       =  InBuffer.BufferSize;

461                              memcpy(&CommandResponseSizes.largestCommand,

462                                      &InputBuffer[6],              sizeof(UINT32));

463                      }

464

465                      _rpc__Send_Command(locality,                      InBuffer,  &OutBuffer);

466                      //   record     the  number         of     bytes   in  the  response     if  it     is  the  largest

467                      //   we  have   seen   so    far.

468                      if(OutBuffer.BufferSize                    >  CommandResponseSizes.largestResponseSize)

469                      {

470                              CommandResponseSizes.largestResponseSize

471                               =      OutBuffer.BufferSize;

472                              memcpy(&CommandResponseSizes.largestResponse,

473                                      &OutputBuffer[6],                 sizeof(UINT32));

474                      }

475                      ok   =   WriteVarBytes(s,

476                                                   (char*)          OutBuffer.Buffer,

477                                                   OutBuffer.BufferSize);

478                      if(!ok)

479                              return  TRUE;

480                      break;

481

482                case     TPM_REMOTE_HANDSHAKE:

483                      ok   =   ReadBytes(s,        (char*)&clientVersion,              4);

484                      if(!ok)

485                              return  TRUE;

486                      if(     clientVersion        ==     0   )

487                      {

488                              printf("Unsupported                client  version   (0).\n");

489                              return  TRUE;

490                      }

491                      ok   &=  WriteUINT32(s,             ServerVersion);

492                      ok   &=  WriteUINT32(s,

493                                            tpmInRawMode            |    tpmPlatformAvailable          |   tpmSupportsPP);

494                      break;

495

496                case     TPM_SET_ALTERNATIVE_RESULT:

     Family "2.0"                                         TCG Published                                               Page 553

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                                          October 30, 2014
     Trusted Platform Module Library                                               Part 4: Supporting  Routines

497                      ok  =  ReadBytes(s,      (char*)&result,  4);

498                      if(!ok)

499                             return  TRUE;

500                      //  Alternative  result   is   not  applicable  to   the  simulator.

501                      break;

502

503                case  TPM_SESSION_END:

504                      //  Client     signaled   end-of-session

505                      return   TRUE;

506

507                case  TPM_STOP:

508                      //  Client     requested  the  simulator  to   exit

509                      return   FALSE;

510                default:

511                      printf("Unrecognized      TPM  interface  command    %d\n",  Command);

512                      return   TRUE;

513        }

514        ok   =  WriteUINT32(s,0);

515        if(!ok)

516                return    TRUE;

517     }

518     return  FALSE;

519  }

     Page 554                                      TCG Published                                 Family "2.0"

     October 30, 2014                     Copyright © TCG 2006-2014                   Level 00 Revision 01.16
    Part 4: Supporting Routines                                                                   Trusted Platform Module Library

    D.4      TPMCmdp.c

    D.4.1.    Description

    This file contains the functions that process the commands received on the control port or the command

    port  of  the    simulator.    The  control     port   is  used     to  allow     simulation  of  hardware  events  (such  as,

    _TPM_Hash_Start()) to test the simulated TPM's reaction to those events. This improves code coverage

    of the testing.

    D.4.2.    Includes and Data Definitions

1   #define     _SWAP_H                 //     Preclude     inclusion        of  unnecessary      simulator     header

2   #include      <stdlib.h>

3   #include      <stdio.h>

4   #include      <stdint.h>

5   #include      <setjmp.h>

6   #include      "bool.h"

7   #include      "Platform.h"

8   #include      "ExecCommand_fp.h"

9   #include      "Manufacture_fp.h"

10  #include      "DRTM_fp.h"

11  #include      "_TPM_Init_fp.h"

12  #include      "TpmFail_fp.h"

13  #include      <windows.h>

14  #include      "TpmTcpProtocol.h"

15  static    BOOL          s_isPowerOn         =   FALSE;

    D.4.3.    Functions

    D.4.3.1.      Signal_PowerOn()

    This function processes a power-on indicataion. Amoung other things, it calls the _TPM_Init()               hangler.

16  void

17  _rpc__Signal_PowerOn(

18        BOOL              isReset

19        )

20  {

21        //  if   power    is     on  and  this    is    not   a  call     to   do   TPM  reset  then  return

22        if(s_isPowerOn           &&  !isReset)

23              return;

24

25        //  If   this   is    a   reset   but     power   is     not  on,     then  return

26        if(isReset      &&    !s_isPowerOn)

27              return;

28

29        //  Pass   power      on     signal   to  platform

30        if(isReset)

31              _plat__Signal_Reset();

32        else

33              _plat__Signal_PowerOn();

34

35        //  Pass   power      on     signal   to  TPM

36        _TPM_Init();

37

38        //  Set    state     as   power   on

39        s_isPowerOn       =   TRUE;

40  }

    Family "2.0"                                            TCG Published                                               Page 555

    Level 00 Revision 01.16                         Copyright © TCG 2006-2014                                   October 30, 2014
    Trusted Platform Module Library                                                            Part 4: Supporting Routines

    D.4.3.2.      Signal_PowerOff()

    This function processes the power off indication. Its  primary  funtion    is  to  set  a  flag  indicatin g  that  the  next

    power on indication should cause _TPM_Init() to be     called.

41  void

42  _rpc__Signal_PowerOff(

43        void

44        )

45  {

46        if(!s_isPowerOn)         return;

47

48        //  Pass  power     off    signal  to  platform

49        _plat__Signal_PowerOff();

50

51        s_isPowerOn      =  FALSE;

52

53        return;

54  }

    D.4.3.3.      _rpc__ForceFailureMode()

    This function is used to debug the Failure Mode        logic of the TPM. It will set a flag in the TPM        code       such

    that the next call to TPM2_SelfTest() will result in   a failure, putting the TPM into Failure Mode.

55  void

56  _rpc__ForceFailureMode(

57        void

58        )

59  {

60        SetForceFailureMode();

61  }

    D.4.3.4.      _rpc__Signal_PhysicalPresenceOn()

    This function is called to simulate activation of the physical  presence   pin.

62  void

63  _rpc__Signal_PhysicalPresenceOn(

64        void

65        )

66  {

67        //  If  TPM  is     power  off,    reject  this  signal

68        if(!s_isPowerOn)         return;

69

70        //  Pass  physical       presence  on  to  platform

71        _plat__Signal_PhysicalPresenceOn();

72

73        return;

74  }

    D.4.3.5.      _rpc__Signal_PhysicalPresenceOff()

    This function is called to simulate deactivation of the physical presence      pin.

75  void

76  _rpc__Signal_PhysicalPresenceOff(

77        void

78        )

79  {

    Page 556                                         TCG Published                                                Family "2.0"

    October 30, 2014                         Copyright © TCG 2006-2014                         Level 00 Revision 01.16
     Part 4: Supporting Routines                                                     Trusted  Platform Module Library

80         //  If  TPM  is  power  off,  reject  this     signal

81         if(!s_isPowerOn)    return;

82

83         //  Pass  physical  presence  off     to  platform

84         _plat__Signal_PhysicalPresenceOff();

85

86         return;

87   }

     D.4.3.6.      _rpc__Signal_Hash_Start()

     This function is called to simulate a _TPM_Hash_Start() event.  It  will  call

88   void

89   _rpc__Signal_Hash_Start(

90         void

91         )

92   {

93         //  If  TPM  is  power  off,  reject  this     signal

94         if(!s_isPowerOn)    return;

95

96         //  Pass  _TPM_Hash_Start     signal  to   TPM

97         Signal_Hash_Start();

98         return;

99   }

     D.4.3.7.      _rpc__Signal_Hash_Data()

     This function is called to simulate a _TPM_Hash_Data() event.

100  void

101  _rpc__Signal_Hash_Data(

102        _IN_BUFFER          input

103        )

104  {

105        //  If  TPM  is  power  off,  reject  this     signal

106        if(!s_isPowerOn)    return;

107

108        //  Pass  _TPM_Hash_Data      signal  to  TPM

109        Signal_Hash_Data(input.BufferSize,          input.Buffer);

110        return;

111  }

     D.4.3.8.      _rpc__Signal_HashEnd()

     This function is called to simulate a _TPM_Hash_End() event.

112  void

113  _rpc__Signal_HashEnd(

114        void

115        )

116  {

117        //  If  TPM  is  power  off,  reject  this     signal

118        if(!s_isPowerOn)    return;

119

120        //  Pass  _TPM_HashEnd  signal   to   TPM

121        Signal_Hash_End();

122        return;

123  }

     Command interface Entry of a RPC call

     Family "2.0"                                    TCG Published                            Page 557

     Level 00 Revision 01.16             Copyright © TCG 2006-2014                            October 30, 2014
     Trusted Platform Module Library                                                         Part 4: Supporting Routines

124  void

125  _rpc__Send_Command(

126        unsigned      char  locality,

127        _IN_BUFFER          request,

128        _OUT_BUFFER         *response

129        )

130  {

131        //  If   TPM  is    power  off,  reject   any    commands.

132        if(!s_isPowerOn)    {

133              response->BufferSize       =    0;

134              return;

135        }

136        //  Set  the   locality    of    the  command    so  that  it  doesn't  change    during  the  command

137        _plat__LocalitySet(locality);

138        //  Do   implementation-specific          command    dispatch

139        ExecuteCommand(request.BufferSize,               request.Buffer,

140                                         &response->BufferSize,        &response->Buffer);

141        return;

142

143  }

     D.4.3.9.      _rpc__Signal_CancelOn()

     This function is used to turn on the indication to cancel a command in process.         An executing command is

     not interrupted. The command code may perodically check this indication to              see if it should abort the

     current command processing and returned TPM_RC_CANCELLED.

144  void

145  _rpc__Signal_CancelOn(

146        void

147        )

148  {

149        //  If   TPM  is    power  off,  reject   this   signal

150        if(!s_isPowerOn)    return;

151

152        //  Set  the   platform    canceling      flag.

153        _plat__SetCancel();

154

155        return;

156  }

     D.4.3.10.     _rpc__Signal_CancelOff()

     This function is used to turn off the indication to cancel a     command  in  process.

157  void

158  _rpc__Signal_CancelOff(

159        void

160        )

161  {

162        //  If   TPM  is    power  off,  reject   this   signal

163        if(!s_isPowerOn)    return;

164

165        //  Set  the   platform    canceling      flag.

166        _plat__ClearCancel();

167

168        return;

169  }

     Page 558                                        TCG Published                                        Family "2.0"

     October 30, 2014                            Copyright © TCG 2006-2014                   Level 00 Revision 01.16
     Part 4: Supporting Routines                                                      Trusted Platform Module Library

     D.4.3.11.     _rpc__Signal_NvOn()

     In a system where the NV memory used by the TPM is not within the TPM, the                   NV  may  not  always  be

     available. This function turns on the indicator that indicates that NV is available.

170  void

171  _rpc__Signal_NvOn(

172        void

173        )

174  {

175        //  If  TPM  is       power  off,  reject  this  signal

176        if(!s_isPowerOn)      return;

177

178        _plat__SetNvAvail();

179        return;

180  }

     D.4.3.12.     _rpc__Signal_NvOff()

     This function is used to set the indication that NV memory       is  no  longer  available.

181  void

182  _rpc__Signal_NvOff(

183        void

184        )

185  {

186        //  If  TPM  is       power  off,  reject  this  signal

187        if(!s_isPowerOn)      return;

188

189        _plat__ClearNvAvail();

190        return;

191  }

     D.4.3.13.     _rpc__Shutdown()

     This function is used to stop the TPM simulator.

192  void

193  _rpc__Shutdown(

194        void

195        )

196  {

197        RPC_STATUS        status;

198

199        //  Stop     TPM

200        TPM_TearDown();

201

202        status    =  RpcMgmtStopServerListening(NULL);

203        if  (status       !=  RPC_S_OK)

204        {

205              printf_s("RpcMgmtStopServerListening            returned:    0x%x\n",     status);

206              exit(status);

207        }

208

209        status    =  RpcServerUnregisterIf(NULL,         NULL,   FALSE);

210        if  (status       !=  RPC_S_OK)

211        {

212              printf_s("RpcServerUnregisterIf            returned      0x%x\n",    status);

213              exit(status);

214        }

215  }

     Family "2.0"                                     TCG Published                                             Page 559

     Level 00 Revision 01.16                  Copyright © TCG 2006-2014                               October 30, 2014
    Trusted Platform Module Library                                                      Part 4: Supporting Routines

    D.5      TPMCmds.c

    D.5.1.     Description

    This file contains the entry point for the simulator.

    D.5.2.     Includes, Defines, Data Definitions, and Function Prototypes

1   #include    <stdlib.h>

2   #include    <stdio.h>

3   #include    <stdint.h>

4   #include    <ctype.h>

5   #include    <windows.h>

6   #include    <strsafe.h>

7   #include    "string.h"

8   #include    "TpmTcpProtocol.h"

9   #include    "..\tpm\include\TpmBuildSwitches.h"

10  #include    "..\tpm\include\prototypes\Manufacture_fp.h"

11  #define     PURPOSE  \

12  "TPM     Reference   Simulator.\nCopyright       Microsoft       2010,  2011.\n"

13  #define     DEFAULT_TPM_PORT      2321

14  void*    MainPointer;

15  int   _plat__NVEnable(void*       platParameters);

16  void     _plat__NVDisable();

17  int   StartTcpServer(int  PortNumber);

    D.5.3.     Functions

    D.5.3.1.    Usage()

    This function prints the proper calling sequence for the simulator.

18  void

19  Usage(

20        char                    *pszProgramName

21        )

22  {

23        fprintf_s(stderr,   "%s",      PURPOSE);

24        fprintf_s(stderr,   "Usage:\n");

25        fprintf_s(stderr,   "%s                -   Starts     the  TPM  server  listening    on  port  %d\n",

26                      pszProgramName,     DEFAULT_TPM_PORT);

27        fprintf_s(stderr,

28                      "%s  PortNum  -  Starts      the   TPM  server    listening  on  port  PortNum\n",

29                      pszProgramName);

30        fprintf_s(stderr,   "%s     ?          -   This      message\n",  pszProgramName);

31        exit(1);

32  }

    D.5.3.2.    main()

    This is the main entry point for the simulator.

    main: register the interface, start listening for clients

33  void     __cdecl

34  main(

35        int                argc,

36        char               *argv[]

37        )

    Page 560                                         TCG Published                                       Family "2.0"

    October 30, 2014                        Copyright © TCG 2006-2014                    Level 00 Revision 01.16
    Part  4: Supporting Routines                                      Trusted  Platform Module Library

38  {

39        int  portNum   =   DEFAULT_TPM_PORT;

40        if(argc>2)

41        {

42             Usage(argv[0]);

43        }

44

45        if(argc==2)

46        {

47             if(strcmp(argv[1],     "?")    ==0)

48             {

49                 Usage(argv[0]);

50             }

51             portNum   =   atoi(argv[1]);

52             if(portNum    <=0  ||  portNum>65535)

53             {

54                 Usage(argv[0]);

55             }

56        }

57        _plat__NVEnable(NULL);

58        if(TPM_Manufacture(1)       !=  0)

59        {

60             exit(1);

61        }

62        //   Coverage  test  -  repeated    manufacturing  attempt

63        if(TPM_Manufacture(0)       !=  1)

64        {

65             exit(2);

66        }

67        //   Coverage  test  -  re-manufacturing

68        TPM_TearDown();

69        if(TPM_Manufacture(1)       !=  0)

70        {

71             exit(3);

72        }

73        //   Disable   NV  memory

74        _plat__NVDisable();

75

76        StartTcpServer(portNum);

77        return;

78  }

    Family "2.0"                                    TCG Published              Page 561

    Level 00 Revision 01.16               Copyright © TCG 2006-2014            October 30, 2014
